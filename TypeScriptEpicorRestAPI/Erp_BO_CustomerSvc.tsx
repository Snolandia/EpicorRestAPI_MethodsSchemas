import * as configEpicorSchemas from "./configEpicorSchemas"


// Title: Erp.BO.CustomerSvc
// Description: Customer Business Object
// Version: v1



//////////////////////////////////////////////////////////////////////////
// OData methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Get service document
   Description: Get service document for the service
   OperationID: GetServiceDocument
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => application/json
   */  
export function getServiceDocument(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<JSON>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as JSON)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Get metadata document
   Description: Get service ODATA metadata in XML format
   OperationID: GetMetadata
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: Returns metadata document => content
   */  
export function get_metadata(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/$metadata", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get Customers items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_Customers
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerRow
   */  
export function get_Customers(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_Customers
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_Customers(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the Customer item
   Description: Calls GetByID to retrieve the Customer item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_Customer
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerRow
   */  
export function get_Customers_Company_CustNum(Company:string, CustNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update Customer for the service
   Description: Calls UpdateExt to update Customer. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_Customer
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_Customers_Company_CustNum(Company:string, CustNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete Customer item
   Description: Call UpdateExt to delete Customer item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_Customer
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_Customers_Company_CustNum(Company:string, CustNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomCrdPools items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomCrdPools1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomCrdPoolRow
   */  
export function get_Customers_Company_CustNum_CustomCrdPools(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomCrdPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomCrdPools", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomCrdPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomCrdPool item
   Description: Calls GetByID to retrieve the CustomCrdPool item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomCrdPool1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param SysRowID Desc: SysRowID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomCrdPoolRow
   */  
export function get_Customers_Company_CustNum_CustomCrdPools_SysRowID(Company:string, CustNum:string, SysRowID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomCrdPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomCrdPools(" + SysRowID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomCrdPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustBillToes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustBillToes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustBillToRow
   */  
export function get_Customers_Company_CustNum_CustBillToes(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBillToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustBillToes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBillToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustBillTo item
   Description: Calls GetByID to retrieve the CustBillTo item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustBillTo1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BTCustNum Desc: BTCustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustBillToRow
   */  
export function get_Customers_Company_CustNum_CustBillToes_Company_CustNum_BTCustNum(Company:string, CustNum:string, BTCustNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustBillToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustBillToes(" + Company + "," + CustNum + "," + BTCustNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustBillToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustBanks items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustBanks1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustBankRow
   */  
export function get_Customers_Company_CustNum_CustBanks(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBankRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustBanks", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBankRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustBank item
   Description: Calls GetByID to retrieve the CustBank item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustBank1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BankID Desc: BankID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustBankRow
   */  
export function get_Customers_Company_CustNum_CustBanks_Company_CustNum_BankID(Company:string, CustNum:string, BankID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustBankRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustBanks(" + Company + "," + CustNum + "," + BankID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustBankRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustChilds items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustChilds1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustChildRow
   */  
export function get_Customers_Company_CustNum_CustChilds(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustChildRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustChilds", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustChildRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustChild item
   Description: Calls GetByID to retrieve the CustChild item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustChild1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustChildRow
   */  
export function get_Customers_Company_CustNum_CustChilds_Company_CustNum(Company:string, CustNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustChildRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustChilds(" + Company + "," + CustNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustChildRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustDfltDocTypes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustDfltDocTypes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustDfltDocTypeRow
   */  
export function get_Customers_Company_CustNum_CustDfltDocTypes(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustDfltDocTypeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustDfltDocTypes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustDfltDocTypeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustDfltDocType item
   Description: Calls GetByID to retrieve the CustDfltDocType item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustDfltDocType1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param InvoiceType Desc: InvoiceType   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustDfltDocTypeRow
   */  
export function get_Customers_Company_CustNum_CustDfltDocTypes_Company_CustNum_InvoiceType(Company:string, CustNum:string, InvoiceType:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustDfltDocTypeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustDfltDocTypes(" + Company + "," + CustNum + "," + InvoiceType + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustDfltDocTypeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustICs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustICs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustICRow
   */  
export function get_Customers_Company_CustNum_CustICs(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustICRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustICs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustICRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustIC item
   Description: Calls GetByID to retrieve the CustIC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustIC1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ICTypeID Desc: ICTypeID   Required: True   Allow empty value : True
      @param ICCode Desc: ICCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustICRow
   */  
export function get_Customers_Company_CustNum_CustICs_Company_CustNum_ShipToNum_ICTypeID_ICCode(Company:string, CustNum:string, ShipToNum:string, ICTypeID:string, ICCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustICRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustICs(" + Company + "," + CustNum + "," + ShipToNum + "," + ICTypeID + "," + ICCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustICRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustLabExpRates items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustLabExpRates1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustLabExpRateRow
   */  
export function get_Customers_Company_CustNum_CustLabExpRates(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustLabExpRates", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustLabExpRate item
   Description: Calls GetByID to retrieve the CustLabExpRate item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustLabExpRate1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustLabExpRateRow
   */  
export function get_Customers_Company_CustNum_CustLabExpRates_Company_CustNum_ExpenseCode(Company:string, CustNum:string, ExpenseCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustLabExpRates(" + Company + "," + CustNum + "," + ExpenseCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustMandates items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustMandates1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustMandateRow
   */  
export function get_Customers_Company_CustNum_CustMandates(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMandateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustMandates", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMandateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustMandate item
   Description: Calls GetByID to retrieve the CustMandate item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustMandate1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param MandateType Desc: MandateType   Required: True   Allow empty value : True
      @param MandateReference Desc: MandateReference   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustMandateRow
   */  
export function get_Customers_Company_CustNum_CustMandates_Company_CustNum_MandateType_MandateReference(Company:string, CustNum:string, MandateType:string, MandateReference:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustMandateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustMandates(" + Company + "," + CustNum + "," + MandateType + "," + MandateReference + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustMandateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomerDocs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomerDocs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerDocsRow
   */  
export function get_Customers_Company_CustNum_CustomerDocs(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerDocs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerDoc item
   Description: Calls GetByID to retrieve the CustomerDoc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerDoc1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerDocsRow
   */  
export function get_Customers_Company_CustNum_CustomerDocs_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerDocsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerDocs(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerDocsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustRestrictions items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustRestrictions1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustRestrictionRow
   */  
export function get_Customers_Company_CustNum_CustRestrictions(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustRestrictions", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustRestriction item
   Description: Calls GetByID to retrieve the CustRestriction item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustRestriction1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustRestrictionRow
   */  
export function get_Customers_Company_CustNum_CustRestrictions_Company_CustNum_RestrictionTypeID(Company:string, CustNum:string, RestrictionTypeID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustRestrictions(" + Company + "," + CustNum + "," + RestrictionTypeID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustUPSEmails items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustUPSEmails1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustUPSEmailRow
   */  
export function get_Customers_Company_CustNum_CustUPSEmails(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustUPSEmailRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustUPSEmails", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustUPSEmailRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustUPSEmail item
   Description: Calls GetByID to retrieve the CustUPSEmail item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustUPSEmail1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustUPSEmailRow
   */  
export function get_Customers_Company_CustNum_CustUPSEmails_Company_CustNum_UPSQVSeq(Company:string, CustNum:string, UPSQVSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustUPSEmailRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustUPSEmails(" + Company + "," + CustNum + "," + UPSQVSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustUPSEmailRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomerDiscPriceLsts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomerDiscPriceLsts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerDiscPriceLstRow
   */  
export function get_Customers_Company_CustNum_CustomerDiscPriceLsts(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerDiscPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerDiscPriceLst item
   Description: Calls GetByID to retrieve the CustomerDiscPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerDiscPriceLst1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerDiscPriceLstRow
   */  
export function get_Customers_Company_CustNum_CustomerDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomerFSPriceLists items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomerFSPriceLists1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerFSPriceListRow
   */  
export function get_Customers_Company_CustNum_CustomerFSPriceLists(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerFSPriceListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerFSPriceLists", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerFSPriceListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerFSPriceList item
   Description: Calls GetByID to retrieve the CustomerFSPriceList item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerFSPriceList1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerFSPriceListRow
   */  
export function get_Customers_Company_CustNum_CustomerFSPriceLists_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerFSPriceListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerFSPriceLists(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerFSPriceListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get GlbCustCreds items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_GlbCustCreds1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.GlbCustCredRow
   */  
export function get_Customers_Company_CustNum_GlbCustCreds(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_GlbCustCredRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/GlbCustCreds", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_GlbCustCredRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the GlbCustCred item
   Description: Calls GetByID to retrieve the GlbCustCred item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_GlbCustCred1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExtCompany Desc: ExtCompany   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.GlbCustCredRow
   */  
export function get_Customers_Company_CustNum_GlbCustCreds_Company_CustNum_ExtCompany(Company:string, CustNum:string, ExtCompany:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_GlbCustCredRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/GlbCustCreds(" + Company + "," + CustNum + "," + ExtCompany + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_GlbCustCredRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get MXCustomerFiscalTexts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_MXCustomerFiscalTexts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.MXCustomerFiscalTextRow
   */  
export function get_Customers_Company_CustNum_MXCustomerFiscalTexts(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MXCustomerFiscalTextRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/MXCustomerFiscalTexts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MXCustomerFiscalTextRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the MXCustomerFiscalText item
   Description: Calls GetByID to retrieve the MXCustomerFiscalText item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_MXCustomerFiscalText1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param FiscalTextSeq Desc: FiscalTextSeq   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.MXCustomerFiscalTextRow
   */  
export function get_Customers_Company_CustNum_MXCustomerFiscalTexts_Company_CustNum_FiscalTextSeq(Company:string, CustNum:string, FiscalTextSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_MXCustomerFiscalTextRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/MXCustomerFiscalTexts(" + Company + "," + CustNum + "," + FiscalTextSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_MXCustomerFiscalTextRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get NAMembers items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_NAMembers1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.NAMemberRow
   */  
export function get_Customers_Company_CustNum_NAMembers(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_NAMemberRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/NAMembers", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_NAMemberRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the NAMember item
   Description: Calls GetByID to retrieve the NAMember item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_NAMember1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param SysRowID Desc: SysRowID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.NAMemberRow
   */  
export function get_Customers_Company_CustNum_NAMembers_SysRowID(Company:string, CustNum:string, SysRowID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_NAMemberRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/NAMembers(" + SysRowID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_NAMemberRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PECustWhldHists items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PECustWhldHists1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PECustWhldHistRow
   */  
export function get_Customers_Company_CustNum_PECustWhldHists(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PECustWhldHistRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/PECustWhldHists", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PECustWhldHistRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PECustWhldHist item
   Description: Calls GetByID to retrieve the PECustWhldHist item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PECustWhldHist1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RecordSeq Desc: RecordSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PECustWhldHistRow
   */  
export function get_Customers_Company_CustNum_PECustWhldHists_Company_CustNum_RecordSeq(Company:string, CustNum:string, RecordSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PECustWhldHistRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/PECustWhldHists(" + Company + "," + CustNum + "," + RecordSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PECustWhldHistRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToRow
   */  
export function get_Customers_Company_CustNum_ShipToes(Company:string, CustNum:string, select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/ShipToes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipTo item
   Description: Calls GetByID to retrieve the ShipTo item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipTo1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToRow
   */  
export function get_Customers_Company_CustNum_ShipToes_Company_CustNum_ShipToNum(Company:string, CustNum:string, ShipToNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustMFBills items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustMFBills1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustMFBillRow
   */  
export function get_Customers_Company_CustNum_CustMFBills(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustMFBills", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustMFBill item
   Description: Calls GetByID to retrieve the CustMFBill item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustMFBill1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustMFBillRow
   */  
export function get_Customers_Company_CustNum_CustMFBills_Company_CustNum_PayBTFlag(Company:string, CustNum:string, PayBTFlag:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustMFBills(" + Company + "," + CustNum + "," + PayBTFlag + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get MangCusts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_MangCusts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.MangCustRow
   */  
export function get_Customers_Company_CustNum_MangCusts(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MangCustRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/MangCusts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MangCustRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the MangCust item
   Description: Calls GetByID to retrieve the MangCust item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_MangCust1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param VendorNum Desc: VendorNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.MangCustRow
   */  
export function get_Customers_Company_CustNum_MangCusts_Company_CustNum_VendorNum(Company:string, CustNum:string, VendorNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_MangCustRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/MangCusts(" + Company + "," + CustNum + "," + VendorNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_MangCustRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToSrches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToSrches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToSrchRow
   */  
export function get_Customers_Company_CustNum_ShipToSrches(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToSrchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/ShipToSrches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToSrchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToSrch item
   Description: Calls GetByID to retrieve the ShipToSrch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToSrch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param SysRowID Desc: SysRowID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToSrchRow
   */  
export function get_Customers_Company_CustNum_ShipToSrches_SysRowID(Company:string, CustNum:string, SysRowID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToSrchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/ShipToSrches(" + SysRowID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToSrchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomerPriceLsts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomerPriceLsts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerPriceLstRow
   */  
export function get_Customers_Company_CustNum_CustomerPriceLsts(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerPriceLst item
   Description: Calls GetByID to retrieve the CustomerPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerPriceLst1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerPriceLstRow
   */  
export function get_Customers_Company_CustNum_CustomerPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get EntityGLCs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_EntityGLCs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.EntityGLCRow
   */  
export function get_Customers_Company_CustNum_EntityGLCs(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/EntityGLCs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the EntityGLC item
   Description: Calls GetByID to retrieve the EntityGLC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_EntityGLC1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   */  
export function get_Customers_Company_CustNum_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, CustNum:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get TaxExempts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_TaxExempts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.TaxExemptRow
   */  
export function get_Customers_Company_CustNum_TaxExempts(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/TaxExempts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the TaxExempt item
   Description: Calls GetByID to retrieve the TaxExempt item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_TaxExempt1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   */  
export function get_Customers_Company_CustNum_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, CustNum:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomerAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomerAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerAttchRow
   */  
export function get_Customers_Company_CustNum_CustomerAttches(Company:string, CustNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerAttch item
   Description: Calls GetByID to retrieve the CustomerAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerAttchRow
   */  
export function get_Customers_Company_CustNum_CustomerAttches_Company_CustNum_DrawingSeq(Company:string, CustNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Customers(" + Company + "," + CustNum + ")/CustomerAttches(" + Company + "," + CustNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomCrdPools items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomCrdPools
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomCrdPoolRow
   */  
export function get_CustomCrdPools(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomCrdPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomCrdPools", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomCrdPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomCrdPools
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomCrdPoolRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomCrdPoolRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomCrdPools(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomCrdPools", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomCrdPool item
   Description: Calls GetByID to retrieve the CustomCrdPool item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomCrdPool
      @param SysRowID Desc: SysRowID   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomCrdPoolRow
   */  
export function get_CustomCrdPools_SysRowID(SysRowID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomCrdPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomCrdPools(" + SysRowID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomCrdPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomCrdPool for the service
   Description: Calls UpdateExt to update CustomCrdPool. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomCrdPool
      @param SysRowID Desc: SysRowID   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomCrdPoolRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomCrdPools_SysRowID(SysRowID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomCrdPools(" + SysRowID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomCrdPool item
   Description: Call UpdateExt to delete CustomCrdPool item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomCrdPool
      @param SysRowID Desc: SysRowID   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomCrdPools_SysRowID(SysRowID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomCrdPools(" + SysRowID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustBillToes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustBillToes
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustBillToRow
   */  
export function get_CustBillToes(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBillToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBillToes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBillToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustBillToes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustBillToRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustBillToRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustBillToes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBillToes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustBillTo item
   Description: Calls GetByID to retrieve the CustBillTo item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustBillTo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BTCustNum Desc: BTCustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustBillToRow
   */  
export function get_CustBillToes_Company_CustNum_BTCustNum(Company:string, CustNum:string, BTCustNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustBillToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBillToes(" + Company + "," + CustNum + "," + BTCustNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustBillToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustBillTo for the service
   Description: Calls UpdateExt to update CustBillTo. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustBillTo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BTCustNum Desc: BTCustNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustBillToRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustBillToes_Company_CustNum_BTCustNum(Company:string, CustNum:string, BTCustNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBillToes(" + Company + "," + CustNum + "," + BTCustNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustBillTo item
   Description: Call UpdateExt to delete CustBillTo item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustBillTo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BTCustNum Desc: BTCustNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustBillToes_Company_CustNum_BTCustNum(Company:string, CustNum:string, BTCustNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBillToes(" + Company + "," + CustNum + "," + BTCustNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustBanks items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustBanks
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustBankRow
   */  
export function get_CustBanks(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBankRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBanks", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBankRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustBanks
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustBankRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustBankRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustBanks(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBanks", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustBank item
   Description: Calls GetByID to retrieve the CustBank item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustBank
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BankID Desc: BankID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustBankRow
   */  
export function get_CustBanks_Company_CustNum_BankID(Company:string, CustNum:string, BankID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustBankRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBanks(" + Company + "," + CustNum + "," + BankID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustBankRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustBank for the service
   Description: Calls UpdateExt to update CustBank. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustBank
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BankID Desc: BankID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustBankRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustBanks_Company_CustNum_BankID(Company:string, CustNum:string, BankID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBanks(" + Company + "," + CustNum + "," + BankID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustBank item
   Description: Call UpdateExt to delete CustBank item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustBank
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param BankID Desc: BankID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustBanks_Company_CustNum_BankID(Company:string, CustNum:string, BankID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustBanks(" + Company + "," + CustNum + "," + BankID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustChilds items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustChilds
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustChildRow
   */  
export function get_CustChilds(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustChildRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustChilds", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustChildRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustChilds
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustChildRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustChildRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustChilds(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustChilds", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustChild item
   Description: Calls GetByID to retrieve the CustChild item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustChild
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustChildRow
   */  
export function get_CustChilds_Company_CustNum(Company:string, CustNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustChildRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustChilds(" + Company + "," + CustNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustChildRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustChild for the service
   Description: Calls UpdateExt to update CustChild. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustChild
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustChildRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustChilds_Company_CustNum(Company:string, CustNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustChilds(" + Company + "," + CustNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustChild item
   Description: Call UpdateExt to delete CustChild item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustChild
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustChilds_Company_CustNum(Company:string, CustNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustChilds(" + Company + "," + CustNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustDfltDocTypes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustDfltDocTypes
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustDfltDocTypeRow
   */  
export function get_CustDfltDocTypes(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustDfltDocTypeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustDfltDocTypes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustDfltDocTypeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustDfltDocTypes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustDfltDocTypeRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustDfltDocTypeRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustDfltDocTypes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustDfltDocTypes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustDfltDocType item
   Description: Calls GetByID to retrieve the CustDfltDocType item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustDfltDocType
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param InvoiceType Desc: InvoiceType   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustDfltDocTypeRow
   */  
export function get_CustDfltDocTypes_Company_CustNum_InvoiceType(Company:string, CustNum:string, InvoiceType:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustDfltDocTypeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustDfltDocTypes(" + Company + "," + CustNum + "," + InvoiceType + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustDfltDocTypeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustDfltDocType for the service
   Description: Calls UpdateExt to update CustDfltDocType. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustDfltDocType
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param InvoiceType Desc: InvoiceType   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustDfltDocTypeRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustDfltDocTypes_Company_CustNum_InvoiceType(Company:string, CustNum:string, InvoiceType:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustDfltDocTypes(" + Company + "," + CustNum + "," + InvoiceType + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustDfltDocType item
   Description: Call UpdateExt to delete CustDfltDocType item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustDfltDocType
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param InvoiceType Desc: InvoiceType   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustDfltDocTypes_Company_CustNum_InvoiceType(Company:string, CustNum:string, InvoiceType:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustDfltDocTypes(" + Company + "," + CustNum + "," + InvoiceType + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustICs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustICs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustICRow
   */  
export function get_CustICs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustICRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustICs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustICRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustICs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustICRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustICRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustICs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustICs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustIC item
   Description: Calls GetByID to retrieve the CustIC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustIC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ICTypeID Desc: ICTypeID   Required: True   Allow empty value : True
      @param ICCode Desc: ICCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustICRow
   */  
export function get_CustICs_Company_CustNum_ShipToNum_ICTypeID_ICCode(Company:string, CustNum:string, ShipToNum:string, ICTypeID:string, ICCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustICRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustICs(" + Company + "," + CustNum + "," + ShipToNum + "," + ICTypeID + "," + ICCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustICRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustIC for the service
   Description: Calls UpdateExt to update CustIC. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustIC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ICTypeID Desc: ICTypeID   Required: True   Allow empty value : True
      @param ICCode Desc: ICCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustICRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustICs_Company_CustNum_ShipToNum_ICTypeID_ICCode(Company:string, CustNum:string, ShipToNum:string, ICTypeID:string, ICCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustICs(" + Company + "," + CustNum + "," + ShipToNum + "," + ICTypeID + "," + ICCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustIC item
   Description: Call UpdateExt to delete CustIC item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustIC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ICTypeID Desc: ICTypeID   Required: True   Allow empty value : True
      @param ICCode Desc: ICCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustICs_Company_CustNum_ShipToNum_ICTypeID_ICCode(Company:string, CustNum:string, ShipToNum:string, ICTypeID:string, ICCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustICs(" + Company + "," + CustNum + "," + ShipToNum + "," + ICTypeID + "," + ICCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustLabExpRates items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustLabExpRates
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustLabExpRateRow
   */  
export function get_CustLabExpRates(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustLabExpRates", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustLabExpRates
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustLabExpRateRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustLabExpRateRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustLabExpRates(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustLabExpRates", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustLabExpRate item
   Description: Calls GetByID to retrieve the CustLabExpRate item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustLabExpRate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustLabExpRateRow
   */  
export function get_CustLabExpRates_Company_CustNum_ExpenseCode(Company:string, CustNum:string, ExpenseCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustLabExpRates(" + Company + "," + CustNum + "," + ExpenseCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustLabExpRate for the service
   Description: Calls UpdateExt to update CustLabExpRate. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustLabExpRate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustLabExpRateRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustLabExpRates_Company_CustNum_ExpenseCode(Company:string, CustNum:string, ExpenseCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustLabExpRates(" + Company + "," + CustNum + "," + ExpenseCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustLabExpRate item
   Description: Call UpdateExt to delete CustLabExpRate item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustLabExpRate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustLabExpRates_Company_CustNum_ExpenseCode(Company:string, CustNum:string, ExpenseCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustLabExpRates(" + Company + "," + CustNum + "," + ExpenseCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustMandates items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustMandates
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustMandateRow
   */  
export function get_CustMandates(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMandateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMandates", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMandateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustMandates
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustMandateRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustMandateRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustMandates(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMandates", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustMandate item
   Description: Calls GetByID to retrieve the CustMandate item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustMandate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param MandateType Desc: MandateType   Required: True   Allow empty value : True
      @param MandateReference Desc: MandateReference   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustMandateRow
   */  
export function get_CustMandates_Company_CustNum_MandateType_MandateReference(Company:string, CustNum:string, MandateType:string, MandateReference:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustMandateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMandates(" + Company + "," + CustNum + "," + MandateType + "," + MandateReference + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustMandateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustMandate for the service
   Description: Calls UpdateExt to update CustMandate. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustMandate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param MandateType Desc: MandateType   Required: True   Allow empty value : True
      @param MandateReference Desc: MandateReference   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustMandateRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustMandates_Company_CustNum_MandateType_MandateReference(Company:string, CustNum:string, MandateType:string, MandateReference:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMandates(" + Company + "," + CustNum + "," + MandateType + "," + MandateReference + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustMandate item
   Description: Call UpdateExt to delete CustMandate item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustMandate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param MandateType Desc: MandateType   Required: True   Allow empty value : True
      @param MandateReference Desc: MandateReference   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustMandates_Company_CustNum_MandateType_MandateReference(Company:string, CustNum:string, MandateType:string, MandateReference:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMandates(" + Company + "," + CustNum + "," + MandateType + "," + MandateReference + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomerDocs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomerDocs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerDocsRow
   */  
export function get_CustomerDocs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomerDocs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerDocsRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerDocsRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomerDocs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerDoc item
   Description: Calls GetByID to retrieve the CustomerDoc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerDoc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerDocsRow
   */  
export function get_CustomerDocs_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerDocsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocs(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerDocsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomerDoc for the service
   Description: Calls UpdateExt to update CustomerDoc. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomerDoc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerDocsRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomerDocs_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocs(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomerDoc item
   Description: Call UpdateExt to delete CustomerDoc item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomerDoc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomerDocs_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocs(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustRestrictions items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustRestrictions
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustRestrictionRow
   */  
export function get_CustRestrictions(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustRestrictions", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustRestrictions
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustRestrictionRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustRestrictionRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustRestrictions(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustRestrictions", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustRestriction item
   Description: Calls GetByID to retrieve the CustRestriction item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustRestrictionRow
   */  
export function get_CustRestrictions_Company_CustNum_RestrictionTypeID(Company:string, CustNum:string, RestrictionTypeID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustRestrictions(" + Company + "," + CustNum + "," + RestrictionTypeID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustRestriction for the service
   Description: Calls UpdateExt to update CustRestriction. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustRestrictionRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustRestrictions_Company_CustNum_RestrictionTypeID(Company:string, CustNum:string, RestrictionTypeID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustRestrictions(" + Company + "," + CustNum + "," + RestrictionTypeID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustRestriction item
   Description: Call UpdateExt to delete CustRestriction item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustRestrictions_Company_CustNum_RestrictionTypeID(Company:string, CustNum:string, RestrictionTypeID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustRestrictions(" + Company + "," + CustNum + "," + RestrictionTypeID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustUPSEmails items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustUPSEmails
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustUPSEmailRow
   */  
export function get_CustUPSEmails(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustUPSEmailRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustUPSEmails", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustUPSEmailRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustUPSEmails
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustUPSEmailRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustUPSEmailRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustUPSEmails(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustUPSEmails", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustUPSEmail item
   Description: Calls GetByID to retrieve the CustUPSEmail item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustUPSEmail
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustUPSEmailRow
   */  
export function get_CustUPSEmails_Company_CustNum_UPSQVSeq(Company:string, CustNum:string, UPSQVSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustUPSEmailRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustUPSEmails(" + Company + "," + CustNum + "," + UPSQVSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustUPSEmailRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustUPSEmail for the service
   Description: Calls UpdateExt to update CustUPSEmail. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustUPSEmail
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustUPSEmailRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustUPSEmails_Company_CustNum_UPSQVSeq(Company:string, CustNum:string, UPSQVSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustUPSEmails(" + Company + "," + CustNum + "," + UPSQVSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustUPSEmail item
   Description: Call UpdateExt to delete CustUPSEmail item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustUPSEmail
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustUPSEmails_Company_CustNum_UPSQVSeq(Company:string, CustNum:string, UPSQVSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustUPSEmails(" + Company + "," + CustNum + "," + UPSQVSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomerDiscPriceLsts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomerDiscPriceLsts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerDiscPriceLstRow
   */  
export function get_CustomerDiscPriceLsts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDiscPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomerDiscPriceLsts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerDiscPriceLstRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerDiscPriceLstRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomerDiscPriceLsts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDiscPriceLsts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerDiscPriceLst item
   Description: Calls GetByID to retrieve the CustomerDiscPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerDiscPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerDiscPriceLstRow
   */  
export function get_CustomerDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomerDiscPriceLst for the service
   Description: Calls UpdateExt to update CustomerDiscPriceLst. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomerDiscPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerDiscPriceLstRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomerDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomerDiscPriceLst item
   Description: Call UpdateExt to delete CustomerDiscPriceLst item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomerDiscPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomerDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomerFSPriceLists items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomerFSPriceLists
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerFSPriceListRow
   */  
export function get_CustomerFSPriceLists(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerFSPriceListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerFSPriceLists", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerFSPriceListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomerFSPriceLists
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerFSPriceListRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerFSPriceListRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomerFSPriceLists(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerFSPriceLists", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerFSPriceList item
   Description: Calls GetByID to retrieve the CustomerFSPriceList item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerFSPriceList
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerFSPriceListRow
   */  
export function get_CustomerFSPriceLists_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerFSPriceListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerFSPriceLists(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerFSPriceListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomerFSPriceList for the service
   Description: Calls UpdateExt to update CustomerFSPriceList. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomerFSPriceList
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerFSPriceListRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomerFSPriceLists_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerFSPriceLists(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomerFSPriceList item
   Description: Call UpdateExt to delete CustomerFSPriceList item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomerFSPriceList
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomerFSPriceLists_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerFSPriceLists(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get GlbCustCreds items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_GlbCustCreds
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.GlbCustCredRow
   */  
export function get_GlbCustCreds(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_GlbCustCredRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GlbCustCreds", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_GlbCustCredRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_GlbCustCreds
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.GlbCustCredRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.GlbCustCredRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GlbCustCreds(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GlbCustCreds", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the GlbCustCred item
   Description: Calls GetByID to retrieve the GlbCustCred item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_GlbCustCred
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExtCompany Desc: ExtCompany   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.GlbCustCredRow
   */  
export function get_GlbCustCreds_Company_CustNum_ExtCompany(Company:string, CustNum:string, ExtCompany:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_GlbCustCredRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GlbCustCreds(" + Company + "," + CustNum + "," + ExtCompany + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_GlbCustCredRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update GlbCustCred for the service
   Description: Calls UpdateExt to update GlbCustCred. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_GlbCustCred
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExtCompany Desc: ExtCompany   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.GlbCustCredRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_GlbCustCreds_Company_CustNum_ExtCompany(Company:string, CustNum:string, ExtCompany:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GlbCustCreds(" + Company + "," + CustNum + "," + ExtCompany + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete GlbCustCred item
   Description: Call UpdateExt to delete GlbCustCred item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_GlbCustCred
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ExtCompany Desc: ExtCompany   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_GlbCustCreds_Company_CustNum_ExtCompany(Company:string, CustNum:string, ExtCompany:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GlbCustCreds(" + Company + "," + CustNum + "," + ExtCompany + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get MXCustomerFiscalTexts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_MXCustomerFiscalTexts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.MXCustomerFiscalTextRow
   */  
export function get_MXCustomerFiscalTexts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MXCustomerFiscalTextRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MXCustomerFiscalTexts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MXCustomerFiscalTextRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_MXCustomerFiscalTexts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.MXCustomerFiscalTextRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.MXCustomerFiscalTextRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_MXCustomerFiscalTexts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MXCustomerFiscalTexts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the MXCustomerFiscalText item
   Description: Calls GetByID to retrieve the MXCustomerFiscalText item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_MXCustomerFiscalText
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param FiscalTextSeq Desc: FiscalTextSeq   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.MXCustomerFiscalTextRow
   */  
export function get_MXCustomerFiscalTexts_Company_CustNum_FiscalTextSeq(Company:string, CustNum:string, FiscalTextSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_MXCustomerFiscalTextRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MXCustomerFiscalTexts(" + Company + "," + CustNum + "," + FiscalTextSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_MXCustomerFiscalTextRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update MXCustomerFiscalText for the service
   Description: Calls UpdateExt to update MXCustomerFiscalText. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_MXCustomerFiscalText
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param FiscalTextSeq Desc: FiscalTextSeq   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.MXCustomerFiscalTextRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_MXCustomerFiscalTexts_Company_CustNum_FiscalTextSeq(Company:string, CustNum:string, FiscalTextSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MXCustomerFiscalTexts(" + Company + "," + CustNum + "," + FiscalTextSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete MXCustomerFiscalText item
   Description: Call UpdateExt to delete MXCustomerFiscalText item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_MXCustomerFiscalText
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param FiscalTextSeq Desc: FiscalTextSeq   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_MXCustomerFiscalTexts_Company_CustNum_FiscalTextSeq(Company:string, CustNum:string, FiscalTextSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MXCustomerFiscalTexts(" + Company + "," + CustNum + "," + FiscalTextSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get NAMembers items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_NAMembers
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.NAMemberRow
   */  
export function get_NAMembers(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_NAMemberRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/NAMembers", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_NAMemberRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_NAMembers
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.NAMemberRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.NAMemberRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_NAMembers(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/NAMembers", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the NAMember item
   Description: Calls GetByID to retrieve the NAMember item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_NAMember
      @param SysRowID Desc: SysRowID   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.NAMemberRow
   */  
export function get_NAMembers_SysRowID(SysRowID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_NAMemberRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/NAMembers(" + SysRowID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_NAMemberRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update NAMember for the service
   Description: Calls UpdateExt to update NAMember. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_NAMember
      @param SysRowID Desc: SysRowID   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.NAMemberRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_NAMembers_SysRowID(SysRowID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/NAMembers(" + SysRowID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete NAMember item
   Description: Call UpdateExt to delete NAMember item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_NAMember
      @param SysRowID Desc: SysRowID   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_NAMembers_SysRowID(SysRowID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/NAMembers(" + SysRowID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PECustWhldHists items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PECustWhldHists
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PECustWhldHistRow
   */  
export function get_PECustWhldHists(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PECustWhldHistRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PECustWhldHists", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PECustWhldHistRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PECustWhldHists
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PECustWhldHistRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PECustWhldHistRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PECustWhldHists(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PECustWhldHists", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PECustWhldHist item
   Description: Calls GetByID to retrieve the PECustWhldHist item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PECustWhldHist
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RecordSeq Desc: RecordSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PECustWhldHistRow
   */  
export function get_PECustWhldHists_Company_CustNum_RecordSeq(Company:string, CustNum:string, RecordSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PECustWhldHistRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PECustWhldHists(" + Company + "," + CustNum + "," + RecordSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PECustWhldHistRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PECustWhldHist for the service
   Description: Calls UpdateExt to update PECustWhldHist. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PECustWhldHist
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RecordSeq Desc: RecordSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PECustWhldHistRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PECustWhldHists_Company_CustNum_RecordSeq(Company:string, CustNum:string, RecordSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PECustWhldHists(" + Company + "," + CustNum + "," + RecordSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PECustWhldHist item
   Description: Call UpdateExt to delete PECustWhldHist item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PECustWhldHist
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param RecordSeq Desc: RecordSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PECustWhldHists_Company_CustNum_RecordSeq(Company:string, CustNum:string, RecordSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PECustWhldHists(" + Company + "," + CustNum + "," + RecordSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToes
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToRow
   */  
export function get_ShipToes(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipTo item
   Description: Calls GetByID to retrieve the ShipTo item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipTo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum(Company:string, CustNum:string, ShipToNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipTo for the service
   Description: Calls UpdateExt to update ShipTo. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipTo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToes_Company_CustNum_ShipToNum(Company:string, CustNum:string, ShipToNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipTo item
   Description: Call UpdateExt to delete ShipTo item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipTo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToes_Company_CustNum_ShipToNum(Company:string, CustNum:string, ShipToNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToRestrictions items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToRestrictions1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToRestrictionRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToRestrictions(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToRestrictions", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToRestriction item
   Description: Calls GetByID to retrieve the ShipToRestriction item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToRestriction1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToRestrictionRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToRestrictions_Company_CustNum_ShipToNum_RestrictionTypeID(Company:string, CustNum:string, ShipToNum:string, RestrictionTypeID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToRestrictions(" + Company + "," + CustNum + "," + ShipToNum + "," + RestrictionTypeID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToLabExpRates items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToLabExpRates1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToLabExpRateRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToLabExpRates(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToLabExpRates", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToLabExpRate item
   Description: Calls GetByID to retrieve the ShipToLabExpRate item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToLabExpRate1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToLabExpRateRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToLabExpRates_Company_CustNum_ShipToNum_ExpenseCode(Company:string, CustNum:string, ShipToNum:string, ExpenseCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToLabExpRates(" + Company + "," + CustNum + "," + ShipToNum + "," + ExpenseCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get CustomerDocsSHes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_CustomerDocsSHes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerDocsSHRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_CustomerDocsSHes(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsSHRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/CustomerDocsSHes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsSHRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerDocsSH item
   Description: Calls GetByID to retrieve the CustomerDocsSH item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerDocsSH1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerDocsSHRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_CustomerDocsSHes_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerDocsSHRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/CustomerDocsSHes(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerDocsSHRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToDiscPriceLsts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToDiscPriceLsts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToDiscPriceLstRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToDiscPriceLsts(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToDiscPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToDiscPriceLst item
   Description: Calls GetByID to retrieve the ShipToDiscPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToDiscPriceLst1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToDiscPriceLstRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToMFBills items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToMFBills1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToMFBillRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToMFBills(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToMFBills", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToMFBill item
   Description: Calls GetByID to retrieve the ShipToMFBill item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToMFBill1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToMFBillRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToMFBills_Company_CustNum_ShipToNum_PayBTFlag(Company:string, CustNum:string, ShipToNum:string, PayBTFlag:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToMFBills(" + Company + "," + CustNum + "," + ShipToNum + "," + PayBTFlag + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToPriceLsts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToPriceLsts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToPriceLstRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToPriceLsts(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToPriceLst item
   Description: Calls GetByID to retrieve the ShipToPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToPriceLst1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToPriceLstRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToUPSEmls items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToUPSEmls1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToUPSEmlRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToUPSEmls(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToUPSEmlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToUPSEmls", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToUPSEmlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToUPSEml item
   Description: Calls GetByID to retrieve the ShipToUPSEml item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToUPSEml1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToUPSEmlRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToUPSEmls_Company_CustNum_ShipToNum_UPSQVSeq(Company:string, CustNum:string, ShipToNum:string, UPSQVSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToUPSEmlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToUPSEmls(" + Company + "," + CustNum + "," + ShipToNum + "," + UPSQVSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToUPSEmlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get ShipToAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_ShipToAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToAttchRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToAttches(Company:string, CustNum:string, ShipToNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToAttch item
   Description: Calls GetByID to retrieve the ShipToAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToAttchRow
   */  
export function get_ShipToes_Company_CustNum_ShipToNum_ShipToAttches_Company_CustNum_ShipToNum_DrawingSeq(Company:string, CustNum:string, ShipToNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToes(" + Company + "," + CustNum + "," + ShipToNum + ")/ShipToAttches(" + Company + "," + CustNum + "," + ShipToNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToRestrictions items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToRestrictions
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToRestrictionRow
   */  
export function get_ShipToRestrictions(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToRestrictions", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToRestrictions
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToRestrictionRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToRestrictionRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToRestrictions(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToRestrictions", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToRestriction item
   Description: Calls GetByID to retrieve the ShipToRestriction item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToRestrictionRow
   */  
export function get_ShipToRestrictions_Company_CustNum_ShipToNum_RestrictionTypeID(Company:string, CustNum:string, ShipToNum:string, RestrictionTypeID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToRestrictions(" + Company + "," + CustNum + "," + ShipToNum + "," + RestrictionTypeID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToRestriction for the service
   Description: Calls UpdateExt to update ShipToRestriction. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToRestrictionRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToRestrictions_Company_CustNum_ShipToNum_RestrictionTypeID(Company:string, CustNum:string, ShipToNum:string, RestrictionTypeID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToRestrictions(" + Company + "," + CustNum + "," + ShipToNum + "," + RestrictionTypeID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToRestriction item
   Description: Call UpdateExt to delete ShipToRestriction item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToRestrictions_Company_CustNum_ShipToNum_RestrictionTypeID(Company:string, CustNum:string, ShipToNum:string, RestrictionTypeID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToRestrictions(" + Company + "," + CustNum + "," + ShipToNum + "," + RestrictionTypeID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToLabExpRates items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToLabExpRates
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToLabExpRateRow
   */  
export function get_ShipToLabExpRates(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToLabExpRates", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToLabExpRates
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToLabExpRateRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToLabExpRateRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToLabExpRates(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToLabExpRates", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToLabExpRate item
   Description: Calls GetByID to retrieve the ShipToLabExpRate item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToLabExpRate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToLabExpRateRow
   */  
export function get_ShipToLabExpRates_Company_CustNum_ShipToNum_ExpenseCode(Company:string, CustNum:string, ShipToNum:string, ExpenseCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToLabExpRateRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToLabExpRates(" + Company + "," + CustNum + "," + ShipToNum + "," + ExpenseCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToLabExpRateRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToLabExpRate for the service
   Description: Calls UpdateExt to update ShipToLabExpRate. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToLabExpRate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToLabExpRateRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToLabExpRates_Company_CustNum_ShipToNum_ExpenseCode(Company:string, CustNum:string, ShipToNum:string, ExpenseCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToLabExpRates(" + Company + "," + CustNum + "," + ShipToNum + "," + ExpenseCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToLabExpRate item
   Description: Call UpdateExt to delete ShipToLabExpRate item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToLabExpRate
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param ExpenseCode Desc: ExpenseCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToLabExpRates_Company_CustNum_ShipToNum_ExpenseCode(Company:string, CustNum:string, ShipToNum:string, ExpenseCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToLabExpRates(" + Company + "," + CustNum + "," + ShipToNum + "," + ExpenseCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomerDocsSHes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomerDocsSHes
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerDocsSHRow
   */  
export function get_CustomerDocsSHes(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsSHRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocsSHes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsSHRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomerDocsSHes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerDocsSHRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerDocsSHRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomerDocsSHes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocsSHes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerDocsSH item
   Description: Calls GetByID to retrieve the CustomerDocsSH item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerDocsSH
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerDocsSHRow
   */  
export function get_CustomerDocsSHes_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerDocsSHRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocsSHes(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerDocsSHRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomerDocsSH for the service
   Description: Calls UpdateExt to update CustomerDocsSH. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomerDocsSH
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerDocsSHRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomerDocsSHes_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocsSHes(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomerDocsSH item
   Description: Call UpdateExt to delete CustomerDocsSH item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomerDocsSH
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DocumentName Desc: DocumentName   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomerDocsSHes_Company_CustNum_ShipToNum_DocumentName(Company:string, CustNum:string, ShipToNum:string, DocumentName:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerDocsSHes(" + Company + "," + CustNum + "," + ShipToNum + "," + DocumentName + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToDiscPriceLsts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToDiscPriceLsts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToDiscPriceLstRow
   */  
export function get_ShipToDiscPriceLsts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToDiscPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToDiscPriceLsts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToDiscPriceLstRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToDiscPriceLstRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToDiscPriceLsts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToDiscPriceLsts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToDiscPriceLst item
   Description: Calls GetByID to retrieve the ShipToDiscPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToDiscPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToDiscPriceLstRow
   */  
export function get_ShipToDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToDiscPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToDiscPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToDiscPriceLst for the service
   Description: Calls UpdateExt to update ShipToDiscPriceLst. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToDiscPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToDiscPriceLstRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToDiscPriceLst item
   Description: Call UpdateExt to delete ShipToDiscPriceLst item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToDiscPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToDiscPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToDiscPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToMFBills items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToMFBills
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToMFBillRow
   */  
export function get_ShipToMFBills(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToMFBills", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToMFBills
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToMFBillRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToMFBillRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToMFBills(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToMFBills", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToMFBill item
   Description: Calls GetByID to retrieve the ShipToMFBill item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToMFBill
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToMFBillRow
   */  
export function get_ShipToMFBills_Company_CustNum_ShipToNum_PayBTFlag(Company:string, CustNum:string, ShipToNum:string, PayBTFlag:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToMFBills(" + Company + "," + CustNum + "," + ShipToNum + "," + PayBTFlag + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToMFBill for the service
   Description: Calls UpdateExt to update ShipToMFBill. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToMFBill
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToMFBillRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToMFBills_Company_CustNum_ShipToNum_PayBTFlag(Company:string, CustNum:string, ShipToNum:string, PayBTFlag:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToMFBills(" + Company + "," + CustNum + "," + ShipToNum + "," + PayBTFlag + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToMFBill item
   Description: Call UpdateExt to delete ShipToMFBill item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToMFBill
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToMFBills_Company_CustNum_ShipToNum_PayBTFlag(Company:string, CustNum:string, ShipToNum:string, PayBTFlag:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToMFBills(" + Company + "," + CustNum + "," + ShipToNum + "," + PayBTFlag + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToPriceLsts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToPriceLsts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToPriceLstRow
   */  
export function get_ShipToPriceLsts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToPriceLsts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToPriceLstRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToPriceLstRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToPriceLsts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToPriceLsts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToPriceLst item
   Description: Calls GetByID to retrieve the ShipToPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToPriceLstRow
   */  
export function get_ShipToPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToPriceLst for the service
   Description: Calls UpdateExt to update ShipToPriceLst. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToPriceLstRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToPriceLst item
   Description: Call UpdateExt to delete ShipToPriceLst item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToUPSEmls items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToUPSEmls
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToUPSEmlRow
   */  
export function get_ShipToUPSEmls(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToUPSEmlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToUPSEmls", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToUPSEmlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToUPSEmls
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToUPSEmlRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToUPSEmlRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToUPSEmls(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToUPSEmls", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToUPSEml item
   Description: Calls GetByID to retrieve the ShipToUPSEml item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToUPSEml
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToUPSEmlRow
   */  
export function get_ShipToUPSEmls_Company_CustNum_ShipToNum_UPSQVSeq(Company:string, CustNum:string, ShipToNum:string, UPSQVSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToUPSEmlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToUPSEmls(" + Company + "," + CustNum + "," + ShipToNum + "," + UPSQVSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToUPSEmlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToUPSEml for the service
   Description: Calls UpdateExt to update ShipToUPSEml. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToUPSEml
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToUPSEmlRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToUPSEmls_Company_CustNum_ShipToNum_UPSQVSeq(Company:string, CustNum:string, ShipToNum:string, UPSQVSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToUPSEmls(" + Company + "," + CustNum + "," + ShipToNum + "," + UPSQVSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToUPSEml item
   Description: Call UpdateExt to delete ShipToUPSEml item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToUPSEml
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToUPSEmls_Company_CustNum_ShipToNum_UPSQVSeq(Company:string, CustNum:string, ShipToNum:string, UPSQVSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToUPSEmls(" + Company + "," + CustNum + "," + ShipToNum + "," + UPSQVSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToAttchRow
   */  
export function get_ShipToAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToAttch item
   Description: Calls GetByID to retrieve the ShipToAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToAttchRow
   */  
export function get_ShipToAttches_Company_CustNum_ShipToNum_DrawingSeq(Company:string, CustNum:string, ShipToNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToAttches(" + Company + "," + CustNum + "," + ShipToNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToAttch for the service
   Description: Calls UpdateExt to update ShipToAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToAttches_Company_CustNum_ShipToNum_DrawingSeq(Company:string, CustNum:string, ShipToNum:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToAttches(" + Company + "," + CustNum + "," + ShipToNum + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToAttch item
   Description: Call UpdateExt to delete ShipToAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToAttches_Company_CustNum_ShipToNum_DrawingSeq(Company:string, CustNum:string, ShipToNum:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToAttches(" + Company + "," + CustNum + "," + ShipToNum + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustMFBills items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustMFBills
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustMFBillRow
   */  
export function get_CustMFBills(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMFBills", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustMFBills
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustMFBillRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustMFBillRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustMFBills(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMFBills", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustMFBill item
   Description: Calls GetByID to retrieve the CustMFBill item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustMFBill
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustMFBillRow
   */  
export function get_CustMFBills_Company_CustNum_PayBTFlag(Company:string, CustNum:string, PayBTFlag:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustMFBillRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMFBills(" + Company + "," + CustNum + "," + PayBTFlag + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustMFBillRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustMFBill for the service
   Description: Calls UpdateExt to update CustMFBill. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustMFBill
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustMFBillRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustMFBills_Company_CustNum_PayBTFlag(Company:string, CustNum:string, PayBTFlag:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMFBills(" + Company + "," + CustNum + "," + PayBTFlag + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustMFBill item
   Description: Call UpdateExt to delete CustMFBill item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustMFBill
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param PayBTFlag Desc: PayBTFlag   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustMFBills_Company_CustNum_PayBTFlag(Company:string, CustNum:string, PayBTFlag:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustMFBills(" + Company + "," + CustNum + "," + PayBTFlag + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get MangCusts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_MangCusts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.MangCustRow
   */  
export function get_MangCusts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MangCustRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MangCusts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MangCustRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_MangCusts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.MangCustRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.MangCustRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_MangCusts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MangCusts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the MangCust item
   Description: Calls GetByID to retrieve the MangCust item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_MangCust
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param VendorNum Desc: VendorNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.MangCustRow
   */  
export function get_MangCusts_Company_CustNum_VendorNum(Company:string, CustNum:string, VendorNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_MangCustRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MangCusts(" + Company + "," + CustNum + "," + VendorNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_MangCustRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update MangCust for the service
   Description: Calls UpdateExt to update MangCust. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_MangCust
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param VendorNum Desc: VendorNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.MangCustRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_MangCusts_Company_CustNum_VendorNum(Company:string, CustNum:string, VendorNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MangCusts(" + Company + "," + CustNum + "," + VendorNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete MangCust item
   Description: Call UpdateExt to delete MangCust item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_MangCust
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param VendorNum Desc: VendorNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_MangCusts_Company_CustNum_VendorNum(Company:string, CustNum:string, VendorNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MangCusts(" + Company + "," + CustNum + "," + VendorNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get ShipToSrches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_ShipToSrches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.ShipToSrchRow
   */  
export function get_ShipToSrches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToSrchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToSrches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToSrchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_ShipToSrches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.ShipToSrchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.ShipToSrchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToSrches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToSrches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the ShipToSrch item
   Description: Calls GetByID to retrieve the ShipToSrch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_ShipToSrch
      @param SysRowID Desc: SysRowID   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.ShipToSrchRow
   */  
export function get_ShipToSrches_SysRowID(SysRowID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_ShipToSrchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToSrches(" + SysRowID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_ShipToSrchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update ShipToSrch for the service
   Description: Calls UpdateExt to update ShipToSrch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_ShipToSrch
      @param SysRowID Desc: SysRowID   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.ShipToSrchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_ShipToSrches_SysRowID(SysRowID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToSrches(" + SysRowID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete ShipToSrch item
   Description: Call UpdateExt to delete ShipToSrch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_ShipToSrch
      @param SysRowID Desc: SysRowID   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_ShipToSrches_SysRowID(SysRowID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToSrches(" + SysRowID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomerPriceLsts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomerPriceLsts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerPriceLstRow
   */  
export function get_CustomerPriceLsts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerPriceLsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomerPriceLsts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerPriceLstRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerPriceLstRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomerPriceLsts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerPriceLsts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerPriceLst item
   Description: Calls GetByID to retrieve the CustomerPriceLst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerPriceLstRow
   */  
export function get_CustomerPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerPriceLstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerPriceLstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomerPriceLst for the service
   Description: Calls UpdateExt to update CustomerPriceLst. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomerPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerPriceLstRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomerPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomerPriceLst item
   Description: Call UpdateExt to delete CustomerPriceLst item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomerPriceLst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param ShipToNum Desc: ShipToNum   Required: True   Allow empty value : True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomerPriceLsts_Company_CustNum_ShipToNum_SeqNum(Company:string, CustNum:string, ShipToNum:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerPriceLsts(" + Company + "," + CustNum + "," + ShipToNum + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get EntityGLCs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_EntityGLCs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.EntityGLCRow
   */  
export function get_EntityGLCs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/EntityGLCs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_EntityGLCs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_EntityGLCs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/EntityGLCs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the EntityGLC item
   Description: Calls GetByID to retrieve the EntityGLC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_EntityGLC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   */  
export function get_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update EntityGLC for the service
   Description: Calls UpdateExt to update EntityGLC. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_EntityGLC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete EntityGLC item
   Description: Call UpdateExt to delete EntityGLC item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_EntityGLC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get TaxExempts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_TaxExempts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.TaxExemptRow
   */  
export function get_TaxExempts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/TaxExempts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_TaxExempts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_TaxExempts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/TaxExempts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the TaxExempt item
   Description: Calls GetByID to retrieve the TaxExempt item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_TaxExempt
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   */  
export function get_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update TaxExempt for the service
   Description: Calls UpdateExt to update TaxExempt. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_TaxExempt
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete TaxExempt item
   Description: Call UpdateExt to delete TaxExempt item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_TaxExempt
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get CustomerAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_CustomerAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerAttchRow
   */  
export function get_CustomerAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_CustomerAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.CustomerAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.CustomerAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustomerAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the CustomerAttch item
   Description: Calls GetByID to retrieve the CustomerAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_CustomerAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.CustomerAttchRow
   */  
export function get_CustomerAttches_Company_CustNum_DrawingSeq(Company:string, CustNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_CustomerAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerAttches(" + Company + "," + CustNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_CustomerAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update CustomerAttch for the service
   Description: Calls UpdateExt to update CustomerAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_CustomerAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.CustomerAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_CustomerAttches_Company_CustNum_DrawingSeq(Company:string, CustNum:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerAttches(" + Company + "," + CustNum + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete CustomerAttch item
   Description: Call UpdateExt to delete CustomerAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_CustomerAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param CustNum Desc: CustNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_CustomerAttches_Company_CustNum_DrawingSeq(Company:string, CustNum:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustomerAttches(" + Company + "," + CustNum + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get Partners items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_Partners
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartnerRow
   */  
export function get_Partners(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartnerRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Partners", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartnerRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_Partners
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartnerRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartnerRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_Partners(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Partners", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the Partner item
   Description: Calls GetByID to retrieve the Partner item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_Partner
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartnerNum Desc: PartnerNum   Required: True
      @param PartnerType Desc: PartnerType   Required: True
      @param PartnerID Desc: PartnerID   Required: True   Allow empty value : True
      @param SearchID Desc: SearchID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartnerRow
   */  
export function get_Partners_Company_PartnerNum_PartnerType_PartnerID_SearchID(Company:string, PartnerNum:string, PartnerType:string, PartnerID:string, SearchID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartnerRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Partners(" + Company + "," + PartnerNum + "," + PartnerType + "," + PartnerID + "," + SearchID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartnerRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update Partner for the service
   Description: Calls UpdateExt to update Partner. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_Partner
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartnerNum Desc: PartnerNum   Required: True
      @param PartnerType Desc: PartnerType   Required: True
      @param PartnerID Desc: PartnerID   Required: True   Allow empty value : True
      @param SearchID Desc: SearchID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartnerRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_Partners_Company_PartnerNum_PartnerType_PartnerID_SearchID(Company:string, PartnerNum:string, PartnerType:string, PartnerID:string, SearchID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Partners(" + Company + "," + PartnerNum + "," + PartnerType + "," + PartnerID + "," + SearchID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete Partner item
   Description: Call UpdateExt to delete Partner item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_Partner
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartnerNum Desc: PartnerNum   Required: True
      @param PartnerType Desc: PartnerType   Required: True
      @param PartnerID Desc: PartnerID   Required: True   Allow empty value : True
      @param SearchID Desc: SearchID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_Partners_Company_PartnerNum_PartnerType_PartnerID_SearchID(Company:string, PartnerNum:string, PartnerType:string, PartnerID:string, SearchID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Partners(" + Company + "," + PartnerNum + "," + PartnerType + "," + PartnerID + "," + SearchID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetList for the service
   Description: Get list of items<div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetList
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.CustomerListRow
   */  
export function get_List(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/List", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
// Custom methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Invoke method GetRows
   Description: Returns a dataset containing all rows that satisfy the where clauses.
   OperationID: Get_GetRows
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRows_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetRows(whereClauseCustomer:string, whereClauseCustomerAttch:string, whereClauseCustomCrdPool:string, whereClausePartner:string, whereClauseCustBillTo:string, whereClauseCustBank:string, whereClauseCustChild:string, whereClauseCustDfltDocType:string, whereClauseCustIC:string, whereClauseCustLabExpRate:string, whereClauseCustMandate:string, whereClauseCustomerDocs:string, whereClauseCustRestriction:string, whereClauseCustUPSEmail:string, whereClauseCustomerDiscPriceLst:string, whereClauseCustomerFSPriceList:string, whereClauseGlbCustCred:string, whereClauseMXCustomerFiscalText:string, whereClauseNAMember:string, whereClausePECustWhldHist:string, whereClauseShipTo:string, whereClauseShipToAttch:string, whereClauseShipToRestriction:string, whereClauseShipToLabExpRate:string, whereClauseCustomerDocsSH:string, whereClauseShipToDiscPriceLst:string, whereClauseShipToMFBill:string, whereClauseShipToPriceLst:string, whereClauseShipToUPSEml:string, whereClauseCustMFBill:string, whereClauseMangCust:string, whereClauseShipToSrch:string, whereClauseCustomerPriceLst:string, whereClauseEntityGLC:string, whereClauseTaxExempt:string, pageSize:string, absolutePage:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof whereClauseCustomer!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomer=" + whereClauseCustomer
   }
   if(typeof whereClauseCustomerAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomerAttch=" + whereClauseCustomerAttch
   }
   if(typeof whereClauseCustomCrdPool!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomCrdPool=" + whereClauseCustomCrdPool
   }
   if(typeof whereClausePartner!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartner=" + whereClausePartner
   }
   if(typeof whereClauseCustBillTo!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustBillTo=" + whereClauseCustBillTo
   }
   if(typeof whereClauseCustBank!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustBank=" + whereClauseCustBank
   }
   if(typeof whereClauseCustChild!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustChild=" + whereClauseCustChild
   }
   if(typeof whereClauseCustDfltDocType!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustDfltDocType=" + whereClauseCustDfltDocType
   }
   if(typeof whereClauseCustIC!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustIC=" + whereClauseCustIC
   }
   if(typeof whereClauseCustLabExpRate!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustLabExpRate=" + whereClauseCustLabExpRate
   }
   if(typeof whereClauseCustMandate!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustMandate=" + whereClauseCustMandate
   }
   if(typeof whereClauseCustomerDocs!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomerDocs=" + whereClauseCustomerDocs
   }
   if(typeof whereClauseCustRestriction!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustRestriction=" + whereClauseCustRestriction
   }
   if(typeof whereClauseCustUPSEmail!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustUPSEmail=" + whereClauseCustUPSEmail
   }
   if(typeof whereClauseCustomerDiscPriceLst!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomerDiscPriceLst=" + whereClauseCustomerDiscPriceLst
   }
   if(typeof whereClauseCustomerFSPriceList!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomerFSPriceList=" + whereClauseCustomerFSPriceList
   }
   if(typeof whereClauseGlbCustCred!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseGlbCustCred=" + whereClauseGlbCustCred
   }
   if(typeof whereClauseMXCustomerFiscalText!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseMXCustomerFiscalText=" + whereClauseMXCustomerFiscalText
   }
   if(typeof whereClauseNAMember!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseNAMember=" + whereClauseNAMember
   }
   if(typeof whereClausePECustWhldHist!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePECustWhldHist=" + whereClausePECustWhldHist
   }
   if(typeof whereClauseShipTo!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipTo=" + whereClauseShipTo
   }
   if(typeof whereClauseShipToAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToAttch=" + whereClauseShipToAttch
   }
   if(typeof whereClauseShipToRestriction!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToRestriction=" + whereClauseShipToRestriction
   }
   if(typeof whereClauseShipToLabExpRate!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToLabExpRate=" + whereClauseShipToLabExpRate
   }
   if(typeof whereClauseCustomerDocsSH!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomerDocsSH=" + whereClauseCustomerDocsSH
   }
   if(typeof whereClauseShipToDiscPriceLst!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToDiscPriceLst=" + whereClauseShipToDiscPriceLst
   }
   if(typeof whereClauseShipToMFBill!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToMFBill=" + whereClauseShipToMFBill
   }
   if(typeof whereClauseShipToPriceLst!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToPriceLst=" + whereClauseShipToPriceLst
   }
   if(typeof whereClauseShipToUPSEml!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToUPSEml=" + whereClauseShipToUPSEml
   }
   if(typeof whereClauseCustMFBill!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustMFBill=" + whereClauseCustMFBill
   }
   if(typeof whereClauseMangCust!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseMangCust=" + whereClauseMangCust
   }
   if(typeof whereClauseShipToSrch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseShipToSrch=" + whereClauseShipToSrch
   }
   if(typeof whereClauseCustomerPriceLst!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseCustomerPriceLst=" + whereClauseCustomerPriceLst
   }
   if(typeof whereClauseEntityGLC!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseEntityGLC=" + whereClauseEntityGLC
   }
   if(typeof whereClauseTaxExempt!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseTaxExempt=" + whereClauseTaxExempt
   }
   if(typeof pageSize!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "pageSize=" + pageSize
   }
   if(typeof absolutePage!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "absolutePage=" + absolutePage
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetRows" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetByID
   Description: Returns a DataSet given the primary key.
   OperationID: Get_GetByID
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetByID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetByID(custNum:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof custNum!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "custNum=" + custNum
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetByID" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method LandingPageGetRows
   Description: GetRows used for Landing page in kinetic UI
   OperationID: LandingPageGetRows
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/LandingPageGetRows_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/LandingPageGetRows_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_LandingPageGetRows(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/LandingPageGetRows", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomer
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomerAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartner
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartner
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartner_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartner_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartner(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewPartner", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustBillTo
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustBillTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustBillTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustBillTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustBillTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustBillTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustBank
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustBank
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustBank_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustBank_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustBank(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustBank", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustChild
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustChild
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustChild_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustChild_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustChild(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustChild", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustDfltDocType
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustDfltDocType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustDfltDocType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustDfltDocType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustDfltDocType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustDfltDocType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustIC
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustIC
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustIC_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustIC_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustIC(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustIC", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustLabExpRate
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustLabExpRate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustLabExpRate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustLabExpRate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustLabExpRate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustLabExpRate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustMandate
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustMandate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustMandate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustMandate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustMandate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustMandate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerDocs
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomerDocs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerDocs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerDocs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerDocs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerDocs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustRestriction
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustRestriction
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustRestriction_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustRestriction_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustRestriction(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustRestriction", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustUPSEmail
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustUPSEmail
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustUPSEmail_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustUPSEmail_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustUPSEmail(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustUPSEmail", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerDiscPriceLst
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomerDiscPriceLst
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerDiscPriceLst_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerDiscPriceLst_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerDiscPriceLst(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerDiscPriceLst", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerFSPriceList
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomerFSPriceList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerFSPriceList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerFSPriceList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerFSPriceList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerFSPriceList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewGlbCustCred
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewGlbCustCred
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewGlbCustCred_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewGlbCustCred_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewGlbCustCred(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewGlbCustCred", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewMXCustomerFiscalText
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewMXCustomerFiscalText
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewMXCustomerFiscalText_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewMXCustomerFiscalText_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewMXCustomerFiscalText(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewMXCustomerFiscalText", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipTo
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToRestriction
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToRestriction
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToRestriction_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToRestriction_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToRestriction(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToRestriction", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToLabExpRate
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToLabExpRate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToLabExpRate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToLabExpRate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToLabExpRate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToLabExpRate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerDocsSH
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomerDocsSH
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerDocsSH_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerDocsSH_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerDocsSH(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerDocsSH", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToDiscPriceLst
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToDiscPriceLst
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToDiscPriceLst_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToDiscPriceLst_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToDiscPriceLst(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToDiscPriceLst", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToMFBill
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToMFBill
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToMFBill_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToMFBill_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToMFBill(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToMFBill", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToPriceLst
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToPriceLst
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToPriceLst_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToPriceLst_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToPriceLst(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToPriceLst", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewShipToUPSEml
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewShipToUPSEml
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewShipToUPSEml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewShipToUPSEml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewShipToUPSEml(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewShipToUPSEml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustMFBill
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustMFBill
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustMFBill_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustMFBill_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustMFBill(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustMFBill", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewMangCust
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewMangCust
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewMangCust_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewMangCust_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewMangCust(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewMangCust", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerPriceLst
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewCustomerPriceLst
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerPriceLst_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerPriceLst_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerPriceLst(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerPriceLst", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewEntityGLC
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewEntityGLC
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewEntityGLC_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewEntityGLC_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewEntityGLC(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewEntityGLC", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewTaxExempt
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewTaxExempt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewTaxExempt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewTaxExempt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewTaxExempt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewTaxExempt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeleteByID
   Description: Deletes a row given its ID.
   OperationID: DeleteByID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DeleteByID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeleteByID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeleteByID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/DeleteByID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetList
   Description: Returns a list of rows that satisfy the where clause.
   OperationID: Get_GetList
      @param whereClause Desc: An expression used to filter the rows. Can be left blank for all rows.   Required: True   Allow empty value : True
      @param pageSize Desc: The maximum number of rows to return. Leave as zero for no maximum.   Required: True
      @param absolutePage Desc: Page of rows to return.   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetList(whereClause:string, pageSize:string, absolutePage:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof whereClause!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClause=" + whereClause
   }
   if(typeof pageSize!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "pageSize=" + pageSize
   }
   if(typeof absolutePage!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "absolutePage=" + absolutePage
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetList" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBySysRowID
   OperationID: Get_GetBySysRowID
   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBySysRowID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetBySysRowID(id:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof id!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "id=" + id
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetBySysRowID" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBySysRowIDs
   OperationID: Get_GetBySysRowIDs
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBySysRowIDs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetBySysRowIDs(ids:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof ids!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "ids=" + ids
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetBySysRowIDs" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method Update
   Description: Commits the DataSet changes to the data store.
   OperationID: Update
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Update_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/Update_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_Update(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/Update", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateExt
   Description: Apply input data to service by calling GetByID/GetNew/Update methods.
   OperationID: UpdateExt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateExt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateExt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateExt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/UpdateExt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerGlobalFields
   Description: none
   OperationID: GetCustomerGlobalFields
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerGlobalFields_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerGlobalFields_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerGlobalFields(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerGlobalFields", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetShipToGlobalFields
   Description: none
   OperationID: GetShipToGlobalFields
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetShipToGlobalFields_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetShipToGlobalFields_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetShipToGlobalFields(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetShipToGlobalFields", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustBillToGlobalFields
   Description: none
   OperationID: GetCustBillToGlobalFields
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustBillToGlobalFields_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustBillToGlobalFields_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustBillToGlobalFields(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustBillToGlobalFields", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AllowCustomerDetailUpdate
   Description: This method exists soley for the purpose of allowing security for
updating customer detail information to be defined
   OperationID: AllowCustomerDetailUpdate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/AllowCustomerDetailUpdate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AllowCustomerDetailUpdate(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/AllowCustomerDetailUpdate", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustDfltInvoiceType
   Description: Set TranDocType when Invice Type was changed
   OperationID: ChangeCustDfltInvoiceType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustDfltInvoiceType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustDfltInvoiceType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustDfltInvoiceType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustDfltInvoiceType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustICICCode
   Description: Validates change of ICCode
   OperationID: ChangeCustICICCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustICICCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustICICCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustICICCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustICICCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustMandateBankAcctID
   Description: Validates change of BankAcctID
   OperationID: ChangeCustMandateBankAcctID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustMandateBankAcctID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustMandateBankAcctID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustMandateBankAcctID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustMandateBankAcctID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustomerAllowAltBillTo
   Description: Validates change of AllowAltBillTo
   OperationID: ChangeCustomerAllowAltBillTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustomerAllowAltBillTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustomerAllowAltBillTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustomerAllowAltBillTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustomerAllowAltBillTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustomerChargeCode
   Description: Validates ChargeCode value
   OperationID: ChangeCustomerChargeCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustomerChargeCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustomerChargeCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustomerChargeCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustomerChargeCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustomerFinCharges
   Description: Validates FinCharges value
   OperationID: ChangeCustomerFinCharges
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustomerFinCharges_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustomerFinCharges_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustomerFinCharges(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustomerFinCharges", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustomerReminderGroup
   Description: Validates ReminderGroup value
   OperationID: ChangeCustomerReminderGroup
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustomerReminderGroup_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustomerReminderGroup_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustomerReminderGroup(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCustomerReminderGroup", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeDeferredRev
   Description: Performs required logic when Customer.DeferredRev is modified.
   OperationID: ChangeDeferredRev
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeDeferredRev_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeDeferredRev_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeDeferredRev(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeDeferredRev", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeAGIDDocTypeCode
   Description: Argentina CSF - Performs required logic when Customer.AGIDDocTypeCode is modified.
   OperationID: ChangeAGIDDocTypeCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeAGIDDocTypeCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeAGIDDocTypeCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeAGIDDocTypeCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeAGIDDocTypeCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeListCode
   Description: This method validates and populates the ListCode in either CustomerPriceLst
or ShipToPriceLst
   OperationID: ChangeListCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeListCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeListCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeListCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeListCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMandateReference
   Description: Change mandate reference.
   OperationID: ChangeMandateReference
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMandateReference_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMandateReference_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMandateReference(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeMandateReference", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ModifySearchIDs
   Description: Modify Search ID.
   OperationID: ModifySearchIDs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ModifySearchIDs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ModifySearchIDs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ModifySearchIDs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ModifySearchIDs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRACode
   Description: Performs required logic when Customer.RACode is modified.
   OperationID: ChangeRACode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRACode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRACode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRACode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeRACode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCreditHold
   Description: This method checks if customer will go on credit hold.  Then asks if the user
wants all orders to go on credit hold.  To be right befor updated.  If the user
answers yes to putting orders on hold, then the ApplyHoldToOrder field needs to be populated
   OperationID: CheckCreditHold
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCreditHold_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCreditHold_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCreditHold(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CheckCreditHold", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckDupCustomer
   Description: This method checks the Name,Address1 and ZipCode fields to see if there are
any duplicate customers.  A ListDataSet will be returned to the user of any duplicates asking
if the user wants to continue.  Needs to be run before Update on a NEW record only
   OperationID: CheckDupCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckDupCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckDupCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckDupCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CheckDupCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckEFFieldLength
   Description: This method checks if the field length of the Name and address fields will fit
within the External Financials integration rules.  If not, a list of problem fields will be sent
back to the user to either change, or accept that they will be truncated when the
customer is sent over to SoftCell.
   OperationID: CheckEFFieldLength
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckEFFieldLength_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckEFFieldLength_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckEFFieldLength(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CheckEFFieldLength", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckRUC
   Description: CSF Peru - This method test the validity of the Tax ID (RUC)
   OperationID: CheckRUC
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckRUC_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckRUC_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckRUC(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CheckRUC", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckVATFormat
   Description: This method test the validity of the VAT format
   OperationID: CheckVATFormat
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckVATFormat_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckVATFormat_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckVATFormat(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CheckVATFormat", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChgBTCountry
   Description: This method clears the BillTo address format string if the country has changed
   OperationID: ChgBTCountry
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChgBTCountry_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChgBTCountry_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChgBTCountry(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChgBTCountry", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChgCentralCollection
   Description: Method to validate if the Parent Company in Company Configuration is selected to allow be a Central Collection Customer.
   OperationID: ChgCentralCollection
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChgCentralCollection_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChgCentralCollection_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChgCentralCollection(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChgCentralCollection", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChgCountry
   Description: This method sets the ShipVia, Language and FormatStr fields when the Country has changed.
   OperationID: ChgCountry
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChgCountry_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChgCountry_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChgCountry(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChgCountry", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChgGlobalCust
   Description: Method to call when changing the global customer flag on a customer.
Assigns the GlbFlag base on the new value.
   OperationID: ChgGlobalCust
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChgGlobalCust_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChgGlobalCust_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChgGlobalCust(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChgGlobalCust", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChgICTrader
   Description: Method to call when changing the ICTrader flag on a customer.
Assigns the EnableGlobalCust based on the new value.
   OperationID: ChgICTrader
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChgICTrader_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChgICTrader_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChgICTrader(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChgICTrader", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetECCTypesList
   Description: Returns a list of available options for ECC Types depending on user having a Dealer Network Management License
   OperationID: GetECCTypesList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetECCTypesList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetECCTypesList(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetECCTypesList", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerDocsPartOptionAvailList
   Description: Fill PartOptionAvailList with the non selected options from PartOptionSelList
   OperationID: GetCustomerDocsPartOptionAvailList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerDocsPartOptionAvailList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerDocsPartOptionAvailList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerDocsPartOptionAvailList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerDocsPartOptionAvailList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeleteBTAddress
   Description: This method clears out the Billto Address fields.  To be run if the user no longer
wants a separate Bill To Address
   OperationID: DeleteBTAddress
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DeleteBTAddress_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeleteBTAddress_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeleteBTAddress(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/DeleteBTAddress", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ETCAfterAddrVal
   Description: After the tax integration has been called, update the customer address if it
was changed.
   OperationID: ETCAfterAddrVal
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ETCAfterAddrVal_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ETCAfterAddrVal_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ETCAfterAddrVal(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ETCAfterAddrVal", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ETCValidateAddress
   Description: Call tax integration and loads temp tables from the results.
   OperationID: ETCValidateAddress
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ETCValidateAddress_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ETCValidateAddress_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ETCValidateAddress(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ETCValidateAddress", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GenerateMandateReference
   Description: This method generates mandate reference for mandate
   OperationID: GenerateMandateReference
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GenerateMandateReference_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GenerateMandateReference_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GenerateMandateReference(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GenerateMandateReference", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetAddrElementList
   Description: This method returns the available address elements in a delimited list
   OperationID: GetAddrElementList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetAddrElementList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetAddrElementList(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetAddrElementList", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetAllShipTo
   Description: This returns the ShipTo record in the Customer dataset with ShipTo child
records returned.
   OperationID: GetAllShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetAllShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetAllShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetAllShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetAllShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetAltShipTo
   Description: This returns the alternate ShipTo record in the Customer dataset.  ShipTo child
records are not returned.
   OperationID: GetAltShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetAltShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetAltShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetAltShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetAltShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBankAccountList
   Description: This method returns a list of Fields
   OperationID: GetBankAccountList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBankAccountList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetBankAccountList(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetBankAccountList", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBillDayList
   Description: This method returns the list of Bill Days to select from based on the billing Frequency
   OperationID: GetBillDayList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetBillDayList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBillDayList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetBillDayList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetBillDayList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBillToRefs
   Description: This method returns all the 'sold to' customers for this alt bill to.
   OperationID: GetBillToRefs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetBillToRefs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBillToRefs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetBillToRefs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetBillToRefs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetByCustID
   Description: This method finds the customer record by CustId instead of CustNum
   OperationID: GetByCustID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetByCustID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetByCustID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetByCustID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetByCustID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerAndOptionalShipTo
   Description: This method retrieves the Customer and optional shipTo data for passed CustNum / ShipToNum
   OperationID: GetCustomerAndOptionalShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerAndOptionalShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerAndOptionalShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerAndOptionalShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerAndOptionalShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCompanyDataForMandate
   Description: This method retrieves company data for mandate
   OperationID: GetCompanyDataForMandate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCompanyDataForMandate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCompanyDataForMandate(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCompanyDataForMandate", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustBillToForLink
   Description: This returns the CustBillTo record in the Customer dataset for linking.
   OperationID: GetCustBillToForLink
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustBillToForLink_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustBillToForLink_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustBillToForLink(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustBillToForLink", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomer
   Description: This returns the Customer dataset with only the Customer datatable populated.
Customer child records are not returned.
   OperationID: GetCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerDataForMandate
   Description: This method retrieves customer data for mandate
   OperationID: GetCustomerDataForMandate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerDataForMandate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerDataForMandate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerDataForMandate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerDataForMandate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerForLink
   Description: This returns the Customer dataset for linking.
OBSOLETE METHOD:  Use method GetCustomer instead.
   OperationID: GetCustomerForLink
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerForLink_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerForLink_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerForLink(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerForLink", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerTerritory
   Description: This method sets the Customer's Territory ID according to system rules
   OperationID: GetCustomerTerritory
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerTerritory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerTerritory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerTerritory(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerTerritory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerUIDefaults
   Description: Return separated list of values for use in CustomerEntry
AllowCustomerDetailUpdate = Security.CheckSecurityAccess("BO.Customer.AllowCustomerDetailUpdate")
DisabledFields = List of fields to disable if AllowCustomerDetailUpdate is false
ExternalCRMIntegrationIsEnabled = CRSyst.ExternalCRMIntegration
GlbCustomersExist = GlbCustomer record exists
TaxValidationAllow = XbSyst.TaxValidationAllow
ELIEinvoice = XbSyst.ELIEinvoice
   OperationID: GetCustomerUIDefaults
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerUIDefaults_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerUIDefaults(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerUIDefaults", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDisabledFields
   Description: This method returns a list of fields the user has access to
when the user does not have rights to update detail information.
   OperationID: GetDisabledFields
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDisabledFields_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDisabledFields(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetDisabledFields", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetGlbCustomerList
   Description: This method returns the GlbCustomer dataset based on a delimited list of
GlbCustNum values passed in.
   OperationID: GetGlbCustomerList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetGlbCustomerList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetGlbCustomerList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetGlbCustomerList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetGlbCustomerList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListForAuthorizedTerritories
   Description: This overload of GetList adds Customers which ShipTo's fall within authorized territories.
   OperationID: GetListForAuthorizedTerritories
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListForAuthorizedTerritories_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListForAuthorizedTerritories_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListForAuthorizedTerritories(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetListForAuthorizedTerritories", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListCustom
   Description: This overload of GetList adds Customers which ShipTo's fall within authorized territories.
   OperationID: GetListCustom
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListCustom_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListCustom_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListCustom(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetListCustom", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListFromSelectedKeys
   Description: This methods will return all of the Customers records that meet the selection criteria.
This method will try to mirror the functionality of the base GetList method but
since we are populating a temp table we need our own public method.
   OperationID: GetListFromSelectedKeys
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListFromSelectedKeys_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListFromSelectedKeys_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListFromSelectedKeys(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetListFromSelectedKeys", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewAltShipTo
   Description: This returns the alternate ShipTo record in the Customer dataset using the
default ShipTo as a base.
   OperationID: GetNewAltShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewAltShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewAltShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewAltShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewAltShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetParentCustInfo
   Description: This method sets the parent Customer information
   OperationID: GetParentCustInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetParentCustInfo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetParentCustInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetParentCustInfo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetParentCustInfo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetShipTo
   Description: This returns the ShipTo record in the Customer dataset.  ShipTo child
records are not returned.
   OperationID: GetShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetShipToRows
   Description: GetShipToRows method returns all the ShipTos for a specific customer by paging.
   OperationID: GetShipToRows
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetShipToRows_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetShipToRows_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetShipToRows(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetShipToRows", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetShipToForLink
   Description: This returns the ShipTo record in the Customer dataset for linking.
OBSOLETE METHOD:  Use method GetShipTo instead.
   OperationID: GetShipToForLink
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetShipToForLink_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetShipToForLink_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetShipToForLink(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetShipToForLink", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetShipToTerritory
   Description: This method defaults the ShipTo Territory according to system rules
   OperationID: GetShipToTerritory
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetShipToTerritory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetShipToTerritory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetShipToTerritory(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetShipToTerritory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GlbCustomersExist
   Description: This method checks if GlbCustomer records exists or not.  Can be used
to determine if the option to link/unlink customers is available.
   OperationID: GlbCustomersExist
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GlbCustomersExist_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GlbCustomersExist(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GlbCustomersExist", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method LinkGlbCustBillTo
   Description: This method performs the actual logic to link CustBillTo records for a linked customer.
It will only allow CustBillTo's of linked customers to be processed, otherwise an exception
will be raised.  The ability to link CustBillTo's for a linked Customer should be offered
immediately after performing the update method on a Linked Customer but it does not have
to be limited to that time only.
It is run after the PreLinkGlbCustBillTo method which determines the CustBillToNum to link to.
If the CustBillToNum is for a CustBillTo that already exists, the GlbCustBillTo information is
translated and then copied to the CustomerDataSet as an update.
If the CustBillToNum is for a new CustBillTo, the GlbCustBillTo information is translated and then
copied to the CustomerDataSet as an Add.  Until the update method is run on the CustBillTo
record the Link process is not completed.
Once the CustBillTo record has been linked, the GlbCustCnt records need to be offered up
to be linked as well.
   OperationID: LinkGlbCustBillTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/LinkGlbCustBillTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/LinkGlbCustBillTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_LinkGlbCustBillTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/LinkGlbCustBillTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method LinkGlbCustomer
   Description: This method performs the actual logic behind linking a customer.  It is run after
the PreLinkGlbCustomer method which determines the Customer ID to link to.
If the Customer Id is for a Customer that already exists, the GlbCustomer information is
translated and then copied to the CustomerDataSet as an update.
If the Customer ID is for a new Customer, the GlbCustomer information is translated and then
copied to the CustomerDataSet as an Add.  Until the update method is run on Customer record
the Link process is not completed.
Once the Customer record has been linked, the GlbShipto and GlbCustCnt records needs to
be offered up to be linked as well.
   OperationID: LinkGlbCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/LinkGlbCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/LinkGlbCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_LinkGlbCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/LinkGlbCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method LinkGlbShipTo
   Description: This method performs the actual logic to link shipto records for a linked customer.
It will only allow shipto's of linked customers to be processed, otherwise an exception
will be raised.  The ability to link ShipTo's for a linked Customer should be offered
immediately after performing the update method on a Linked Customer but it does not have
to be limited to that time only.
It is run after the PreLinkGlbShipto method which determines the ShiptoNum to link to.
If the ShipToNum is for a Shipto that already exists, the GlbShipTo information is
translated and then copied to the CustomerDataSet as an update.
If the ShipToNum is for a new ShipTo, the GlbShipTo information is translated and then
copied to the CustomerDataSet as an Add.  Until the update method is run on the ShipTo
record the Link process is not completed.
Once the ShipTo record has been linked, the GlbCustCnt records need to be offered up
to be linked as well.
   OperationID: LinkGlbShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/LinkGlbShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/LinkGlbShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_LinkGlbShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/LinkGlbShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method RefreshGlbShipTo
   Description: Refresh GlbShipTo data
   OperationID: RefreshGlbShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/RefreshGlbShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/RefreshGlbShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_RefreshGlbShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/RefreshGlbShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SkipGlbShipTo
   Description: Mark unlinked GlbShipTo records as skipped
   OperationID: SkipGlbShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SkipGlbShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SkipGlbShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SkipGlbShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/SkipGlbShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SkipSingleGlbShipTo
   Description: Mark a specified GlbShipTo records as skipped
   OperationID: SkipSingleGlbShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SkipSingleGlbShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SkipSingleGlbShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SkipSingleGlbShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/SkipSingleGlbShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method MoveOnePosition
   Description: This method moves the Customer/ShipTo PriceLst Up/Down one position in the
grid and returns the whole updated datatable.
   OperationID: MoveOnePosition
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/MoveOnePosition_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/MoveOnePosition_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_MoveOnePosition(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MoveOnePosition", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method MoveOnePositionDisc
   Description: This method moves the Customer/ShipTo Disc PriceLst Up/Down one position in the
grid and returns the whole updated datatable.
   OperationID: MoveOnePositionDisc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/MoveOnePositionDisc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/MoveOnePositionDisc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_MoveOnePositionDisc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/MoveOnePositionDisc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeAltShipTo
   Description: This sets the ShipTo table based on the MasterCustNum and MasterShipToNum fields.
To be used when the alternate fields change
   OperationID: OnChangeAltShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeAltShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeAltShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeAltShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeAltShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCreditCardOrder
   Description: This method validates field CreditCardOrder
   OperationID: OnChangeCreditCardOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCreditCardOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCreditCardOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCreditCardOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeCreditCardOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCustBankBankBranchCode
   Description: This method validates field BankBranchCode
   OperationID: OnChangeCustBankBankBranchCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCustBankBankBranchCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCustBankBankBranchCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCustBankBankBranchCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeCustBankBankBranchCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCustBankPayMethod
   Description: This method populates Pay Method type.
   OperationID: OnChangeCustBankPayMethod
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCustBankPayMethod_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCustBankPayMethod_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCustBankPayMethod(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeCustBankPayMethod", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCustICPrimary
   Description: This method validates the Primary checkbox for customer Industry Class.
   OperationID: OnChangeCustICPrimary
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCustICPrimary_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCustICPrimary_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCustICPrimary(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeCustICPrimary", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCustomerTaxRegion
   Description: This method validates TaxRegionCode and populates description for customer.
   OperationID: OnChangeCustomerTaxRegion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCustomerTaxRegion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCustomerTaxRegion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCustomerTaxRegion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeCustomerTaxRegion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofAltBT
   Description: This method retrieves the CustBillTo record using the CustID passed. The AllowAsBillTo
flag must be set on the bill to customer record.
   OperationID: OnChangeofAltBT
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofAltBT_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofAltBT_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofAltBT(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeofAltBT", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofBankAccount
   Description: This method retrieves the BankAcct record using the BankAcctID passed.
   OperationID: OnChangeofBankAccount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofBankAccount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofBankAccount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofBankAccount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeofBankAccount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofCustomerAddr
   Description: Set the AddressVal flag to false which will indicate the address needs validation.
   OperationID: OnChangeofCustomerAddr
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofCustomerAddr_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofCustomerAddr_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofCustomerAddr(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeofCustomerAddr", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofShipToAddr
   Description: Set the AddressVal flag to false which will indicate the address needs validation.
   OperationID: OnChangeofShipToAddr
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofShipToAddr_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofShipToAddr_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofShipToAddr(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeofShipToAddr", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeShipToTaxRegion
   Description: This method validates TaxRegionCode and populates description for shipto.
   OperationID: OnChangeShipToTaxRegion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeShipToTaxRegion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeShipToTaxRegion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeShipToTaxRegion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeShipToTaxRegion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeVendorID
   Description: This method validates VendorID and populates vendor name.
   OperationID: OnChangeVendorID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeVendorID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeVendorID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeVendorID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeVendorID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeELIDefReportID
   Description: OnChangeELIDefReportID
   OperationID: OnChangeELIDefReportID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeELIDefReportID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeELIDefReportID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeELIDefReportID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnChangeELIDefReportID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnMandateBankAccountChanging
   Description: This method validates Bank account ID for mandate.
   OperationID: OnMandateBankAccountChanging
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnMandateBankAccountChanging_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnMandateBankAccountChanging_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnMandateBankAccountChanging(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnMandateBankAccountChanging", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnMandateDateChanging
   Description: This method validates Valid From date for mandate.
   OperationID: OnMandateDateChanging
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnMandateDateChanging_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnMandateDateChanging_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnMandateDateChanging(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnMandateDateChanging", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnMandateSignedDateChanging
   Description: This method validates Signed date for mandate.
   OperationID: OnMandateSignedDateChanging
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnMandateSignedDateChanging_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnMandateSignedDateChanging_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnMandateSignedDateChanging(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnMandateSignedDateChanging", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnMandateStatusChanging
   Description: This method validates Status of mandate.
   OperationID: OnMandateStatusChanging
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnMandateStatusChanging_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnMandateStatusChanging_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnMandateStatusChanging(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/OnMandateStatusChanging", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PreLinkGlbCustBillTo
   Description: Linking a GlbCustBillTo record ties a global record to a new or existing CustBillTo record so
that any changes made to the GlbCustBillTo record in another company are automatically copied
to any linked CustBillTo's.
This method performs the pre link logic to check of okay to link or get the new BTCustNum
to create/link to.  Will be run before LinkGlbCustBillTo which actually creates/updates a
CustBillTo record and will send the modified record back for update.  When the Link "button" is
originally selected, the LinkBTCustNum will be defaulted to the GlbBTCustNum field.
It will then check to see if this ID is available for use.  If available for use the system
will return a question asking the user if they want to use this number.  If the answer is no,
then the user either needs to select an existing BTCustNum for the current customer to link
to or enter a brand new BTCustNum for the customer.  You will run this method until the
user's answer is yes.  Then the LinkGlbCustBillTo method is called.
   OperationID: PreLinkGlbCustBillTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PreLinkGlbCustBillTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PreLinkGlbCustBillTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PreLinkGlbCustBillTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PreLinkGlbCustBillTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PreLinkGlbCustomer
   Description: Linking a Glbcustomer record ties a global record to a new or existing Customer record so
that any changes made to the GlbCustomer record in another company are automatically copied
to any linked customers.
This method performs the pre link logic to check of okay to link or get the new custid
to create/link to.  Will be run before LinkGlbCustomer which actually creates/updates a
customer record and will send the modified record back for update.  When the Link "button" is
originally selected, the LinkCustID will be defaulted to the GlbCustId field.  It will then
check to see if this ID is available for Use.  If available for use the system will return a
question asking the user if they want to use this number.  If the answer is no, then the user
either needs to select an existing customer's ID to link to or enter a brand new ID.  You will
run this method until the user answer is yes.  Then the LinkGlbCustomer method is called.
   OperationID: PreLinkGlbCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PreLinkGlbCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PreLinkGlbCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PreLinkGlbCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PreLinkGlbCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PreLinkGlbShipTo
   Description: Linking a GlbShipTo record ties a global record to a new or existing ShipTo record so
that any changes made to the GlbShipTo record in another company are automatically copied
to any linked shipto's.
This method performs the pre link logic to check of okay to link or get the new shiptonum
to create/link to.  Will be run before LinkGlbShipTo which actually creates/updates a
shipto record and will send the modified record back for update.  When the Link "button" is
originally selected, the LinkShipToNum will be defaulted to the GlbShipToNum field.
It will then check to see if this ID is available for use.  If available for use the system
will return a question asking the user if they want to use this number.  If the answer is no,
then the user either needs to select an existing ShipToNum for the current customer to link
to or enter a brand new ShipToNum for the customer.  You will run this method until the
user's answer is yes.  Then the LinkGlbShipTo method is called.
   OperationID: PreLinkGlbShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PreLinkGlbShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PreLinkGlbShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PreLinkGlbShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/PreLinkGlbShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ResetShipToIntl
   Description: Resets the ship to intl.
   OperationID: ResetShipToIntl
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ResetShipToIntl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ResetShipToIntl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ResetShipToIntl(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ResetShipToIntl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetUPSQVEnable
   Description: Sets the UPSQV enable.
   OperationID: SetUPSQVEnable
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetUPSQVEnable_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetUPSQVEnable_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetUPSQVEnable(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/SetUPSQVEnable", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ShipToETCAfterAddrVal
   Description: After the tax integration has been called, update the customer address if it
was changed.
   OperationID: ShipToETCAfterAddrVal
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ShipToETCAfterAddrVal_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ShipToETCAfterAddrVal_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToETCAfterAddrVal(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToETCAfterAddrVal", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ShipToETCValAddr
   Description: Call tax integration and loads temp tables from the results.
   OperationID: ShipToETCValAddr
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ShipToETCValAddr_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ShipToETCValAddr_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToETCValAddr(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToETCValAddr", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ShipToTerrSelectChange
   Description: This sets the ShipTo TerritoryID field based on the TerritorySelect flag.
To be used when the Territory Select field changes
   OperationID: ShipToTerrSelectChange
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ShipToTerrSelectChange_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ShipToTerrSelectChange_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ShipToTerrSelectChange(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ShipToTerrSelectChange", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SkipGlbCustomer
   Description: This method performs the logic behind the skip option for GlbCustomer
Skip - sets the Skipped flag to true.
If the CustNum field is not 0 will error out
   OperationID: SkipGlbCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SkipGlbCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SkipGlbCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SkipGlbCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/SkipGlbCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UnlinkGlbCustomer
   Description: This method performs the logic behind the unlink option for GlbCustomer
Unlink - clears the CustNum and CustId field in GlbCustomer.  Returns the Customer DataSet
   OperationID: UnlinkGlbCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UnlinkGlbCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UnlinkGlbCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UnlinkGlbCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/UnlinkGlbCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateCreditTotals
   Description: This method updates the TotOpenCredit and TotGlobalCredit fields.  To be called when
the include credit flags are changed.
   OperationID: UpdateCreditTotals
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateCreditTotals_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateCreditTotals_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateCreditTotals(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/UpdateCreditTotals", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateGlobalLimits
   Description: This method converts the global credit limit from the global currency value to
the local currency value.  To be used when the global currency code changes or
when the global credit limits are changed.
   OperationID: UpdateGlobalLimits
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateGlobalLimits_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateGlobalLimits_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateGlobalLimits(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/UpdateGlobalLimits", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateCountry
   Description: validate the country number
   OperationID: ValidateCountry
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateCountry_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateCountry_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateCountry(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateCountry", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateNAParentCreditPrc
   Description: This method validates the NA parent credit percentage.
   OperationID: ValidateNAParentCreditPrc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateNAParentCreditPrc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateNAParentCreditPrc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateNAParentCreditPrc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateNAParentCreditPrc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateNACreditSharedPrc
   Description: This method validate the NA credit shared percentage.
   OperationID: ValidateNACreditSharedPrc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateNACreditSharedPrc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateNACreditSharedPrc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateNACreditSharedPrc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateNACreditSharedPrc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateGlbNAParentCreditPrc
   Description: This method validates the global NA parent credit percentage.
   OperationID: ValidateGlbNAParentCreditPrc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateGlbNAParentCreditPrc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateGlbNAParentCreditPrc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateGlbNAParentCreditPrc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateGlbNAParentCreditPrc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateGlbNACreditSharedPrc
   Description: This method validate the global NA credit shared percentage.
   OperationID: ValidateGlbNACreditSharedPrc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateGlbNACreditSharedPrc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateGlbNACreditSharedPrc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateGlbNACreditSharedPrc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateGlbNACreditSharedPrc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidatePayBTFlag
   Description: Validates the pay BT flag.
   OperationID: ValidatePayBTFlag
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidatePayBTFlag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidatePayBTFlag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidatePayBTFlag(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidatePayBTFlag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetTerms
   OperationID: GetTerms
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetTerms_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetTerms_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetTerms(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetTerms", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method IsLocal
   Description: (CSF Norway) This method check the Customer is local.
   OperationID: IsLocal
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/IsLocal_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/IsLocal_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_IsLocal(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/IsLocal", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCodeDescList
   OperationID: GetCodeDescList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCodeDescList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCodeDescList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCodeDescList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCodeDescList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StorePartner
   Description: Stores Partner
   OperationID: StorePartner
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/StorePartner_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StorePartner_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StorePartner(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/StorePartner", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerCountryISOCode
   Description: get custoemt country iso code
   OperationID: GetCustomerCountryISOCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerCountryISOCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerCountryISOCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerCountryISOCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerCountryISOCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetExternalCRMIntegrationIsEnabled
   OperationID: GetExternalCRMIntegrationIsEnabled
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetExternalCRMIntegrationIsEnabled_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetExternalCRMIntegrationIsEnabled(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetExternalCRMIntegrationIsEnabled", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCustCntWithExternalCRMEnabled
   OperationID: CheckCustCntWithExternalCRMEnabled
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCustCntWithExternalCRMEnabled_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCustCntWithExternalCRMEnabled_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCustCntWithExternalCRMEnabled(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CheckCustCntWithExternalCRMEnabled", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetOrdersCreditOverride
   OperationID: SetOrdersCreditOverride
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetOrdersCreditOverride_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetOrdersCreditOverride_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetOrdersCreditOverride(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/SetOrdersCreditOverride", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMXPurchaseType
   Description: Performs required logic when Customer.MXPurchaseType is modified.
   OperationID: ChangeMXPurchaseType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMXPurchaseType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMXPurchaseType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMXPurchaseType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeMXPurchaseType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateAgingCode
   Description: Validates Aging Code.
   OperationID: ValidateAgingCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateAgingCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateAgingCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateAgingCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateAgingCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListARBankRemittanceSlip
   Description: Returns a List Dataset for AR Bank Remittance Slip
   OperationID: GetListARBankRemittanceSlip
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListARBankRemittanceSlip_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListARBankRemittanceSlip_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListARBankRemittanceSlip(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetListARBankRemittanceSlip", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListARRemittanceSlip
   Description: Returns a List Dataset for AR Remittance Slip
   OperationID: GetListARRemittanceSlip
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListARRemittanceSlip_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListARRemittanceSlip_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListARRemittanceSlip(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetListARRemittanceSlip", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCOOperType
   Description: Performs required logic when Customer.COOperType is modified.
   OperationID: ChangeCOOperType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCOOperType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCOOperType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCOOperType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ChangeCOOperType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateAllTaxID
   Description: Invokes ValidateTaxIDCustomer and ValidateTaxIDShipTo
   OperationID: ValidateAllTaxID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateAllTaxID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateAllTaxID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateAllTaxID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateAllTaxID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateTaxIDCustomer
   OperationID: ValidateTaxIDCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateTaxIDCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateTaxIDCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateTaxIDCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateTaxIDCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateTaxIDShipTo
   OperationID: ValidateTaxIDShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateTaxIDShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateTaxIDShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateTaxIDShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/ValidateTaxIDShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetHMRCValidationLog
   OperationID: GetHMRCValidationLog
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetHMRCValidationLog_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetHMRCValidationLog_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetHMRCValidationLog(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetHMRCValidationLog", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewCustomerSettlementDay
   OperationID: GetNewCustomerSettlementDay
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewCustomerSettlementDay_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewCustomerSettlementDay_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewCustomerSettlementDay(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetNewCustomerSettlementDay", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCustomerSettlementDay
   OperationID: GetCustomerSettlementDay
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCustomerSettlementDay_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCustomerSettlementDay_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCustomerSettlementDay(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetCustomerSettlementDay", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CustSettlementDayUpdate
   OperationID: CustSettlementDayUpdate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CustSettlementDayUpdate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CustSettlementDayUpdate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustSettlementDayUpdate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustSettlementDayUpdate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CustSettlementDayDelete
   OperationID: CustSettlementDayDelete
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CustSettlementDayDelete_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CustSettlementDayDelete_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CustSettlementDayDelete(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/CustSettlementDayDelete", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetEnableSettlementFeature
   Description: Gets the EnableSettlementFeature
   OperationID: GetEnableSettlementFeature
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetEnableSettlementFeature_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetEnableSettlementFeature(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.CustomerSvc/GetEnableSettlementFeature", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
// OData Schemas:
//////////////////////////////////////////////////////////////////////////
export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBankRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustBankRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustBillToRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustBillToRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustChildRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustChildRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustDfltDocTypeRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustDfltDocTypeRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustICRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustICRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustLabExpRateRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustLabExpRateRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMFBillRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustMFBillRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustMandateRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustMandateRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustRestrictionRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustRestrictionRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustUPSEmailRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustUPSEmailRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomCrdPoolRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomCrdPoolRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDiscPriceLstRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerDiscPriceLstRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerDocsRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerDocsSHRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerDocsSHRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerFSPriceListRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerFSPriceListRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerListRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerListRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerPriceLstRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerPriceLstRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_CustomerRow{
   "odatametadata":string,
   "value":Erp_Tablesets_CustomerRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow{
   "odatametadata":string,
   "value":Erp_Tablesets_EntityGLCRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_GlbCustCredRow{
   "odatametadata":string,
   "value":Erp_Tablesets_GlbCustCredRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MXCustomerFiscalTextRow{
   "odatametadata":string,
   "value":Erp_Tablesets_MXCustomerFiscalTextRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_MangCustRow{
   "odatametadata":string,
   "value":Erp_Tablesets_MangCustRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_NAMemberRow{
   "odatametadata":string,
   "value":Erp_Tablesets_NAMemberRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PECustWhldHistRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PECustWhldHistRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartnerRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartnerRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToDiscPriceLstRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToDiscPriceLstRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToLabExpRateRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToLabExpRateRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToMFBillRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToMFBillRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToPriceLstRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToPriceLstRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRestrictionRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToRestrictionRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToSrchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToSrchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_ShipToUPSEmlRow{
   "odatametadata":string,
   "value":Erp_Tablesets_ShipToUPSEmlRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow{
   "odatametadata":string,
   "value":Erp_Tablesets_TaxExemptRow[],
}

export interface Erp_Tablesets_CustBankRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   "CustNum":number,
      /**  Customer Bank ID  */  
   "BankID":string,
      /**  Customer Bank Name  */  
   "BankName":string,
      /**  Bank Account Number for the Customer.  */  
   "BankAcctNumber":string,
      /**  Swift Number or ABA Routing Number  */  
   "BankIdentifier":string,
      /**  Indicates primary bank for Customer.  */  
   "PrimaryBank":boolean,
      /**  Name on the Bank Account  */  
   "NameOnAccount":string,
      /**  Customer address, line 1  */  
   "Address1":string,
      /**  Customer address, line 2  */  
   "Address2":string,
      /**  Customer address, line 3  */  
   "Address3":string,
      /**  Customer city  */  
   "City":string,
      /**  Bank state or province  */  
   "State":string,
      /**  Customer postal code (zip code)  */  
   "PostalCode":string,
      /**  Customer country code.  */  
   "Country":number,
      /**  Customer Bank Branch Code  */  
   "BankBranchCode":string,
      /**  IBAN Code  */  
   "IBANCode":string,
      /**  Unique identifier of the payment method  */  
   "PMUID":number,
      /**  Customer Legal Name  */  
   "LegalName":string,
      /**  Agreement Reference  */  
   "AgreeRef":string,
      /**  Correspondence Account  */  
   "CorrespAccount":string,
      /**  A date field, indicating when the agreement to withdraw money from the customer expires.  */  
   "AgreeExpDate":string,
      /**  Local BIC  */  
   "LocalBIC":string,
      /**  Free Form Bank Person Code. Used in localizations.  */  
   "BankPersonCode":string,
      /**  AllowAsAltRemitToBank  */  
   "AllowAsAltRemitToBank":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  TransPersonName  */  
   "TransPersonName":string,
      /**  TransPersonName2  */  
   "TransPersonName2":string,
      /**  TransPersonName3  */  
   "TransPersonName3":string,
      /**  TransPersonName4  */  
   "TransPersonName4":string,
      /**  TransPersonName5  */  
   "TransPersonName5":string,
      /**  MX Tax ID  */  
   "MXRFC":string,
      /**  Mexico SAT Code  */  
   "MXSATCode":string,
      /**  A customer alias used to make and receive payments.  */  
   "PayID":string,
      /**  Free Form Bank Region Type (Local or Foreign) . Used in localizations.  */  
   "BankRegionType":string,
   "CountryName":string,
   "BitFlag":number,
   "BankBranchCodeDescBankBranchCode":string,
   "BankBranchCodeDescDescription":string,
   "CustNumCustID":string,
   "CustNumBTName":string,
   "CustNumName":string,
   "PayMethodSummarizePerCustomer":boolean,
   "PayMethodType":number,
   "PayMethodName":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustBillToRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   "CustNum":number,
      /**  Indicates the CustNum of the alternate Bill To Customer.  */  
   "BTCustNum":number,
      /**  Indicates whether this Alt Bill To is the default record or not.  */  
   "DefaultBillTo":boolean,
      /**  If checked, the invoice print routine will use the address from this alternate customer as the invoice address.  */  
   "InvoiceAddress":boolean,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Tax Payer Registration Reason Code  */  
   "TaxRegReason":string,
      /**  Organization Registration Code  */  
   "OrgRegCode":string,
      /**  Our Bank Code  */  
   "OurBankCode":string,
      /**  Full Legal name  */  
   "BTLegalName":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  If this value is true, the Customer that is designated as the Alternate Bill To has not been sent to FSA.  */  
   "FSACustomerNotSent":boolean,
      /**  BTAddress one from the Cusomer table for this AltBTCustNum.  */  
   "BTAddress1":string,
      /**  BTAddress two from the Customer table for this AltBTCustNum.  */  
   "BTAddress2":string,
      /**  BTAddress three from the Customer table for this AltBTCustNum.  */  
   "BTAddress3":string,
      /**  The BTAddrList from the Customer table for this AltBTCustNum.  */  
   "BTAddrList":string,
      /**  The BTcity from the Customer table for this AltBTCustNum.  */  
   "BTCity":string,
      /**  Primary billing contact.  */  
   "BTConPrc":number,
      /**  Contact name.  */  
   "BTContactName":string,
      /**  The BTCountry from the Customer table for this AltBTCustNum.  */  
   "BTCountry":string,
      /**  Bill to credit hold flag.  */  
   "BTCreditHold":boolean,
      /**  The BT Customer ID from the Customer table for this AltBTCustNum.  */  
   "BTCustID":string,
      /**  The BT Customer Name from the Customer table for this AltBTCustNum.  */  
   "BTCustomerName":string,
      /**  The BTFaxNum from the Customer table for this AltBTCustNum.  */  
   "BTFaxNum":string,
      /**  The BTPhoneNum from the Customer table for this AltBTCustNum.  */  
   "BTPhoneNum":string,
      /**  The BTState from the Customer Table for this AltBTCustNum.  */  
   "BTState":string,
      /**  The BTZip from the Customer table for this AltBTCustNum.  */  
   "BTZip":string,
      /**  Customer ID from the Customer table for this AltBTCustNum.  */  
   "CustID":string,
      /**  The Customer Name from the Customer table for this AltBTCustNum.  */  
   "CustomerName":string,
      /**  Indicates if CustBillTo is Global (Master or Linked)  */  
   "GlbFlag":boolean,
      /**  Delimited list of GlbCompany, GlbCustNum and GlbBTCustNum that is linking to this CustBillTo  */  
   "GlbLink":string,
      /**  The full formatted address from the Customer table for this AltBTCustNum.  */  
   "BTAddress":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustChildRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   "CustID":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  The full name of the customer.  */  
   "Name":string,
      /**  Parent Customer Name  */  
   "ParentName":string,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   "ParentCustNum":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustDfltDocTypeRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   "CustNum":number,
      /**  The invoice type the default document type is for..  */  
   "InvoiceType":string,
      /**  The id of the default transaction type.  */  
   "TranDocTypeID":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  set 'ARInvoice' or 'Credit Memo' depends on the Invoice Type to filter combo TranDocType  */  
   "InvcTypeTranDoc":string,
   "BitFlag":number,
   "TranDocTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustICRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the industry class is related to.  */  
   "CustNum":number,
      /**  Foreign key to the Ship To table. Empty if the Industry Class is not related to a ShipTo.  */  
   "ShipToNum":string,
      /**  Foreign key to the ICType table. A short name, acronym or identifier for the Industry Class Type.  */  
   "ICTypeID":string,
      /**  Foreign key to the ICCode table. Represents the SIC/ISIC/NAICS/NACE code for the current industry class.  */  
   "ICCode":string,
      /**  Indicates if the current class code is the primary for the type.  */  
   "Primary":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "CustomerBTName":string,
   "CustomerName":string,
   "CustomerCustID":string,
   "ICCodeDescription":string,
   "ICTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustLabExpRateRow{
      /**  Company  */  
   "Company":string,
      /**  CustNum  */  
   "CustNum":number,
      /**  ExpenseCode  */  
   "ExpenseCode":string,
      /**  RateType  */  
   "RateType":number,
      /**  RateMultiplier  */  
   "RateMultiplier":number,
      /**  FixedRate  */  
   "FixedRate":number,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
   "BitFlag":number,
   "CustomerName":string,
   "CustomerBTName":string,
   "CustomerCustID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustMFBillRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   "PayBTFlag":string,
      /**   Describes the billing type.  Valid values and their description are:
1 - Shipper
2 - FedEx  Collect
3 - Third Party
4 - UPS Prepaid
5 - FedEx Recipient
6 - UPS Consignee
7 - UPS Freight Collect
8 - UPS Free On Board
9 - UPS Cost and Freight
10 - UPS Delivery Duty Paid
11 - UPS Shpping Duty and Tax Consignee  */  
   "PayTypeDesc":string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   "PayAccount":string,
      /**  Shipping Billing Address  */  
   "PayBTAddress1":string,
      /**  Shipping biling address line 2  */  
   "PayBTAddress2":string,
      /**  Shipping biling address line 3.  */  
   "PayBTAddress3":string,
      /**  Shipping billing city  */  
   "PayBTCity":string,
      /**  Shipping Billing state or province  */  
   "PayBTState":string,
      /**  Manifest Billing Postal Code.  */  
   "PayBTZip":string,
      /**  Shipping biling country  */  
   "PayBTCountry":string,
      /**  Internal field used to store the country number.  */  
   "PayBTCountryNum":number,
      /**  Shipping billing phone number  */  
   "PayBTPhone":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustMandateRow{
      /**  Company  */  
   "Company":string,
      /**  MandateType  */  
   "MandateType":string,
      /**  MandateReference  */  
   "MandateReference":string,
      /**  CustNum  */  
   "CustNum":number,
      /**  BankAcctID  */  
   "BankAcctID":string,
      /**  CreditorID  */  
   "CreditorID":string,
      /**  ValidFrom  */  
   "ValidFrom":string,
      /**  ValidTo  */  
   "ValidTo":string,
      /**  CreditorName  */  
   "CreditorName":string,
      /**  CreditorAddress1  */  
   "CreditorAddress1":string,
      /**  CreditorAddress2  */  
   "CreditorAddress2":string,
      /**  CreditorAddress3  */  
   "CreditorAddress3":string,
      /**  CreditorCity  */  
   "CreditorCity":string,
      /**  CreditorZip  */  
   "CreditorZip":string,
      /**  CreditorCountryNum  */  
   "CreditorCountryNum":number,
      /**  CreditorRefPartyName  */  
   "CreditorRefPartyName":string,
      /**  CreditorRefPartyID  */  
   "CreditorRefPartyID":string,
      /**  DebtorName  */  
   "DebtorName":string,
      /**  DebtorAddress1  */  
   "DebtorAddress1":string,
      /**  DebtorAddress2  */  
   "DebtorAddress2":string,
      /**  DebtorAddress3  */  
   "DebtorAddress3":string,
      /**  DebtorCity  */  
   "DebtorCity":string,
      /**  DebtorZip  */  
   "DebtorZip":string,
      /**  DebtorCountryNum  */  
   "DebtorCountryNum":number,
      /**  DebtorRefPartyName  */  
   "DebtorRefPartyName":string,
      /**  DebtorRefPartyID  */  
   "DebtorRefPartyID":string,
      /**  SignedPlace  */  
   "SignedPlace":string,
      /**  SignedBy  */  
   "SignedBy":string,
      /**  SignedDate  */  
   "SignedDate":string,
      /**  UndContractID  */  
   "UndContractID":string,
      /**  CreatedBy  */  
   "CreatedBy":string,
      /**  CreatedDate  */  
   "CreatedDate":string,
      /**  PrintedBy  */  
   "PrintedBy":string,
      /**  PrintedDate  */  
   "PrintedDate":string,
      /**  FirstUseDate  */  
   "FirstUseDate":string,
      /**  LastUseDate  */  
   "LastUseDate":string,
      /**  PaymentType  */  
   "PaymentType":string,
      /**  Comment  */  
   "Comment":string,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
      /**  MandateStatus  */  
   "MandateStatus":string,
   "BankAcctDescription":string,
   "BankAcctBankName":string,
   "BankAcctLegalName":string,
   "BankAcctIBANCode":string,
   "BankAcctBankIdentifier":string,
   "CustBankIBANCode":string,
   "CustBankBankIdentifier":string,
      /**  Mandate can be deleted if CustMandate.FirstUseDate = Null or it has not been used for 14 months prior to current date (date of CustMandate.LastUseDate + 14 months < Current Date.  */  
   "MandateCanBeDeleted":boolean,
   "MandateReferenceExt":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustRestrictionRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  Restriction Type identification.  */  
   "RestrictionTypeID":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "CustNumCustID":string,
   "CustNumBTName":string,
   "CustNumName":string,
   "RestrictionTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustUPSEmailRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  UPS Quantum View Sequence  */  
   "UPSQVSeq":number,
      /**  Email address to notify for a UPS shipment  */  
   "EmailAddress":string,
      /**  Logical indicating if the EmailAddress is to be updated at shipping.  */  
   "ShipmentNotify":boolean,
      /**  Logical indicating if the Email Address is to be notified of a failed shipment.  */  
   "FailureNotify":boolean,
      /**  Logical indicating if the Email Address is to be notified of delivery.  */  
   "DeliveryNotify":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Logical indicating whether or not the UPS Quantum View fields are to be enabled.  */  
   "EnableQuantumView":boolean,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomCrdPoolRow{
      /**  Company  */  
   "Company":string,
   "CustNum":number,
   "CrdPoolCode":string,
   "CreditUsed":number,
   "CreditAvailable":number,
      /**  Global Pool - shows if the pool belongs to Global National Account  */  
   "GlobalNA":boolean,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerAttchRow{
   "Company":string,
   "CustNum":number,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerDiscPriceLstRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   "CustNum":number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   "ShipToNum":string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   "SeqNum":number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   "ListCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PriceListListDescription":string,
   "PriceListEndDate":string,
   "PriceListStartDate":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerDocsRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   "CustNum":number,
      /**  The ShipTo.ShipToNum of the Ship To that the customer  */  
   "ShipToNum":string,
      /**  The document name the parameters are for.  For example, incoming and outgoing data is via EDI, the value in this field would be the various document types/names found in EDI such as 830, 850, 862, etc.  */  
   "DocumentName":string,
      /**   The type of document.  Values are:
InForecast - Forecast
InUnfirm - Unfirm Releases
InShSched - Incoming Shipping Schedule
ASN - Advance Shipping Notice
Inv - Invoice
SOAck - Sales Order Acknowledgement
ChgResp - Response to a Sales Order change
Status - Order Status  */  
   "DocumentType":string,
      /**  An alternate trading partner name for this document.  */  
   "AltTradingPartnerName":string,
      /**  Determines whether or not this record is in test mode (true) or production mode (false).  */  
   "TestRecord":boolean,
      /**  Use customer master defaults for inbound orders.  This would be information such as discount, sales reps, etc.  */  
   "UseCustomerDefaults":boolean,
      /**  On incoming DemandDetail records, indicates if the Part master should be checked for the existance of the part.  If true, a warning will be written to the DemandLog table if the part does not exist.  */  
   "CheckForPart":boolean,
      /**  Indicates of only customer parts are to be used when creating orders.  */  
   "UseCustPart":boolean,
      /**  Identifies whether or not an outbound XML document is created during the Accept Inbound Demand process.  */  
   "OutBoundDocReq":boolean,
      /**  Specific Map ID for the customer or ship to.  Non-editable, updated by custom programming.  */  
   "MapID":string,
      /**   The type of action to take for incoming demands.  Values are:
ALW - Always accept the demand automatically
ANE - Accpet the demand automatically if no errors
ASD - Always stop at demand.  User will accept demands manually.  */  
   "AcceptType":string,
      /**   Indicates if this document an inbound document or outbound document.  Values are:
I - Inbound
O - Outbound  */  
   "DocDirection":string,
      /**  The outbound document name.  Used when OutBoundDocReq is true.  Not required.  */  
   "OutboundDocName":string,
      /**  Indicates if Order Releases that have not been shipped and do not have a job will be deleted when receiving this document type.  */  
   "DeleteCurrentReleases":boolean,
      /**  Use the UPC in the Part table  */  
   "UsePartUPC":boolean,
      /**  Indicates if the OutboundDocName document is manual.  */  
   "OutboundManual":boolean,
      /**  Indicates if the OutboundDocName document is automatic.  */  
   "OutboundAutomatic":boolean,
      /**  A list of the order in which a part should be validated when an inbound file is sent through EDI.  */  
   "EDIPartValidation":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  PartOptionAvailList  */  
   "PartOptionAvailList":string,
      /**  PartOptionSelList  */  
   "PartOptionSelList":string,
      /**  A LIST-DELIM delimited list of part options  */  
   "PartOptionSelectedList":string,
   "BitFlag":number,
   "CustomerBTName":string,
   "CustomerName":string,
   "CustomerCustID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerDocsSHRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   "CustNum":number,
      /**  The ShipTo.ShipToNum of the Ship To that the customer  */  
   "ShipToNum":string,
      /**  The document name the parameters are for.  For example, incoming and outgoing data is via EDI, the value in this field would be the various document types/names found in EDI such as 830, 850, 862, etc.  */  
   "DocumentName":string,
      /**   The type of document.  Values are:
InForecast - Forecast
InUnfirm - Unfirm Releases
InShSched - Incoming Shipping Schedule
ASN - Advance Shipping Notice
Inv - Invoice
SOAck - Sales Order Acknowledgement
ChgResp - Response to a Sales Order change
Status - Order Status  */  
   "DocumentType":string,
      /**  An alternate trading partner name for this document.  */  
   "AltTradingPartnerName":string,
      /**  Determines whether or not this record is in test mode (true) or production mode (false).  */  
   "TestRecord":boolean,
      /**  Use customer master defaults for inbound orders.  This would be information such as discount, sales reps, etc.  */  
   "UseCustomerDefaults":boolean,
      /**  On incoming DemandDetail records, indicates if the Part master should be checked for the existance of the part.  If true, a warning will be written to the DemandLog table if the part does not exist.  */  
   "CheckForPart":boolean,
      /**  Indicates of only customer parts are to be used when creating orders.  */  
   "UseCustPart":boolean,
      /**  Identifies whether or not an outbound XML document is created during the Accept Inbound Demand process.  */  
   "OutBoundDocReq":boolean,
      /**  Specific Map ID for the customer or ship to.  Non-editable, updated by custom programming.  */  
   "MapID":string,
      /**   The type of action to take for incoming demands.  Values are:
ALW - Always accept the demand automatically
ANE - Accpet the demand automatically if no errors
ASD - Always stop at demand.  User will accept demands manually.  */  
   "AcceptType":string,
      /**   Indicates if this document an inbound document or outbound document.  Values are:
I - Inbound
O - Outbound  */  
   "DocDirection":string,
      /**  The outbound document name.  Used when OutBoundDocReq is true.  Not required.  */  
   "OutboundDocName":string,
      /**  Indicates if Order Releases that have not been shipped and do not have a job will be deleted when receiving this document type.  */  
   "DeleteCurrentReleases":boolean,
      /**  Use the UPC in the Part table  */  
   "UsePartUPC":boolean,
      /**  Indicates if the OutboundDocName document is manual.  */  
   "OutboundManual":boolean,
      /**  Indicates if the OutboundDocName document is automatic.  */  
   "OutboundAutomatic":boolean,
      /**  A list of the order in which a part should be validated when an inbound file is sent through EDI.  */  
   "EDIPartValidation":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  PartOptionAvailList  */  
   "PartOptionAvailList":string,
      /**  PartOptionSelList  */  
   "PartOptionSelList":string,
      /**  A LIST-DELIM delimited list of part options  */  
   "PartOptionSelectedList":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerFSPriceListRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   "CustNum":number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   "ShipToNum":string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to. The lower the number the higher the priority is in the hierarchy.  */  
   "SeqNum":number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   "ListCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PriceListListDescription":string,
   "PriceListEndDate":string,
   "PriceListStartDate":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerListRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   "CustID":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  The full name of the customer.  */  
   "Name":string,
      /**  The city portion of the customer's main address.  */  
   "City":string,
      /**  The state or province portion of the customer's main address.  */  
   "State":string,
      /**  The zip or postal code portion of the customer's main address.  */  
   "Zip":string,
      /**  The country of the main customer address.  */  
   "Country":string,
      /**  Optional field used to record the customer's State Tax Identification number, which is displayed on Sales Acknowledgments.  */  
   "ResaleID":string,
      /**  The SalesTer.TerritoryID value of the territory assigned to the customer.  */  
   "TerritoryID":string,
      /**  Contains the key of the default ship to for the customer. A blank value indicates that the name and address in the Customer file is considered the default ship to. This field is updated when the user marks the check box in ship to maintenance indicating that the ship to is to be designated as the default. This default will be used in areas such as Sales Order entry.  */  
   "ShipToNum":string,
      /**   The Terms.TermsCode value of the default sales terms associated with the customer. A default may be supplied by XaSyst.TermsCode if not blank. The terms will default into quotes and orders for this customer.
For invoices not related to a sales order, these terms will also default into the invoice.  */  
   "TermsCode":string,
   "TerritoryTerritoryDesc":string,
   "CustGrupGroupDesc":string,
      /**  Indicates if customer has been placed into a "Credit Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   "CreditHold":boolean,
      /**  Contains the CustGrup.GroupCode value of the customer group that the customer has been assigned to. This field is used by the application for sorting or filtering on reports and can also be associated with price lists.  */  
   "GroupCode":string,
      /**  The general Business Phone Number for the customer. Displayed in Order entry when no contact is given or when contact has a blank phone number.  */  
   "PhoneNum":string,
      /**  Contains the Country.CountryNum value of the country the customer is located in.  */  
   "CountryNum":number,
      /**  Used to define the type of the customer record.  */  
   "CustomerType":string,
      /**  Indicates whether or not this customer will be included in marketing lists.  */  
   "NoContact":boolean,
      /**  When yes, a ShipTo CustID on certain forms will be enabled. This allows a shipto of a different customer to be referenced as a 3rd party for a document.  */  
   "AllowShipTo3":boolean,
      /**   Determines print options for any customer parts related to this customer.

M = Main Part Reference (Default)
S = Secondary Part Reference
O = Only Part Reference Printed
N = Customer Part Not Printed  */  
   "CustPartOpts":string,
      /**  If yes, indicates that Customer has at least one associated CustBank record.  */  
   "HasBank":boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerPriceLstRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   "CustNum":number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   "ShipToNum":string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   "SeqNum":number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   "ListCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PriceListListDescription":string,
   "PriceListEndDate":string,
   "PriceListStartDate":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_CustomerRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   "CustID":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  The full name of the customer.  */  
   "Name":string,
      /**  The first line of the customer's main address.  */  
   "Address1":string,
      /**  The second line of the customer's main address.  */  
   "Address2":string,
      /**  The third line of the customer's main address.  */  
   "Address3":string,
      /**  The city portion of the customer's main address.  */  
   "City":string,
      /**  The state or province portion of the customer's main address.  */  
   "State":string,
      /**  The zip or postal code portion of the customer's main address.  */  
   "Zip":string,
      /**  The country of the main customer address.  */  
   "Country":string,
      /**  Optional field used to record the customer's State Tax Identification number, which is displayed on Sales Acknowledgments.  */  
   "ResaleID":string,
      /**  The SalesRep.SalesRepCode of the default salesperson for the customer. This field is used to supply defaults to Order Entry and Invoice entry for invoices that do not reference a sales orders.  */  
   "SalesRepCode":string,
      /**  The SalesTer.TerritoryID value of the territory assigned to the customer.  */  
   "TerritoryID":string,
      /**  Contains the key of the default ship to for the customer. A blank value indicates that the name and address in the Customer file is considered the default ship to. This field is updated when the user marks the check box in ship to maintenance indicating that the ship to is to be designated as the default. This default will be used in areas such as Sales Order entry.  */  
   "ShipToNum":string,
      /**   The Terms.TermsCode value of the default sales terms associated with the customer. A default may be supplied by XaSyst.TermsCode if not blank. The terms will default into quotes and orders for this customer.
For invoices not related to a sales order, these terms will also default into the invoice.  */  
   "TermsCode":string,
      /**  Contains the ShipVia.ShipViaCode value of the default ShipVia for the customer.  */  
   "ShipViaCode":string,
      /**  Controls whether or not this customer's statement will print when   printing of customer statements.  */  
   "PrintStatements":boolean,
      /**  Only customers that are PrintLabels = Yes will be selected for printing of mailing labels.  */  
   "PrintLabels":boolean,
      /**   Allows the user to establish whether or not a specific customer requires Sales Order Acknowledgements.  This does not force or limit the printing of sales acknowledgments directly from within Order Entry.  Order entry displays this setting to the user so that they know if they should print the acknowledgment.
For batch mode printing, (where ranges of sales orders are selected...future release) this setting will be used to exclude orders from printing.  */  
   "PrintAck":boolean,
      /**  Controls whether or not the customer will be included in the finance charge calculation process.  */  
   "FinCharges":boolean,
      /**  Indicates if customer has been placed into a "Credit Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   "CreditHold":boolean,
      /**  Contains the CustGrup.GroupCode value of the customer group that the customer has been assigned to. This field is used by the application for sorting or filtering on reports and can also be associated with price lists.  */  
   "GroupCode":string,
      /**  An optional field used to establish a default purchasing discount percentage for any order placed by customer. This value is supplied to order entry as a default for line item discount percent.  */  
   "DiscountPercent":number,
      /**  Contains the CustCnt.ConNum value of the Primary Purchasing contact for the customer. This field is not directly maintainable. Instead it is set during contact maintenance by having the user mark a check box indicating primary Purchaser.  This is the contact that is used as a default in Order Entry and Quoting.  */  
   "PrimPCon":number,
      /**  The same as the PrimPCon except that this is the Primary Billing Contact and this is used as a default in invoice entry.  */  
   "PrimBCon":number,
      /**  Same as PrimPCon except that this the Primary Shipping Contact and is used as a default in Packing Slip entry.  */  
   "PrimSCon":number,
      /**   Comments are intended to be internal comments about a specific customer. These do get pulled into other programs. They are mainly intended as an online storage facility.
To be view-as EDITOR widget.  */  
   "Comment":string,
      /**  The date when the customer was established as a customer. Use the system date as a default when creating new customers.  */  
   "EstDate":string,
      /**  The Fax Number for the customer. Optional field. Field is displayed in Order entry when no contact is specifically given or the contact has a blank fax number.  */  
   "FaxNum":string,
      /**  The general Business Phone Number for the customer. Displayed in Order entry when no contact is given or when contact has a blank phone number.  */  
   "PhoneNum":string,
      /**  Indicates the reason why the customer is normally exempt from sales tax. Used as a default in invoice entry.  If field is non-blank it is considered exempt.  */  
   "TaxExempt":string,
      /**  The QMarkup.MarkupID value of the quote markup table which will be used to provide default markup percents in quote entry for this customer. If left blank the quote module will use the default quote markup table for the customer. (See EQSyst.MarkupID).  */  
   "MarkUpID":string,
      /**   Represents the day of the week or month that this customer is invoiced on. The possible choices are determined by the Customer.Bill-Frequency field value.

When the Bill-Frequency is "W" (Weeky):
The valid values are 0-7 where 0=All Days,1=Sun,2=Mon,...,7=Sat.  

ll-frequency is 'M' (Monthly) this field contains the 1st -> 31st as possible choices to represent the day of the month to bill on.  */  
   "BillDay":number,
      /**  Determines whether or not packing slips for the same Sales Order and Fiscal Period will combined into a single invoice or not. If the packing slips are for different sales orders for the customer or fall in different fiscal periods, seperate invoices will be created even when this field is set to Yes.  */  
   "OneInvPerPS":boolean,
      /**  Contains the default FOB.FOB value of the FOB policy for this  customers orders.  Default used in sales order entry for this customer.  */  
   "DefaultFOB":string,
      /**  Determines whether or not Open Sales Orders are to be included in the credit limit checking process for the customer. This checkbox will also include open service contracts.  */  
   "CreditIncludeOrders":boolean,
      /**  Date on which the next credit review should be conducted for the customer.  */  
   "CreditReviewDate":string,
      /**  Date on which the customer was last placed on credit hold. This field is maintained by the system.  */  
   "CreditHoldDate":string,
      /**  Indicates how the customer was placed on credit hold.  Valid values are "MANUAL", "INVOICES", "ORDERS", and "CONTRACTS".  "MANUAL" means that the user placed the customer on hold.  INVOICES means that the customer's open A/R balance exceeded the credit limit.  ORDERS means that the sum of the open A/R and the open orders exceeded the credit limit. This field is maintained by the system.  */  
   "CreditHoldSource":string,
      /**  The UserFile.DCDUSERID value of the user that last cleared the customer's credit hold. This field is maintained by the system.  */  
   "CreditClearUserID":string,
      /**  The date that the user last cleared the customer's credit hold. This field is maintained by the system.  */  
   "CreditClearDate":string,
      /**  The time that the user last cleared the customer's credit hold in HH:MM:SS format. This field is maintained by the system.  */  
   "CreditClearTime":string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   "EDICode":string,
      /**  Contains the Currency.CurrencyCode value of the customer's base currency.  */  
   "CurrencyCode":string,
      /**  Contains the Country.CountryNum value of the country the customer is located in.  */  
   "CountryNum":number,
      /**  Contains the LangName.LangNameID value of the customer's language. This controls which language will be selected when extracting part descriptions from PartLangDesc table and report labels for customer related forms such as orders, packing slips and invoices.  */  
   "LangNameID":string,
      /**  Area/City code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Country table.  This field is only visible if ISSyst.EnableHarbour is set to yes.  */  
   "BorderCrossing":string,
      /**  Optional custom address format used to format the customer's main address.  */  
   "FormatStr":string,
      /**  The Bill To name of this customer. Will be used by the AR module for Invoices. This defaults to the Customer.Name but can be overrode by the user.  */  
   "BTName":string,
      /**  The first line of the customer's Bill To address.  */  
   "BTAddress1":string,
      /**  The second line of the customer's Bill To address.  */  
   "BTAddress2":string,
      /**  The second line of the customer's Bill To address.  */  
   "BTAddress3":string,
      /**  The city portion of the customer's Bill To address.  */  
   "BTCity":string,
      /**  The state or province portion of the customer's Bill To address.  */  
   "BTState":string,
      /**  The zip or postal code portion of the customer's Bill To address.  */  
   "BTZip":string,
      /**  The Country.Countrynum value of the Country portion of the customer's Bill To address.  */  
   "BTCountryNum":number,
      /**  Contains the Country.Description value of the Country portion of the customer's Bill To address.  */  
   "BTCountry":string,
      /**  The phone number related to the customer's Bill To Address.  */  
   "BTPhoneNum":string,
      /**  The fax number of the customer's Bill To address.  */  
   "BTFaxNum":string,
      /**  Optional custom address format used to format the customer's Bill To address.  */  
   "BTFormatStr":string,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   "ParentCustNum":number,
      /**  Contains the TaxRgn.TaxRegionCode value of the customer's tax region for purposes of Sales Tax calculations.  */  
   "TaxRegionCode":string,
      /**  Determines whether or not this customer is an inter-company customer.  */  
   "ICCust":boolean,
      /**  The day of the month that service contracts for the customer marked for recurring invoicing are billed on.  If the invoice group's invoice date is greater than or equal to this date then the invoice will be generated.  */  
   "ContBillDay":number,
      /**  Default email address for the customer.  */  
   "EMailAddress":string,
      /**  Determines whether or not the customer will accept partial shipments at the line or order level. This functionality is only available with the Advanced Material Management module.  */  
   "ShippingQualifier":string,
      /**  Contains the AllocPri.PriorityCode value of the priority that this customer's orders receive. This functionality is only available with the Advanced Material Management module.  */  
   "AllocPriorityCode":string,
      /**  Contains the ReservePri.PriorityCode value of the priority that this customer's orders receive. This functionality is only available with the Advanced Material Management module.  */  
   "ReservePriorityCode":string,
      /**  Used with Global alerts  */  
   "LinkPortNum":number,
      /**  Indicates if this customer will be able to access Customer Connect.  Only Customers with this equal to YES will be synchronized between the Manufacturing System DB and Customer Connect DB.  */  
   "WebCustomer":boolean,
      /**  Used to define the type of the customer record.  */  
   "CustomerType":string,
      /**  Indicates whether or not this customer will be included in marketing lists.  */  
   "NoContact":boolean,
      /**  Determines whether or not the customer's territory can be changed by system processes that could potentially change the territory from its current value.  */  
   "TerritoryLock":boolean,
      /**  The Customer's website URL.  */  
   "CustURL":string,
      /**  The pending sales territory that the customer will be assigned to based on changes to the territory boundaries.  This functionality is only available with the CRM module.  */  
   "PendingTerritoryID":string,
      /**  External Company  ID  */  
   "ExtID":string,
      /**  Determines whether or not shipments to this customer for different sales orders within the same fiscal period wil be consolidated into one invoice. (See Customer.OneInvPerPS - for the shipments from the same sales order are handled).  */  
   "ConsolidateSO":boolean,
      /**  BillFrequency  */  
   "BillFrequency":string,
      /**  Indicates that Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking.  */  
   "CreditIncludePI":boolean,
      /**  Determines whether or not this customer is shared between more than one company.  */  
   "GlobalCust":boolean,
      /**  Indicates if this customer participates in the Inter-Company Trading.  */  
   "ICTrader":boolean,
      /**  Establishes the tax authority for this customer.  */  
   "TaxAuthorityCode":string,
      /**  Determines whether or not an external delivery note is required for the customer.  This field is available only when ExtCompany.SendShip is set to Yes.  This will provide the default for the ShipHead record.  */  
   "ExternalDeliveryNote":boolean,
      /**  Determines whether or not Open Orders are to be included in the global credit limit checking process. This checkbox will also include open service contracts.  */  
   "GlobalCredIncOrd":boolean,
      /**  Indicates whether or not Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking process.  */  
   "GlobalCredIncPI":boolean,
      /**  Holds the Currency.CurrencyCode value of that the global customer will exchange data in.  */  
   "GlobalCurrencyCode":string,
      /**  Customer ID  */  
   "ExternalID":string,
      /**  Determines whether or not the customer has been placed into a "Global Credit Hold" status.  Any non-blank value will trigger notification of this condition in Order Entry and Shipping.  */  
   "GlobalCreditHold":string,
      /**  Determines whether or not this customer record will receive global updates.  */  
   "GlobalLock":boolean,
      /**  Determines whether or not the system should check existing orders for this customer to insure that the same PO number is not used twice by the customer.  */  
   "CheckDuplicatePO":boolean,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit.  A credit limit of zero is considered as having unlimited credit.  */  
   "CreditLimit":number,
      /**  An optional field that allows user to enter a monetary value to be used as a credit limit for payment instruments such as post dated checks or bank drafts.  A credit limit of zero is considered as having unlimited credit.  */  
   "CustPILimit":number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit Limit.  A credit limit of zero is considered as having unlimited credit.  */  
   "GlobalCreditLimit":number,
      /**  An optional field that allows user to enter a monetary value to be used as a credit limit for payment instruments such as post dated checks or bank drafts.  A credit limit of zero is considered as having unlimited credit.  */  
   "GlobalPILimit":number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit limit.  Credit limit of zero is considered as having unlimited credit. Stored in Global Currency.  */  
   "DocGlobalCreditLimit":number,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit. Stored in Global currency  */  
   "DocGlobalPILimit":number,
      /**  Indicates whether RFQ Attachments are allowed for this Customer  */  
   "RfqAttachAllow":boolean,
      /**   The discount qualifier is primarily used when applying order value based discounts to the customer's sales orders.  The value of this field affects the discount percent given to the customer.  Here's the rule:
"MIN" = means that the default order discount percent is the minimum discount the customer could get as compared to the order value based discount.
"MAX" = means that the default order discount percent is the maximum discount the customer could get as compared to the order value based discount.
"ADD" = means that the customer could get the order value based discount in addition to the default order discount.  */  
   "DiscountQualifier":string,
      /**  Specifies the current customer can be an alternate bill to customer.  */  
   "AllowAltBillTo":boolean,
      /**  Days to use in calculating the Order Detail Ship By date from the incoming need by date.  */  
   "DemandDeliveryDays":number,
      /**   Indicates incoming date type.  Values are:
S - Shipping Date
N - Need By Date  */  
   "DemandDateType":string,
      /**  The number of days from today to give a warning when adding a new order release record from an incoming shipping schedule.  */  
   "DemandAddLeadTime":number,
      /**  Indicates what type of action to take if the add lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandAddAction":string,
      /**  The number of days from today to give a warning when changing an order release record from an incoming shipping schedule.  This does not include changes to quantity or dates.  */  
   "DemandChangeLeadTime":number,
      /**  Indicates what type of action to take if the change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandChangeAction":string,
      /**  The number of days from today to give a warning when canceling an order release record from an incoming shipping schedule.  */  
   "DemandCancelLeadTime":number,
      /**  Indicates what type of action to take if the cancel lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandCancelAction":string,
      /**  The number of days from today to give a warning when adding a new order line record from an incoming shipping schedule.  */  
   "DemandNewLineLeadTime":number,
      /**  Indicates what type of action to take if the new line lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandNewLineAction":string,
      /**  The number of days from today to give a warning when changing the quantity on an order release record from an incoming shipping schedule.  */  
   "DemandQtyChangeLeadTime":number,
      /**  Indicates what type of action to take if the quantity change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandQtyChangeAction":string,
      /**  The number of days from today to give a warning when changing the date on an order release record from an incoming shipping schedule.  */  
   "DemandChangeDateLeadTime":number,
      /**  Indicates what type of action to take if the change date lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandChangeDateAction":string,
      /**  The trading partner name.  */  
   "TradingPartnerName":string,
      /**  Is this a residential delivery  */  
   "ResDelivery":boolean,
      /**  Is a Saturday delivery acceptable  */  
   "SatDelivery":boolean,
      /**  Is a Saturday pickup available  */  
   "SatPickup":boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   "Hazmat":boolean,
      /**  Documents Only delivery  */  
   "DocOnly":boolean,
      /**  Reference Notes for the delivery  */  
   "RefNotes":string,
      /**  Apply Handling Charge to shipment  */  
   "ApplyChrg":boolean,
      /**  Handling Charge Amount  */  
   "ChrgAmount":number,
      /**  Prefer COD delivery  */  
   "COD":boolean,
      /**  Add Freight COD Amount owed  */  
   "CODFreight":boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   "CODCheck":boolean,
      /**  Amount due on Cashier's check or money order  */  
   "CODAmount":number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   "GroundType":string,
      /**  Indicates whether to send an email notification of delivery  */  
   "NotifyFlag":boolean,
      /**  The list of email address to notify about a delivery  */  
   "NotifyEMail":string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   "DeclaredIns":boolean,
      /**  Declared Insurance Amount  */  
   "DeclaredAmt":number,
      /**  Periodicity Code.  Must be a valid code in the Periodicity table.  */  
   "PeriodicityCode":number,
      /**  Service delivery requires signature  */  
   "ServSignature":boolean,
      /**  Service Priority Alert flag  */  
   "ServAlert":boolean,
      /**  Service Home Delivery allowed  */  
   "ServHomeDel":boolean,
      /**  Service Home Delivery Type Code  */  
   "DeliveryType":string,
      /**  Service Home Delivery date  */  
   "ServDeliveryDate":string,
      /**  Home delivery phone number  */  
   "ServPhone":string,
      /**  Service Delivery Instructions  */  
   "ServInstruct":string,
      /**  Service Signature release is on file  */  
   "ServRelease":boolean,
      /**  Service Signature Release authorization number  */  
   "ServAuthNum":string,
      /**  Service Reference 1  */  
   "ServRef1":string,
      /**  Service Reference 2  */  
   "ServRef2":string,
      /**  Service Reference 3  */  
   "ServRef3":string,
      /**  Service Reference 4  */  
   "ServRef4":string,
      /**  Service Reference 5  */  
   "ServRef5":string,
      /**  Used to calculate on-time delivery performance rating  */  
   "EarlyBuffer":number,
      /**  Used to calculate on-time delivery performance rating  */  
   "LateBuffer":number,
      /**  Indicates if the unit price between the demand and the contract should be validated.  If this flag is checked, and the prices are different, when the demand is accepted a record will be written to the DemandLog table.  */  
   "DemandUnitPriceDiff":boolean,
      /**  Indicates what type of action to take if the unit price between the demand and the contract is different.  Options are B (reject the change) or W (warning - alert that the unit price is different but allow the record to be accepted).  */  
   "DemandUnitPriceDiffAction":string,
      /**  A flag that indicates whether this address should be validated by the tax service.  */  
   "ExcFromVal":boolean,
      /**  A flag indicating that an address has already been validated. This helps improve the performance of the bulk address validation process by allowing address that have already been validated to be skipped. This flag is set anytime a successful validation is performed, either by the bulk address validation or validation from the Customer form.  */  
   "AddressVal":boolean,
      /**  This is the Vendor ID to be used when generating a Rebate for the customer  */  
   "RebateVendorNum":number,
      /**  Indicates if the rebate should be a Check or a Credit Memo  */  
   "RebateForm":string,
      /**  Indicates if the order should default as a credit card order.  Can be overriden at the order level.  */  
   "CreditCardOrder":boolean,
      /**  Check for the part in the Part master.  */  
   "DemandCheckForPart":boolean,
      /**  Indicates what type of action to take if the Check for Part options is selected and the part is not in the part master file.  Options are B (reject the change) or W (warning - alert that the part is not in the part master but allow the record to be accepted).  */  
   "DemandCheckForPartAction":string,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Unique Identifier for the Finance Charges  */  
   "ChargeCode":string,
      /**  Individual Pack ID'srequired. Used in manifesting.  */  
   "IndividualPackIDs":boolean,
      /**  International Shipment flag. Used in manifesting.  */  
   "IntrntlShip":boolean,
      /**  Certificates of Origin required flag. Used in manifesting.  */  
   "CertOfOrigin":boolean,
      /**  Commercial Invoice required flag. Used in manifesting.  */  
   "CommercialInvoice":boolean,
      /**  Ship Export Declaration required flag. Used in manifesting.  */  
   "ShipExprtDeclartn":boolean,
      /**  Letter of Instruction required. Used in manifesting.  */  
   "LetterOfInstr":boolean,
      /**  Freight Forwarder ID.  */  
   "FFID":string,
      /**  Freight Forwarder Company Name  */  
   "FFCompName":string,
      /**  Freight Forwarder first address line.  */  
   "FFAddress1":string,
      /**  Freight Forwarder second address line.  */  
   "FFAddress2":string,
      /**  Freight Forwarder third address line.  */  
   "FFAddress3":string,
      /**  Freight Forwarder city portion of address.  */  
   "FFCity":string,
      /**  Freight Forwarder state portion of address.  */  
   "FFState":string,
      /**  Freight Forwarder postal code or zip code portion of address.  */  
   "FFZip":string,
      /**  Freight Forwarder country portion of address.  */  
   "FFCountry":string,
      /**  Freight Forwarder country number portion of address.  */  
   "FFCountryNum":number,
      /**  Freight Forwarder phone Number.  */  
   "FFPhoneNum":string,
      /**  Non Standard Package flag. Used in manifesting.  */  
   "NonStdPkg":boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   "DeliveryConf":number,
      /**  Additional Handling flag. Used in manifesting.  */  
   "AddlHdlgFlag":boolean,
      /**  UPS Quantum View  */  
   "UPSQuantumView":boolean,
      /**  UPS Quantum View From Name  */  
   "UPSQVShipFromName":string,
      /**  UPS Quantum View Memo  */  
   "UPSQVMemo":string,
      /**  Always equal to Customer.  Used to link the customer table to the UPSQVEmail table.  */  
   "UPSQVEmailType":string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   "FFContact":string,
      /**  Used to determine if an address changed because of the tax integration.  If true, the tax integration changed the address.  */  
   "ETCAddrChg":boolean,
      /**  Define the rule how Tax amount from for sales related documents shall be rounded to the general number of decimals from the Currency:  0 - Use rounding rules from Currency; 1 - Round up; 2 - Round down; 3 - Normal rounding.  Used when Company parameter - Customer specific Tax Rounding is set.  */  
   "TaxRoundRule":number,
      /**  Tax calculation per line or invoice.  It can be "L" = per line or "I" = per invoice.  Default is "L".  */  
   "TaxMethod":string,
      /**  Remit cash receipts in AR. No cash receipts will be accepted from customers without this authorization  */  
   "ValidPayer":boolean,
      /**  Sold to customer in the AR Invoice Entry. The user will not be able to enter invoices for customers without this authorization  */  
   "ValidSoldTo":boolean,
      /**  Receive shipments for orders entered in OE. Unless the user selects this option, the user must enter a Ship-to address in the Order Entry form.  */  
   "ValidShipTo":boolean,
      /**  Children are allowed to pay for their parents  */  
   "OverrideRlsClass":boolean,
      /**  Accept payments from any customer within the national account, regardless of parent-child status  */  
   "AcrossNatAcc":boolean,
      /**  allow use Parent Credit in National Account  */  
   "NAParentCreditIsUsed":boolean,
      /**  allow/deny to a customer share his own credit with other customers within the National account  */  
   "NACreditIsShare":boolean,
      /**  define what type of credit will be used first when the customer  */  
   "NACreditPreferenceList":string,
      /**  Max Percent of Parent Credit to Use  */  
   "NAParentCreditPrc":number,
      /**  Percentage of the customer credit shared to his Children.  */  
   "NACreditSharedPrc":number,
      /**  Indicates if One Time Shipto information can be entered for this customer.  OTS, are entered in Quote, Sales Order, RMA, Service Contract and Service Call. In Shipping and Invoicing the OTS infomation is used.  */  
   "AllowOTS":boolean,
      /**  Flag indicating that this is a 3PL customer.  */  
   "ThirdPLCust":boolean,
      /**  VendID of the associated supplier.  Only populated if ManagedCust flag = true.  Entered through Supplier Entry  */  
   "ManagedVendID":string,
      /**  VendNum associated with VendID of associated supplier.  Only populated if ManagedCust flag = true.  */  
   "ManagedVendNum":number,
      /**  Code of Overriden Relationship Class  */  
   "NARlsClassCode":string,
      /**  Direct Debiting flag for use with Promissory Notes.  */  
   "DirectDebiting":boolean,
      /**  Unique Identifier for the Reminder Group.  */  
   "ReminderCode":string,
      /**  allow use Global Parent Credit in National Account  */  
   "GlbNAParentCreditIsUsed":boolean,
      /**  allow/deny to a customer share his own credit with other customers within the Global National account  */  
   "GlbNACreditIsShare":boolean,
      /**  Max Percent of Global Parent Credit to Use  */  
   "GlbNAParentCreditPrc":number,
      /**  Percentage of the customer credit shared to his Global Children.  */  
   "GlbNACreditSharedPrc":number,
      /**  When yes, a ShipTo CustID on certain forms will be enabled. This allows a shipto of a different customer to be referenced as a 3rd party for a document.  */  
   "AllowShipTo3":boolean,
      /**  The default value used on One Time Ship To panels. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   "OTSSaveAs":string,
      /**   Determines print options for any customer parts related to this customer.

M = Main Part Reference (Default)
S = Secondary Part Reference
O = Only Part Reference Printed
N = Customer Part Not Printed  */  
   "CustPartOpts":string,
      /**  If yes, indicates that Customer has at least one associated CustBank record.  */  
   "HasBank":boolean,
      /**  Unique identifier of the payment method  */  
   "PMUID":number,
      /**  Check for Revision  */  
   "DemandCheckForRev":boolean,
      /**  Hold for Review  */  
   "OrderHoldForReview":boolean,
      /**  Check for Revision Action  */  
   "DemandCheckForRevAction":string,
      /**  List of all ship to territories for the customer  */  
   "ShipToTerrList":string,
      /**  The Banking Reference number to be used on AR Invoice sent to the customer  */  
   "AcctRefNumber":string,
      /**  Full Legal name  */  
   "LegalName":string,
      /**  Tax Payer Registration Reason Code  */  
   "TaxRegReason":string,
      /**  If this flag it?s turned on then one invoice per packing line will be created when invoicing a packing slip at the ?Get Shipments? action on the AR Invoice entry.  */  
   "InvPerPackLine":boolean,
      /**  Organization Registration Code  */  
   "OrgRegCode":string,
      /**  Define if at the moment of processing a demand the process should also close those rejected schedules that remain at demand entry  */  
   "DemandCloseRejSkd":boolean,
      /**  Our Bank Code  */  
   "OurBankCode":string,
      /**  Flag that indicates if the Demand non matched will be closed.  */  
   "DemandCloseNoMatch":boolean,
      /**  Flag to Check Partial Shipments  */  
   "DmdCheckPartialShip":boolean,
      /**  Flag to Check Partial Shipments Action B = Stop W = Warning  */  
   "DmdCheckShipAction":string,
      /**  Flag to check for cummulative info.  */  
   "DemandCheckCUMM":boolean,
      /**  Flag to Check what action should the system take the options are B = Stop and  W Warning  */  
   "DemandCheckCUMMAction":string,
      /**  Defines if Internal Pricing or Customer Pricing will be used for checking price differences  */  
   "DemandPricing":string,
      /**  Defines the tolerance for price difference validations  */  
   "PriceTolerance":number,
      /**  Preferred bank for cash receipts from sale to customer.  */  
   "PreferredBank":string,
      /**  If this flags is turned on then Demand CTP will automatically be executed as a part of the demand to order process.  */  
   "CheckDateCapPromise":boolean,
      /**  Confirm or not the Capable to Promise jobs from Demand Entry  */  
   "CheckConfirmCapPromise":boolean,
      /**  If checked, Updates the date in Demand Entry  */  
   "CheckUpdateCapPromise":boolean,
      /**  This field will define the dates that will be validated as a part of the demand to order process. The valid values for this combo will be:  Need By (N), Ship By (S) and Both (B)  */  
   "DemandCapPromiseDate":string,
      /**  The value on this field will define the action to be taken when validating CTP. The valid values for this combo box will be: Warning (W) and Stop (S)  */  
   "DemandCapPromiseAction":string,
      /**   This field will define the dates that will be updated as a part of the demand to order process. The valid options will be:
Need By (N), Ship By (S) and Both  (B) NOTE .-In all the cases above the update of date will only be done if the CTP dates are beyond the dates on the file.  */  
   "DemandCapPromiseUpdate":string,
      /**  Status of the Periodic Billing  */  
   "PeriodicBilling":boolean,
      /**  Criteria used for the calculation of the due date. Only enable if Periodic Billing status is active.  */  
   "DueDateCriteria":string,
      /**  Periodic Billing Terms. A period between the billing or summarizing date and the due date (for example: 30 days, 45 days, 60 days).  */  
   "PBTerms":number,
      /**  Evaluated Receipt Settlement Order. This flag will be used as a default when the user creates a Demand Entry PO or a Sales Order  */  
   "ERSOrder":boolean,
      /**  This checkbox indicates if the Demand schedule could be splited when there are not enough stock for a part, from the CTP.  */  
   "DemandSplitSched":boolean,
      /**  When set to TRUE the smart string functionality will only be processed when the incoming demand is new. After it has been processed and saved, if a retransmission is sent the smart string values will be ignored.  */  
   "OTSmartString":boolean,
      /**  Indicates if revenue is deferred for contracts assigned to this group.  */  
   "DeferredRev":boolean,
      /**  Revenue Amortization Code.  */  
   "RACode":string,
      /**  If true then demand will be rejected when one or more demand lines are not configured properly. Applies only to Configurable parts.  */  
   "DemandCheckConfig":boolean,
      /**  Indicates the action to be taken if configuration values have not been entered for one or more demand lines.  */  
   "DemandCheckCfgAction":string,
      /**  AllowAsAltRemitTo  */  
   "AllowAsAltRemitTo":boolean,
      /**  FederalID  */  
   "FederalID":string,
      /**  WIApplication  */  
   "WIApplication":string,
      /**  WICustomer  */  
   "WICustomer":string,
      /**  WIShippingCosts  */  
   "WIShippingCosts":boolean,
      /**  LOQBookPCFinishing  */  
   "LOQBookPCFinishing":boolean,
      /**  LOQBookPCPaper  */  
   "LOQBookPCPaper":boolean,
      /**  LOQBookPCPress  */  
   "LOQBookPCPress":boolean,
      /**  LOQBookPCPlates  */  
   "LOQBookPCPlates":boolean,
      /**  Variations  */  
   "Variations":boolean,
      /**  OversPct  */  
   "OversPct":number,
      /**  UndersPct  */  
   "UndersPct":number,
      /**  DefaultLOQstyle  */  
   "DefaultLOQstyle":string,
      /**  DefaultOrderAcknowledgement  */  
   "DefaultOrderAcknowledgement":string,
      /**  DefaultPackSlip  */  
   "DefaultPackSlip":string,
      /**  DefaultOversPricing  */  
   "DefaultOversPricing":string,
      /**  LOQPrepressStyle  */  
   "LOQPrepressStyle":string,
      /**  CSR  */  
   "CSR":string,
      /**  LOQBookCaFinishing  */  
   "LOQBookCaFinishing":boolean,
      /**  LOQBookCapaper  */  
   "LOQBookCapaper":boolean,
      /**  LOQBookCaPress  */  
   "LOQBookCaPress":boolean,
      /**  LOQBookCatPlates  */  
   "LOQBookCatPlates":boolean,
      /**  LOQVariations  */  
   "LOQVariations":boolean,
      /**  DefaultInvoicestyle  */  
   "DefaultInvoicestyle":string,
      /**  AEPLOQType  */  
   "AEPLOQType":string,
      /**  BusinessCust  */  
   "BusinessCust":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  THBranchID  */  
   "THBranchID":string,
      /**  CustPricingSchema  */  
   "CustPricingSchema":string,
      /**  ParamCode  */  
   "ParamCode":string,
      /**  AGAFIPResponsibilityCode  */  
   "AGAFIPResponsibilityCode":string,
      /**  AGBillToProvinceCode  */  
   "AGBillToProvinceCode":string,
      /**  AGGrossIncomeTaxID  */  
   "AGGrossIncomeTaxID":string,
      /**  AGIDDocTypeCode  */  
   "AGIDDocTypeCode":string,
      /**  AGIDDocumentNumber  */  
   "AGIDDocumentNumber":string,
      /**  AGProvinceCode  */  
   "AGProvinceCode":string,
      /**  AGUseGoodDefaultMark  */  
   "AGUseGoodDefaultMark":boolean,
      /**  In Collections  */  
   "Collections":boolean,
      /**  CollectionsDate  */  
   "CollectionsDate":string,
      /**  Date Collection Posted  */  
   "DateCollectionPosted":string,
      /**  MXMunicipio  */  
   "MXMunicipio":string,
      /**  Displays list of Peru Identity Types.  */  
   "PEIdentityDocType":string,
      /**  Peru Document ID.  */  
   "PEDocumentID":string,
      /**  Peru Goods Contributor withholding status.  */  
   "PEGoodsContributor":boolean,
      /**  Peru Withholding Agent status.  */  
   "PEWithholdAgent":boolean,
      /**  Peru Collection Agent withholding status.  */  
   "PECollectionAgent":boolean,
      /**  Peru Not Found withholding status.  */  
   "PENotFound":boolean,
      /**  Peru No Address Provided withholding status.  */  
   "PENoAddress":boolean,
      /**  EntityUseCode  */  
   "EntityUseCode":string,
      /**  InvcOrderCmpDflt  */  
   "InvcOrderCmpDflt":boolean,
      /**  EInvoice  */  
   "EInvoice":boolean,
      /**  RegistrationCode  */  
   "RegistrationCode":string,
      /**  EAddress  */  
   "EAddress":string,
      /**  Check if the part is a run out part.  */  
   "DemandCheckForRunOutPart":boolean,
      /**  Indicates what type of action to take if the Check for Run Out Part option is selected and the part is marked as a run out part.  Options are B (reject the change) or W (warning - alert that the part is marked as run out but allow the record to be accepted).  */  
   "DemandCheckForRunOutPartAction":string,
      /**  E-Invoice CompanyID Attribute  */  
   "EInvCompanyIDAttr":string,
      /**  INCSTNumber  */  
   "INCSTNumber":string,
      /**  INPANNumber  */  
   "INPANNumber":string,
      /**  Colombia Loc Field. OneTimeCustVend new table ID  */  
   "COOneTimeID":string,
      /**  Colombia Loc Field.  */  
   "COIsOneTimeCust":boolean,
      /**  DEOrgType  */  
   "DEOrgType":string,
      /**  PEGuaranteeName  */  
   "PEGuaranteeName":string,
      /**  PEGuaranteeAddress1  */  
   "PEGuaranteeAddress1":string,
      /**  PEGuaranteeAddress2  */  
   "PEGuaranteeAddress2":string,
      /**  PEGuaranteeAddress3  */  
   "PEGuaranteeAddress3":string,
      /**  PEGuaranteeCity  */  
   "PEGuaranteeCity":string,
      /**  PEGuaranteeState  */  
   "PEGuaranteeState":string,
      /**  PEGuaranteeZip  */  
   "PEGuaranteeZip":string,
      /**  PEGuaranteeCountry  */  
   "PEGuaranteeCountry":string,
      /**  PEGuaranteePhoneNum  */  
   "PEGuaranteePhoneNum":string,
      /**  PEGuaranteeTaxID  */  
   "PEGuaranteeTaxID":string,
      /**  Our Supplier Code  */  
   "OurSupplierCode":string,
      /**  Type of customer created by ECC.  Valid values are: B=B2b, C=B2C  */  
   "ECCType":string,
      /**  MYIndustryCode  */  
   "MYIndustryCode":string,
      /**  This field defines if the customer is synchronized to an External CRM. Only enabled if the External CRM integration is on at the Company configuration.  */  
   "SyncToExternalCRM":boolean,
      /**  This field holds the id of this customer in the External CRM  */  
   "ExternalCRMCustomerID":string,
      /**  This fields holds the customer type of this customer in the External CRM.  */  
   "ExternalCRMCustomerType":string,
      /**  This field defines the last time that the  Customer  has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   "ExternalCRMLastSync":string,
      /**  This fields determines if the customer needs to be synchronized to the External CRM. If there are changes in the customer master file , Epicor ERP automatically turns on this field.  */  
   "ExternalCRMSyncRequired":boolean,
      /**  Ownership of the customer  */  
   "Ownership":string,
      /**  Industry of the customer  */  
   "Industry":string,
      /**  Annual revenue of the customer  */  
   "AnnualRevenue":number,
      /**  Number of employees of the customer  */  
   "NumberOfEmployees":number,
      /**  Location of the ticker of this customer  */  
   "TickerLocation":string,
      /**  Ticker for the customer  */  
   "TickerSymbol":string,
      /**  Rating for the customer  */  
   "Rating":string,
      /**  TW GUI Code  */  
   "TWGUIRegNum":string,
      /**  MXAccountNumber  */  
   "MXAccountNumber":string,
      /**  Indicates that the shipment lines will be consolidated within the invoice for the same part, the same order, and the same packing slip.  */  
   "ConsolidateLinesPerPart":boolean,
      /**  TWTaxPayerType  */  
   "TWTaxPayerType":number,
      /**  TWDeductGUIFormatCode  */  
   "TWDeductGUIFormatCode":string,
      /**  MXCURP  */  
   "MXCURP":string,
      /**  PEAddressID  */  
   "PEAddressID":string,
      /**  PEPerceptionRegime  */  
   "PEPerceptionRegime":string,
      /**  TaxEntityType  */  
   "TaxEntityType":string,
      /**  GST Compliance Rate field for India  */  
   "INGSTComplianceRate":number,
      /**  INTaxRegistrationID  */  
   "INTaxRegistrationID":string,
      /**  MXPurchaseType  */  
   "MXPurchaseType":string,
      /**  Determines if the customer has to be synchronized with Epicor FSA application.  */  
   "SendToFSA":boolean,
      /**  MXGeneralPublic  */  
   "MXGeneralPublic":boolean,
      /**  Indicates if customer has been placed into an "Aging Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   "AgingCreditHold":boolean,
      /**  Date on which the customer was last placed on aging hold. This field is maintained by the system.  */  
   "AgingCreditHoldDate":string,
      /**  Indicates how the customer was placed on aging hold.  Valid values are "MANUAL" and "PROCESS".  "MANUAL" means that the user placed the customer on hold.  “PROCESS” means that the Mass Credit Information Update Process places the customer on aging hold.  This field is maintained by the system.  */  
   "AgingCreditHoldSource":string,
      /**  The UserFile.DCDUSERID value of the user that last cleared the customer's aging hold. This field is maintained by the system.  */  
   "AgingCreditClearUserID":string,
      /**  The date that the user last cleared the customer's aging hold. This field is maintained by the system.  */  
   "AgingCreditClearDate":string,
      /**  The aging code assigned to the customer.  */  
   "AgingCreditCode":string,
      /**  Indicates whether this customer is importer of records or not. Used for Avalara Tax Connect calculation.  */  
   "ImporterOfRecord":boolean,
      /**  Standard Entry Class Code  */  
   "SEC":string,
      /**  E-Invoice EndpointID Attribute  */  
   "EInvEndpointIDAttr":string,
      /**  Indicates whether sales orders from this sold to customer should be treated as Blind Shipments by Manifest.  */  
   "UseBlindShipping":boolean,
      /**  ELIEinvoice  */  
   "ELIEinvoice":boolean,
      /**  ELIDefReportID  */  
   "ELIDefReportID":string,
      /**  ELIDefStyleNum  */  
   "ELIDefStyleNum":number,
      /**  ELIDefToMail  */  
   "ELIDefToMail":string,
      /**  ELIDefCCMail  */  
   "ELIDefCCMail":string,
      /**  ELIDefMailTempID  */  
   "ELIDefMailTempID":string,
      /**  ELISendMail  */  
   "ELISendMail":boolean,
      /**  COFiscalResp1  */  
   "COFiscalResp1":string,
      /**  COFiscalResp2  */  
   "COFiscalResp2":string,
      /**  COFiscalResp3  */  
   "COFiscalResp3":string,
      /**  COOperType  */  
   "COOperType":string,
      /**  Flag that indicates if the Customer is for Central Collection.  */  
   "CentralCollection":boolean,
      /**  NettingVendorNum  */  
   "NettingVendorNum":number,
      /**  EORI Number  */  
   "EORINumber":string,
      /**  AGIsElectronicCreditInvEligible  */  
   "AGIsElectronicCreditInvEligible":boolean,
      /**  Tax ID Validation Status. Not Validated – 0, Valid – 1, Invalid – 2.  */  
   "TaxValidationStatus":number,
      /**  Tax Validation Date  */  
   "TaxValidationDate":string,
      /**  HMRCTaxValidationLog  */  
   "HMRCTaxValidationLog":string,
      /**  Indicates if the record is inactive.  */  
   "Inactive":boolean,
      /**  Customer Scheme ID  */  
   "ExternalSchemeID":string,
      /**  EInvoice Operator Code  */  
   "ELIOperatorCode":string,
      /**  Sending Option  */  
   "ELISendingOption":number,
      /**  EInvoice Operator ID  */  
   "ELIOperatorID":string,
      /**  EInvExternalID  */  
   "EInvExternalID":string,
      /**  Tax Regime  */  
   "MXTaxRegime":string,
      /**  ExclusionMonth  */  
   "ExclusionMonth":number,
      /**  FSMSendTo  */  
   "FSMSendTo":boolean,
      /**  FSMRegionCode  */  
   "FSMRegionCode":string,
      /**  FSMArea  */  
   "FSMArea":string,
      /**  Default E-invoice Report Style  */  
   "ELIRcptDefStyleNum":number,
      /**  CovenantDiscPercent  */  
   "CovenantDiscPercent":number,
   "ACATCommCare":boolean,
   "ACATRespCareType":string,
   "ACATRespCareTypeDesc":string,
      /**  Customer Address in format delimited string  */  
   "AddrList":string,
      /**  This value is a temp field that is populated from JCSyst.AdvancedLaborRate  */  
   "AdvancedLaborRate":boolean,
      /**  Apply credit hold status to orders  */  
   "ApplyHoldToOrders":boolean,
      /**  delimited list of customer attributes  */  
   "AttrCodeList":string,
      /**  Company base currency.  */  
   "BaseCurrCode":string,
   "BillDayDesc":string,
   "BillFreqDescription":string,
      /**  Bill To Address in format delimited list  */  
   "BTAddrList":string,
      /**  Delimited list of Business Categories  */  
   "BusinessCatList":string,
      /**  ChargeCode Description  */  
   "ChargeCodeDesc":string,
      /**  List of fields which are referenced by COA segments.  */  
   "COASegReferences":string,
   "COOperTypeDesc":string,
   "CustTypeDescription":string,
   "DiscQualDescription":string,
   "DspBTFormatStr":string,
      /**  Display Format String  */  
   "DspFormatStr":string,
   "DspRlsClass":string,
      /**  List of available ECC Payment Method codes  */  
   "ECCPaymentCodes":string,
      /**  List of available ECC Payment Method descriptions  */  
   "ECCPaymentDesc":string,
      /**  List of ECC Payment Method codes selected  */  
   "ECCPaymentList":string,
      /**  List of ECC Payment Method descriptions selected  */  
   "ECCPaymentXDesc":string,
      /**  List of ECC Ship Via codes selected  */  
   "ECCShipViaList":string,
   "EnableGlobalCust":boolean,
   "EnableGlobalLock":boolean,
      /**  Indicates if an "Multi" External Company record exists to enable GlobalCust  */  
   "ExtCoExist":boolean,
   "FxdGlbOrdCredit":number,
   "FxdGlbPICredit":number,
   "FxdOrderCredit":number,
   "FxdPICredit":number,
   "FxdTotOrders":number,
   "FxdTotPI":number,
      /**  Indicates if the Customer is Global (master or linked)  */  
   "GlbFlag":boolean,
      /**  Delimited list of GlbCompany and GlbCustNum that is linking to this customer  */  
   "GlbLink":string,
      /**  Global Shared Credit Available  */  
   "GlbNAChildCrdAvail":number,
      /**  Global Own Credit Available  */  
   "GlbNAOwnCreditAvail":number,
   "GlbNAOwnCreditUsedDsp":number,
      /**  Global Parents Credit Available  */  
   "GlbNAParentCrdAvail":number,
   "GlbNAParentsCreditUsedDsp":number,
   "GlbNAPoolCrdAvail":number,
   "GlbNAPoolCreditUsed":number,
   "GlbNASharedCreditUsedDsp":number,
      /**  Indicates if integrated with a financial package  */  
   "IntegrationFlag":boolean,
      /**  Flag used for integrations whether to run the on change country logic.  */  
   "IntRunChangeCountry":boolean,
      /**  Identifies the default price list for the customer.  Must be unique and present in PriceLst table.  */  
   "ListCode":string,
   "LLLBAnnualHomeCap":number,
   "LLLBAnnualPartPenCap":number,
   "LLLBAnnualResiCap":number,
   "LLLBAnnualSelfFndCap":number,
   "LLLBAsAtDate":string,
      /**  Indicates if the Clients Asset and Income Assessment has been received  */  
   "LLLBAssetAssess":boolean,
   "LLLBLifeTimeCap":number,
   "LLLBMeansTestAmt":number,
   "LLLBMeansTestFeeAmt":number,
   "LLLBPrevEntryDate":string,
      /**  Customer?s credit available to be shared with his Children in National Account  */  
   "NAChildCrdAvail":number,
      /**  If the customer in the Credit Checking National Account  */  
   "NACreditCust":boolean,
      /**  Customer is in Credit National Account and his Credit data have been updated, so recalculation is needed  */  
   "NACreditUpdated":boolean,
      /**  Own Credit Available  */  
   "NAOwnCreditAvail":number,
   "NAOwnCreditUsedDsp":number,
      /**  Available Parent?s Credit in National Accout  */  
   "NAParentCrdAvail":number,
   "NAParentsCreditUsedDsp":number,
      /**  Available credit from credit pools to be used by this customer in National account.  */  
   "NAPoolCrdAvail":number,
   "NAPoolCreditUsed":number,
   "NASharedCreditUsedDsp":number,
      /**  Total Credit Available from National Account  */  
   "NATotalCreditAvail":number,
      /**  Total Credit Used from National Account  */  
   "NATotalCreditUsed":number,
      /**  A user defined external Netting Vendor ID.  This must be existing Vendor ID within the file.  */  
   "NettingVendorID":string,
      /**  CustID of Parent Customer  */  
   "ParentCustID":string,
      /**  Name of Parent Customer  */  
   "ParentName":string,
   "PeriodicityDesc":string,
      /**  List of available Periodicity values.  */  
   "PeriodicityList":string,
      /**  Indicates whether PI fields should be enabled or not  */  
   "PIFlag":boolean,
      /**  Reminder Group Description  */  
   "ReminderGroupDesc":string,
      /**  Sales Tax ID  */  
   "SalesTaxID":string,
      /**  Automated Bank Reconciliation: Search IDs.  */  
   "SearchIDs":string,
      /**  flag indicating whether packing slips are sent to integration partner  */  
   "SendShipment":boolean,
      /**  Service Tax ID  */  
   "ServiceTaxID":string,
   "ShippingQualifierDesc":string,
      /**  Total Global Invoice Credit (including current company)  */  
   "TotGlbInvoiceCredit":number,
      /**  Total Global Open Credit (based on GlbCredInc flags)  */  
   "TotGlbOpenCredit":number,
      /**  Total Global Order Credit (including current company)  */  
   "TotGlbOrderCredit":number,
      /**  Total Global Payment Instruments Credit (including current company)  */  
   "TotGlbPICredit":number,
   "TotInvoiceCredit":number,
   "TotLCCredit":number,
   "TotLCCumInvoices":number,
   "TotLCInvoiceBal":number,
   "TotLCOpenOrders":number,
   "TotLCUsed":number,
      /**  Total Credit based on CredInc flags  */  
   "TotOpenCredit":number,
      /**  Total number of open invoices  */  
   "TotOpenInvoices":number,
      /**  Total number of open invoices for LCs  */  
   "TotOpenInvoicesLC":number,
      /**  Total number of open LCs  */  
   "TotOpenLC":number,
      /**  Total number of open orders for LCs  */  
   "TotOpenOrderLC":number,
      /**  Total number of open orders  */  
   "TotOpenOrders":number,
      /**  Total number of open Payment Instruments  */  
   "TotOpenPI":number,
   "TotOrderCredit":number,
   "TotPICredit":number,
   "ACATOtherCare":boolean,
   "LanguageDescription":string,
      /**  Area of ISTMO de Tehuantepec (Polos de Desarrollo). Value is from MXLocISTMO User Code.  */  
   "MXISTMO":string,
      /**  E-invoice default report id for cash receipt  */  
   "ELIRcptDefReportID":string,
   "BitFlag":number,
   "AGAFIPResponsibilityDescription":string,
   "AGBillToProvinceDescription":string,
   "AGIDDocTypeCUITMark":boolean,
   "AGIDDocTypeDescription":string,
   "AgingCreditDescription":string,
   "AGProvinceDescription":string,
   "BTCountryISOCode":string,
   "BTCountryEUMember":boolean,
   "CompanySendToFSA":boolean,
   "CountryISOCode":string,
   "CountryFormatStr":string,
   "CountryEUMember":boolean,
   "CurrencyCurrName":string,
   "CurrencyCurrencyID":string,
   "CurrencyCurrSymbol":string,
   "CurrencyCurrDesc":string,
   "CurrencyDocumentDesc":string,
   "CustGrupGroupDesc":string,
   "DeliveryTypeDescription":string,
   "FOBDescription":string,
   "GlobalCurrencyCurrSymbol":string,
   "GlobalCurrencyCurrDesc":string,
   "GlobalCurrencyDocumentDesc":string,
   "GlobalCurrencyCurrencyID":string,
   "GlobalCurrencyCurrName":string,
   "MarkUpDescription":string,
   "MXPurchaseTypeCodeDesc":string,
   "PayMethodSummarizePerCustomer":boolean,
   "PayMethodType":number,
   "PayMethodName":string,
   "PreferredBankBankName":string,
   "PreferredBankDescription":string,
   "RASchedCdRADesc":string,
   "ReservePriDescription":string,
   "SalesRepName":string,
   "ShipViaWebDesc":string,
   "ShipViaDescription":string,
   "TATaxAuthorityDescription":string,
   "TaxRegionDescription":string,
   "TermsDescription":string,
   "TerritoryTerritoryDesc":string,
   "XbSystELIEinvoice":boolean,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_EntityGLCRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   "RelatedToFile":string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   "Key1":string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   "Key2":string,
      /**   3rd component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key3":string,
      /**   4th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key4":string,
      /**   5th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key5":string,
      /**   6th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key6":string,
      /**  Identifier of the GL Control Type.  */  
   "GLControlType":string,
      /**  GL Control Identifier.  */  
   "GLControlCode":string,
      /**  Identifies the entity.  Reference only.  Used for integrity validation when deleting a GLCTEntity record.  */  
   "BusinessEntity":string,
      /**  Global Company identifier.  Used in Multi-Company Journal.  */  
   "ExtCompanyID":string,
      /**  Flag to indicate the account in this record is for an external company.  */  
   "IsExternalCompany":boolean,
      /**  Marks this EntityGLC as global, available to be sent out to other companies.  */  
   "GlobalEntityGLC":boolean,
      /**  Disables this record from receiving global updates.  */  
   "GlobalLock":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  BankAcctID of the related BankAcct record.  */  
   "BankAcctID":string,
   "BankFeeID":string,
      /**  CallCode of the related FSCallCd record.  */  
   "CallCode":string,
   "ChargeCode":string,
      /**  ClassCode of the related FAClass record.  */  
   "ClassCode":string,
      /**  ClassID.  This can be ClassID of PartClass, PRClsDed, or PRClsTax  */  
   "ClassID":string,
      /**  ContractCode of the related FSContCd record.  */  
   "ContractCode":string,
      /**  CurrencyCode of the related Currency record.  */  
   "CurrencyCode":string,
      /**  CustNum of the related Customer record  */  
   "CustNum":number,
      /**  DeductionID of PRClsDed or PRDeduct.  */  
   "DeductionID":string,
      /**  EmpID of the related PREmpMas record.  */  
   "EmpID":string,
      /**  ExpenseCode of PayTLbr, LabExpCd  */  
   "ExpenseCode":string,
      /**  ExtSystemID of ExtCompany table  */  
   "ExtSystemID":string,
      /**  FromPlant value of the related PlntTranDef record.  */  
   "FromPlant":string,
      /**  GroupCode of the related FAGroup record.  */  
   "GroupCode":string,
   "GroupID":string,
   "HeadNum":number,
   "InvoiceNum":string,
      /**  JCDept of the related JCDept record.  */  
   "JCDept":string,
      /**  MiscCode of the related MiscChrg or PurMisc record.  */  
   "MiscCode":string,
      /**  PartNum of the related Part record.  */  
   "PartNum":string,
      /**  PayTypeID of PayType  */  
   "PayTypeID":string,
   "PerConName":string,
      /**  PI Status  */  
   "PIStatus":string,
      /**  Plant of the related PlantConfCtrl record.  */  
   "Plant":string,
      /**  ProdCode of the related ProdGrup record.  */  
   "ProdCode":string,
      /**  ProjectID of the related Project record.  */  
   "ProjectID":string,
      /**  PurchCode of the related GLPurch record.  */  
   "PurchCode":string,
      /**  RateCode of the related GLRate record.  */  
   "RateCode":string,
      /**  ReasonCode of the related Reason record.  */  
   "ReasonCode":string,
      /**  ReasonType of the related Reason record.  */  
   "ReasonType":string,
      /**  SalesCatID of the related SalesCat record.  */  
   "SalesCatID":string,
      /**  Shift value of the related JCShift record.  */  
   "Shift":number,
      /**  TaxCode of the related SalesTax record.  */  
   "TaxCode":string,
      /**  TaxTblID of PRTaxMas or PRClsTax.  */  
   "TaxTblID":string,
      /**  ToPlant value of the related PlntTranDef record.  */  
   "ToPlant":string,
      /**  TransferMethod of ExtCompany table  */  
   "TransferMethod":string,
      /**  Type ID  */  
   "TypeID":string,
      /**  VendorNum of the related Vendor record.  */  
   "VendorNum":number,
      /**  WarehouseCode of the related Warehse record.  */  
   "WarehouseCode":string,
   "ExpenseTypeCode":string,
   "IsFiltered":boolean,
   "OprTypeCode":string,
   "CashDeskID":string,
   "TIN":string,
   "ReclassCodeID":string,
   "BitFlag":number,
   "GLCntrlDescription":string,
   "GLCntrlTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_GlbCustCredRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program. This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never need to know about the value of this field.  */  
   "CustNum":number,
      /**  Company credit totals came from (not just owner of the global customer)  */  
   "ExtCompany":string,
   "ExtCompName":string,
      /**  Date the credit was last updated  */  
   "UpdateDate":string,
      /**  Open AR Credit in Global Currency  */  
   "DocARTotal":number,
      /**  Open Order Credit in Global Currency  */  
   "DocSOTotal":number,
      /**  Open PI Credit in Global Currency  */  
   "DocPITotal":number,
      /**  AR Credit in local companies base currency  */  
   "ARTotal":number,
      /**  SO Credit in local companies base currency  */  
   "SOTotal":number,
      /**  PI Credit in local companies base currency  */  
   "PITotal":number,
      /**  Holds connection and exchange rate error messages  */  
   "ErrorMsg":string,
      /**  This field holds the associated Global Customer number.  If this is the "parent" customer then it will match the CustNum field.  0 indicates that this is not a global customer at all  */  
   "GlbCustNum":number,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   "ParentCustNum":number,
      /**  Holds the Currency.CurrencyCode value of that the global customer will exchange data in.  */  
   "GlobalCurrencyCode":string,
      /**  Total Number of Open Invoices  */  
   "TotalInvoices":number,
      /**  Total Number of Open Orders  */  
   "TotalOrders":number,
      /**  Total Number of open Payment Instruments  */  
   "TotalPayIns":number,
      /**  Parent's Credit used by this customer  */  
   "NAParentsCreditUsed":number,
      /**  Shared Credit used by children  */  
   "NASharedCreditUsed":number,
      /**  Own Credit used by himself  */  
   "NAOwnCreditUsed":number,
      /**  Global Parent's Credit used by this customer  */  
   "GlbNAParentsCreditUsed":number,
      /**  Shared Credit used by Global children  */  
   "GlbNASharedCreditUsed":number,
      /**  Pool Credit used  */  
   "NAPoolCreditUsed":number,
      /**  Global Credit Pool used  */  
   "GlbNAPoolCreditUsed":number,
      /**  Own Credit used by himself  */  
   "GlbNAOwnCreditUsed":number,
      /**  Allocated Credit exceed Credit Limit  */  
   "NAExceedLimit":number,
      /**  Allocated Credit exceed Global Credit Limit  */  
   "GlbNAExceedLimit":number,
      /**  AR Letter of Credit Credit in local companies base currency  */  
   "ARLOCTotal":number,
      /**  Open AR Letter of Credit Credit in Global Currency  */  
   "DocARLOCTotal":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_MXCustomerFiscalTextRow{
      /**  Company  */  
   "Company":string,
      /**  CustNum  */  
   "CustNum":number,
      /**  FiscalTextSeq  */  
   "FiscalTextSeq":number,
      /**  TaxProv  */  
   "TaxProv":string,
      /**  Rule  */  
   "Rule":string,
      /**  FiscalText  */  
   "FiscalText":string,
      /**  IncludeInXML  */  
   "IncludeInXML":boolean,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_MangCustRow{
      /**  Unique CustNum of the managed customer.  */  
   "CustNum":number,
      /**  Company Identifier.  */  
   "Company":string,
      /**  The unique code that link this table to the Vendor Master table.  This represents a valid supplier for this managed customer.  */  
   "VendorNum":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "CustNumCustID":string,
   "CustNumBTName":string,
   "CustNumName":string,
   "VendorNumCity":string,
   "VendorNumTermsCode":string,
   "VendorNumCurrencyCode":string,
   "VendorNumAddress2":string,
   "VendorNumName":string,
   "VendorNumCountry":string,
   "VendorNumAddress3":string,
   "VendorNumDefaultFOB":string,
   "VendorNumAddress1":string,
   "VendorNumVendorID":string,
   "VendorNumZIP":string,
   "VendorNumState":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_NAMemberRow{
   "Company":string,
      /**  Code of RlsClass  */  
   "RlsClassCode":string,
   "TopCustNum":number,
   "CustNum":number,
   "TopCustID":string,
   "Tiered":boolean,
   "TopCustName":string,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PECustWhldHistRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Customer Number  */  
   "CustNum":number,
      /**  Record Sequence  */  
   "RecordSeq":number,
      /**  Create Date  */  
   "CreateDate":string,
      /**  User Identifier.  */  
   "UserID":string,
      /**  Good Contributor  */  
   "GoodContributor":boolean,
      /**  Indicates the status of Withholding Agent.  */  
   "WithholdingAgent":boolean,
      /**  Collection Agent withholding status.  */  
   "CollectionAgent":boolean,
      /**  Not Found withholding status.  */  
   "NotFound":boolean,
      /**  No Address Provided withholding status.  */  
   "NoAddress":boolean,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartnerRow{
      /**  Company  */  
   "Company":string,
      /**  PartnerNum  */  
   "PartnerNum":number,
      /**  PartnerType  */  
   "PartnerType":number,
      /**  SearchID  */  
   "SearchID":string,
      /**  IsActive  */  
   "IsActive":boolean,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
      /**  PartnerID  */  
   "PartnerID":string,
   "DspSearchID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToAttchRow{
   "Company":string,
   "CustNum":number,
   "ShipToNum":string,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToDiscPriceLstRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   "CustNum":number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   "ShipToNum":string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   "SeqNum":number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   "ListCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PriceListStartDate":string,
   "PriceListEndDate":string,
   "PriceListListDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToLabExpRateRow{
      /**  Company  */  
   "Company":string,
      /**  CustNum  */  
   "CustNum":number,
      /**  ShipToNum  */  
   "ShipToNum":string,
      /**  ExpenseCode  */  
   "ExpenseCode":string,
      /**  RateType  */  
   "RateType":number,
      /**  RateMultiplier  */  
   "RateMultiplier":number,
      /**  FixedRate  */  
   "FixedRate":number,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
   "BitFlag":number,
   "ShipToShipToNum":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToMFBillRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   "ShipToNum":string,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   "PayBTFlag":string,
      /**   Describes the billing type.  Valid values and their description are:
1 - Shipper
2 - FedEx  Collect
3 - Third Party
4 - UPS Prepaid
5 - FedEx Recipient
6 - UPS Consignee
7 - UPS Freight Collect
8 - UPS Free On Board
9 - UPS Cost and Freight
10 - UPS Delivery Duty Paid
11 - UPS Shpping Duty and Tax Consignee  */  
   "PayTypeDesc":string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   "PayAccount":string,
      /**  Shipping Billing Address  */  
   "PayBTAddress1":string,
      /**  Shipping biling address line 2  */  
   "PayBTAddress2":string,
      /**  Shipping biling address line 3.  */  
   "PayBTAddress3":string,
      /**  Shipping billing city  */  
   "PayBTCity":string,
      /**  Shipping Billing state or province  */  
   "PayBTState":string,
      /**  Manifest billing postal code  */  
   "PayBTZip":string,
      /**  Shipping biling country  */  
   "PayBTCountry":string,
      /**  Internal field used to store the country number.  */  
   "PayBTCountryNum":number,
      /**  Shipping billing phone number  */  
   "PayBTPhone":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToPriceLstRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   "CustNum":number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   "ShipToNum":string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   "SeqNum":number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   "ListCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PriceListListDescription":string,
   "PriceListStartDate":string,
   "PriceListEndDate":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToRestrictionRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   "CustNum":number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   "ShipToNum":string,
      /**  Restriction Type identification.  */  
   "RestrictionTypeID":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "CustNumName":string,
   "CustNumCustID":string,
   "CustNumBTName":string,
   "RestrictionTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   "CustNum":number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   "ShipToNum":string,
      /**  Name of the ShipTo. When creating new records the Customer.Name is used as a default.  */  
   "Name":string,
      /**  The first line of the ShipTo address.  */  
   "Address1":string,
      /**  The second line of the ShipTo address.  */  
   "Address2":string,
      /**  The third line of the ShipTo address.  */  
   "Address3":string,
      /**  The city portion of the ShipTo address.  */  
   "City":string,
      /**  The state or province portion of the ShipTo address.  */  
   "State":string,
      /**  The zip or postal code portion of the ShipTo address.  */  
   "ZIP":string,
      /**  The country portion of the ShipTo address.  */  
   "Country":string,
      /**  The State Tax Identification Number. Used in Order Entry and prints on Sales Acknowledgements.  */  
   "ResaleID":string,
      /**  The SalesRep.SalesRepCode value of the default salesperson for the customer. Used as a default in Order Entry and Invoice entry. The SalesRep from the customer master is used as an initial default when creating new ship to.  */  
   "SalesRepCode":string,
      /**  The SalesTer.TerritoryID value of the territory the customer is assigned to.  */  
   "TerritoryID":string,
      /**  The ShipVia.ShipViaCode value of the default ShipVia assigned to the customer. Used as a default in Order Entry, Shipping and Invoicing.  The shipvia from the customer record for this shipto is used as the initial default when creating new ShipTo records.  */  
   "ShipViaCode":string,
      /**  The CustCnt.ConNum of the default shipping contact for the ShipTo location. The primary shipping contact is used as a default in the shipping process.  */  
   "PrimSCon":number,
      /**  The fax number for the ShipTo location. isplayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   "FaxNum":string,
      /**  The business phone number for the ShipTo location. Displayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   "PhoneNum":string,
      /**  Determines whether or not the ShipTo location is normally exempt from sales tax. Used as a default in invoice entry.  If the field is non-blank it is considered exempt.   This code is totally user definable and no validation is required.  */  
   "TaxExempt":string,
      /**  A mutually agreed upon value that links a customer's EDI shipto record (an N1 / ST) to the Manufacturing System DB ShipTo record.  */  
   "EDIShipNum":string,
      /**  The Country.CountryNum value of the country selected in the ShipTo.Country field.  */  
   "CountryNum":number,
      /**  The LangName.LangNameID value of the default Language assigned to the ShipTo location. This controls which language will be selected when extracting part descriptions from PartLangDesc table.  */  
   "LangNameID":string,
      /**  Area/city code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Customer table. This field is only visible if ISSyst.EnableHarbour is set.  */  
   "BorderCrossing":string,
      /**  Optional custom address format for the ShipTo location.  */  
   "FormatStr":string,
      /**  Contains the TaxRgn.TaxRegionCode value of the customer's tax region for purposes of Sales Tax calculations.  */  
   "TaxRegionCode":string,
      /**  The email address of the ShipTo location.  */  
   "EMailAddress":string,
      /**   Determines how the ShipTo location should be assigned to a territory. There are 3 methods for Territory assignment in Ship-to:

Sync - Keep the ShipTo territory synchronized with the territory on the
       main customer record. (ShipTo.TerritoryID = Customer.TerritoryID)
Syst - Let the system (Get Territory) determine the territory to assign         to the ShipTo based on territory boundaries.
Lock - Check this method after assigning the territory manually to 
       prevent the system from attempting to reassign the territory.  */  
   "TerritorySelect":string,
      /**  The pending sales territory that the customer will be assigned to based on changes to the territory boundaries.  This functionality is only available with the CRM module.  */  
   "PendingTerritoryID":string,
      /**  Determines whether or not the ShipTo record was created by an EDI transaction.  */  
   "CreatedByEDI":boolean,
      /**  Unique identifier of the ShipTo from an external General Ledger interface such as the EuroFinancial integration.  */  
   "ExternalID":string,
      /**  The TaxAuthorityCd.TaxAuthorityCode value of the Tax Authority assigned to this ShipTo location.  */  
   "TaxAuthorityCode":string,
      /**  Disable this record from receiving global updates.  */  
   "GlobalLock":boolean,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   "EDICode":string,
      /**  Days to use in calculating the Order Detail Ship By date from the incoming need by date.  */  
   "DemandDeliveryDays":number,
      /**   Indicates incoming date type.  Values are:
S - Shipping Date
N - Need By Date  */  
   "DemandDateType":string,
      /**  The number of days from today to give a warning when adding a new order release record from an incoming shipping schedule.  */  
   "DemandAddLeadTime":number,
      /**  Indicates what type of action to take if the add lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandAddAction":string,
      /**  The number of days from today to give a warning when changing an order release record from an incoming shipping schedule.  This does not include changes to quantity or dates.  */  
   "DemandChangeLeadTime":number,
      /**  Indicates what type of action to take if the change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandChangeAction":string,
      /**  The number of days from today to give a warning when canceling an order release record from an incoming shipping schedule.  */  
   "DemandCancelLeadTime":number,
      /**  Indicates what type of action to take if the cancel lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandCancelAction":string,
      /**  The number of days from today to give a warning when adding a new order line record from an incoming shipping schedule.  */  
   "DemandNewLineLeadTime":number,
      /**  Indicates what type of action to take if the new line lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandNewLineAction":string,
      /**  The number of days from today to give a warning when changing the quantity on an order release record from an incoming shipping schedule.  */  
   "DemandQtyChangeLeadTime":number,
      /**  Indicates what type of action to take if the quantity change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandQtyChangeAction":string,
      /**  The number of days from today to give a warning when changing the date on an order release record from an incoming shipping schedule.  */  
   "DemandChangeDateLeadTime":number,
      /**  Indicates what type of action to take if the change date lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   "DemandChangeDateAction":string,
      /**  The trading partner name.  */  
   "TradingPartnerName":string,
      /**  Is this a residential delivery  */  
   "ResDelivery":boolean,
      /**  Is a Saturday delivery acceptable  */  
   "SatDelivery":boolean,
      /**  Is a Saturday pickup available  */  
   "SatPickup":boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   "Hazmat":boolean,
      /**  Documents Only delivery  */  
   "DocOnly":boolean,
      /**  Reference Notes for the delivery  */  
   "RefNotes":string,
      /**  Apply Handling Charge to shipment  */  
   "ApplyChrg":boolean,
      /**  Handling Charge Amount  */  
   "ChrgAmount":number,
      /**  Prefer COD delivery  */  
   "COD":boolean,
      /**  Add Freight COD Amount owed  */  
   "CODFreight":boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   "CODCheck":boolean,
      /**  Amount due on Cashier's check or money order  */  
   "CODAmount":number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   "GroundType":string,
      /**  Indicates whether to send an email notification of delivery  */  
   "NotifyFlag":boolean,
      /**  The list of email address to notify about a delivery  */  
   "NotifyEMail":string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   "DeclaredIns":boolean,
      /**  Declared Insurance Amount  */  
   "DeclaredAmt":number,
      /**  Periodicity Code.  Must be a valid code in the Periodicity table.  */  
   "PeriodicityCode":number,
      /**  Service delivery requires signature  */  
   "ServSignature":boolean,
      /**  Service Priority Alert flag  */  
   "ServAlert":boolean,
      /**  Service Home Delivery allowed  */  
   "ServHomeDel":boolean,
      /**  Service Home Delivery Type Code  */  
   "DeliveryType":string,
      /**  Service Home Delivery date  */  
   "ServDeliveryDate":string,
      /**  Home delivery phone number  */  
   "ServPhone":string,
      /**  Service Delivery Instructions  */  
   "ServInstruct":string,
      /**  Service Signature release is on file  */  
   "ServRelease":boolean,
      /**  Service Signature Release authorization number  */  
   "ServAuthNum":string,
      /**  Service Reference 1  */  
   "ServRef1":string,
      /**  Added for international shipping, Is a commercial invoice required  */  
   "CommercialInvoice":boolean,
      /**  Service Reference 2  */  
   "ServRef2":string,
      /**  Added for international shipping. Shipper's Export Declaration required  */  
   "ShipExprtDeclartn":boolean,
      /**  Service Reference 3  */  
   "ServRef3":string,
      /**  For International shipping.  Certificate of Orgin required.  */  
   "CertOfOrigin":boolean,
      /**  Service Reference 4  */  
   "ServRef4":string,
      /**  For International shipping.  Shipper's Letter of Instruction.  */  
   "LetterOfInstr":boolean,
      /**  Service Reference 5  */  
   "ServRef5":string,
      /**  International Shipping - HazardousShipment  */  
   "HazardousShipment":boolean,
      /**  Override Carrier Defaults.  If not checked then the customer values will be used if overriden else the Site values  */  
   "OverrideCarrier":boolean,
      /**  Is this an International shipment  */  
   "IntrntlShip":boolean,
      /**  Override Service Options.  If not checked then the customer values will be used if overriden else the Site values  */  
   "OverrideService":boolean,
      /**  Indicates if the demand fields from the customer should be used.  */  
   "DemandUseCustomerValues":boolean,
      /**  Tax Payer Registration Reason Code  */  
   "TaxRegReason":string,
      /**  Used to calculate on-time delivery performance rating  */  
   "EarlyBuffer":number,
      /**  Organization Registration Code  */  
   "OrgRegCode":string,
      /**  Used to calculate on-time delivery performance rating  */  
   "LateBuffer":number,
      /**  Indicates if the unit price between the demand and the contract should be validated.  If this flag is checked, and the prices are different, when the demand is accepted a record will be written to the DemandLog table.  */  
   "DemandUnitPriceDiff":boolean,
      /**  Indicates what type of action to take if the unit price between the demand and the contract is different.  Options are B (reject the change) or W (warning - alert that the unit price is different but allow the record to be accepted).  */  
   "DemandUnitPriceDiffAction":string,
      /**  A flag that indicates whether this address should be validated by the tax service.  */  
   "ExcFromVal":boolean,
      /**  A flag indicating that an address has already been validated. This helps improve the performance of the bulk address validation process by allowing address that have already been validated to be skipped. This flag is set anytime a successful validation is performed, either by the bulk address validation or validation from the Customer form.  */  
   "AddressVal":boolean,
      /**  Check for the part in the Part master.  */  
   "DemandCheckForPart":boolean,
      /**  Indicates what type of action to take if the Check for Part options is selected and the part is not in the part master file.  Options are B (reject the change) or W (warning - alert that the part is not in the part master but allow the record to be accepted).  */  
   "DemandCheckForPartAction":string,
      /**  International Shipping. Frieght Forwarder ID  */  
   "FFID":string,
      /**  International Shipping. The first line of the Frieght Forwarder main address.  */  
   "FFAddress1":string,
      /**  International Shipping. The second line of the Frieght Forwarder main address.  */  
   "FFAddress2":string,
      /**  Shipping, The city portion of the Frieght Forwarder main address.  */  
   "FFCity":string,
      /**  International Shipping. The state or province portion of the shipment Frieght Forwarder main address.  */  
   "FFState":string,
      /**  International Shipping. The zip or postal code portion of the shipping Frieght Forwarder main address.  */  
   "FFZip":string,
      /**  International shipping. The country of the Frieght Forwarder .  */  
   "FFCountry":string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   "FFContact":string,
      /**  International Shipping. Frieght Forwarder company name  */  
   "FFCompName":string,
      /**  International Shipping. Frieght Forwarder Phone number  */  
   "FFPhoneNum":string,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Individual Pack IDs  */  
   "IndividualPackIDs":boolean,
      /**  Freight Forwarder Third address line  */  
   "FFCountryNum":number,
      /**  Additional Handling flag  */  
   "NonStdPkg":boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   "DeliveryConf":number,
      /**  Non Standard Packaging  */  
   "AddlHdlgFlag":boolean,
      /**  UPS Quantum View  */  
   "UPSQuantumView":boolean,
      /**  UPS Quantum View From Name  */  
   "UPSQVShipFromName":string,
      /**  UPS Quantum View Memo  */  
   "UPSQVMemo":string,
      /**  Freight Forwarder Country portion of the address  */  
   "FFAddress3":string,
      /**  Used to determine if an address changed because of the tax integration.  If true, the tax integration changed the address.  */  
   "ETCAddrChg":boolean,
      /**  Indicates if this is a alternate ShipTo. An alternate is a Shipto that is valid for this customer, but is defined/maintained by the "master" customer. See ShipTo.MasterCustNum/MasterShiptoNum.  */  
   "IsAlternate":boolean,
      /**  Pertains to Alternate Shipto (IsAlternate). Contains the CustNum of the Shipto record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   "MasterCustNum":number,
      /**  Pertains to Alternate Shipto (IsAlternate). Contains the ShipToNum of the Shipto record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   "MasterShipToNum":string,
      /**  Check for Revision  */  
   "DemandCheckForRev":boolean,
      /**  Check for Revision Action  */  
   "DemandCheckForRevAction":string,
      /**  Flag for checking partial Shipment for Demand Entry.  */  
   "DemandCheckPartialShip":boolean,
      /**  Check Partial Shipments Action: B =Stop  and W = Warning  */  
   "DemandCheckShipAction":string,
      /**  Define if at the moment of processing a demand the process should also close those rejected schedules that remain at demand entry  */  
   "DemandCloseRejSkd":boolean,
      /**  Defines if Internal Pricing or Customer Pricing will be used for checking price differences  */  
   "DemandPricing":string,
      /**  Defines the tolerance for price difference validations  */  
   "PriceTolerance":number,
      /**  If this flags is turned on then Demand CTP will automatically be executed as a part of the demand to order process.  */  
   "CheckDateCapPromise":boolean,
      /**  Confirm or not the Capable to Promise jobs from Demand Entry  */  
   "CheckConfirmCapPromise":boolean,
      /**  If checked, Updates the date in Demand Entry  */  
   "CheckUpdateCapPromise":boolean,
      /**  This field will define the dates that will be validated as a part of the demand to order process. The valid values for this combo will be:  Need By (N), Ship By (S) and Both (B)  */  
   "DemandCapPromiseDate":string,
      /**  The value on this field will define the action to be taken when validating CTP. The valid values for this combo box will be: Warning (W) and Stop (S)  */  
   "DemandCapPromiseAction":string,
      /**   This field will define the dates that will be updated as a part of the demand to order process. The valid options will be:
Need By (N), Ship By (S) and Both  (B) NOTE .-In all the cases above the update of date will only be done if the CTP dates are beyond the dates on the file.  */  
   "DemandCapPromiseUpdate":string,
      /**  When set to TRUE the smart string functionality will only be processed when the incoming demand is new. After it has been processed and saved, if a retransmission is sent the smart string values will be ignored.  */  
   "OTSmartString":boolean,
      /**  Full Legal name  */  
   "LegalName":string,
      /**  If true then demand will be rejected when one or more demand lines are not configured properly. Applies only to Configurable parts.  */  
   "DemandCheckConfig":boolean,
      /**  Indicates the action to be taken if configuration values have not been entered for one or more demand lines.  */  
   "DemandCheckCfgAction":string,
      /**  WIWebShipTo  */  
   "WIWebShipTo":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  AGApartment  */  
   "AGApartment":string,
      /**  AGExtraStreetNumber  */  
   "AGExtraStreetNumber":string,
      /**  AGFloor  */  
   "AGFloor":string,
      /**  AGGrossIncomeTaxID  */  
   "AGGrossIncomeTaxID":string,
      /**  AGLocationCode  */  
   "AGLocationCode":string,
      /**  AGNeighborhood  */  
   "AGNeighborhood":string,
      /**  AGProvinceCode  */  
   "AGProvinceCode":string,
      /**  AGStreet  */  
   "AGStreet":string,
      /**  AGStreetNumber  */  
   "AGStreetNumber":string,
      /**  EntityUseCode  */  
   "EntityUseCode":string,
      /**  Check if the part is a run out part.  */  
   "DemandCheckForRunOutPart":boolean,
      /**  Indicates what type of action to take if the Check for Run Out Part option is selected and the part is marked as a run out part.  Options are B (reject the change) or W (warning - alert that the part is marked as run out but allow the record to be accepted).  */  
   "DemandCheckForRunOutPartAction":string,
      /**  INExciseRegNumber  */  
   "INExciseRegNumber":string,
      /**  INVATNumber  */  
   "INVATNumber":string,
      /**  INSTRegistration  */  
   "INSTRegistration":string,
      /**  MXCURP  */  
   "MXCURP":string,
      /**  MXMunicipio  */  
   "MXMunicipio":string,
      /**  MXFederalID  */  
   "MXFederalID":string,
      /**  INTaxRegistrationID  */  
   "INTaxRegistrationID":string,
      /**  Geographical Location Code  */  
   "PEUBIGEOCode":string,
      /**  EORI Number  */  
   "EORINumber":string,
      /**  Tax ID Validation Status: Not Validated – 0, Valid – 1, Invalid – 2.  */  
   "TaxValidationStatus":number,
      /**  Tax Validation Date  */  
   "TaxValidationDate":string,
      /**  HMRCTaxValidationLog  */  
   "HMRCTaxValidationLog":string,
      /**  Indicates if the record is inactive.  */  
   "Inactive":boolean,
      /**  FSMRegionCode  */  
   "FSMRegionCode":string,
      /**  FSMArea  */  
   "FSMArea":string,
      /**  List of fields which are referenced by COA segments.  */  
   "COASegReferences":string,
      /**  Used for ContactTracker.  This is needed so the UI can relate the Contact Tracker tables together.  */  
   "ContactName":string,
      /**  Display Format String  */  
   "DspFormatStr":string,
      /**  Indicates if ShipTo is Global (Master or Linked)  */  
   "GlbFlag":boolean,
      /**  Delimited list of GlbCompany, GlbCustNum and GlbShipto that is linking to this shipto  */  
   "GlbLink":string,
      /**  Indicates Integration with financial package (like EuroFin)  */  
   "IntegrationFlag":boolean,
      /**  Flag used for integrations whether to run the on change country logic.  */  
   "IntRunChangeCountry":boolean,
   "PeriodicityDesc":string,
      /**  List of available Periodicity values  */  
   "PeriodicityList":string,
      /**  Used to indicate if primary shipto.  Updates Customer.ShipToNum field  */  
   "PrimaryShipTo":boolean,
      /**  Sales Tax ID  */  
   "SalesTaxID":string,
      /**  Service Tax ID  */  
   "ServiceTaxID":string,
   "TerritorySelectDescription":string,
      /**  Use this field to display/update; replaces TerritorySelect  */  
   "TerrSelectFlag":string,
      /**  Address in formatted delimited list  */  
   "AddrList":string,
   "LanguageDescription":string,
      /**  Area of ISTMO de Tehuantepec (Polos de Desarrollo). Value is from MXLocISTMO User Code.  */  
   "MXISTMO":string,
   "BitFlag":number,
   "AGLocationDescription":string,
   "AGProvinceDescription":string,
   "CountryISOCode":string,
   "CountryEUMember":boolean,
   "CustNumName":string,
   "CustNumCustID":string,
   "CustNumBTName":string,
   "DeliveryTypeDescription":string,
   "MasterCustIDBTName":string,
   "MasterCustIDCustID":string,
   "MasterCustIDName":string,
   "SalesRepName":string,
   "ShipViaWebDesc":string,
   "ShipViaDescription":string,
   "TATaxAuthorityDescription":string,
   "TaxRegionDescription":string,
   "TerritoryTerritoryDesc":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToSrchRow{
   "Company":string,
   "CustNum":number,
   "ShipToID":string,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_ShipToUPSEmlRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   "CustNum":number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   "ShipToNum":string,
      /**  UPS Quantum View Sequence  */  
   "UPSQVSeq":number,
      /**  Email address to notify for a UPS shipment  */  
   "EmailAddress":string,
      /**  Logical indicating if the EmailAddress is to be updated at shipping.  */  
   "ShipmentNotify":boolean,
      /**  Logical indicating if the Email Address is to be notified of a failed shipment.  */  
   "FailureNotify":boolean,
      /**  Logical indicating if the Email Address is to be notified of delivery.  */  
   "DeliveryNotify":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Logical indicating whether or not the UPS Quantum View fields are to be enabled.  */  
   "EnableQuantumView":boolean,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_TaxExemptRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   "RelatedToFile":string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   "Key1":string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   "Key2":string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   "TaxCode":string,
      /**  Tax Rate Code  */  
   "RateCode":string,
      /**  Exemption Effective Start Date  */  
   "EffectiveFrom":string,
      /**  Exemption Effective End Date  */  
   "EffectiveTo":string,
      /**  Exemption Type  */  
   "ExemptType":number,
      /**  Exemption Percent  */  
   "ExemptPercent":number,
      /**  Tax Legal Text Code  */  
   "TextCode":string,
      /**  Tax Resolution Number  */  
   "ResolutionNum":string,
      /**  Tax Resolution Date  */  
   "ResolutionDate":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  A unique Customer identifier.  */  
   "CustNum":number,
      /**  The PartNum field identifies the Part.  */  
   "PartNum":string,
      /**  A unique Vendor identifier.  */  
   "VendorNum":number,
   "BitFlag":number,
   "SalesTaxDescription":string,
   "SalesTRCDescription":string,
   "TaxTextDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}




//////////////////////////////////////////////////////////////////////////
// Custom Schemas:
//////////////////////////////////////////////////////////////////////////
export interface AllowCustomerDetailUpdate_output{
}

   /** Required : 
      @param agIDDocTypeCode
      @param ds
   */  
export interface ChangeAGIDDocTypeCode_input{
      /**  Argentinean ID Document Type  */  
   agIDDocTypeCode:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeAGIDDocTypeCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param coOperType
      @param ds
   */  
export interface ChangeCOOperType_input{
      /**  Proposed input value  */  
   coOperType:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCOOperType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipInvoiceType
      @param ds
   */  
export interface ChangeCustDfltInvoiceType_input{
      /**  Invoice Type value  */  
   ipInvoiceType:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustDfltInvoiceType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param custNum
      @param shipToNum
      @param icTypeID
      @param proposedICCode
      @param ds
   */  
export interface ChangeCustICICCode_input{
   custNum:number,
   shipToNum:string,
   icTypeID:string,
   proposedICCode:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustICICCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param custNum
      @param mandateType
      @param mandateReference
      @param proposedBankAcctID
      @param ds
   */  
export interface ChangeCustMandateBankAcctID_input{
   custNum:number,
   mandateType:string,
   mandateReference:string,
   proposedBankAcctID:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustMandateBankAcctID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param proposedAllowAltBillTo
      @param ds
   */  
export interface ChangeCustomerAllowAltBillTo_input{
   proposedAllowAltBillTo:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustomerAllowAltBillTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipChargeCode
      @param ds
   */  
export interface ChangeCustomerChargeCode_input{
      /**  ChargeCode value  */  
   ipChargeCode:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustomerChargeCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipFinCharges
      @param ds
   */  
export interface ChangeCustomerFinCharges_input{
      /**  FinCharges value  */  
   ipFinCharges:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustomerFinCharges_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipReminderCode
      @param ds
   */  
export interface ChangeCustomerReminderGroup_input{
      /**  ReminderCode value  */  
   ipReminderCode:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeCustomerReminderGroup_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipDeferredRev
      @param ds
   */  
export interface ChangeDeferredRev_input{
      /**  Proposed input value of Deferred Rev  */  
   ipDeferredRev:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeDeferredRev_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param listCode
      @param tableName
      @param ds
   */  
export interface ChangeListCode_input{
      /**  Proposed Price List Code  */  
   listCode:string,
      /**  Table to look in, either Customer or ShipTo or FieldService  */  
   tableName:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeListCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipMXPurchaseType
      @param ds
   */  
export interface ChangeMXPurchaseType_input{
      /**  Proposed input value of Type of Purchase  */  
   ipMXPurchaseType:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeMXPurchaseType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeMandateReference_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeMandateReference_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipRACode
      @param ds
   */  
export interface ChangeRACode_input{
      /**  Proposed input value of RA Code  */  
   ipRACode:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChangeRACode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface CheckCreditHold_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface CheckCreditHold_output{
parameters : {
      /**  output parameters  */  
   vMessage:string,
}
}

   /** Required : 
      @param custNum
   */  
export interface CheckCustCntWithExternalCRMEnabled_input{
   custNum:number,
}

export interface CheckCustCntWithExternalCRMEnabled_output{
   returnObj:boolean,
}

   /** Required : 
      @param vName
      @param custId
      @param vRowid
      @param vAddress1
      @param vZip
   */  
export interface CheckDupCustomer_input{
      /**  This parameter takes a value for something  */  
   vName:string,
      /**  Customer ID field  */  
   custId:string,
      /**  RowIdent field of the Customer  */  
   vRowid:string,
      /**  Customer Address field  */  
   vAddress1:string,
      /**  Customer Postal Code  */  
   vZip:string,
}

export interface CheckDupCustomer_output{
   returnObj:Erp_Tablesets_CustomerListTableset[],
}

   /** Required : 
      @param vCustNum
      @param vCustType
      @param vName
      @param vAddress1
      @param vAddress2
      @param vAddress3
      @param vCity
      @param vState
      @param vBTName
      @param vBTAddress1
      @param vBTAddress2
      @param vBTAddress3
      @param vBTCity
      @param vBTState
   */  
export interface CheckEFFieldLength_input{
      /**  Customer.CustNum  */  
   vCustNum:number,
      /**  Customer.CustType  */  
   vCustType:string,
      /**  Customer.Name  */  
   vName:string,
      /**  Customer.Address1  */  
   vAddress1:string,
      /**  Customer.Address2  */  
   vAddress2:string,
      /**  Customer.Address3  */  
   vAddress3:string,
      /**  Customer.City  */  
   vCity:string,
      /**  Customer.State  */  
   vState:string,
      /**  Customer.BTName  */  
   vBTName:string,
      /**  Customer.BTAddress1  */  
   vBTAddress1:string,
      /**  Customer.BTAddress2  */  
   vBTAddress2:string,
      /**  Customer.BTAddress3  */  
   vBTAddress3:string,
      /**  Customer.BTCity  */  
   vBTCity:string,
      /**  Customer.BTState  */  
   vBTState:string,
}

export interface CheckEFFieldLength_output{
parameters : {
      /**  output parameters  */  
   vMessage:string,
}
}

   /** Required : 
      @param ds
   */  
export interface CheckRUC_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface CheckRUC_output{
parameters : {
      /**  output parameters  */  
   opMessage:string,
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param tableName
      @param ds
   */  
export interface CheckVATFormat_input{
      /**  Indicates which table is being updated, Customer or ShipTo  */  
   tableName:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface CheckVATFormat_output{
      /**  true if format is valid  */  
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   opMessage:string,
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChgBTCountry_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChgBTCountry_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipProposedCentralCollection
      @param ds
   */  
export interface ChgCentralCollection_input{
      /**  Central Collection value  */  
   ipProposedCentralCollection:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChgCentralCollection_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param tableName
   */  
export interface ChgCountry_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  Indicates which table is being updated, Customer or ShipTo  */  
   tableName:string,
}

export interface ChgCountry_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ProposedGlobalCust
      @param ds
   */  
export interface ChgGlobalCust_input{
      /**  The proposed global customer value  */  
   ProposedGlobalCust:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChgGlobalCust_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ProposedICTrader
      @param ds
   */  
export interface ChgICTrader_input{
      /**  The proposed IC Trader value  */  
   ProposedICTrader:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ChgICTrader_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param sysRowID
   */  
export interface CustSettlementDayDelete_input{
   sysRowID:string,
}

export interface CustSettlementDayDelete_output{
}

   /** Required : 
      @param ds
   */  
export interface CustSettlementDayUpdate_input{
   ds:Erp_Tablesets_CustSettlementDayTableset[],
}

export interface CustSettlementDayUpdate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustSettlementDayTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface DeleteBTAddress_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  Customer.CustNum  */  
   custNum:number,
}

export interface DeleteBTAddress_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param custNum
   */  
export interface DeleteByID_input{
   custNum:number,
}

export interface DeleteByID_output{
}

   /** Required : 
      @param ds
      @param ds1
      @param CustNum
   */  
export interface ETCAfterAddrVal_input{
   ds:Erp_Tablesets_CustomerTableset[],
   ds1:Erp_Tablesets_ETCAddrValidationTableset[],
      /**  Customer.CustNum  */  
   CustNum:number,
}

export interface ETCAfterAddrVal_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param CustNum
   */  
export interface ETCValidateAddress_input{
      /**  Customer.CustNum  */  
   CustNum:number,
}

export interface ETCValidateAddress_output{
   returnObj:Erp_Tablesets_ETCAddrValidationTableset[],
parameters : {
      /**  output parameters  */  
   StatusFlag:boolean,
   ErrorFlag:boolean,
   ErrorMsg:string,
}
}

export interface Erp_Tablesets_BillToRefsRow{
      /**  Company.  */  
   Company:string,
      /**  Unique key of the parent customer record for this BillToRef.  */  
   CustNum:number,
      /**  Referenced customer number.  */  
   RefCustNum:number,
      /**  Referenced CustID.  */  
   RefCustID:string,
      /**  Referenced Customer name  */  
   RefCustomerName:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_BillToRefsTableset{
   BillToRefs:Erp_Tablesets_BillToRefsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_CustBankRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   CustNum:number,
      /**  Customer Bank ID  */  
   BankID:string,
      /**  Customer Bank Name  */  
   BankName:string,
      /**  Bank Account Number for the Customer.  */  
   BankAcctNumber:string,
      /**  Swift Number or ABA Routing Number  */  
   BankIdentifier:string,
      /**  Indicates primary bank for Customer.  */  
   PrimaryBank:boolean,
      /**  Name on the Bank Account  */  
   NameOnAccount:string,
      /**  Customer address, line 1  */  
   Address1:string,
      /**  Customer address, line 2  */  
   Address2:string,
      /**  Customer address, line 3  */  
   Address3:string,
      /**  Customer city  */  
   City:string,
      /**  Bank state or province  */  
   State:string,
      /**  Customer postal code (zip code)  */  
   PostalCode:string,
      /**  Customer country code.  */  
   Country:number,
      /**  Customer Bank Branch Code  */  
   BankBranchCode:string,
      /**  IBAN Code  */  
   IBANCode:string,
      /**  Unique identifier of the payment method  */  
   PMUID:number,
      /**  Customer Legal Name  */  
   LegalName:string,
      /**  Agreement Reference  */  
   AgreeRef:string,
      /**  Correspondence Account  */  
   CorrespAccount:string,
      /**  A date field, indicating when the agreement to withdraw money from the customer expires.  */  
   AgreeExpDate:string,
      /**  Local BIC  */  
   LocalBIC:string,
      /**  Free Form Bank Person Code. Used in localizations.  */  
   BankPersonCode:string,
      /**  AllowAsAltRemitToBank  */  
   AllowAsAltRemitToBank:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  TransPersonName  */  
   TransPersonName:string,
      /**  TransPersonName2  */  
   TransPersonName2:string,
      /**  TransPersonName3  */  
   TransPersonName3:string,
      /**  TransPersonName4  */  
   TransPersonName4:string,
      /**  TransPersonName5  */  
   TransPersonName5:string,
      /**  MX Tax ID  */  
   MXRFC:string,
      /**  Mexico SAT Code  */  
   MXSATCode:string,
      /**  A customer alias used to make and receive payments.  */  
   PayID:string,
      /**  Free Form Bank Region Type (Local or Foreign) . Used in localizations.  */  
   BankRegionType:string,
   CountryName:string,
   BitFlag:number,
   BankBranchCodeDescBankBranchCode:string,
   BankBranchCodeDescDescription:string,
   CustNumCustID:string,
   CustNumBTName:string,
   CustNumName:string,
   PayMethodSummarizePerCustomer:boolean,
   PayMethodType:number,
   PayMethodName:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustBillToRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   CustNum:number,
      /**  Indicates the CustNum of the alternate Bill To Customer.  */  
   BTCustNum:number,
      /**  Indicates whether this Alt Bill To is the default record or not.  */  
   DefaultBillTo:boolean,
      /**  If checked, the invoice print routine will use the address from this alternate customer as the invoice address.  */  
   InvoiceAddress:boolean,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Tax Payer Registration Reason Code  */  
   TaxRegReason:string,
      /**  Organization Registration Code  */  
   OrgRegCode:string,
      /**  Our Bank Code  */  
   OurBankCode:string,
      /**  Full Legal name  */  
   BTLegalName:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  If this value is true, the Customer that is designated as the Alternate Bill To has not been sent to FSA.  */  
   FSACustomerNotSent:boolean,
      /**  BTAddress one from the Cusomer table for this AltBTCustNum.  */  
   BTAddress1:string,
      /**  BTAddress two from the Customer table for this AltBTCustNum.  */  
   BTAddress2:string,
      /**  BTAddress three from the Customer table for this AltBTCustNum.  */  
   BTAddress3:string,
      /**  The BTAddrList from the Customer table for this AltBTCustNum.  */  
   BTAddrList:string,
      /**  The BTcity from the Customer table for this AltBTCustNum.  */  
   BTCity:string,
      /**  Primary billing contact.  */  
   BTConPrc:number,
      /**  Contact name.  */  
   BTContactName:string,
      /**  The BTCountry from the Customer table for this AltBTCustNum.  */  
   BTCountry:string,
      /**  Bill to credit hold flag.  */  
   BTCreditHold:boolean,
      /**  The BT Customer ID from the Customer table for this AltBTCustNum.  */  
   BTCustID:string,
      /**  The BT Customer Name from the Customer table for this AltBTCustNum.  */  
   BTCustomerName:string,
      /**  The BTFaxNum from the Customer table for this AltBTCustNum.  */  
   BTFaxNum:string,
      /**  The BTPhoneNum from the Customer table for this AltBTCustNum.  */  
   BTPhoneNum:string,
      /**  The BTState from the Customer Table for this AltBTCustNum.  */  
   BTState:string,
      /**  The BTZip from the Customer table for this AltBTCustNum.  */  
   BTZip:string,
      /**  Customer ID from the Customer table for this AltBTCustNum.  */  
   CustID:string,
      /**  The Customer Name from the Customer table for this AltBTCustNum.  */  
   CustomerName:string,
      /**  Indicates if CustBillTo is Global (Master or Linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany, GlbCustNum and GlbBTCustNum that is linking to this CustBillTo  */  
   GlbLink:string,
      /**  The full formatted address from the Customer table for this AltBTCustNum.  */  
   BTAddress:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustChildRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   CustID:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  The full name of the customer.  */  
   Name:string,
      /**  Parent Customer Name  */  
   ParentName:string,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   ParentCustNum:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustDfltDocTypeRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   CustNum:number,
      /**  The invoice type the default document type is for..  */  
   InvoiceType:string,
      /**  The id of the default transaction type.  */  
   TranDocTypeID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  set 'ARInvoice' or 'Credit Memo' depends on the Invoice Type to filter combo TranDocType  */  
   InvcTypeTranDoc:string,
   BitFlag:number,
   TranDocTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustICRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the industry class is related to.  */  
   CustNum:number,
      /**  Foreign key to the Ship To table. Empty if the Industry Class is not related to a ShipTo.  */  
   ShipToNum:string,
      /**  Foreign key to the ICType table. A short name, acronym or identifier for the Industry Class Type.  */  
   ICTypeID:string,
      /**  Foreign key to the ICCode table. Represents the SIC/ISIC/NAICS/NACE code for the current industry class.  */  
   ICCode:string,
      /**  Indicates if the current class code is the primary for the type.  */  
   Primary:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   CustomerBTName:string,
   CustomerName:string,
   CustomerCustID:string,
   ICCodeDescription:string,
   ICTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustLabExpRateRow{
      /**  Company  */  
   Company:string,
      /**  CustNum  */  
   CustNum:number,
      /**  ExpenseCode  */  
   ExpenseCode:string,
      /**  RateType  */  
   RateType:number,
      /**  RateMultiplier  */  
   RateMultiplier:number,
      /**  FixedRate  */  
   FixedRate:number,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
   BitFlag:number,
   CustomerName:string,
   CustomerBTName:string,
   CustomerCustID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustMFBillRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   PayBTFlag:string,
      /**   Describes the billing type.  Valid values and their description are:
1 - Shipper
2 - FedEx  Collect
3 - Third Party
4 - UPS Prepaid
5 - FedEx Recipient
6 - UPS Consignee
7 - UPS Freight Collect
8 - UPS Free On Board
9 - UPS Cost and Freight
10 - UPS Delivery Duty Paid
11 - UPS Shpping Duty and Tax Consignee  */  
   PayTypeDesc:string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   PayAccount:string,
      /**  Shipping Billing Address  */  
   PayBTAddress1:string,
      /**  Shipping biling address line 2  */  
   PayBTAddress2:string,
      /**  Shipping biling address line 3.  */  
   PayBTAddress3:string,
      /**  Shipping billing city  */  
   PayBTCity:string,
      /**  Shipping Billing state or province  */  
   PayBTState:string,
      /**  Manifest Billing Postal Code.  */  
   PayBTZip:string,
      /**  Shipping biling country  */  
   PayBTCountry:string,
      /**  Internal field used to store the country number.  */  
   PayBTCountryNum:number,
      /**  Shipping billing phone number  */  
   PayBTPhone:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustMandateRow{
      /**  Company  */  
   Company:string,
      /**  MandateType  */  
   MandateType:string,
      /**  MandateReference  */  
   MandateReference:string,
      /**  CustNum  */  
   CustNum:number,
      /**  BankAcctID  */  
   BankAcctID:string,
      /**  CreditorID  */  
   CreditorID:string,
      /**  ValidFrom  */  
   ValidFrom:string,
      /**  ValidTo  */  
   ValidTo:string,
      /**  CreditorName  */  
   CreditorName:string,
      /**  CreditorAddress1  */  
   CreditorAddress1:string,
      /**  CreditorAddress2  */  
   CreditorAddress2:string,
      /**  CreditorAddress3  */  
   CreditorAddress3:string,
      /**  CreditorCity  */  
   CreditorCity:string,
      /**  CreditorZip  */  
   CreditorZip:string,
      /**  CreditorCountryNum  */  
   CreditorCountryNum:number,
      /**  CreditorRefPartyName  */  
   CreditorRefPartyName:string,
      /**  CreditorRefPartyID  */  
   CreditorRefPartyID:string,
      /**  DebtorName  */  
   DebtorName:string,
      /**  DebtorAddress1  */  
   DebtorAddress1:string,
      /**  DebtorAddress2  */  
   DebtorAddress2:string,
      /**  DebtorAddress3  */  
   DebtorAddress3:string,
      /**  DebtorCity  */  
   DebtorCity:string,
      /**  DebtorZip  */  
   DebtorZip:string,
      /**  DebtorCountryNum  */  
   DebtorCountryNum:number,
      /**  DebtorRefPartyName  */  
   DebtorRefPartyName:string,
      /**  DebtorRefPartyID  */  
   DebtorRefPartyID:string,
      /**  SignedPlace  */  
   SignedPlace:string,
      /**  SignedBy  */  
   SignedBy:string,
      /**  SignedDate  */  
   SignedDate:string,
      /**  UndContractID  */  
   UndContractID:string,
      /**  CreatedBy  */  
   CreatedBy:string,
      /**  CreatedDate  */  
   CreatedDate:string,
      /**  PrintedBy  */  
   PrintedBy:string,
      /**  PrintedDate  */  
   PrintedDate:string,
      /**  FirstUseDate  */  
   FirstUseDate:string,
      /**  LastUseDate  */  
   LastUseDate:string,
      /**  PaymentType  */  
   PaymentType:string,
      /**  Comment  */  
   Comment:string,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
      /**  MandateStatus  */  
   MandateStatus:string,
   BankAcctDescription:string,
   BankAcctBankName:string,
   BankAcctLegalName:string,
   BankAcctIBANCode:string,
   BankAcctBankIdentifier:string,
   CustBankIBANCode:string,
   CustBankBankIdentifier:string,
      /**  Mandate can be deleted if CustMandate.FirstUseDate = Null or it has not been used for 14 months prior to current date (date of CustMandate.LastUseDate + 14 months < Current Date.  */  
   MandateCanBeDeleted:boolean,
   MandateReferenceExt:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustRestrictionRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  Restriction Type identification.  */  
   RestrictionTypeID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   CustNumCustID:string,
   CustNumBTName:string,
   CustNumName:string,
   RestrictionTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustSettlementDayTableset{
   CustomerSettlementDay:Erp_Tablesets_CustomerSettlementDayRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_CustUPSEmailRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  UPS Quantum View Sequence  */  
   UPSQVSeq:number,
      /**  Email address to notify for a UPS shipment  */  
   EmailAddress:string,
      /**  Logical indicating if the EmailAddress is to be updated at shipping.  */  
   ShipmentNotify:boolean,
      /**  Logical indicating if the Email Address is to be notified of a failed shipment.  */  
   FailureNotify:boolean,
      /**  Logical indicating if the Email Address is to be notified of delivery.  */  
   DeliveryNotify:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Logical indicating whether or not the UPS Quantum View fields are to be enabled.  */  
   EnableQuantumView:boolean,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomCrdPoolRow{
      /**  Company  */  
   Company:string,
   CustNum:number,
   CrdPoolCode:string,
   CreditUsed:number,
   CreditAvailable:number,
      /**  Global Pool - shows if the pool belongs to Global National Account  */  
   GlobalNA:boolean,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerAttchRow{
   Company:string,
   CustNum:number,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerDiscPriceLstRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   CustNum:number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   ShipToNum:string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   SeqNum:number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   ListCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PriceListListDescription:string,
   PriceListEndDate:string,
   PriceListStartDate:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerDocsRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   CustNum:number,
      /**  The ShipTo.ShipToNum of the Ship To that the customer  */  
   ShipToNum:string,
      /**  The document name the parameters are for.  For example, incoming and outgoing data is via EDI, the value in this field would be the various document types/names found in EDI such as 830, 850, 862, etc.  */  
   DocumentName:string,
      /**   The type of document.  Values are:
InForecast - Forecast
InUnfirm - Unfirm Releases
InShSched - Incoming Shipping Schedule
ASN - Advance Shipping Notice
Inv - Invoice
SOAck - Sales Order Acknowledgement
ChgResp - Response to a Sales Order change
Status - Order Status  */  
   DocumentType:string,
      /**  An alternate trading partner name for this document.  */  
   AltTradingPartnerName:string,
      /**  Determines whether or not this record is in test mode (true) or production mode (false).  */  
   TestRecord:boolean,
      /**  Use customer master defaults for inbound orders.  This would be information such as discount, sales reps, etc.  */  
   UseCustomerDefaults:boolean,
      /**  On incoming DemandDetail records, indicates if the Part master should be checked for the existance of the part.  If true, a warning will be written to the DemandLog table if the part does not exist.  */  
   CheckForPart:boolean,
      /**  Indicates of only customer parts are to be used when creating orders.  */  
   UseCustPart:boolean,
      /**  Identifies whether or not an outbound XML document is created during the Accept Inbound Demand process.  */  
   OutBoundDocReq:boolean,
      /**  Specific Map ID for the customer or ship to.  Non-editable, updated by custom programming.  */  
   MapID:string,
      /**   The type of action to take for incoming demands.  Values are:
ALW - Always accept the demand automatically
ANE - Accpet the demand automatically if no errors
ASD - Always stop at demand.  User will accept demands manually.  */  
   AcceptType:string,
      /**   Indicates if this document an inbound document or outbound document.  Values are:
I - Inbound
O - Outbound  */  
   DocDirection:string,
      /**  The outbound document name.  Used when OutBoundDocReq is true.  Not required.  */  
   OutboundDocName:string,
      /**  Indicates if Order Releases that have not been shipped and do not have a job will be deleted when receiving this document type.  */  
   DeleteCurrentReleases:boolean,
      /**  Use the UPC in the Part table  */  
   UsePartUPC:boolean,
      /**  Indicates if the OutboundDocName document is manual.  */  
   OutboundManual:boolean,
      /**  Indicates if the OutboundDocName document is automatic.  */  
   OutboundAutomatic:boolean,
      /**  A list of the order in which a part should be validated when an inbound file is sent through EDI.  */  
   EDIPartValidation:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  PartOptionAvailList  */  
   PartOptionAvailList:string,
      /**  PartOptionSelList  */  
   PartOptionSelList:string,
      /**  A LIST-DELIM delimited list of part options  */  
   PartOptionSelectedList:string,
   BitFlag:number,
   CustomerBTName:string,
   CustomerName:string,
   CustomerCustID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerDocsSHRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   CustNum:number,
      /**  The ShipTo.ShipToNum of the Ship To that the customer  */  
   ShipToNum:string,
      /**  The document name the parameters are for.  For example, incoming and outgoing data is via EDI, the value in this field would be the various document types/names found in EDI such as 830, 850, 862, etc.  */  
   DocumentName:string,
      /**   The type of document.  Values are:
InForecast - Forecast
InUnfirm - Unfirm Releases
InShSched - Incoming Shipping Schedule
ASN - Advance Shipping Notice
Inv - Invoice
SOAck - Sales Order Acknowledgement
ChgResp - Response to a Sales Order change
Status - Order Status  */  
   DocumentType:string,
      /**  An alternate trading partner name for this document.  */  
   AltTradingPartnerName:string,
      /**  Determines whether or not this record is in test mode (true) or production mode (false).  */  
   TestRecord:boolean,
      /**  Use customer master defaults for inbound orders.  This would be information such as discount, sales reps, etc.  */  
   UseCustomerDefaults:boolean,
      /**  On incoming DemandDetail records, indicates if the Part master should be checked for the existance of the part.  If true, a warning will be written to the DemandLog table if the part does not exist.  */  
   CheckForPart:boolean,
      /**  Indicates of only customer parts are to be used when creating orders.  */  
   UseCustPart:boolean,
      /**  Identifies whether or not an outbound XML document is created during the Accept Inbound Demand process.  */  
   OutBoundDocReq:boolean,
      /**  Specific Map ID for the customer or ship to.  Non-editable, updated by custom programming.  */  
   MapID:string,
      /**   The type of action to take for incoming demands.  Values are:
ALW - Always accept the demand automatically
ANE - Accpet the demand automatically if no errors
ASD - Always stop at demand.  User will accept demands manually.  */  
   AcceptType:string,
      /**   Indicates if this document an inbound document or outbound document.  Values are:
I - Inbound
O - Outbound  */  
   DocDirection:string,
      /**  The outbound document name.  Used when OutBoundDocReq is true.  Not required.  */  
   OutboundDocName:string,
      /**  Indicates if Order Releases that have not been shipped and do not have a job will be deleted when receiving this document type.  */  
   DeleteCurrentReleases:boolean,
      /**  Use the UPC in the Part table  */  
   UsePartUPC:boolean,
      /**  Indicates if the OutboundDocName document is manual.  */  
   OutboundManual:boolean,
      /**  Indicates if the OutboundDocName document is automatic.  */  
   OutboundAutomatic:boolean,
      /**  A list of the order in which a part should be validated when an inbound file is sent through EDI.  */  
   EDIPartValidation:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  PartOptionAvailList  */  
   PartOptionAvailList:string,
      /**  PartOptionSelList  */  
   PartOptionSelList:string,
      /**  A LIST-DELIM delimited list of part options  */  
   PartOptionSelectedList:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerFSPriceListRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   CustNum:number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   ShipToNum:string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to. The lower the number the higher the priority is in the hierarchy.  */  
   SeqNum:number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   ListCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PriceListListDescription:string,
   PriceListEndDate:string,
   PriceListStartDate:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerListRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   CustID:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  The full name of the customer.  */  
   Name:string,
      /**  The city portion of the customer's main address.  */  
   City:string,
      /**  The state or province portion of the customer's main address.  */  
   State:string,
      /**  The zip or postal code portion of the customer's main address.  */  
   Zip:string,
      /**  The country of the main customer address.  */  
   Country:string,
      /**  Optional field used to record the customer's State Tax Identification number, which is displayed on Sales Acknowledgments.  */  
   ResaleID:string,
      /**  The SalesTer.TerritoryID value of the territory assigned to the customer.  */  
   TerritoryID:string,
      /**  Contains the key of the default ship to for the customer. A blank value indicates that the name and address in the Customer file is considered the default ship to. This field is updated when the user marks the check box in ship to maintenance indicating that the ship to is to be designated as the default. This default will be used in areas such as Sales Order entry.  */  
   ShipToNum:string,
      /**   The Terms.TermsCode value of the default sales terms associated with the customer. A default may be supplied by XaSyst.TermsCode if not blank. The terms will default into quotes and orders for this customer.
For invoices not related to a sales order, these terms will also default into the invoice.  */  
   TermsCode:string,
   TerritoryTerritoryDesc:string,
   CustGrupGroupDesc:string,
      /**  Indicates if customer has been placed into a "Credit Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   CreditHold:boolean,
      /**  Contains the CustGrup.GroupCode value of the customer group that the customer has been assigned to. This field is used by the application for sorting or filtering on reports and can also be associated with price lists.  */  
   GroupCode:string,
      /**  The general Business Phone Number for the customer. Displayed in Order entry when no contact is given or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Contains the Country.CountryNum value of the country the customer is located in.  */  
   CountryNum:number,
      /**  Used to define the type of the customer record.  */  
   CustomerType:string,
      /**  Indicates whether or not this customer will be included in marketing lists.  */  
   NoContact:boolean,
      /**  When yes, a ShipTo CustID on certain forms will be enabled. This allows a shipto of a different customer to be referenced as a 3rd party for a document.  */  
   AllowShipTo3:boolean,
      /**   Determines print options for any customer parts related to this customer.

M = Main Part Reference (Default)
S = Secondary Part Reference
O = Only Part Reference Printed
N = Customer Part Not Printed  */  
   CustPartOpts:string,
      /**  If yes, indicates that Customer has at least one associated CustBank record.  */  
   HasBank:boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerListTableset{
   CustomerList:Erp_Tablesets_CustomerListRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_CustomerPriceLstRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   CustNum:number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   ShipToNum:string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   SeqNum:number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   ListCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PriceListListDescription:string,
   PriceListEndDate:string,
   PriceListStartDate:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   CustID:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  The full name of the customer.  */  
   Name:string,
      /**  The first line of the customer's main address.  */  
   Address1:string,
      /**  The second line of the customer's main address.  */  
   Address2:string,
      /**  The third line of the customer's main address.  */  
   Address3:string,
      /**  The city portion of the customer's main address.  */  
   City:string,
      /**  The state or province portion of the customer's main address.  */  
   State:string,
      /**  The zip or postal code portion of the customer's main address.  */  
   Zip:string,
      /**  The country of the main customer address.  */  
   Country:string,
      /**  Optional field used to record the customer's State Tax Identification number, which is displayed on Sales Acknowledgments.  */  
   ResaleID:string,
      /**  The SalesRep.SalesRepCode of the default salesperson for the customer. This field is used to supply defaults to Order Entry and Invoice entry for invoices that do not reference a sales orders.  */  
   SalesRepCode:string,
      /**  The SalesTer.TerritoryID value of the territory assigned to the customer.  */  
   TerritoryID:string,
      /**  Contains the key of the default ship to for the customer. A blank value indicates that the name and address in the Customer file is considered the default ship to. This field is updated when the user marks the check box in ship to maintenance indicating that the ship to is to be designated as the default. This default will be used in areas such as Sales Order entry.  */  
   ShipToNum:string,
      /**   The Terms.TermsCode value of the default sales terms associated with the customer. A default may be supplied by XaSyst.TermsCode if not blank. The terms will default into quotes and orders for this customer.
For invoices not related to a sales order, these terms will also default into the invoice.  */  
   TermsCode:string,
      /**  Contains the ShipVia.ShipViaCode value of the default ShipVia for the customer.  */  
   ShipViaCode:string,
      /**  Controls whether or not this customer's statement will print when   printing of customer statements.  */  
   PrintStatements:boolean,
      /**  Only customers that are PrintLabels = Yes will be selected for printing of mailing labels.  */  
   PrintLabels:boolean,
      /**   Allows the user to establish whether or not a specific customer requires Sales Order Acknowledgements.  This does not force or limit the printing of sales acknowledgments directly from within Order Entry.  Order entry displays this setting to the user so that they know if they should print the acknowledgment.
For batch mode printing, (where ranges of sales orders are selected...future release) this setting will be used to exclude orders from printing.  */  
   PrintAck:boolean,
      /**  Controls whether or not the customer will be included in the finance charge calculation process.  */  
   FinCharges:boolean,
      /**  Indicates if customer has been placed into a "Credit Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   CreditHold:boolean,
      /**  Contains the CustGrup.GroupCode value of the customer group that the customer has been assigned to. This field is used by the application for sorting or filtering on reports and can also be associated with price lists.  */  
   GroupCode:string,
      /**  An optional field used to establish a default purchasing discount percentage for any order placed by customer. This value is supplied to order entry as a default for line item discount percent.  */  
   DiscountPercent:number,
      /**  Contains the CustCnt.ConNum value of the Primary Purchasing contact for the customer. This field is not directly maintainable. Instead it is set during contact maintenance by having the user mark a check box indicating primary Purchaser.  This is the contact that is used as a default in Order Entry and Quoting.  */  
   PrimPCon:number,
      /**  The same as the PrimPCon except that this is the Primary Billing Contact and this is used as a default in invoice entry.  */  
   PrimBCon:number,
      /**  Same as PrimPCon except that this the Primary Shipping Contact and is used as a default in Packing Slip entry.  */  
   PrimSCon:number,
      /**   Comments are intended to be internal comments about a specific customer. These do get pulled into other programs. They are mainly intended as an online storage facility.
To be view-as EDITOR widget.  */  
   Comment:string,
      /**  The date when the customer was established as a customer. Use the system date as a default when creating new customers.  */  
   EstDate:string,
      /**  The Fax Number for the customer. Optional field. Field is displayed in Order entry when no contact is specifically given or the contact has a blank fax number.  */  
   FaxNum:string,
      /**  The general Business Phone Number for the customer. Displayed in Order entry when no contact is given or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Indicates the reason why the customer is normally exempt from sales tax. Used as a default in invoice entry.  If field is non-blank it is considered exempt.  */  
   TaxExempt:string,
      /**  The QMarkup.MarkupID value of the quote markup table which will be used to provide default markup percents in quote entry for this customer. If left blank the quote module will use the default quote markup table for the customer. (See EQSyst.MarkupID).  */  
   MarkUpID:string,
      /**   Represents the day of the week or month that this customer is invoiced on. The possible choices are determined by the Customer.Bill-Frequency field value.

When the Bill-Frequency is "W" (Weeky):
The valid values are 0-7 where 0=All Days,1=Sun,2=Mon,...,7=Sat.  

ll-frequency is 'M' (Monthly) this field contains the 1st -> 31st as possible choices to represent the day of the month to bill on.  */  
   BillDay:number,
      /**  Determines whether or not packing slips for the same Sales Order and Fiscal Period will combined into a single invoice or not. If the packing slips are for different sales orders for the customer or fall in different fiscal periods, seperate invoices will be created even when this field is set to Yes.  */  
   OneInvPerPS:boolean,
      /**  Contains the default FOB.FOB value of the FOB policy for this  customers orders.  Default used in sales order entry for this customer.  */  
   DefaultFOB:string,
      /**  Determines whether or not Open Sales Orders are to be included in the credit limit checking process for the customer. This checkbox will also include open service contracts.  */  
   CreditIncludeOrders:boolean,
      /**  Date on which the next credit review should be conducted for the customer.  */  
   CreditReviewDate:string,
      /**  Date on which the customer was last placed on credit hold. This field is maintained by the system.  */  
   CreditHoldDate:string,
      /**  Indicates how the customer was placed on credit hold.  Valid values are "MANUAL", "INVOICES", "ORDERS", and "CONTRACTS".  "MANUAL" means that the user placed the customer on hold.  INVOICES means that the customer's open A/R balance exceeded the credit limit.  ORDERS means that the sum of the open A/R and the open orders exceeded the credit limit. This field is maintained by the system.  */  
   CreditHoldSource:string,
      /**  The UserFile.DCDUSERID value of the user that last cleared the customer's credit hold. This field is maintained by the system.  */  
   CreditClearUserID:string,
      /**  The date that the user last cleared the customer's credit hold. This field is maintained by the system.  */  
   CreditClearDate:string,
      /**  The time that the user last cleared the customer's credit hold in HH:MM:SS format. This field is maintained by the system.  */  
   CreditClearTime:string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  Contains the Currency.CurrencyCode value of the customer's base currency.  */  
   CurrencyCode:string,
      /**  Contains the Country.CountryNum value of the country the customer is located in.  */  
   CountryNum:number,
      /**  Contains the LangName.LangNameID value of the customer's language. This controls which language will be selected when extracting part descriptions from PartLangDesc table and report labels for customer related forms such as orders, packing slips and invoices.  */  
   LangNameID:string,
      /**  Area/City code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Country table.  This field is only visible if ISSyst.EnableHarbour is set to yes.  */  
   BorderCrossing:string,
      /**  Optional custom address format used to format the customer's main address.  */  
   FormatStr:string,
      /**  The Bill To name of this customer. Will be used by the AR module for Invoices. This defaults to the Customer.Name but can be overrode by the user.  */  
   BTName:string,
      /**  The first line of the customer's Bill To address.  */  
   BTAddress1:string,
      /**  The second line of the customer's Bill To address.  */  
   BTAddress2:string,
      /**  The second line of the customer's Bill To address.  */  
   BTAddress3:string,
      /**  The city portion of the customer's Bill To address.  */  
   BTCity:string,
      /**  The state or province portion of the customer's Bill To address.  */  
   BTState:string,
      /**  The zip or postal code portion of the customer's Bill To address.  */  
   BTZip:string,
      /**  The Country.Countrynum value of the Country portion of the customer's Bill To address.  */  
   BTCountryNum:number,
      /**  Contains the Country.Description value of the Country portion of the customer's Bill To address.  */  
   BTCountry:string,
      /**  The phone number related to the customer's Bill To Address.  */  
   BTPhoneNum:string,
      /**  The fax number of the customer's Bill To address.  */  
   BTFaxNum:string,
      /**  Optional custom address format used to format the customer's Bill To address.  */  
   BTFormatStr:string,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   ParentCustNum:number,
      /**  Contains the TaxRgn.TaxRegionCode value of the customer's tax region for purposes of Sales Tax calculations.  */  
   TaxRegionCode:string,
      /**  Determines whether or not this customer is an inter-company customer.  */  
   ICCust:boolean,
      /**  The day of the month that service contracts for the customer marked for recurring invoicing are billed on.  If the invoice group's invoice date is greater than or equal to this date then the invoice will be generated.  */  
   ContBillDay:number,
      /**  Default email address for the customer.  */  
   EMailAddress:string,
      /**  Determines whether or not the customer will accept partial shipments at the line or order level. This functionality is only available with the Advanced Material Management module.  */  
   ShippingQualifier:string,
      /**  Contains the AllocPri.PriorityCode value of the priority that this customer's orders receive. This functionality is only available with the Advanced Material Management module.  */  
   AllocPriorityCode:string,
      /**  Contains the ReservePri.PriorityCode value of the priority that this customer's orders receive. This functionality is only available with the Advanced Material Management module.  */  
   ReservePriorityCode:string,
      /**  Used with Global alerts  */  
   LinkPortNum:number,
      /**  Indicates if this customer will be able to access Customer Connect.  Only Customers with this equal to YES will be synchronized between the Manufacturing System DB and Customer Connect DB.  */  
   WebCustomer:boolean,
      /**  Used to define the type of the customer record.  */  
   CustomerType:string,
      /**  Indicates whether or not this customer will be included in marketing lists.  */  
   NoContact:boolean,
      /**  Determines whether or not the customer's territory can be changed by system processes that could potentially change the territory from its current value.  */  
   TerritoryLock:boolean,
      /**  The Customer's website URL.  */  
   CustURL:string,
      /**  The pending sales territory that the customer will be assigned to based on changes to the territory boundaries.  This functionality is only available with the CRM module.  */  
   PendingTerritoryID:string,
      /**  External Company  ID  */  
   ExtID:string,
      /**  Determines whether or not shipments to this customer for different sales orders within the same fiscal period wil be consolidated into one invoice. (See Customer.OneInvPerPS - for the shipments from the same sales order are handled).  */  
   ConsolidateSO:boolean,
      /**  BillFrequency  */  
   BillFrequency:string,
      /**  Indicates that Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking.  */  
   CreditIncludePI:boolean,
      /**  Determines whether or not this customer is shared between more than one company.  */  
   GlobalCust:boolean,
      /**  Indicates if this customer participates in the Inter-Company Trading.  */  
   ICTrader:boolean,
      /**  Establishes the tax authority for this customer.  */  
   TaxAuthorityCode:string,
      /**  Determines whether or not an external delivery note is required for the customer.  This field is available only when ExtCompany.SendShip is set to Yes.  This will provide the default for the ShipHead record.  */  
   ExternalDeliveryNote:boolean,
      /**  Determines whether or not Open Orders are to be included in the global credit limit checking process. This checkbox will also include open service contracts.  */  
   GlobalCredIncOrd:boolean,
      /**  Indicates whether or not Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking process.  */  
   GlobalCredIncPI:boolean,
      /**  Holds the Currency.CurrencyCode value of that the global customer will exchange data in.  */  
   GlobalCurrencyCode:string,
      /**  Customer ID  */  
   ExternalID:string,
      /**  Determines whether or not the customer has been placed into a "Global Credit Hold" status.  Any non-blank value will trigger notification of this condition in Order Entry and Shipping.  */  
   GlobalCreditHold:string,
      /**  Determines whether or not this customer record will receive global updates.  */  
   GlobalLock:boolean,
      /**  Determines whether or not the system should check existing orders for this customer to insure that the same PO number is not used twice by the customer.  */  
   CheckDuplicatePO:boolean,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit.  A credit limit of zero is considered as having unlimited credit.  */  
   CreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a credit limit for payment instruments such as post dated checks or bank drafts.  A credit limit of zero is considered as having unlimited credit.  */  
   CustPILimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit Limit.  A credit limit of zero is considered as having unlimited credit.  */  
   GlobalCreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a credit limit for payment instruments such as post dated checks or bank drafts.  A credit limit of zero is considered as having unlimited credit.  */  
   GlobalPILimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit limit.  Credit limit of zero is considered as having unlimited credit. Stored in Global Currency.  */  
   DocGlobalCreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit. Stored in Global currency  */  
   DocGlobalPILimit:number,
      /**  Indicates whether RFQ Attachments are allowed for this Customer  */  
   RfqAttachAllow:boolean,
      /**   The discount qualifier is primarily used when applying order value based discounts to the customer's sales orders.  The value of this field affects the discount percent given to the customer.  Here's the rule:
"MIN" = means that the default order discount percent is the minimum discount the customer could get as compared to the order value based discount.
"MAX" = means that the default order discount percent is the maximum discount the customer could get as compared to the order value based discount.
"ADD" = means that the customer could get the order value based discount in addition to the default order discount.  */  
   DiscountQualifier:string,
      /**  Specifies the current customer can be an alternate bill to customer.  */  
   AllowAltBillTo:boolean,
      /**  Days to use in calculating the Order Detail Ship By date from the incoming need by date.  */  
   DemandDeliveryDays:number,
      /**   Indicates incoming date type.  Values are:
S - Shipping Date
N - Need By Date  */  
   DemandDateType:string,
      /**  The number of days from today to give a warning when adding a new order release record from an incoming shipping schedule.  */  
   DemandAddLeadTime:number,
      /**  Indicates what type of action to take if the add lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandAddAction:string,
      /**  The number of days from today to give a warning when changing an order release record from an incoming shipping schedule.  This does not include changes to quantity or dates.  */  
   DemandChangeLeadTime:number,
      /**  Indicates what type of action to take if the change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeAction:string,
      /**  The number of days from today to give a warning when canceling an order release record from an incoming shipping schedule.  */  
   DemandCancelLeadTime:number,
      /**  Indicates what type of action to take if the cancel lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandCancelAction:string,
      /**  The number of days from today to give a warning when adding a new order line record from an incoming shipping schedule.  */  
   DemandNewLineLeadTime:number,
      /**  Indicates what type of action to take if the new line lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandNewLineAction:string,
      /**  The number of days from today to give a warning when changing the quantity on an order release record from an incoming shipping schedule.  */  
   DemandQtyChangeLeadTime:number,
      /**  Indicates what type of action to take if the quantity change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandQtyChangeAction:string,
      /**  The number of days from today to give a warning when changing the date on an order release record from an incoming shipping schedule.  */  
   DemandChangeDateLeadTime:number,
      /**  Indicates what type of action to take if the change date lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeDateAction:string,
      /**  The trading partner name.  */  
   TradingPartnerName:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  Periodicity Code.  Must be a valid code in the Periodicity table.  */  
   PeriodicityCode:number,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Used to calculate on-time delivery performance rating  */  
   EarlyBuffer:number,
      /**  Used to calculate on-time delivery performance rating  */  
   LateBuffer:number,
      /**  Indicates if the unit price between the demand and the contract should be validated.  If this flag is checked, and the prices are different, when the demand is accepted a record will be written to the DemandLog table.  */  
   DemandUnitPriceDiff:boolean,
      /**  Indicates what type of action to take if the unit price between the demand and the contract is different.  Options are B (reject the change) or W (warning - alert that the unit price is different but allow the record to be accepted).  */  
   DemandUnitPriceDiffAction:string,
      /**  A flag that indicates whether this address should be validated by the tax service.  */  
   ExcFromVal:boolean,
      /**  A flag indicating that an address has already been validated. This helps improve the performance of the bulk address validation process by allowing address that have already been validated to be skipped. This flag is set anytime a successful validation is performed, either by the bulk address validation or validation from the Customer form.  */  
   AddressVal:boolean,
      /**  This is the Vendor ID to be used when generating a Rebate for the customer  */  
   RebateVendorNum:number,
      /**  Indicates if the rebate should be a Check or a Credit Memo  */  
   RebateForm:string,
      /**  Indicates if the order should default as a credit card order.  Can be overriden at the order level.  */  
   CreditCardOrder:boolean,
      /**  Check for the part in the Part master.  */  
   DemandCheckForPart:boolean,
      /**  Indicates what type of action to take if the Check for Part options is selected and the part is not in the part master file.  Options are B (reject the change) or W (warning - alert that the part is not in the part master but allow the record to be accepted).  */  
   DemandCheckForPartAction:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Unique Identifier for the Finance Charges  */  
   ChargeCode:string,
      /**  Individual Pack ID'srequired. Used in manifesting.  */  
   IndividualPackIDs:boolean,
      /**  International Shipment flag. Used in manifesting.  */  
   IntrntlShip:boolean,
      /**  Certificates of Origin required flag. Used in manifesting.  */  
   CertOfOrigin:boolean,
      /**  Commercial Invoice required flag. Used in manifesting.  */  
   CommercialInvoice:boolean,
      /**  Ship Export Declaration required flag. Used in manifesting.  */  
   ShipExprtDeclartn:boolean,
      /**  Letter of Instruction required. Used in manifesting.  */  
   LetterOfInstr:boolean,
      /**  Freight Forwarder ID.  */  
   FFID:string,
      /**  Freight Forwarder Company Name  */  
   FFCompName:string,
      /**  Freight Forwarder first address line.  */  
   FFAddress1:string,
      /**  Freight Forwarder second address line.  */  
   FFAddress2:string,
      /**  Freight Forwarder third address line.  */  
   FFAddress3:string,
      /**  Freight Forwarder city portion of address.  */  
   FFCity:string,
      /**  Freight Forwarder state portion of address.  */  
   FFState:string,
      /**  Freight Forwarder postal code or zip code portion of address.  */  
   FFZip:string,
      /**  Freight Forwarder country portion of address.  */  
   FFCountry:string,
      /**  Freight Forwarder country number portion of address.  */  
   FFCountryNum:number,
      /**  Freight Forwarder phone Number.  */  
   FFPhoneNum:string,
      /**  Non Standard Package flag. Used in manifesting.  */  
   NonStdPkg:boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Additional Handling flag. Used in manifesting.  */  
   AddlHdlgFlag:boolean,
      /**  UPS Quantum View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View From Name  */  
   UPSQVShipFromName:string,
      /**  UPS Quantum View Memo  */  
   UPSQVMemo:string,
      /**  Always equal to Customer.  Used to link the customer table to the UPSQVEmail table.  */  
   UPSQVEmailType:string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   FFContact:string,
      /**  Used to determine if an address changed because of the tax integration.  If true, the tax integration changed the address.  */  
   ETCAddrChg:boolean,
      /**  Define the rule how Tax amount from for sales related documents shall be rounded to the general number of decimals from the Currency:  0 - Use rounding rules from Currency; 1 - Round up; 2 - Round down; 3 - Normal rounding.  Used when Company parameter - Customer specific Tax Rounding is set.  */  
   TaxRoundRule:number,
      /**  Tax calculation per line or invoice.  It can be "L" = per line or "I" = per invoice.  Default is "L".  */  
   TaxMethod:string,
      /**  Remit cash receipts in AR. No cash receipts will be accepted from customers without this authorization  */  
   ValidPayer:boolean,
      /**  Sold to customer in the AR Invoice Entry. The user will not be able to enter invoices for customers without this authorization  */  
   ValidSoldTo:boolean,
      /**  Receive shipments for orders entered in OE. Unless the user selects this option, the user must enter a Ship-to address in the Order Entry form.  */  
   ValidShipTo:boolean,
      /**  Children are allowed to pay for their parents  */  
   OverrideRlsClass:boolean,
      /**  Accept payments from any customer within the national account, regardless of parent-child status  */  
   AcrossNatAcc:boolean,
      /**  allow use Parent Credit in National Account  */  
   NAParentCreditIsUsed:boolean,
      /**  allow/deny to a customer share his own credit with other customers within the National account  */  
   NACreditIsShare:boolean,
      /**  define what type of credit will be used first when the customer  */  
   NACreditPreferenceList:string,
      /**  Max Percent of Parent Credit to Use  */  
   NAParentCreditPrc:number,
      /**  Percentage of the customer credit shared to his Children.  */  
   NACreditSharedPrc:number,
      /**  Indicates if One Time Shipto information can be entered for this customer.  OTS, are entered in Quote, Sales Order, RMA, Service Contract and Service Call. In Shipping and Invoicing the OTS infomation is used.  */  
   AllowOTS:boolean,
      /**  Flag indicating that this is a 3PL customer.  */  
   ThirdPLCust:boolean,
      /**  VendID of the associated supplier.  Only populated if ManagedCust flag = true.  Entered through Supplier Entry  */  
   ManagedVendID:string,
      /**  VendNum associated with VendID of associated supplier.  Only populated if ManagedCust flag = true.  */  
   ManagedVendNum:number,
      /**  Code of Overriden Relationship Class  */  
   NARlsClassCode:string,
      /**  Direct Debiting flag for use with Promissory Notes.  */  
   DirectDebiting:boolean,
      /**  Unique Identifier for the Reminder Group.  */  
   ReminderCode:string,
      /**  allow use Global Parent Credit in National Account  */  
   GlbNAParentCreditIsUsed:boolean,
      /**  allow/deny to a customer share his own credit with other customers within the Global National account  */  
   GlbNACreditIsShare:boolean,
      /**  Max Percent of Global Parent Credit to Use  */  
   GlbNAParentCreditPrc:number,
      /**  Percentage of the customer credit shared to his Global Children.  */  
   GlbNACreditSharedPrc:number,
      /**  When yes, a ShipTo CustID on certain forms will be enabled. This allows a shipto of a different customer to be referenced as a 3rd party for a document.  */  
   AllowShipTo3:boolean,
      /**  The default value used on One Time Ship To panels. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   OTSSaveAs:string,
      /**   Determines print options for any customer parts related to this customer.

M = Main Part Reference (Default)
S = Secondary Part Reference
O = Only Part Reference Printed
N = Customer Part Not Printed  */  
   CustPartOpts:string,
      /**  If yes, indicates that Customer has at least one associated CustBank record.  */  
   HasBank:boolean,
      /**  Unique identifier of the payment method  */  
   PMUID:number,
      /**  Check for Revision  */  
   DemandCheckForRev:boolean,
      /**  Hold for Review  */  
   OrderHoldForReview:boolean,
      /**  Check for Revision Action  */  
   DemandCheckForRevAction:string,
      /**  List of all ship to territories for the customer  */  
   ShipToTerrList:string,
      /**  The Banking Reference number to be used on AR Invoice sent to the customer  */  
   AcctRefNumber:string,
      /**  Full Legal name  */  
   LegalName:string,
      /**  Tax Payer Registration Reason Code  */  
   TaxRegReason:string,
      /**  If this flag it?s turned on then one invoice per packing line will be created when invoicing a packing slip at the ?Get Shipments? action on the AR Invoice entry.  */  
   InvPerPackLine:boolean,
      /**  Organization Registration Code  */  
   OrgRegCode:string,
      /**  Define if at the moment of processing a demand the process should also close those rejected schedules that remain at demand entry  */  
   DemandCloseRejSkd:boolean,
      /**  Our Bank Code  */  
   OurBankCode:string,
      /**  Flag that indicates if the Demand non matched will be closed.  */  
   DemandCloseNoMatch:boolean,
      /**  Flag to Check Partial Shipments  */  
   DmdCheckPartialShip:boolean,
      /**  Flag to Check Partial Shipments Action B = Stop W = Warning  */  
   DmdCheckShipAction:string,
      /**  Flag to check for cummulative info.  */  
   DemandCheckCUMM:boolean,
      /**  Flag to Check what action should the system take the options are B = Stop and  W Warning  */  
   DemandCheckCUMMAction:string,
      /**  Defines if Internal Pricing or Customer Pricing will be used for checking price differences  */  
   DemandPricing:string,
      /**  Defines the tolerance for price difference validations  */  
   PriceTolerance:number,
      /**  Preferred bank for cash receipts from sale to customer.  */  
   PreferredBank:string,
      /**  If this flags is turned on then Demand CTP will automatically be executed as a part of the demand to order process.  */  
   CheckDateCapPromise:boolean,
      /**  Confirm or not the Capable to Promise jobs from Demand Entry  */  
   CheckConfirmCapPromise:boolean,
      /**  If checked, Updates the date in Demand Entry  */  
   CheckUpdateCapPromise:boolean,
      /**  This field will define the dates that will be validated as a part of the demand to order process. The valid values for this combo will be:  Need By (N), Ship By (S) and Both (B)  */  
   DemandCapPromiseDate:string,
      /**  The value on this field will define the action to be taken when validating CTP. The valid values for this combo box will be: Warning (W) and Stop (S)  */  
   DemandCapPromiseAction:string,
      /**   This field will define the dates that will be updated as a part of the demand to order process. The valid options will be:
Need By (N), Ship By (S) and Both  (B) NOTE .-In all the cases above the update of date will only be done if the CTP dates are beyond the dates on the file.  */  
   DemandCapPromiseUpdate:string,
      /**  Status of the Periodic Billing  */  
   PeriodicBilling:boolean,
      /**  Criteria used for the calculation of the due date. Only enable if Periodic Billing status is active.  */  
   DueDateCriteria:string,
      /**  Periodic Billing Terms. A period between the billing or summarizing date and the due date (for example: 30 days, 45 days, 60 days).  */  
   PBTerms:number,
      /**  Evaluated Receipt Settlement Order. This flag will be used as a default when the user creates a Demand Entry PO or a Sales Order  */  
   ERSOrder:boolean,
      /**  This checkbox indicates if the Demand schedule could be splited when there are not enough stock for a part, from the CTP.  */  
   DemandSplitSched:boolean,
      /**  When set to TRUE the smart string functionality will only be processed when the incoming demand is new. After it has been processed and saved, if a retransmission is sent the smart string values will be ignored.  */  
   OTSmartString:boolean,
      /**  Indicates if revenue is deferred for contracts assigned to this group.  */  
   DeferredRev:boolean,
      /**  Revenue Amortization Code.  */  
   RACode:string,
      /**  If true then demand will be rejected when one or more demand lines are not configured properly. Applies only to Configurable parts.  */  
   DemandCheckConfig:boolean,
      /**  Indicates the action to be taken if configuration values have not been entered for one or more demand lines.  */  
   DemandCheckCfgAction:string,
      /**  AllowAsAltRemitTo  */  
   AllowAsAltRemitTo:boolean,
      /**  FederalID  */  
   FederalID:string,
      /**  WIApplication  */  
   WIApplication:string,
      /**  WICustomer  */  
   WICustomer:string,
      /**  WIShippingCosts  */  
   WIShippingCosts:boolean,
      /**  LOQBookPCFinishing  */  
   LOQBookPCFinishing:boolean,
      /**  LOQBookPCPaper  */  
   LOQBookPCPaper:boolean,
      /**  LOQBookPCPress  */  
   LOQBookPCPress:boolean,
      /**  LOQBookPCPlates  */  
   LOQBookPCPlates:boolean,
      /**  Variations  */  
   Variations:boolean,
      /**  OversPct  */  
   OversPct:number,
      /**  UndersPct  */  
   UndersPct:number,
      /**  DefaultLOQstyle  */  
   DefaultLOQstyle:string,
      /**  DefaultOrderAcknowledgement  */  
   DefaultOrderAcknowledgement:string,
      /**  DefaultPackSlip  */  
   DefaultPackSlip:string,
      /**  DefaultOversPricing  */  
   DefaultOversPricing:string,
      /**  LOQPrepressStyle  */  
   LOQPrepressStyle:string,
      /**  CSR  */  
   CSR:string,
      /**  LOQBookCaFinishing  */  
   LOQBookCaFinishing:boolean,
      /**  LOQBookCapaper  */  
   LOQBookCapaper:boolean,
      /**  LOQBookCaPress  */  
   LOQBookCaPress:boolean,
      /**  LOQBookCatPlates  */  
   LOQBookCatPlates:boolean,
      /**  LOQVariations  */  
   LOQVariations:boolean,
      /**  DefaultInvoicestyle  */  
   DefaultInvoicestyle:string,
      /**  AEPLOQType  */  
   AEPLOQType:string,
      /**  BusinessCust  */  
   BusinessCust:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  THBranchID  */  
   THBranchID:string,
      /**  CustPricingSchema  */  
   CustPricingSchema:string,
      /**  ParamCode  */  
   ParamCode:string,
      /**  AGAFIPResponsibilityCode  */  
   AGAFIPResponsibilityCode:string,
      /**  AGBillToProvinceCode  */  
   AGBillToProvinceCode:string,
      /**  AGGrossIncomeTaxID  */  
   AGGrossIncomeTaxID:string,
      /**  AGIDDocTypeCode  */  
   AGIDDocTypeCode:string,
      /**  AGIDDocumentNumber  */  
   AGIDDocumentNumber:string,
      /**  AGProvinceCode  */  
   AGProvinceCode:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  In Collections  */  
   Collections:boolean,
      /**  CollectionsDate  */  
   CollectionsDate:string,
      /**  Date Collection Posted  */  
   DateCollectionPosted:string,
      /**  MXMunicipio  */  
   MXMunicipio:string,
      /**  Displays list of Peru Identity Types.  */  
   PEIdentityDocType:string,
      /**  Peru Document ID.  */  
   PEDocumentID:string,
      /**  Peru Goods Contributor withholding status.  */  
   PEGoodsContributor:boolean,
      /**  Peru Withholding Agent status.  */  
   PEWithholdAgent:boolean,
      /**  Peru Collection Agent withholding status.  */  
   PECollectionAgent:boolean,
      /**  Peru Not Found withholding status.  */  
   PENotFound:boolean,
      /**  Peru No Address Provided withholding status.  */  
   PENoAddress:boolean,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  InvcOrderCmpDflt  */  
   InvcOrderCmpDflt:boolean,
      /**  EInvoice  */  
   EInvoice:boolean,
      /**  RegistrationCode  */  
   RegistrationCode:string,
      /**  EAddress  */  
   EAddress:string,
      /**  Check if the part is a run out part.  */  
   DemandCheckForRunOutPart:boolean,
      /**  Indicates what type of action to take if the Check for Run Out Part option is selected and the part is marked as a run out part.  Options are B (reject the change) or W (warning - alert that the part is marked as run out but allow the record to be accepted).  */  
   DemandCheckForRunOutPartAction:string,
      /**  E-Invoice CompanyID Attribute  */  
   EInvCompanyIDAttr:string,
      /**  INCSTNumber  */  
   INCSTNumber:string,
      /**  INPANNumber  */  
   INPANNumber:string,
      /**  Colombia Loc Field. OneTimeCustVend new table ID  */  
   COOneTimeID:string,
      /**  Colombia Loc Field.  */  
   COIsOneTimeCust:boolean,
      /**  DEOrgType  */  
   DEOrgType:string,
      /**  PEGuaranteeName  */  
   PEGuaranteeName:string,
      /**  PEGuaranteeAddress1  */  
   PEGuaranteeAddress1:string,
      /**  PEGuaranteeAddress2  */  
   PEGuaranteeAddress2:string,
      /**  PEGuaranteeAddress3  */  
   PEGuaranteeAddress3:string,
      /**  PEGuaranteeCity  */  
   PEGuaranteeCity:string,
      /**  PEGuaranteeState  */  
   PEGuaranteeState:string,
      /**  PEGuaranteeZip  */  
   PEGuaranteeZip:string,
      /**  PEGuaranteeCountry  */  
   PEGuaranteeCountry:string,
      /**  PEGuaranteePhoneNum  */  
   PEGuaranteePhoneNum:string,
      /**  PEGuaranteeTaxID  */  
   PEGuaranteeTaxID:string,
      /**  Our Supplier Code  */  
   OurSupplierCode:string,
      /**  Type of customer created by ECC.  Valid values are: B=B2b, C=B2C  */  
   ECCType:string,
      /**  MYIndustryCode  */  
   MYIndustryCode:string,
      /**  This field defines if the customer is synchronized to an External CRM. Only enabled if the External CRM integration is on at the Company configuration.  */  
   SyncToExternalCRM:boolean,
      /**  This field holds the id of this customer in the External CRM  */  
   ExternalCRMCustomerID:string,
      /**  This fields holds the customer type of this customer in the External CRM.  */  
   ExternalCRMCustomerType:string,
      /**  This field defines the last time that the  Customer  has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   ExternalCRMLastSync:string,
      /**  This fields determines if the customer needs to be synchronized to the External CRM. If there are changes in the customer master file , Epicor ERP automatically turns on this field.  */  
   ExternalCRMSyncRequired:boolean,
      /**  Ownership of the customer  */  
   Ownership:string,
      /**  Industry of the customer  */  
   Industry:string,
      /**  Annual revenue of the customer  */  
   AnnualRevenue:number,
      /**  Number of employees of the customer  */  
   NumberOfEmployees:number,
      /**  Location of the ticker of this customer  */  
   TickerLocation:string,
      /**  Ticker for the customer  */  
   TickerSymbol:string,
      /**  Rating for the customer  */  
   Rating:string,
      /**  TW GUI Code  */  
   TWGUIRegNum:string,
      /**  MXAccountNumber  */  
   MXAccountNumber:string,
      /**  Indicates that the shipment lines will be consolidated within the invoice for the same part, the same order, and the same packing slip.  */  
   ConsolidateLinesPerPart:boolean,
      /**  TWTaxPayerType  */  
   TWTaxPayerType:number,
      /**  TWDeductGUIFormatCode  */  
   TWDeductGUIFormatCode:string,
      /**  MXCURP  */  
   MXCURP:string,
      /**  PEAddressID  */  
   PEAddressID:string,
      /**  PEPerceptionRegime  */  
   PEPerceptionRegime:string,
      /**  TaxEntityType  */  
   TaxEntityType:string,
      /**  GST Compliance Rate field for India  */  
   INGSTComplianceRate:number,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  MXPurchaseType  */  
   MXPurchaseType:string,
      /**  Determines if the customer has to be synchronized with Epicor FSA application.  */  
   SendToFSA:boolean,
      /**  MXGeneralPublic  */  
   MXGeneralPublic:boolean,
      /**  Indicates if customer has been placed into an "Aging Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   AgingCreditHold:boolean,
      /**  Date on which the customer was last placed on aging hold. This field is maintained by the system.  */  
   AgingCreditHoldDate:string,
      /**  Indicates how the customer was placed on aging hold.  Valid values are "MANUAL" and "PROCESS".  "MANUAL" means that the user placed the customer on hold.  “PROCESS” means that the Mass Credit Information Update Process places the customer on aging hold.  This field is maintained by the system.  */  
   AgingCreditHoldSource:string,
      /**  The UserFile.DCDUSERID value of the user that last cleared the customer's aging hold. This field is maintained by the system.  */  
   AgingCreditClearUserID:string,
      /**  The date that the user last cleared the customer's aging hold. This field is maintained by the system.  */  
   AgingCreditClearDate:string,
      /**  The aging code assigned to the customer.  */  
   AgingCreditCode:string,
      /**  Indicates whether this customer is importer of records or not. Used for Avalara Tax Connect calculation.  */  
   ImporterOfRecord:boolean,
      /**  Standard Entry Class Code  */  
   SEC:string,
      /**  E-Invoice EndpointID Attribute  */  
   EInvEndpointIDAttr:string,
      /**  Indicates whether sales orders from this sold to customer should be treated as Blind Shipments by Manifest.  */  
   UseBlindShipping:boolean,
      /**  ELIEinvoice  */  
   ELIEinvoice:boolean,
      /**  ELIDefReportID  */  
   ELIDefReportID:string,
      /**  ELIDefStyleNum  */  
   ELIDefStyleNum:number,
      /**  ELIDefToMail  */  
   ELIDefToMail:string,
      /**  ELIDefCCMail  */  
   ELIDefCCMail:string,
      /**  ELIDefMailTempID  */  
   ELIDefMailTempID:string,
      /**  ELISendMail  */  
   ELISendMail:boolean,
      /**  COFiscalResp1  */  
   COFiscalResp1:string,
      /**  COFiscalResp2  */  
   COFiscalResp2:string,
      /**  COFiscalResp3  */  
   COFiscalResp3:string,
      /**  COOperType  */  
   COOperType:string,
      /**  Flag that indicates if the Customer is for Central Collection.  */  
   CentralCollection:boolean,
      /**  NettingVendorNum  */  
   NettingVendorNum:number,
      /**  EORI Number  */  
   EORINumber:string,
      /**  AGIsElectronicCreditInvEligible  */  
   AGIsElectronicCreditInvEligible:boolean,
      /**  Tax ID Validation Status. Not Validated – 0, Valid – 1, Invalid – 2.  */  
   TaxValidationStatus:number,
      /**  Tax Validation Date  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Indicates if the record is inactive.  */  
   Inactive:boolean,
      /**  Customer Scheme ID  */  
   ExternalSchemeID:string,
      /**  EInvoice Operator Code  */  
   ELIOperatorCode:string,
      /**  Sending Option  */  
   ELISendingOption:number,
      /**  EInvoice Operator ID  */  
   ELIOperatorID:string,
      /**  EInvExternalID  */  
   EInvExternalID:string,
      /**  Tax Regime  */  
   MXTaxRegime:string,
      /**  ExclusionMonth  */  
   ExclusionMonth:number,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMRegionCode  */  
   FSMRegionCode:string,
      /**  FSMArea  */  
   FSMArea:string,
      /**  Default E-invoice Report Style  */  
   ELIRcptDefStyleNum:number,
      /**  CovenantDiscPercent  */  
   CovenantDiscPercent:number,
   ACATCommCare:boolean,
   ACATRespCareType:string,
   ACATRespCareTypeDesc:string,
      /**  Customer Address in format delimited string  */  
   AddrList:string,
      /**  This value is a temp field that is populated from JCSyst.AdvancedLaborRate  */  
   AdvancedLaborRate:boolean,
      /**  Apply credit hold status to orders  */  
   ApplyHoldToOrders:boolean,
      /**  delimited list of customer attributes  */  
   AttrCodeList:string,
      /**  Company base currency.  */  
   BaseCurrCode:string,
   BillDayDesc:string,
   BillFreqDescription:string,
      /**  Bill To Address in format delimited list  */  
   BTAddrList:string,
      /**  Delimited list of Business Categories  */  
   BusinessCatList:string,
      /**  ChargeCode Description  */  
   ChargeCodeDesc:string,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
   COOperTypeDesc:string,
   CustTypeDescription:string,
   DiscQualDescription:string,
   DspBTFormatStr:string,
      /**  Display Format String  */  
   DspFormatStr:string,
   DspRlsClass:string,
      /**  List of available ECC Payment Method codes  */  
   ECCPaymentCodes:string,
      /**  List of available ECC Payment Method descriptions  */  
   ECCPaymentDesc:string,
      /**  List of ECC Payment Method codes selected  */  
   ECCPaymentList:string,
      /**  List of ECC Payment Method descriptions selected  */  
   ECCPaymentXDesc:string,
      /**  List of ECC Ship Via codes selected  */  
   ECCShipViaList:string,
   EnableGlobalCust:boolean,
   EnableGlobalLock:boolean,
      /**  Indicates if an "Multi" External Company record exists to enable GlobalCust  */  
   ExtCoExist:boolean,
   FxdGlbOrdCredit:number,
   FxdGlbPICredit:number,
   FxdOrderCredit:number,
   FxdPICredit:number,
   FxdTotOrders:number,
   FxdTotPI:number,
      /**  Indicates if the Customer is Global (master or linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany and GlbCustNum that is linking to this customer  */  
   GlbLink:string,
      /**  Global Shared Credit Available  */  
   GlbNAChildCrdAvail:number,
      /**  Global Own Credit Available  */  
   GlbNAOwnCreditAvail:number,
   GlbNAOwnCreditUsedDsp:number,
      /**  Global Parents Credit Available  */  
   GlbNAParentCrdAvail:number,
   GlbNAParentsCreditUsedDsp:number,
   GlbNAPoolCrdAvail:number,
   GlbNAPoolCreditUsed:number,
   GlbNASharedCreditUsedDsp:number,
      /**  Indicates if integrated with a financial package  */  
   IntegrationFlag:boolean,
      /**  Flag used for integrations whether to run the on change country logic.  */  
   IntRunChangeCountry:boolean,
      /**  Identifies the default price list for the customer.  Must be unique and present in PriceLst table.  */  
   ListCode:string,
   LLLBAnnualHomeCap:number,
   LLLBAnnualPartPenCap:number,
   LLLBAnnualResiCap:number,
   LLLBAnnualSelfFndCap:number,
   LLLBAsAtDate:string,
      /**  Indicates if the Clients Asset and Income Assessment has been received  */  
   LLLBAssetAssess:boolean,
   LLLBLifeTimeCap:number,
   LLLBMeansTestAmt:number,
   LLLBMeansTestFeeAmt:number,
   LLLBPrevEntryDate:string,
      /**  Customer?s credit available to be shared with his Children in National Account  */  
   NAChildCrdAvail:number,
      /**  If the customer in the Credit Checking National Account  */  
   NACreditCust:boolean,
      /**  Customer is in Credit National Account and his Credit data have been updated, so recalculation is needed  */  
   NACreditUpdated:boolean,
      /**  Own Credit Available  */  
   NAOwnCreditAvail:number,
   NAOwnCreditUsedDsp:number,
      /**  Available Parent?s Credit in National Accout  */  
   NAParentCrdAvail:number,
   NAParentsCreditUsedDsp:number,
      /**  Available credit from credit pools to be used by this customer in National account.  */  
   NAPoolCrdAvail:number,
   NAPoolCreditUsed:number,
   NASharedCreditUsedDsp:number,
      /**  Total Credit Available from National Account  */  
   NATotalCreditAvail:number,
      /**  Total Credit Used from National Account  */  
   NATotalCreditUsed:number,
      /**  A user defined external Netting Vendor ID.  This must be existing Vendor ID within the file.  */  
   NettingVendorID:string,
      /**  CustID of Parent Customer  */  
   ParentCustID:string,
      /**  Name of Parent Customer  */  
   ParentName:string,
   PeriodicityDesc:string,
      /**  List of available Periodicity values.  */  
   PeriodicityList:string,
      /**  Indicates whether PI fields should be enabled or not  */  
   PIFlag:boolean,
      /**  Reminder Group Description  */  
   ReminderGroupDesc:string,
      /**  Sales Tax ID  */  
   SalesTaxID:string,
      /**  Automated Bank Reconciliation: Search IDs.  */  
   SearchIDs:string,
      /**  flag indicating whether packing slips are sent to integration partner  */  
   SendShipment:boolean,
      /**  Service Tax ID  */  
   ServiceTaxID:string,
   ShippingQualifierDesc:string,
      /**  Total Global Invoice Credit (including current company)  */  
   TotGlbInvoiceCredit:number,
      /**  Total Global Open Credit (based on GlbCredInc flags)  */  
   TotGlbOpenCredit:number,
      /**  Total Global Order Credit (including current company)  */  
   TotGlbOrderCredit:number,
      /**  Total Global Payment Instruments Credit (including current company)  */  
   TotGlbPICredit:number,
   TotInvoiceCredit:number,
   TotLCCredit:number,
   TotLCCumInvoices:number,
   TotLCInvoiceBal:number,
   TotLCOpenOrders:number,
   TotLCUsed:number,
      /**  Total Credit based on CredInc flags  */  
   TotOpenCredit:number,
      /**  Total number of open invoices  */  
   TotOpenInvoices:number,
      /**  Total number of open invoices for LCs  */  
   TotOpenInvoicesLC:number,
      /**  Total number of open LCs  */  
   TotOpenLC:number,
      /**  Total number of open orders for LCs  */  
   TotOpenOrderLC:number,
      /**  Total number of open orders  */  
   TotOpenOrders:number,
      /**  Total number of open Payment Instruments  */  
   TotOpenPI:number,
   TotOrderCredit:number,
   TotPICredit:number,
   ACATOtherCare:boolean,
   LanguageDescription:string,
      /**  Area of ISTMO de Tehuantepec (Polos de Desarrollo). Value is from MXLocISTMO User Code.  */  
   MXISTMO:string,
      /**  E-invoice default report id for cash receipt  */  
   ELIRcptDefReportID:string,
   BitFlag:number,
   AGAFIPResponsibilityDescription:string,
   AGBillToProvinceDescription:string,
   AGIDDocTypeCUITMark:boolean,
   AGIDDocTypeDescription:string,
   AgingCreditDescription:string,
   AGProvinceDescription:string,
   BTCountryISOCode:string,
   BTCountryEUMember:boolean,
   CompanySendToFSA:boolean,
   CountryISOCode:string,
   CountryFormatStr:string,
   CountryEUMember:boolean,
   CurrencyCurrName:string,
   CurrencyCurrencyID:string,
   CurrencyCurrSymbol:string,
   CurrencyCurrDesc:string,
   CurrencyDocumentDesc:string,
   CustGrupGroupDesc:string,
   DeliveryTypeDescription:string,
   FOBDescription:string,
   GlobalCurrencyCurrSymbol:string,
   GlobalCurrencyCurrDesc:string,
   GlobalCurrencyDocumentDesc:string,
   GlobalCurrencyCurrencyID:string,
   GlobalCurrencyCurrName:string,
   MarkUpDescription:string,
   MXPurchaseTypeCodeDesc:string,
   PayMethodSummarizePerCustomer:boolean,
   PayMethodType:number,
   PayMethodName:string,
   PreferredBankBankName:string,
   PreferredBankDescription:string,
   RASchedCdRADesc:string,
   ReservePriDescription:string,
   SalesRepName:string,
   ShipViaWebDesc:string,
   ShipViaDescription:string,
   TATaxAuthorityDescription:string,
   TaxRegionDescription:string,
   TermsDescription:string,
   TerritoryTerritoryDesc:string,
   XbSystELIEinvoice:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerSettlementDayRow{
      /**  Company  */  
   Company:string,
      /**  CustNum  */  
   CustNum:number,
      /**  SettlementDay  */  
   SettlementDay:number,
      /**  ChangedBy  */  
   ChangedBy:string,
      /**  ChangedOn  */  
   ChangedOn:string,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerTableset{
   Customer:Erp_Tablesets_CustomerRow[],
   CustomerAttch:Erp_Tablesets_CustomerAttchRow[],
   CustomCrdPool:Erp_Tablesets_CustomCrdPoolRow[],
   Partner:Erp_Tablesets_PartnerRow[],
   CustBillTo:Erp_Tablesets_CustBillToRow[],
   CustBank:Erp_Tablesets_CustBankRow[],
   CustChild:Erp_Tablesets_CustChildRow[],
   CustDfltDocType:Erp_Tablesets_CustDfltDocTypeRow[],
   CustIC:Erp_Tablesets_CustICRow[],
   CustLabExpRate:Erp_Tablesets_CustLabExpRateRow[],
   CustMandate:Erp_Tablesets_CustMandateRow[],
   CustomerDocs:Erp_Tablesets_CustomerDocsRow[],
   CustRestriction:Erp_Tablesets_CustRestrictionRow[],
   CustUPSEmail:Erp_Tablesets_CustUPSEmailRow[],
   CustomerDiscPriceLst:Erp_Tablesets_CustomerDiscPriceLstRow[],
   CustomerFSPriceList:Erp_Tablesets_CustomerFSPriceListRow[],
   GlbCustCred:Erp_Tablesets_GlbCustCredRow[],
   MXCustomerFiscalText:Erp_Tablesets_MXCustomerFiscalTextRow[],
   NAMember:Erp_Tablesets_NAMemberRow[],
   PECustWhldHist:Erp_Tablesets_PECustWhldHistRow[],
   ShipTo:Erp_Tablesets_ShipToRow[],
   ShipToAttch:Erp_Tablesets_ShipToAttchRow[],
   ShipToRestriction:Erp_Tablesets_ShipToRestrictionRow[],
   ShipToLabExpRate:Erp_Tablesets_ShipToLabExpRateRow[],
   CustomerDocsSH:Erp_Tablesets_CustomerDocsSHRow[],
   ShipToDiscPriceLst:Erp_Tablesets_ShipToDiscPriceLstRow[],
   ShipToMFBill:Erp_Tablesets_ShipToMFBillRow[],
   ShipToPriceLst:Erp_Tablesets_ShipToPriceLstRow[],
   ShipToUPSEml:Erp_Tablesets_ShipToUPSEmlRow[],
   CustMFBill:Erp_Tablesets_CustMFBillRow[],
   MangCust:Erp_Tablesets_MangCustRow[],
   ShipToSrch:Erp_Tablesets_ShipToSrchRow[],
   CustomerPriceLst:Erp_Tablesets_CustomerPriceLstRow[],
   EntityGLC:Erp_Tablesets_EntityGLCRow[],
   TaxExempt:Erp_Tablesets_TaxExemptRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ETCAddrValidationTableset{
   ETCAddress:Erp_Tablesets_ETCAddressRow[],
   ETCMessage:Erp_Tablesets_ETCMessageRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ETCAddressRow{
      /**  Company  */  
   Company:string,
      /**  City name  */  
   City:string,
      /**  Country name  */  
   Country:string,
      /**  Address line 1  */  
   Line1:string,
      /**  Address line 2  */  
   Line2:string,
      /**  Address line 3  */  
   Line3:string,
      /**  Postal or ZIP code  */  
   PostalCode:string,
      /**  State or province name  */  
   Region:string,
      /**  This is an additional field that will be required to designate the type of address that is being validated (customer, plant, etc)  */  
   AddrSource:string,
      /**  This is an additional field to contain an appropriate piece of data to be used with the AddrSource for display in the UI to clarify for the user what data the validated address relates to. Such as AddrSource = Customer and AddrSourceID = ?Addison?  */  
   AddrSourceID:string,
      /**  This is an additional field that will be set if the user has indicated that the Vantage address should be updated from the address validation results.  */  
   UpdateAddr:boolean,
      /**  This value will come from Avalara ValidateResult TransactionID and identifies a unique specific request/response set. It will be used to tie the ETCValidAddress and ETCMessage rows to ETCAddress.  */  
   TransactionID:string,
      /**  This field will be set if by the process calling address validation to indicate whether the user should have the option to update the original address within the address validation UI.  */  
   UpdateAllowed:boolean,
      /**  Programmatically assign unique key to tie the ETCAddress table, the ETCValidAddress table and the ETCMessages table together.  */  
   RequestID:string,
      /**  Programmatically determined value used internally by the adapter. Defaults to the hash code of the Address object.  */  
   AddressCode:string,
      /**  The type of address that was coded (PO Box, Rural Route, and so on), using the input address. This probably needs Code/desc data  Avalara will return F = Firm or company address; G = General Delivery address; H= High-rise or business complex; P = PO Box address; R = Rural route address; S = Street or residential address  */  
   AddressType:string,
      /**  The carrier route associated with the input address (USA). This probably needs Code/desc data  Avalara will return B = PO Box; C = City Delivery; G= General Delivery; H = Highway Contract; R = Rural route.  */  
   CarrierRoute:string,
      /**  City name  */  
   ValidCity:string,
      /**  Country name  */  
   ValidCountry:string,
      /**  County name  */  
   County:string,
      /**  Federal Information Processing Standards Code (USA). This is a unique code representing each geographic combination of state, county, and city. The code is made up of the Federal Information Processing Code (FIPS) that uniquely identifies each state, county, and city in the U.S. See Federal Information Processing Standards (FIPS) Codes for more details. Digits 1-2 are the state code, digits 3-5 are the county code and digits 6-10 are the city code.  */  
   FipsCode:string,
      /**  Line one of the valid address returned by the tax integration.  */  
   ValidLine1:string,
      /**  Line two of the valid address returned by the tax integration.  */  
   ValidLine2:string,
      /**  Line three of the valid address returned by the tax integration.  */  
   ValidLine3:string,
      /**  Line four of the valid address returned by the tax integration.  */  
   ValidLine4:string,
      /**  Postal code returned by the tax integration.  */  
   ValidPostalCode:string,
      /**  A 12-digit POSTNet barcode (USA). Digits 1-5 = ZIP code, digits 6-9 = Plus4 Code, digits 10-11 = delivery point, digit 12 = check digit  */  
   PostNet:string,
      /**  State or province name or abbreviation returned by the tax integration.  */  
   ValidRegion:string,
      /**  This needs Code/desc data.  Avalara will return a single code for each address validation request. We will include the result code in each ETCValidAddress row. Success = Operation Succeeded; Warning = Warnings occured, operation succeeded, Error = Errors occured, operation failed; Exception = Unexpected exceptions occurred, operation failed.  */  
   ResultCode:string,
      /**  This is an additional field to set a unique sequence for each ValidMessage returned for a specific TransactionId.  */  
   ResultSeq:number,
      /**  Carrier Route description  */  
   CarrierRouteDesc:string,
      /**  Address type description  */  
   AddressTypeDesc:string,
   OTSCountry:string,
      /**  A  unique integer assigned by the system to new countries by the  maintenance program. This field is used as the foreign key to identify the country in other files such as Customer, or vendor. The end user should never need to know about the value of this field.  */  
   CountryNum:number,
      /**  Foreign key to the InvcHead.  */  
   InvoiceNum:number,
      /**  This field along with Company and InvoiceNum make up the unique key to the table.  The system generates this number during entry of new detail records.  The system determines next available number by finding the last InvcDtl record for the Invoice and adding 1 to it.  */  
   InvoiceLine:number,
      /**   Auto consume window percentage: this is a percentage to calculate the auto consume window days  that scheduling engine will take in consideration to look for available quantity to consume.
The purpose of this is to look ahead for a few days that will save more time than building the goods, so unless we get the full qty “current date” we need to use the window to look for the remaining.  */  
   ACWPercentage:number,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ETCMessageRow{
      /**  Company  */  
   Company:string,
   Details:string,
      /**  URL to help page for this message  */  
   Helplink:string,
      /**  Gets the name of the message  */  
   Name:string,
      /**  The item the message refers to, if applicable. Used to indicate a missing or incorrect value  */  
   RefersTo:string,
      /**  This probably needs Code/desc data  Avalara will return Success = Operation Succeeded; Warning = Warnings occured, operation succeeded, Error = Errors occured, operation failed; Exception = Unexpected exceptions occurred, operation failed.  */  
   Severity:string,
      /**  source of the message  */  
   Source:string,
      /**  concise summary of the message  */  
   Summary:string,
      /**  This value will come from Avalara ValidateResult TransactionID and identifies a unique specific request/response set. It will be used to tie the ETCMessage row to ETCAddress.  */  
   TransactionID:string,
      /**  This is an additional field that will be required to designate the type of address that is being validated (customer, plant, etc)  */  
   AddrSource:string,
      /**  This is an additional field to contain an appropriate piece of data to be used with the AddrSource for display in the UI to clarify for the user what data the validated address relates to. Such as AddrSource = Customer and AddrSourceID = ?Addison?  */  
   AddrSourceID:string,
      /**  Programitically assigned.  */  
   RequestID:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_EntityGLCRow{
      /**  Company Identifier.  */  
   Company:string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   RelatedToFile:string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   Key1:string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   Key2:string,
      /**   3rd component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key3:string,
      /**   4th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key4:string,
      /**   5th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key5:string,
      /**   6th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key6:string,
      /**  Identifier of the GL Control Type.  */  
   GLControlType:string,
      /**  GL Control Identifier.  */  
   GLControlCode:string,
      /**  Identifies the entity.  Reference only.  Used for integrity validation when deleting a GLCTEntity record.  */  
   BusinessEntity:string,
      /**  Global Company identifier.  Used in Multi-Company Journal.  */  
   ExtCompanyID:string,
      /**  Flag to indicate the account in this record is for an external company.  */  
   IsExternalCompany:boolean,
      /**  Marks this EntityGLC as global, available to be sent out to other companies.  */  
   GlobalEntityGLC:boolean,
      /**  Disables this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  BankAcctID of the related BankAcct record.  */  
   BankAcctID:string,
   BankFeeID:string,
      /**  CallCode of the related FSCallCd record.  */  
   CallCode:string,
   ChargeCode:string,
      /**  ClassCode of the related FAClass record.  */  
   ClassCode:string,
      /**  ClassID.  This can be ClassID of PartClass, PRClsDed, or PRClsTax  */  
   ClassID:string,
      /**  ContractCode of the related FSContCd record.  */  
   ContractCode:string,
      /**  CurrencyCode of the related Currency record.  */  
   CurrencyCode:string,
      /**  CustNum of the related Customer record  */  
   CustNum:number,
      /**  DeductionID of PRClsDed or PRDeduct.  */  
   DeductionID:string,
      /**  EmpID of the related PREmpMas record.  */  
   EmpID:string,
      /**  ExpenseCode of PayTLbr, LabExpCd  */  
   ExpenseCode:string,
      /**  ExtSystemID of ExtCompany table  */  
   ExtSystemID:string,
      /**  FromPlant value of the related PlntTranDef record.  */  
   FromPlant:string,
      /**  GroupCode of the related FAGroup record.  */  
   GroupCode:string,
   GroupID:string,
   HeadNum:number,
   InvoiceNum:string,
      /**  JCDept of the related JCDept record.  */  
   JCDept:string,
      /**  MiscCode of the related MiscChrg or PurMisc record.  */  
   MiscCode:string,
      /**  PartNum of the related Part record.  */  
   PartNum:string,
      /**  PayTypeID of PayType  */  
   PayTypeID:string,
   PerConName:string,
      /**  PI Status  */  
   PIStatus:string,
      /**  Plant of the related PlantConfCtrl record.  */  
   Plant:string,
      /**  ProdCode of the related ProdGrup record.  */  
   ProdCode:string,
      /**  ProjectID of the related Project record.  */  
   ProjectID:string,
      /**  PurchCode of the related GLPurch record.  */  
   PurchCode:string,
      /**  RateCode of the related GLRate record.  */  
   RateCode:string,
      /**  ReasonCode of the related Reason record.  */  
   ReasonCode:string,
      /**  ReasonType of the related Reason record.  */  
   ReasonType:string,
      /**  SalesCatID of the related SalesCat record.  */  
   SalesCatID:string,
      /**  Shift value of the related JCShift record.  */  
   Shift:number,
      /**  TaxCode of the related SalesTax record.  */  
   TaxCode:string,
      /**  TaxTblID of PRTaxMas or PRClsTax.  */  
   TaxTblID:string,
      /**  ToPlant value of the related PlntTranDef record.  */  
   ToPlant:string,
      /**  TransferMethod of ExtCompany table  */  
   TransferMethod:string,
      /**  Type ID  */  
   TypeID:string,
      /**  VendorNum of the related Vendor record.  */  
   VendorNum:number,
      /**  WarehouseCode of the related Warehse record.  */  
   WarehouseCode:string,
   ExpenseTypeCode:string,
   IsFiltered:boolean,
   OprTypeCode:string,
   CashDeskID:string,
   TIN:string,
   ReclassCodeID:string,
   BitFlag:number,
   GLCntrlDescription:string,
   GLCntrlTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbCustBillToRow{
      /**  Company Identifier.  */  
   Company:string,
   GlbCompany:string,
   GlbCustNum:number,
      /**  Indicates the CustNum of the alternate Bill To Customer.  */  
   GlbBTCustNum:number,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   CustNum:number,
      /**  Indicates the CustNum of the alternate Bill To Customer.  */  
   BTCustNum:number,
      /**  Indicates whether this Alt Bill To is the default record or not.  */  
   DefaultBillTo:boolean,
      /**  If checked, the invoice print routine will use the address from this alternate customer as the invoice address.  */  
   InvoiceAddress:boolean,
      /**  Disable this record from receiving global updates  */  
   GlobalLock:boolean,
   ChangeDate:string,
   ChangedBy:string,
   ChangeTime:number,
   BTLegalName:string,
   OrgRegCode:string,
   OurBankCode:string,
   TaxRegReason:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  FSACustomerNotSent  */  
   FSACustomerNotSent:boolean,
      /**  Local BTCustNum to Link To  */  
   LinkBTCustNum:number,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbCustCredRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program. This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never need to know about the value of this field.  */  
   CustNum:number,
      /**  Company credit totals came from (not just owner of the global customer)  */  
   ExtCompany:string,
   ExtCompName:string,
      /**  Date the credit was last updated  */  
   UpdateDate:string,
      /**  Open AR Credit in Global Currency  */  
   DocARTotal:number,
      /**  Open Order Credit in Global Currency  */  
   DocSOTotal:number,
      /**  Open PI Credit in Global Currency  */  
   DocPITotal:number,
      /**  AR Credit in local companies base currency  */  
   ARTotal:number,
      /**  SO Credit in local companies base currency  */  
   SOTotal:number,
      /**  PI Credit in local companies base currency  */  
   PITotal:number,
      /**  Holds connection and exchange rate error messages  */  
   ErrorMsg:string,
      /**  This field holds the associated Global Customer number.  If this is the "parent" customer then it will match the CustNum field.  0 indicates that this is not a global customer at all  */  
   GlbCustNum:number,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   ParentCustNum:number,
      /**  Holds the Currency.CurrencyCode value of that the global customer will exchange data in.  */  
   GlobalCurrencyCode:string,
      /**  Total Number of Open Invoices  */  
   TotalInvoices:number,
      /**  Total Number of Open Orders  */  
   TotalOrders:number,
      /**  Total Number of open Payment Instruments  */  
   TotalPayIns:number,
      /**  Parent's Credit used by this customer  */  
   NAParentsCreditUsed:number,
      /**  Shared Credit used by children  */  
   NASharedCreditUsed:number,
      /**  Own Credit used by himself  */  
   NAOwnCreditUsed:number,
      /**  Global Parent's Credit used by this customer  */  
   GlbNAParentsCreditUsed:number,
      /**  Shared Credit used by Global children  */  
   GlbNASharedCreditUsed:number,
      /**  Pool Credit used  */  
   NAPoolCreditUsed:number,
      /**  Global Credit Pool used  */  
   GlbNAPoolCreditUsed:number,
      /**  Own Credit used by himself  */  
   GlbNAOwnCreditUsed:number,
      /**  Allocated Credit exceed Credit Limit  */  
   NAExceedLimit:number,
      /**  Allocated Credit exceed Global Credit Limit  */  
   GlbNAExceedLimit:number,
      /**  AR Letter of Credit Credit in local companies base currency  */  
   ARLOCTotal:number,
      /**  Open AR Letter of Credit Credit in Global Currency  */  
   DocARLOCTotal:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbCustomerRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A user defined external customer ID.  This must be unique within the file.  This is the unique key in the owner company  */  
   GlbCustID:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This is the unique key in the owner company  */  
   GlbCustNum:number,
   Name:string,
   Address1:string,
   Address2:string,
   Address3:string,
   City:string,
   State:string,
   Zip:string,
      /**  Country is used as part of the mailing address. It can be left blank.  */  
   Country:string,
      /**  Optional field used to record the customer's State Tax Identification number, which is used on Sales Acknowledgments.  */  
   ResaleID:string,
      /**   Contains the default SalesRep for the specific customer. This field is used to supply defaults to Order Entry and Invoice entry for invoices that do not reference Orders.
It can be left blank or must be valid in the SalesRep master file.  */  
   SalesRepCode:string,
      /**  The Sales Territory for the Customer.  */  
   TerritoryID:string,
      /**  Contains the key of the default ship to for a customer. A blank value indicates that the name and address in the Customer file is considered the default ship to. This field is updated when the user marks the check box in shipto maintenance indicating that the ship to is to be designated as the default. This default will be used in areas such as Sales Order entry.  */  
   ShipToNum:string,
      /**  Establishes the default sales terms that should be used for this customer. This field can't be left blank, it must be valid in the Terms file. A default may be supplied by XaSyst.TermsCode if not blank.  It supplies the default in Order entry and Invoice entry.  */  
   TermsCode:string,
      /**  Contains the default ShipVia for a customer. This is an optional field, it can be left blank or it must be valid in the ShipVia master file.  */  
   ShipViaCode:string,
      /**  Controls the selection for printing of Accounts Receivable statements for a customer.  */  
   PrintStatements:boolean,
      /**  Only customers that are PrintLabels = Yes will be selected for printing of mailing labels.  */  
   PrintLabels:boolean,
      /**   Allows the user to establish whether or not a specific customer requires Sales Order Acknowledgments.  This does not force or limit the printing of sales acknowledgments directly from within Order Entry.  Order entry displays this setting to the user so that they know  if they should print the acknowledgment.
For batch mode printing, (where ranges of sales orders are selected...future release) this setting will be used to exclude orders from printing.  */  
   PrintAck:boolean,
      /**  Controls whether or not the customer included in the finance charge calculation process.  */  
   FinCharges:boolean,
      /**  Indicates if customer has been placed into a "Credit Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   CreditHold:boolean,
      /**  Customer Group code for a customer.  This can be blank or it must be valid in the CustsGrup file. This field will be used as a sort and selection parameter for reporting.  */  
   GroupCode:string,
      /**  An optional field used to establish a default purchasing discount percentage for a customer. This value is supplied to order entry as a default for line item discount percent.  */  
   DiscountPercent:number,
      /**  Contains the key of the Primary Purchasing contact for the customer. This field is not directly maintainable. Instead it is set during contact maintenance by having the user mark a check box indicating primary Purchaser.  This is the contact that is used as a default in Order Entry and Quoting.  */  
   PrimPCon:number,
      /**  The same as the PrimPCon except that this is the Billing contact and this is used as a default in invoice entry.  */  
   PrimBCon:number,
      /**  Same as PrimPCon except that this the Shipping contact and is used as a default in Packing Slip entry.  */  
   PrimSCon:number,
      /**   Comments are intended to be internal comments about a specific customer. These do get pulled into other programs. They are mainly intended as an online storage facility.
To be view-as EDITOR widget.  */  
   Comment:string,
      /**  The date when they were established as a customer. Use the system date as a default when creating new customers. This is user maintainable.  */  
   EstDate:string,
      /**  Fax telephone number for the customer. Optional field. Field is displayed in Order entry when no contact is specifically given or the contact has a blank fax number.  */  
   FaxNum:string,
      /**  The general Business Phone Number for the customer. Displayed in Order entry when no contact is given or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Indicates the reason why  customer is normally exempt from sales tax. Used as a default in invoice entry.  If field is non-blank it is considered exempt.   This code is totally user definable and no validation is required.  */  
   TaxExempt:string,
      /**  The ID that establishes link to the default QMarkUp record which provides default markup percents used by quote entry for this customer. This ID is not directly entered. Instead it is derived via the user entering the description of the QMarkUp record. This can be left blank, else must be valid.  */  
   MarkUpID:string,
      /**   ** 6.0 extended functionality
Represents the day of the week that this customer is billed. The valid values are 0-7 where 0=All,1=Sun,2=Mon,...,7=Sat.  
** (where the bill-frequency = 'W' (weekly)
** (where bill-frequency = 'M' (monthly) this field is 1 -> 31
    representing the day of the month to bill on.
This is used during the "Get Shipments" function of invoice entry. For example, if the customer has BillDay = 4(Wed),  the Get Shipments function will select all the packing slips with a ship date that is less  than or equal to the latest Wednesday's date.
** The same also applies to monthly billing (1-31)  */  
   BillDay:number,
      /**  "Combine" Multiple Packing Slips into one Invoice.  NOTE: The field name does not correctly represent what this actually does !  This value is used during the "Get Shipments" function of invoice entry to control how invoices should be created when there are multiple packing slips for the same customer. Basically, if this value is YES then packing slips for the same Order, Fiscal Period are combined into a single invoice. If this value is NO then each packing slip will create a single invoice.  */  
   OneInvPerPS:boolean,
      /**  Default FOB policy for a customers orders.  Order Entry uses this as a default to OrderHed.FOB.  */  
   DefaultFOB:string,
      /**  Indicates that Open Orders are to be included in the credit limit checking. This checkbox will also include open service contracts.  */  
   CreditIncludeOrders:boolean,
      /**  Date that the next credit check should be made for that customer.  */  
   CreditReviewDate:string,
   CreditHoldDate:string,
   CreditHoldSource:string,
   CreditClearUserID:string,
   CreditClearDate:string,
   CreditClearTime:string,
      /**  This is the Trading Partner ID that is used for incoming and outgoing EDI.  */  
   EDICode:string,
      /**  EDI test mode.  When customers are first set up for EDI it is useful to send all documents in test mode so trading partners can verify the data before going into production mode.  */  
   EDITest:boolean,
      /**  Identifies which EDI package the customer is using.  If not null in must be valid in the EDITrnsl table.  */  
   EDITranslator:string,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**  Country part of address. This field is in sync with the Country field. Must be a valid entry in the Country table.  */  
   CountryNum:number,
      /**  Indicates the language to be used.  This controls which language will be selected when extracting part descriptions from PartLangDesc table.  */  
   LangNameID:string,
      /**  Area/city code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Country table.  This field is only visible if ISSyst.EnableHarbour is set.  */  
   BorderCrossing:string,
      /**  Optional Custom address format.  Controls the address format used on crystal forms.  */  
   FormatStr:string,
   BTName:string,
   BTAddress1:string,
   BTAddress2:string,
   BTAddress3:string,
   BTCity:string,
   BTState:string,
   BTZip:string,
      /**  Country part of Bill-to address. This field is in sync with the Country field. Must be a valid entry in the Country table.  */  
   BTCountryNum:number,
      /**  Country is used as part of the bill-to address. It can be left blank.  */  
   BTCountry:string,
      /**  The bill-to address Phone Number for the customer.  */  
   BTPhoneNum:string,
      /**  The bill-to address Fax telephone number for the customer. Optional field.  */  
   BTFaxNum:string,
      /**  Optional bill-to address format.  Controls the address format used on crystal forms.  */  
   BTFormatStr:string,
      /**  The unique Customer Number of the Parent.  */  
   ParentCustNum:number,
   TaxRegionCode:string,
      /**  This is an inter-company customer.  */  
   ICCust:boolean,
      /**  The day of the month that service contracts that are marked for recurring invoices are billed for this customer.  If the Invoice group invoice date is greater than or equal to this date then the invoice will be generated.  */  
   ContBillDay:number,
      /**  Email address of the customer.  */  
   EMailAddress:string,
      /**  Indicates if the customer has any qualifications on completeness of the order before it can be shipped. The valid values are; "O" - Order must be 100% complete,  "L" - Order Line must be 100% complete, "blank" - None.  This setting is a default for orders of a specific customer. See OrderHed.ShipOrderComplete, OrderDtl.ShipLineComplete  */  
   ShippingQualifier:string,
      /**  Code used to relate a AllocPri record to the customer.  This is used as a default to OrderHed.AllocPriCode for order for this customer.  */  
   AllocPriorityCode:string,
      /**  Used with Global alerts  */  
   LinkPortNum:number,
      /**  Indicates if this customer is for eCommerce.  Only Customers with this equal to YES will be synchronized between the Manufacturing System DB and StoreFront DB (VntgSF).  */  
   WebCustomer:boolean,
      /**   Describe the type of Customer this is.
SUS = Suspect
PRO =  Prospect
CUS = Customer  */  
   CustomerType:string,
      /**  Indicates that this contact is not included in marketing lists  */  
   NoContact:boolean,
      /**  This customers territory cannot be changed by any process that changes territories  */  
   TerritoryLock:boolean,
      /**  Customers Website URL .  */  
   CustURL:string,
      /**  The sales territory that the system will assign based on new values in the Sales territory boundary table.  */  
   PendingTerritoryID:string,
   ExtID:string,
      /**  APK - added for consolidation accross multiple SO's for the same customer  */  
   ConsolidateSO:boolean,
      /**  BillFrequency  */  
   BillFrequency:string,
      /**  Indicates that Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking.  */  
   CreditIncludePI:boolean,
      /**  Marks the customer as a global customer, available to be sent out to other companies  */  
   GlobalCust:boolean,
      /**  Owner Company Identifier.  */  
   GlbCompany:string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   CustID:string,
      /**  Indicates if this customer participates in the Inter-Company Trading.  */  
   ICTrader:boolean,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program. This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never need to know about the value of this field.  */  
   CustNum:number,
      /**  Indicates that Open Orders are to be included in the global credit limit checking. This checkbox will also include open service contracts.  */  
   GlobalCredIncOrd:boolean,
      /**  Indicates that Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking.  */  
   GlobalCredIncPI:boolean,
      /**  A unique code that identifies the currency.  */  
   GlobalCurrencyCode:string,
      /**  Indicates if customer has been placed into a "Global Credit Hold" status. Any non-blank value will trigger notification of this condition in Order Entry and Shipping.  */  
   GlobalCreditHold:string,
      /**  Disable this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  Original Owner Company Identifier. - NOT CURRENTLY IN USE  */  
   OldCompany:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This is the unique key in the original owner company - NOT CURRENTLY IN USE  */  
   OldCustNum:number,
      /**  A user defined external customer ID.  This must be unique within the file.  This is the unique key in the original owner company - NOT CURRENTLY IN USE  */  
   OldCustID:string,
      /**  Establishes the tax authority for this customer.  This field can be blank, but if entered, it must be valid in the TaxAuthorityCd file.  */  
   TaxAuthorityCode:string,
      /**  This flag indicates if an external delivery note is required for the customer.  This field is available only when send shipments for financial integration is turned on.  This will provide the default for the ShipHead record.  */  
   ExternalDeliveryNote:boolean,
   ExternalID:string,
   CheckDuplicatePO:boolean,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit.  Credit limit of zero is considered as having unlimited credit.  */  
   CreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit.  */  
   CustPILimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit limit.  Credit limit of zero is considered as having unlimited credit.  */  
   GlobalCreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit.  */  
   GlobalPILimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit limit.  Credit limit of zero is considered as having unlimited credit. Stored in Global Currency.  */  
   DocGlobalCreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit. Stored in Global currency  */  
   DocGlobalPILimit:number,
      /**  Indicates whether RFQ Attachments are allowed for this Customer  */  
   RfqAttachAllow:boolean,
      /**   The discount qualifier is primarily used when applying order value based discounts to the customer's sales orders.  The value of this field affects the discount percent given to the customer.  Here's the rule:
"MIN" = means that the default order discount percent is the minimum discount the customer could get as compared to the order value based discount.
"MAX" = means that the default order discount percent is the maximum discount the customer could get as compared to the order value based discount.
"ADD" = means that the customer could get the order value based discount in addition to the default order discount.  */  
   DiscountQualifier:string,
      /**  Indicates if the user chose to skip this record when linking global customers.  The user can come back at a later time and choose to link a skipped customer if they need to.  */  
   Skipped:boolean,
   AllowAltBillTo:boolean,
   ApplyChrg:boolean,
   ChrgAmount:number,
   COD:boolean,
   CODAmount:number,
   CODCheck:boolean,
   CODFreight:boolean,
   DeclaredAmt:number,
   DeclaredIns:boolean,
   DemandAddAction:string,
   DemandAddLeadTime:number,
   DemandAutoAccept:boolean,
   DemandCancelAction:string,
   DemandCancelLeadTime:number,
   DemandChangeAction:string,
   DemandChangeDateAction:string,
   DemandChangeDateLeadTime:number,
   DemandChangeLeadTime:number,
   DemandDateType:string,
   DemandDayOfWeek:number,
   DemandDeliveryDays:number,
   DemandNewLineAction:string,
   DemandNewLineLeadTime:number,
   DemandQtyChangeAction:string,
   DemandQtyChangeLeadTime:number,
   DemandUseSysDate:boolean,
   DocOnly:boolean,
   GroundType:string,
   Hazmat:boolean,
   NotifyEMail:string,
   NotifyFlag:boolean,
   RefNotes:string,
   ResDelivery:boolean,
   SatDelivery:boolean,
   SatPickup:boolean,
   TradingPartnerName:string,
   VerbalConf:boolean,
   PeriodicityCode:number,
   DeliveryType:string,
   ServAlert:boolean,
   ServAOD:boolean,
   ServAuthNum:string,
   ServDeliveryDate:string,
   ServHomeDel:boolean,
   ServInstruct:string,
   ServPhone:string,
   ServPOD:boolean,
   ServRef1:string,
   ServRef2:string,
   ServRef3:string,
   ServRef4:string,
   ServRef5:string,
   ServRelease:boolean,
   ServSatDelivery:boolean,
   ServSatPickup:boolean,
   ServSignature:boolean,
   CreditDays:number,
   EarlyBuffer:number,
   LateBuffer:number,
   OverrideCarrier:boolean,
   OverrideService:boolean,
   DemandUnitPriceDiff:boolean,
   DemandUnitPriceDiffAction:string,
   AddressVal:boolean,
   ExcFromVal:boolean,
   RebateForm:string,
   RebateVendorNum:number,
   CreditCardOrder:boolean,
   DemandCheckForPart:boolean,
   DemandCheckForPartAction:string,
   ChangeDate:string,
   ChangedBy:string,
   ChangeTime:number,
   ChargeCode:string,
   AddlHdlgFlag:boolean,
   CertOfOrigin:boolean,
   CommercialInvoice:boolean,
   DeliveryConf:number,
   ETCAddrChg:boolean,
   FFAddress1:string,
   FFAddress2:string,
   FFAddress3:string,
   FFCity:string,
   FFCompName:string,
   FFContact:string,
   FFCountry:string,
   FFCountryNum:number,
   FFID:string,
   FFPhoneNum:string,
   FFState:string,
   FFZip:string,
   IndividualPackIDs:boolean,
   IntrntlShip:boolean,
   LetterOfInstr:boolean,
   NonStdPkg:boolean,
   ShipExprtDeclartn:boolean,
   UPSQuantumView:boolean,
   UPSQVEmailType:string,
   UPSQVMemo:string,
   UPSQVShipFromName:string,
   ARCreditTotal:number,
   PICreditTotal:number,
   SOCreditTotal:number,
   TaxMethod:string,
   TaxRoundRule:number,
   AcrossNatAcc:boolean,
   NACreditIsShare:boolean,
   NACreditPreferenceList:string,
   NACreditSharedPrc:number,
   NAParentCreditIsUsed:boolean,
   NAParentCreditPrc:number,
   OverrideRlsClass:boolean,
   ValidPayer:boolean,
   ValidShipTo:boolean,
   ValidSoldTo:boolean,
   AllowOTS:boolean,
   ManagedVendID:string,
   ManagedVendNum:number,
   ThirdPLCust:boolean,
   NARlsClassCode:string,
   AutoGenPromNotes:boolean,
   DirectDebiting:boolean,
   PartPayment:boolean,
   ReservePriorityCode:string,
   NAParentsCreditUsed:number,
   NASharedCreditUsed:number,
   NAOwnCreditUsed:number,
   GlbNACreditIsShare:boolean,
   GlbNACreditSharedPrc:number,
   GlbNAParentCreditIsUsed:boolean,
   GlbNAParentCreditPrc:number,
   GlbNAParentsCreditUsed:number,
   GlbNASharedCreditUsed:number,
   ReminderCode:string,
   AllowShipTo3:boolean,
   NACreditUpdate:string,
   OTSSaveAs:string,
   CustPartOpts:string,
   HasBank:boolean,
   PMUID:number,
   DemandCheckForRev:boolean,
   DemandCheckForRevAction:string,
   OrderHoldForReview:boolean,
   ShipToTerrList:string,
   AcctRefNumber:string,
   DemandCheckCUMM:boolean,
   DemandCheckCUMMAction:string,
   DemandCloseNoMatch:boolean,
   DemandCloseRejSkd:boolean,
   DemandPricing:string,
   DmdCheckPartialShip:boolean,
   DmdCheckShipAction:string,
   InvPerPackLine:boolean,
   LegalName:string,
   OrgRegCode:string,
   OurBankCode:string,
      /**  Defines the tolerance for price difference validations  */  
   PriceTolerance:number,
   TaxRegReason:string,
   CheckConfirmCapPromise:boolean,
   CheckDateCapPromise:boolean,
   CheckUpdateCapPromise:boolean,
   DemandCapPromiseAction:string,
   DemandCapPromiseDate:string,
   DemandCapPromiseUpdate:string,
   DemandSplitSched:boolean,
   DueDateCriteria:string,
   ERSOrder:boolean,
   PBTerms:number,
   PeriodicBilling:boolean,
   PreferredBank:string,
   SICCode:number,
   ICCode:string,
   OTSmartString:boolean,
   DeferredRev:boolean,
   RACode:string,
   DemandCheckCfgAction:string,
   DemandCheckConfig:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  THBranchID  */  
   THBranchID:string,
      /**  CustPricingSchema  */  
   CustPricingSchema:string,
      /**  ParamCode  */  
   ParamCode:string,
      /**  AGAFIPResponsibilityCode  */  
   AGAFIPResponsibilityCode:string,
      /**  AGBillToProvinceCode  */  
   AGBillToProvinceCode:string,
      /**  AGGrossIncomeTaxID  */  
   AGGrossIncomeTaxID:string,
      /**  AGIDDocTypeCode  */  
   AGIDDocTypeCode:string,
      /**  AGIDDocumentNumber  */  
   AGIDDocumentNumber:string,
      /**  AGProvinceCode  */  
   AGProvinceCode:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  Collections  */  
   Collections:boolean,
      /**  CollectionsDate  */  
   CollectionsDate:string,
      /**  DateCollectionPosted  */  
   DateCollectionPosted:string,
      /**  MXMunicipio  */  
   MXMunicipio:string,
      /**  PEIdentityDocType  */  
   PEIdentityDocType:string,
      /**  PEDocumentID  */  
   PEDocumentID:string,
      /**  PEGoodsContributor  */  
   PEGoodsContributor:boolean,
      /**  PEWithholdAgent  */  
   PEWithholdAgent:boolean,
      /**  PECollectionAgent  */  
   PECollectionAgent:boolean,
      /**  PENotFound  */  
   PENotFound:boolean,
      /**  PENoAddress  */  
   PENoAddress:boolean,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  InvcOrderCmpDflt  */  
   InvcOrderCmpDflt:boolean,
      /**  EInvoice  */  
   EInvoice:boolean,
      /**  RegistrationCode  */  
   RegistrationCode:string,
      /**  EAddress  */  
   EAddress:string,
      /**  DemandCheckForRunOutPart  */  
   DemandCheckForRunOutPart:boolean,
      /**  DemandCheckForRunOutPartAction  */  
   DemandCheckForRunOutPartAction:string,
      /**  EInvCompanyIDAttr  */  
   EInvCompanyIDAttr:string,
      /**  INCSTNumber  */  
   INCSTNumber:string,
      /**  INPANNumber  */  
   INPANNumber:string,
      /**  COOneTimeID  */  
   COOneTimeID:string,
      /**  COIsOneTimeCust  */  
   COIsOneTimeCust:boolean,
      /**  DEOrgType  */  
   DEOrgType:string,
      /**  PEGuaranteeName  */  
   PEGuaranteeName:string,
      /**  PEGuaranteeAddress1  */  
   PEGuaranteeAddress1:string,
      /**  PEGuaranteeAddress2  */  
   PEGuaranteeAddress2:string,
      /**  PEGuaranteeAddress3  */  
   PEGuaranteeAddress3:string,
      /**  PEGuaranteeCity  */  
   PEGuaranteeCity:string,
      /**  PEGuaranteeState  */  
   PEGuaranteeState:string,
      /**  PEGuaranteeZip  */  
   PEGuaranteeZip:string,
      /**  PEGuaranteeCountry  */  
   PEGuaranteeCountry:string,
      /**  PEGuaranteePhoneNum  */  
   PEGuaranteePhoneNum:string,
      /**  PEGuaranteeTaxID  */  
   PEGuaranteeTaxID:string,
      /**  OurSupplierCode  */  
   OurSupplierCode:string,
      /**  ECCType  */  
   ECCType:string,
      /**  MYIndustryCode  */  
   MYIndustryCode:string,
      /**  SyncToExternalCRM  */  
   SyncToExternalCRM:boolean,
      /**  ExternalCRMGlbCustomerID  */  
   ExternalCRMGlbCustomerID:string,
      /**  ExternalCRMGlbCustomerType  */  
   ExternalCRMGlbCustomerType:string,
      /**  ExternalCRMLastSync  */  
   ExternalCRMLastSync:string,
      /**  ExternalCRMSyncRequired  */  
   ExternalCRMSyncRequired:boolean,
      /**  Ownership  */  
   Ownership:string,
      /**  Industry  */  
   Industry:string,
      /**  AnnualRevenue  */  
   AnnualRevenue:number,
      /**  NumberOfEmployees  */  
   NumberOfEmployees:number,
      /**  TickerLocation  */  
   TickerLocation:string,
      /**  TickerSymbol  */  
   TickerSymbol:string,
      /**  Rating  */  
   Rating:string,
      /**  TWGUIRegNum  */  
   TWGUIRegNum:string,
      /**  MXAccountNumber  */  
   MXAccountNumber:string,
      /**  ConsolidateLinesPerPart  */  
   ConsolidateLinesPerPart:boolean,
      /**  TWTaxPayerType  */  
   TWTaxPayerType:number,
      /**  TWDeductGUIFormatCode  */  
   TWDeductGUIFormatCode:string,
      /**  MXCURP  */  
   MXCURP:string,
      /**  PEAddressID  */  
   PEAddressID:string,
      /**  PEPerceptionRegime  */  
   PEPerceptionRegime:string,
      /**  TaxEntityType  */  
   TaxEntityType:string,
      /**  INGSTComplianceRate  */  
   INGSTComplianceRate:number,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  MXPurchaseType  */  
   MXPurchaseType:string,
      /**  SendToFSA  */  
   SendToFSA:boolean,
      /**  MXGeneralPublic  */  
   MXGeneralPublic:boolean,
      /**  AgingCreditHold  */  
   AgingCreditHold:boolean,
      /**  AgingCreditHoldDate  */  
   AgingCreditHoldDate:string,
      /**  AgingCreditHoldSource  */  
   AgingCreditHoldSource:string,
      /**  AgingCreditClearUserID  */  
   AgingCreditClearUserID:string,
      /**  AgingCreditClearDate  */  
   AgingCreditClearDate:string,
      /**  AgingCreditCode  */  
   AgingCreditCode:string,
      /**  ImporterOfRecord  */  
   ImporterOfRecord:boolean,
      /**  SEC  */  
   SEC:string,
      /**  EInvEndpointIDAttr  */  
   EInvEndpointIDAttr:string,
      /**  Indicates whether sales orders from this sold to customer should be treated as Blind Shipments by Manifest.  */  
   UseBlindShipping:boolean,
      /**  ELIEinvoice  */  
   ELIEinvoice:boolean,
      /**  ELIDefReportID  */  
   ELIDefReportID:string,
      /**  ELIDefStyleNum  */  
   ELIDefStyleNum:number,
      /**  ELIDefToMail  */  
   ELIDefToMail:string,
      /**  ELIDefCCMail  */  
   ELIDefCCMail:string,
      /**  ELIDefMailTempID  */  
   ELIDefMailTempID:string,
      /**  ELISendMail  */  
   ELISendMail:boolean,
      /**  COFiscalResp1  */  
   COFiscalResp1:string,
      /**  COFiscalResp2  */  
   COFiscalResp2:string,
      /**  COFiscalResp3  */  
   COFiscalResp3:string,
      /**  COOperType  */  
   COOperType:string,
      /**  Central Collection  */  
   CentralCollection:boolean,
      /**  NettingVendorNum  */  
   NettingVendorNum:number,
      /**  EORINumber  */  
   EORINumber:string,
      /**  AGIsElectronicCreditInvEligible  */  
   AGIsElectronicCreditInvEligible:boolean,
      /**  TaxValidationStatus  */  
   TaxValidationStatus:number,
      /**  TaxValidationDate  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Inactive  */  
   Inactive:boolean,
      /**  ExternalSchemeID  */  
   ExternalSchemeID:string,
      /**  ELIOperatorCode  */  
   ELIOperatorCode:string,
      /**  ELISendingOption  */  
   ELISendingOption:number,
      /**  ELIOperatorID  */  
   ELIOperatorID:string,
      /**  EInvExternalID  */  
   EInvExternalID:string,
      /**  MXTaxRegime  */  
   MXTaxRegime:string,
      /**  ExclusionMonth  */  
   ExclusionMonth:number,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMRegionCode  */  
   FSMRegionCode:string,
      /**  FSMArea  */  
   FSMArea:string,
      /**  ELIRcptDefStyleNum  */  
   ELIRcptDefStyleNum:number,
      /**  CovenantDiscPercent  */  
   CovenantDiscPercent:number,
   DisplayCustomerType:string,
      /**  Customer.CustID to link to (new or existing)  */  
   LinkCustID:string,
   DisplayHold:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbCustomerTableset{
   GlbCustomer:Erp_Tablesets_GlbCustomerRow[],
   GlbShipTo:Erp_Tablesets_GlbShipToRow[],
   GlbCustBillTo:Erp_Tablesets_GlbCustBillToRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_GlbShipToRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The unique key  of the Parent Customer record for the ShipTo.  */  
   CustNum:number,
      /**  The ID assigned by the user which makes this record unique for the customer. This field can't be blank.  */  
   ShipToNum:string,
      /**  Name of the ShipTo. When creating new records the Customer.Name is used as a default.  This can't be blank.  */  
   Name:string,
   Address1:string,
   Address2:string,
   Address3:string,
   City:string,
      /**  State ID for the ShipTo.  Can be blank.  */  
   State:string,
   ZIP:string,
      /**  The country is used as part of the mailing address. It can be left blank.  */  
   Country:string,
      /**  The State Tax Identification Number. Used in Order Entry, Prints on Sales Acknowledgements.  */  
   ResaleID:string,
      /**  Defines the default SalesRep for the specific customer ship to. Used to supply default to Order Entry and Invoice entry. The SalesRep from the customer master is used as an initial default when creating new ship to.  */  
   SalesRepCode:string,
      /**  Defines the  Sales Territory for this ShipTo. Can be blank or must  be valid in the Sales Territory master file.  */  
   TerritoryID:string,
      /**  Establishes a default  ShipVia code for the Shipto to be used by Order Entry, Shipping and Invoicing. This must be valid in the ShipVia master file. The shipvia from the customer record for this shipto is used as the initial default when creating new shipto records.  */  
   ShipViaCode:string,
      /**  Contains the key of the contact record which is to be considered as the Primary Shipping Contact. This field is not directly maintainable. Instead it is updated by the user marking the check box for "primary ship"  while in contact maintenance. This could be blank which indicates that there is no primary shipping contact. The primary shipping contact is used as a default in the shipping process.  */  
   PrimSCon:number,
      /**  Fax telephone number for the customer. Optional field.  Displayed by Order entry when no shipping contact is given or that contact has a blank phone number.  */  
   FaxNum:string,
      /**  Business Phone Number for the shipto location.. Displayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Indicates the reason why  customer is normally exempt from sales tax. Used as a default in invoice entry.  If field is non-blank it is considered exempt.   This code is totally user definable and no validation is required.  */  
   TaxExempt:string,
      /**  A mutually agreed upon value that links a customer's EDI shipto record (an N1 / ST) to the Manufacturing System DB ShipTo record.  */  
   EDIShipNum:string,
      /**  Country part of address. This field is in sync with the Country field. It must be a valid entry in the Country table.  */  
   CountryNum:number,
      /**  Indicates the language to be used.  This controls which language will be selected when extracting part descriptions from PartLangDesc table.  */  
   LangNameID:string,
      /**  Area/city code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Customer table. This field is only visible if ISSyst.EnableHarbour is set.  */  
   BorderCrossing:string,
      /**  Optional Custom address format.  Controls the address format used on crystal forms.  */  
   FormatStr:string,
   TaxRegionCode:string,
      /**  Email address of the Ship To.  */  
   EMailAddress:string,
      /**   There are 3 methods for Territory assignment in Ship-to:
"Sync" - Synchronize to The Customer table.  ShipTo.TerritoryID = Customer.TerritoryID
"Syst" - Let the System determine the Territory ID.
"Lock" - The user selects the territory manually and the system will not attempt to re-assign it.  */  
   TerritorySelect:string,
      /**  The sales territory that the system will assign based on new values in the Sales territory boundary table.  */  
   PendingTerritoryID:string,
      /**  Ship to record created from EDI.  */  
   CreatedByEDI:boolean,
      /**  Unique identifier from an external G/L interface  */  
   ExternalID:string,
      /**  Establishes the tax authority for this ship to.  This field can be blank, but if entered, it must be valid in the TaxAuthorityCd file.  */  
   TaxAuthorityCode:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This is the unique key in the owner company  */  
   GlbCustNum:number,
      /**  Owner Company Identifier.  */  
   GlbCompany:string,
   EDICode:string,
      /**  Global ShipToNumber.  This is the number in the parent company  */  
   GlbShipToNum:string,
      /**  Disable this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  Original Owner Company Identifier. - NOT CURRENTLY IN USE  */  
   OldCompany:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This is the unique key in the original owner company - NOT CURRENTLY IN USE  */  
   OldCustNum:number,
      /**  Original ShipToNumber.  This is the number in the original owner's parent company - NOT CURRENTLY IN USE  */  
   OldShipToNum:string,
      /**  Indicates if the user chose to skip this record when linking global ship tos.  The user can come back at a later time and choose to link a skipped ship to if they need to.  */  
   Skipped:boolean,
   ApplyChrg:boolean,
   ChrgAmount:number,
   COD:boolean,
   CODAmount:number,
   CODCheck:boolean,
   CODFreight:boolean,
   DeclaredAmt:number,
   DeclaredIns:boolean,
   DemandAddAction:string,
   DemandAddLeadTime:number,
   DemandAutoAccept:boolean,
   DemandCancelAction:string,
   DemandCancelLeadTime:number,
   DemandChangeAction:string,
   DemandChangeDateAction:string,
   DemandChangeDateLeadTime:number,
   DemandChangeLeadTime:number,
   DemandDateType:string,
   DemandDayOfWeek:number,
   DemandDeliveryDays:number,
   DemandNewLineAction:string,
   DemandNewLineLeadTime:number,
   DemandQtyChangeAction:string,
   DemandQtyChangeLeadTime:number,
   DemandUseSysDate:boolean,
   DocOnly:boolean,
   GroundType:string,
   Hazmat:boolean,
   NotifyEMail:string,
   NotifyFlag:boolean,
   RefNotes:string,
   ResDelivery:boolean,
   SatDelivery:boolean,
   SatPickup:boolean,
   TradingPartnerName:string,
   VerbalConf:boolean,
   PeriodicityCode:number,
   DeliveryType:string,
   ServAlert:boolean,
   ServAOD:boolean,
   ServAuthNum:string,
   ServDeliveryDate:string,
   ServHomeDel:boolean,
   ServInstruct:string,
   ServPhone:string,
   ServPOD:boolean,
   ServRef1:string,
   ServRef2:string,
   ServRef3:string,
   ServRef4:string,
   ServRef5:string,
   ServRelease:boolean,
   ServSatDelivery:boolean,
   ServSatPickup:boolean,
   ServSignature:boolean,
   DemandUseCustomerValues:boolean,
   EarlyBuffer:number,
   LateBuffer:number,
   OverrideCarrier:boolean,
   OverrideService:boolean,
   DemandUnitPriceDiff:boolean,
   DemandUnitPriceDiffAction:string,
   AddressVal:boolean,
   ExcFromVal:boolean,
   CertOfOrigin:boolean,
   CommercialInvoice:boolean,
   ConAddress1:string,
   ConAddress2:string,
   ConCity:string,
   ConCompName:string,
   ConContact:string,
   ConCountry:string,
   ConPhoneNum:string,
   ConsigneeID:string,
   ConState:string,
   ConZip:string,
   DemandCheckForPart:boolean,
   DemandCheckForPartAction:string,
   FFAddress1:string,
   FFAddress2:string,
   FFCity:string,
   FFCompName:string,
   FFContact:string,
   FFCountry:string,
   FFID:string,
   FFPhoneNum:string,
   FFState:string,
   FFZip:string,
   HazardousShipment:boolean,
   IntrntlShip:boolean,
   LetterOfInstr:boolean,
   ShipExprtDeclartn:boolean,
   ChangeDate:string,
   ChangedBy:string,
   ChangeTime:number,
   AddlHdlgFlag:boolean,
   DeliveryConf:number,
   ETCAddrChg:boolean,
   FFAddress3:string,
   FFCountryNum:number,
   IndividualPackIDs:boolean,
   NonStdPkg:boolean,
   UPSQuantumView:boolean,
   UPSQVEmailType:string,
   UPSQVMemo:string,
   UPSQVShipFromName:string,
   IsAlternate:boolean,
   MasterCustNum:number,
   MasterShipToNum:string,
   DemandCheckForRev:boolean,
   DemandCheckForRevAction:string,
   DemandCheckPartialShip:boolean,
   DemandCheckShipAction:string,
   DemandCloseRejSkd:boolean,
   DemandPricing:string,
   OrgRegCode:string,
      /**  Defines the tolerance for price difference validations  */  
   PriceTolerance:number,
   TaxRegReason:string,
   CheckConfirmCapPromise:boolean,
   CheckDateCapPromise:boolean,
   CheckUpdateCapPromise:boolean,
   DemandCapPromiseAction:string,
   DemandCapPromiseDate:string,
   DemandCapPromiseUpdate:string,
   SICCode:number,
   ICCode:string,
   OTSmartString:boolean,
   LegalName:string,
   DemandCheckCfgAction:string,
   DemandCheckConfig:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  DemandCheckForRunOutPart  */  
   DemandCheckForRunOutPart:boolean,
      /**  DemandCheckForRunOutPartAction  */  
   DemandCheckForRunOutPartAction:string,
      /**  INExciseRegNumber  */  
   INExciseRegNumber:string,
      /**  INVATNumber  */  
   INVATNumber:string,
      /**  INSTRegistration  */  
   INSTRegistration:string,
      /**  MXCURP  */  
   MXCURP:string,
      /**  MXMunicipio  */  
   MXMunicipio:string,
      /**  MXFederalID  */  
   MXFederalID:string,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  PEUBIGEOCode  */  
   PEUBIGEOCode:string,
      /**  EORINumber  */  
   EORINumber:string,
      /**  TaxValidationStatus  */  
   TaxValidationStatus:number,
      /**  TaxValidationDate  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Inactive  */  
   Inactive:boolean,
      /**  FSMRegionCode  */  
   FSMRegionCode:string,
      /**  FSMArea  */  
   FSMArea:string,
      /**  Local ShipToNum to LinkTo  */  
   LinkShipToNum:string,
      /**  Indicates if the record is linked  */  
   IsLinked:boolean,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_MXCustomerFiscalTextRow{
      /**  Company  */  
   Company:string,
      /**  CustNum  */  
   CustNum:number,
      /**  FiscalTextSeq  */  
   FiscalTextSeq:number,
      /**  TaxProv  */  
   TaxProv:string,
      /**  Rule  */  
   Rule:string,
      /**  FiscalText  */  
   FiscalText:string,
      /**  IncludeInXML  */  
   IncludeInXML:boolean,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_MangCustRow{
      /**  Unique CustNum of the managed customer.  */  
   CustNum:number,
      /**  Company Identifier.  */  
   Company:string,
      /**  The unique code that link this table to the Vendor Master table.  This represents a valid supplier for this managed customer.  */  
   VendorNum:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   CustNumCustID:string,
   CustNumBTName:string,
   CustNumName:string,
   VendorNumCity:string,
   VendorNumTermsCode:string,
   VendorNumCurrencyCode:string,
   VendorNumAddress2:string,
   VendorNumName:string,
   VendorNumCountry:string,
   VendorNumAddress3:string,
   VendorNumDefaultFOB:string,
   VendorNumAddress1:string,
   VendorNumVendorID:string,
   VendorNumZIP:string,
   VendorNumState:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_NAMemberRow{
   Company:string,
      /**  Code of RlsClass  */  
   RlsClassCode:string,
   TopCustNum:number,
   CustNum:number,
   TopCustID:string,
   Tiered:boolean,
   TopCustName:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PECustWhldHistRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Customer Number  */  
   CustNum:number,
      /**  Record Sequence  */  
   RecordSeq:number,
      /**  Create Date  */  
   CreateDate:string,
      /**  User Identifier.  */  
   UserID:string,
      /**  Good Contributor  */  
   GoodContributor:boolean,
      /**  Indicates the status of Withholding Agent.  */  
   WithholdingAgent:boolean,
      /**  Collection Agent withholding status.  */  
   CollectionAgent:boolean,
      /**  Not Found withholding status.  */  
   NotFound:boolean,
      /**  No Address Provided withholding status.  */  
   NoAddress:boolean,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartnerRow{
      /**  Company  */  
   Company:string,
      /**  PartnerNum  */  
   PartnerNum:number,
      /**  PartnerType  */  
   PartnerType:number,
      /**  SearchID  */  
   SearchID:string,
      /**  IsActive  */  
   IsActive:boolean,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
      /**  PartnerID  */  
   PartnerID:string,
   DspSearchID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToAttchRow{
   Company:string,
   CustNum:number,
   ShipToNum:string,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToDiscPriceLstRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   CustNum:number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   ShipToNum:string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   SeqNum:number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   ListCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PriceListStartDate:string,
   PriceListEndDate:string,
   PriceListListDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToLabExpRateRow{
      /**  Company  */  
   Company:string,
      /**  CustNum  */  
   CustNum:number,
      /**  ShipToNum  */  
   ShipToNum:string,
      /**  ExpenseCode  */  
   ExpenseCode:string,
      /**  RateType  */  
   RateType:number,
      /**  RateMultiplier  */  
   RateMultiplier:number,
      /**  FixedRate  */  
   FixedRate:number,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
   BitFlag:number,
   ShipToShipToNum:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToMFBillRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   ShipToNum:string,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   PayBTFlag:string,
      /**   Describes the billing type.  Valid values and their description are:
1 - Shipper
2 - FedEx  Collect
3 - Third Party
4 - UPS Prepaid
5 - FedEx Recipient
6 - UPS Consignee
7 - UPS Freight Collect
8 - UPS Free On Board
9 - UPS Cost and Freight
10 - UPS Delivery Duty Paid
11 - UPS Shpping Duty and Tax Consignee  */  
   PayTypeDesc:string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   PayAccount:string,
      /**  Shipping Billing Address  */  
   PayBTAddress1:string,
      /**  Shipping biling address line 2  */  
   PayBTAddress2:string,
      /**  Shipping biling address line 3.  */  
   PayBTAddress3:string,
      /**  Shipping billing city  */  
   PayBTCity:string,
      /**  Shipping Billing state or province  */  
   PayBTState:string,
      /**  Manifest billing postal code  */  
   PayBTZip:string,
      /**  Shipping biling country  */  
   PayBTCountry:string,
      /**  Internal field used to store the country number.  */  
   PayBTCountryNum:number,
      /**  Shipping billing phone number  */  
   PayBTPhone:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToPriceLstRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  */  
   CustNum:number,
      /**  This is the ShipToNum of the Customer Ship To.  */  
   ShipToNum:string,
      /**  This is the sequence or hierarchy of the price list codes associated with the ship to.  The lower the number the higher the priority is in the hierarchy.  */  
   SeqNum:number,
      /**  Unique set of characters entered by the user to identify the Price List master within the company.  */  
   ListCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PriceListListDescription:string,
   PriceListStartDate:string,
   PriceListEndDate:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToRestrictionRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   CustNum:number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   ShipToNum:string,
      /**  Restriction Type identification.  */  
   RestrictionTypeID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   CustNumName:string,
   CustNumCustID:string,
   CustNumBTName:string,
   RestrictionTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   CustNum:number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   ShipToNum:string,
      /**  Name of the ShipTo. When creating new records the Customer.Name is used as a default.  */  
   Name:string,
      /**  The first line of the ShipTo address.  */  
   Address1:string,
      /**  The second line of the ShipTo address.  */  
   Address2:string,
      /**  The third line of the ShipTo address.  */  
   Address3:string,
      /**  The city portion of the ShipTo address.  */  
   City:string,
      /**  The state or province portion of the ShipTo address.  */  
   State:string,
      /**  The zip or postal code portion of the ShipTo address.  */  
   ZIP:string,
      /**  The country portion of the ShipTo address.  */  
   Country:string,
      /**  The State Tax Identification Number. Used in Order Entry and prints on Sales Acknowledgements.  */  
   ResaleID:string,
      /**  The SalesRep.SalesRepCode value of the default salesperson for the customer. Used as a default in Order Entry and Invoice entry. The SalesRep from the customer master is used as an initial default when creating new ship to.  */  
   SalesRepCode:string,
      /**  The SalesTer.TerritoryID value of the territory the customer is assigned to.  */  
   TerritoryID:string,
      /**  The ShipVia.ShipViaCode value of the default ShipVia assigned to the customer. Used as a default in Order Entry, Shipping and Invoicing.  The shipvia from the customer record for this shipto is used as the initial default when creating new ShipTo records.  */  
   ShipViaCode:string,
      /**  The CustCnt.ConNum of the default shipping contact for the ShipTo location. The primary shipping contact is used as a default in the shipping process.  */  
   PrimSCon:number,
      /**  The fax number for the ShipTo location. isplayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   FaxNum:string,
      /**  The business phone number for the ShipTo location. Displayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Determines whether or not the ShipTo location is normally exempt from sales tax. Used as a default in invoice entry.  If the field is non-blank it is considered exempt.   This code is totally user definable and no validation is required.  */  
   TaxExempt:string,
      /**  A mutually agreed upon value that links a customer's EDI shipto record (an N1 / ST) to the Manufacturing System DB ShipTo record.  */  
   EDIShipNum:string,
      /**  The Country.CountryNum value of the country selected in the ShipTo.Country field.  */  
   CountryNum:number,
      /**  The LangName.LangNameID value of the default Language assigned to the ShipTo location. This controls which language will be selected when extracting part descriptions from PartLangDesc table.  */  
   LangNameID:string,
      /**  Area/city code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Customer table. This field is only visible if ISSyst.EnableHarbour is set.  */  
   BorderCrossing:string,
      /**  Optional custom address format for the ShipTo location.  */  
   FormatStr:string,
      /**  Contains the TaxRgn.TaxRegionCode value of the customer's tax region for purposes of Sales Tax calculations.  */  
   TaxRegionCode:string,
      /**  The email address of the ShipTo location.  */  
   EMailAddress:string,
      /**   Determines how the ShipTo location should be assigned to a territory. There are 3 methods for Territory assignment in Ship-to:

Sync - Keep the ShipTo territory synchronized with the territory on the
       main customer record. (ShipTo.TerritoryID = Customer.TerritoryID)
Syst - Let the system (Get Territory) determine the territory to assign         to the ShipTo based on territory boundaries.
Lock - Check this method after assigning the territory manually to 
       prevent the system from attempting to reassign the territory.  */  
   TerritorySelect:string,
      /**  The pending sales territory that the customer will be assigned to based on changes to the territory boundaries.  This functionality is only available with the CRM module.  */  
   PendingTerritoryID:string,
      /**  Determines whether or not the ShipTo record was created by an EDI transaction.  */  
   CreatedByEDI:boolean,
      /**  Unique identifier of the ShipTo from an external General Ledger interface such as the EuroFinancial integration.  */  
   ExternalID:string,
      /**  The TaxAuthorityCd.TaxAuthorityCode value of the Tax Authority assigned to this ShipTo location.  */  
   TaxAuthorityCode:string,
      /**  Disable this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  Days to use in calculating the Order Detail Ship By date from the incoming need by date.  */  
   DemandDeliveryDays:number,
      /**   Indicates incoming date type.  Values are:
S - Shipping Date
N - Need By Date  */  
   DemandDateType:string,
      /**  The number of days from today to give a warning when adding a new order release record from an incoming shipping schedule.  */  
   DemandAddLeadTime:number,
      /**  Indicates what type of action to take if the add lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandAddAction:string,
      /**  The number of days from today to give a warning when changing an order release record from an incoming shipping schedule.  This does not include changes to quantity or dates.  */  
   DemandChangeLeadTime:number,
      /**  Indicates what type of action to take if the change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeAction:string,
      /**  The number of days from today to give a warning when canceling an order release record from an incoming shipping schedule.  */  
   DemandCancelLeadTime:number,
      /**  Indicates what type of action to take if the cancel lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandCancelAction:string,
      /**  The number of days from today to give a warning when adding a new order line record from an incoming shipping schedule.  */  
   DemandNewLineLeadTime:number,
      /**  Indicates what type of action to take if the new line lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandNewLineAction:string,
      /**  The number of days from today to give a warning when changing the quantity on an order release record from an incoming shipping schedule.  */  
   DemandQtyChangeLeadTime:number,
      /**  Indicates what type of action to take if the quantity change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandQtyChangeAction:string,
      /**  The number of days from today to give a warning when changing the date on an order release record from an incoming shipping schedule.  */  
   DemandChangeDateLeadTime:number,
      /**  Indicates what type of action to take if the change date lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeDateAction:string,
      /**  The trading partner name.  */  
   TradingPartnerName:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  Periodicity Code.  Must be a valid code in the Periodicity table.  */  
   PeriodicityCode:number,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Added for international shipping, Is a commercial invoice required  */  
   CommercialInvoice:boolean,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Added for international shipping. Shipper's Export Declaration required  */  
   ShipExprtDeclartn:boolean,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  For International shipping.  Certificate of Orgin required.  */  
   CertOfOrigin:boolean,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  For International shipping.  Shipper's Letter of Instruction.  */  
   LetterOfInstr:boolean,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  International Shipping - HazardousShipment  */  
   HazardousShipment:boolean,
      /**  Override Carrier Defaults.  If not checked then the customer values will be used if overriden else the Site values  */  
   OverrideCarrier:boolean,
      /**  Is this an International shipment  */  
   IntrntlShip:boolean,
      /**  Override Service Options.  If not checked then the customer values will be used if overriden else the Site values  */  
   OverrideService:boolean,
      /**  Indicates if the demand fields from the customer should be used.  */  
   DemandUseCustomerValues:boolean,
      /**  Tax Payer Registration Reason Code  */  
   TaxRegReason:string,
      /**  Used to calculate on-time delivery performance rating  */  
   EarlyBuffer:number,
      /**  Organization Registration Code  */  
   OrgRegCode:string,
      /**  Used to calculate on-time delivery performance rating  */  
   LateBuffer:number,
      /**  Indicates if the unit price between the demand and the contract should be validated.  If this flag is checked, and the prices are different, when the demand is accepted a record will be written to the DemandLog table.  */  
   DemandUnitPriceDiff:boolean,
      /**  Indicates what type of action to take if the unit price between the demand and the contract is different.  Options are B (reject the change) or W (warning - alert that the unit price is different but allow the record to be accepted).  */  
   DemandUnitPriceDiffAction:string,
      /**  A flag that indicates whether this address should be validated by the tax service.  */  
   ExcFromVal:boolean,
      /**  A flag indicating that an address has already been validated. This helps improve the performance of the bulk address validation process by allowing address that have already been validated to be skipped. This flag is set anytime a successful validation is performed, either by the bulk address validation or validation from the Customer form.  */  
   AddressVal:boolean,
      /**  Check for the part in the Part master.  */  
   DemandCheckForPart:boolean,
      /**  Indicates what type of action to take if the Check for Part options is selected and the part is not in the part master file.  Options are B (reject the change) or W (warning - alert that the part is not in the part master but allow the record to be accepted).  */  
   DemandCheckForPartAction:string,
      /**  International Shipping. Frieght Forwarder ID  */  
   FFID:string,
      /**  International Shipping. The first line of the Frieght Forwarder main address.  */  
   FFAddress1:string,
      /**  International Shipping. The second line of the Frieght Forwarder main address.  */  
   FFAddress2:string,
      /**  Shipping, The city portion of the Frieght Forwarder main address.  */  
   FFCity:string,
      /**  International Shipping. The state or province portion of the shipment Frieght Forwarder main address.  */  
   FFState:string,
      /**  International Shipping. The zip or postal code portion of the shipping Frieght Forwarder main address.  */  
   FFZip:string,
      /**  International shipping. The country of the Frieght Forwarder .  */  
   FFCountry:string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   FFContact:string,
      /**  International Shipping. Frieght Forwarder company name  */  
   FFCompName:string,
      /**  International Shipping. Frieght Forwarder Phone number  */  
   FFPhoneNum:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Individual Pack IDs  */  
   IndividualPackIDs:boolean,
      /**  Freight Forwarder Third address line  */  
   FFCountryNum:number,
      /**  Additional Handling flag  */  
   NonStdPkg:boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Non Standard Packaging  */  
   AddlHdlgFlag:boolean,
      /**  UPS Quantum View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View From Name  */  
   UPSQVShipFromName:string,
      /**  UPS Quantum View Memo  */  
   UPSQVMemo:string,
      /**  Freight Forwarder Country portion of the address  */  
   FFAddress3:string,
      /**  Used to determine if an address changed because of the tax integration.  If true, the tax integration changed the address.  */  
   ETCAddrChg:boolean,
      /**  Indicates if this is a alternate ShipTo. An alternate is a Shipto that is valid for this customer, but is defined/maintained by the "master" customer. See ShipTo.MasterCustNum/MasterShiptoNum.  */  
   IsAlternate:boolean,
      /**  Pertains to Alternate Shipto (IsAlternate). Contains the CustNum of the Shipto record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterCustNum:number,
      /**  Pertains to Alternate Shipto (IsAlternate). Contains the ShipToNum of the Shipto record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterShipToNum:string,
      /**  Check for Revision  */  
   DemandCheckForRev:boolean,
      /**  Check for Revision Action  */  
   DemandCheckForRevAction:string,
      /**  Flag for checking partial Shipment for Demand Entry.  */  
   DemandCheckPartialShip:boolean,
      /**  Check Partial Shipments Action: B =Stop  and W = Warning  */  
   DemandCheckShipAction:string,
      /**  Define if at the moment of processing a demand the process should also close those rejected schedules that remain at demand entry  */  
   DemandCloseRejSkd:boolean,
      /**  Defines if Internal Pricing or Customer Pricing will be used for checking price differences  */  
   DemandPricing:string,
      /**  Defines the tolerance for price difference validations  */  
   PriceTolerance:number,
      /**  If this flags is turned on then Demand CTP will automatically be executed as a part of the demand to order process.  */  
   CheckDateCapPromise:boolean,
      /**  Confirm or not the Capable to Promise jobs from Demand Entry  */  
   CheckConfirmCapPromise:boolean,
      /**  If checked, Updates the date in Demand Entry  */  
   CheckUpdateCapPromise:boolean,
      /**  This field will define the dates that will be validated as a part of the demand to order process. The valid values for this combo will be:  Need By (N), Ship By (S) and Both (B)  */  
   DemandCapPromiseDate:string,
      /**  The value on this field will define the action to be taken when validating CTP. The valid values for this combo box will be: Warning (W) and Stop (S)  */  
   DemandCapPromiseAction:string,
      /**   This field will define the dates that will be updated as a part of the demand to order process. The valid options will be:
Need By (N), Ship By (S) and Both  (B) NOTE .-In all the cases above the update of date will only be done if the CTP dates are beyond the dates on the file.  */  
   DemandCapPromiseUpdate:string,
      /**  When set to TRUE the smart string functionality will only be processed when the incoming demand is new. After it has been processed and saved, if a retransmission is sent the smart string values will be ignored.  */  
   OTSmartString:boolean,
      /**  Full Legal name  */  
   LegalName:string,
      /**  If true then demand will be rejected when one or more demand lines are not configured properly. Applies only to Configurable parts.  */  
   DemandCheckConfig:boolean,
      /**  Indicates the action to be taken if configuration values have not been entered for one or more demand lines.  */  
   DemandCheckCfgAction:string,
      /**  WIWebShipTo  */  
   WIWebShipTo:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  AGApartment  */  
   AGApartment:string,
      /**  AGExtraStreetNumber  */  
   AGExtraStreetNumber:string,
      /**  AGFloor  */  
   AGFloor:string,
      /**  AGGrossIncomeTaxID  */  
   AGGrossIncomeTaxID:string,
      /**  AGLocationCode  */  
   AGLocationCode:string,
      /**  AGNeighborhood  */  
   AGNeighborhood:string,
      /**  AGProvinceCode  */  
   AGProvinceCode:string,
      /**  AGStreet  */  
   AGStreet:string,
      /**  AGStreetNumber  */  
   AGStreetNumber:string,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  Check if the part is a run out part.  */  
   DemandCheckForRunOutPart:boolean,
      /**  Indicates what type of action to take if the Check for Run Out Part option is selected and the part is marked as a run out part.  Options are B (reject the change) or W (warning - alert that the part is marked as run out but allow the record to be accepted).  */  
   DemandCheckForRunOutPartAction:string,
      /**  INExciseRegNumber  */  
   INExciseRegNumber:string,
      /**  INVATNumber  */  
   INVATNumber:string,
      /**  INSTRegistration  */  
   INSTRegistration:string,
      /**  MXCURP  */  
   MXCURP:string,
      /**  MXMunicipio  */  
   MXMunicipio:string,
      /**  MXFederalID  */  
   MXFederalID:string,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  Geographical Location Code  */  
   PEUBIGEOCode:string,
      /**  EORI Number  */  
   EORINumber:string,
      /**  Tax ID Validation Status: Not Validated – 0, Valid – 1, Invalid – 2.  */  
   TaxValidationStatus:number,
      /**  Tax Validation Date  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Indicates if the record is inactive.  */  
   Inactive:boolean,
      /**  FSMRegionCode  */  
   FSMRegionCode:string,
      /**  FSMArea  */  
   FSMArea:string,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
      /**  Used for ContactTracker.  This is needed so the UI can relate the Contact Tracker tables together.  */  
   ContactName:string,
      /**  Display Format String  */  
   DspFormatStr:string,
      /**  Indicates if ShipTo is Global (Master or Linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany, GlbCustNum and GlbShipto that is linking to this shipto  */  
   GlbLink:string,
      /**  Indicates Integration with financial package (like EuroFin)  */  
   IntegrationFlag:boolean,
      /**  Flag used for integrations whether to run the on change country logic.  */  
   IntRunChangeCountry:boolean,
   PeriodicityDesc:string,
      /**  List of available Periodicity values  */  
   PeriodicityList:string,
      /**  Used to indicate if primary shipto.  Updates Customer.ShipToNum field  */  
   PrimaryShipTo:boolean,
      /**  Sales Tax ID  */  
   SalesTaxID:string,
      /**  Service Tax ID  */  
   ServiceTaxID:string,
   TerritorySelectDescription:string,
      /**  Use this field to display/update; replaces TerritorySelect  */  
   TerrSelectFlag:string,
      /**  Address in formatted delimited list  */  
   AddrList:string,
   LanguageDescription:string,
      /**  Area of ISTMO de Tehuantepec (Polos de Desarrollo). Value is from MXLocISTMO User Code.  */  
   MXISTMO:string,
   BitFlag:number,
   AGLocationDescription:string,
   AGProvinceDescription:string,
   CountryISOCode:string,
   CountryEUMember:boolean,
   CustNumName:string,
   CustNumCustID:string,
   CustNumBTName:string,
   DeliveryTypeDescription:string,
   MasterCustIDBTName:string,
   MasterCustIDCustID:string,
   MasterCustIDName:string,
   SalesRepName:string,
   ShipViaWebDesc:string,
   ShipViaDescription:string,
   TATaxAuthorityDescription:string,
   TaxRegionDescription:string,
   TerritoryTerritoryDesc:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToSrchRow{
   Company:string,
   CustNum:number,
   ShipToID:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToUPSEmlRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   ShipToNum:string,
      /**  UPS Quantum View Sequence  */  
   UPSQVSeq:number,
      /**  Email address to notify for a UPS shipment  */  
   EmailAddress:string,
      /**  Logical indicating if the EmailAddress is to be updated at shipping.  */  
   ShipmentNotify:boolean,
      /**  Logical indicating if the Email Address is to be notified of a failed shipment.  */  
   FailureNotify:boolean,
      /**  Logical indicating if the Email Address is to be notified of delivery.  */  
   DeliveryNotify:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Logical indicating whether or not the UPS Quantum View fields are to be enabled.  */  
   EnableQuantumView:boolean,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_TaxExemptRow{
      /**  Company Identifier.  */  
   Company:string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   RelatedToFile:string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   Key1:string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   Key2:string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   TaxCode:string,
      /**  Tax Rate Code  */  
   RateCode:string,
      /**  Exemption Effective Start Date  */  
   EffectiveFrom:string,
      /**  Exemption Effective End Date  */  
   EffectiveTo:string,
      /**  Exemption Type  */  
   ExemptType:number,
      /**  Exemption Percent  */  
   ExemptPercent:number,
      /**  Tax Legal Text Code  */  
   TextCode:string,
      /**  Tax Resolution Number  */  
   ResolutionNum:string,
      /**  Tax Resolution Date  */  
   ResolutionDate:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  A unique Customer identifier.  */  
   CustNum:number,
      /**  The PartNum field identifies the Part.  */  
   PartNum:string,
      /**  A unique Vendor identifier.  */  
   VendorNum:number,
   BitFlag:number,
   SalesTaxDescription:string,
   SalesTRCDescription:string,
   TaxTextDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_UpdExtCustomerTableset{
   Customer:Erp_Tablesets_CustomerRow[],
   CustomerAttch:Erp_Tablesets_CustomerAttchRow[],
   CustomCrdPool:Erp_Tablesets_CustomCrdPoolRow[],
   Partner:Erp_Tablesets_PartnerRow[],
   CustBillTo:Erp_Tablesets_CustBillToRow[],
   CustBank:Erp_Tablesets_CustBankRow[],
   CustChild:Erp_Tablesets_CustChildRow[],
   CustDfltDocType:Erp_Tablesets_CustDfltDocTypeRow[],
   CustIC:Erp_Tablesets_CustICRow[],
   CustLabExpRate:Erp_Tablesets_CustLabExpRateRow[],
   CustMandate:Erp_Tablesets_CustMandateRow[],
   CustomerDocs:Erp_Tablesets_CustomerDocsRow[],
   CustRestriction:Erp_Tablesets_CustRestrictionRow[],
   CustUPSEmail:Erp_Tablesets_CustUPSEmailRow[],
   CustomerDiscPriceLst:Erp_Tablesets_CustomerDiscPriceLstRow[],
   CustomerFSPriceList:Erp_Tablesets_CustomerFSPriceListRow[],
   GlbCustCred:Erp_Tablesets_GlbCustCredRow[],
   MXCustomerFiscalText:Erp_Tablesets_MXCustomerFiscalTextRow[],
   NAMember:Erp_Tablesets_NAMemberRow[],
   PECustWhldHist:Erp_Tablesets_PECustWhldHistRow[],
   ShipTo:Erp_Tablesets_ShipToRow[],
   ShipToAttch:Erp_Tablesets_ShipToAttchRow[],
   ShipToRestriction:Erp_Tablesets_ShipToRestrictionRow[],
   ShipToLabExpRate:Erp_Tablesets_ShipToLabExpRateRow[],
   CustomerDocsSH:Erp_Tablesets_CustomerDocsSHRow[],
   ShipToDiscPriceLst:Erp_Tablesets_ShipToDiscPriceLstRow[],
   ShipToMFBill:Erp_Tablesets_ShipToMFBillRow[],
   ShipToPriceLst:Erp_Tablesets_ShipToPriceLstRow[],
   ShipToUPSEml:Erp_Tablesets_ShipToUPSEmlRow[],
   CustMFBill:Erp_Tablesets_CustMFBillRow[],
   MangCust:Erp_Tablesets_MangCustRow[],
   ShipToSrch:Erp_Tablesets_ShipToSrchRow[],
   CustomerPriceLst:Erp_Tablesets_CustomerPriceLstRow[],
   EntityGLC:Erp_Tablesets_EntityGLCRow[],
   TaxExempt:Erp_Tablesets_TaxExemptRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

   /** Required : 
      @param custNum
   */  
export interface GenerateMandateReference_input{
      /**  Customer Num  */  
   custNum:number,
}

export interface GenerateMandateReference_output{
parameters : {
      /**  output parameters  */  
   mandateReference:string,
}
}

export interface GetAddrElementList_output{
parameters : {
      /**  output parameters  */  
   addrElementList:string,
}
}

   /** Required : 
      @param custNum
      @param ds
   */  
export interface GetAllShipTo_input{
      /**  CustNum of the customer for the Ship To  */  
   custNum:number,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface GetAllShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param CustID
      @param ShipToNum
      @param MasterCustNum
      @param MasterShipToNum
   */  
export interface GetAltShipTo_input{
      /**  CustID of the customer for the Ship To  */  
   CustID:string,
      /**  ShipToNum of the ShipTo to return  */  
   ShipToNum:string,
      /**  Alternate CustNum of the customer for the Ship To  */  
   MasterCustNum:number,
      /**  Alternate ShipToNum of the ShipTo to return  */  
   MasterShipToNum:string,
}

export interface GetAltShipTo_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

export interface GetBankAccountList_output{
parameters : {
      /**  output parameters  */  
   opBankAccountList:string,
}
}

   /** Required : 
      @param billFreq
   */  
export interface GetBillDayList_input{
      /**  The Customer Billing Frequency "W"eekly or "M"onthly  */  
   billFreq:string,
}

export interface GetBillDayList_output{
parameters : {
      /**  output parameters  */  
   billDayList:string,
}
}

   /** Required : 
      @param CustID
   */  
export interface GetBillToRefs_input{
      /**  Current CustID  */  
   CustID:string,
}

export interface GetBillToRefs_output{
   returnObj:Erp_Tablesets_BillToRefsTableset[],
}

   /** Required : 
      @param custID
      @param withShipTo
   */  
export interface GetByCustID_input{
      /**  The customer character ID  */  
   custID:string,
      /**  Indicates if shipTo should be retrieved or not  */  
   withShipTo:boolean,
}

export interface GetByCustID_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param custNum
   */  
export interface GetByID_input{
   custNum:number,
}

export interface GetByID_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param id
   */  
export interface GetBySysRowID_input{
   id:string,
}

export interface GetBySysRowID_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param ids
   */  
export interface GetBySysRowIDs_input{
   ids:string,
}

export interface GetBySysRowIDs_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param tableName
      @param fieldName
   */  
export interface GetCodeDescList_input{
   tableName:string,
   fieldName:string,
}

export interface GetCodeDescList_output{
   returnObj:string,
}

export interface GetCompanyDataForMandate_output{
parameters : {
      /**  output parameters  */  
   name:string,
   address1:string,
   address2:string,
   address3:string,
   city:string,
   zip:string,
   countrynum:number,
}
}

   /** Required : 
      @param CustID
   */  
export interface GetCustBillToForLink_input{
      /**  CustID field on the GlbCustomer record  */  
   CustID:string,
}

export interface GetCustBillToForLink_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param CustNum
      @param BTCustNum
   */  
export interface GetCustBillToGlobalFields_input{
   CustNum:number,
   BTCustNum:number,
}

export interface GetCustBillToGlobalFields_output{
   returnObj:string,
}

   /** Required : 
      @param custNum
      @param getDefaultShipTo
      @param getShipToNums
      @param shipToNum
   */  
export interface GetCustomerAndOptionalShipTo_input{
      /**  Customer Number  */  
   custNum:number,
      /**  Indicates whether the customer default (blank ShipToNum) should be retrieved  */  
   getDefaultShipTo:boolean,
      /**  Indicates whether a non-default ShipToNum should be retrieved  */  
   getShipToNums:boolean,
      /**  If getShipToNums = true this is the ShipToNum that will be retrieved with the Customer record  */  
   shipToNum:string,
}

export interface GetCustomerAndOptionalShipTo_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param custNum
   */  
export interface GetCustomerCountryISOCode_input{
      /**  customer Num  */  
   custNum:number,
}

export interface GetCustomerCountryISOCode_output{
      /**  Country ISO Code  */  
   returnObj:string,
}

   /** Required : 
      @param custnum
   */  
export interface GetCustomerDataForMandate_input{
      /**  Customer Num  */  
   custnum:number,
}

export interface GetCustomerDataForMandate_output{
parameters : {
      /**  output parameters  */  
   name:string,
   address1:string,
   address2:string,
   address3:string,
   city:string,
   zip:string,
   countrynum:number,
}
}

   /** Required : 
      @param partOptionSelList
      @param tableName
   */  
export interface GetCustomerDocsPartOptionAvailList_input{
      /**  List of selected options  */  
   partOptionSelList:string,
      /**  CustomerDocs or CustomerDocsSH  */  
   tableName:string,
}

export interface GetCustomerDocsPartOptionAvailList_output{
parameters : {
      /**  output parameters  */  
   partOptionAvailList:string,
}
}

   /** Required : 
      @param CustID
   */  
export interface GetCustomerForLink_input{
      /**  LinkCustID field on the GlbCustomer record to link  */  
   CustID:string,
}

export interface GetCustomerForLink_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param CustNum
      @param GlobalLock
   */  
export interface GetCustomerGlobalFields_input{
   CustNum:number,
   GlobalLock:boolean,
}

export interface GetCustomerGlobalFields_output{
   returnObj:string,
}

   /** Required : 
      @param custNum
   */  
export interface GetCustomerSettlementDay_input{
   custNum:number,
}

export interface GetCustomerSettlementDay_output{
   returnObj:Erp_Tablesets_CustSettlementDayTableset[],
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetCustomerTerritory_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  Customer.CustNum  */  
   custNum:number,
}

export interface GetCustomerTerritory_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

export interface GetCustomerUIDefaults_output{
parameters : {
      /**  output parameters  */  
   defaultValues:string,
   disabledFields:string,
}
}

   /** Required : 
      @param CustID
   */  
export interface GetCustomer_input{
      /**  CustID of the customer to return  */  
   CustID:string,
}

export interface GetCustomer_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

export interface GetDisabledFields_output{
parameters : {
      /**  output parameters  */  
   FieldList:string,
}
}

export interface GetECCTypesList_output{
   returnObj:string,
}

export interface GetEnableSettlementFeature_output{
   returnObj:boolean,
}

export interface GetExternalCRMIntegrationIsEnabled_output{
   returnObj:boolean,
}

   /** Required : 
      @param GlbCustNumList
   */  
export interface GetGlbCustomerList_input{
      /**  Delimited list of GlbCustNum values  */  
   GlbCustNumList:string,
}

export interface GetGlbCustomerList_output{
   returnObj:Erp_Tablesets_GlbCustomerTableset[],
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetHMRCValidationLog_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetHMRCValidationLog_output{
   returnObj:string,
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param whereClause
      @param groupID
      @param pageSize
      @param absolutePage
   */  
export interface GetListARBankRemittanceSlip_input{
      /**  whereClause  */  
   whereClause:string,
      /**  CashHeadImport GroupID  */  
   groupID:string,
   pageSize:number,
   absolutePage:number,
}

export interface GetListARBankRemittanceSlip_output{
   returnObj:Erp_Tablesets_CustomerListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param groupID
      @param headNum
      @param pageSize
      @param absolutePage
   */  
export interface GetListARRemittanceSlip_input{
      /**  whereClause  */  
   whereClause:string,
      /**  CashHeadImport GroupID  */  
   groupID:string,
      /**  CashHead.HeadNum (optional)  */  
   headNum:number,
   pageSize:number,
   absolutePage:number,
}

export interface GetListARRemittanceSlip_output{
   returnObj:Erp_Tablesets_CustomerListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
      @param customClause
   */  
export interface GetListCustom_input{
      /**  The search criteria  */  
   whereClause:string,
      /**  Size of a page  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
      /**  Custom WhereClause  */  
   customClause:string,
}

export interface GetListCustom_output{
   returnObj:Erp_Tablesets_CustomerListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
   */  
export interface GetListForAuthorizedTerritories_input{
      /**  The search criteria  */  
   whereClause:string,
      /**  Size of a page  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
}

export interface GetListForAuthorizedTerritories_output{
   returnObj:Erp_Tablesets_CustomerListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param ds
      @param pageSize
      @param absolutePage
   */  
export interface GetListFromSelectedKeys_input{
   ds:Erp_Tablesets_CustomerListTableset[],
      /**  The page size, used only for UI adaptor  */  
   pageSize:number,
      /**  The absolute page, used only for the UI adaptor  */  
   absolutePage:number,
}

export interface GetListFromSelectedKeys_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerListTableset[],
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
   */  
export interface GetList_input{
      /**  An expression used to filter the rows. Can be left blank for all rows.  */  
   whereClause:string,
      /**  The maximum number of rows to return. Leave as zero for no maximum.  */  
   pageSize:number,
      /**  Page of rows to return.  */  
   absolutePage:number,
}

export interface GetList_output{
   returnObj:Erp_Tablesets_CustomerListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param CustID
      @param ShipToNum
   */  
export interface GetNewAltShipTo_input{
      /**  CustID of the customer for the Ship To  */  
   CustID:string,
      /**  ShipToNum of the ShipTo to return  */  
   ShipToNum:string,
}

export interface GetNewAltShipTo_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustBank_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustBank_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustBillTo_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustBillTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface GetNewCustChild_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface GetNewCustChild_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustDfltDocType_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustDfltDocType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
      @param icTypeID
   */  
export interface GetNewCustIC_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
   icTypeID:string,
}

export interface GetNewCustIC_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustLabExpRate_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustLabExpRate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustMFBill_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustMFBill_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param mandateType
   */  
export interface GetNewCustMandate_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   mandateType:string,
}

export interface GetNewCustMandate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustRestriction_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustRestriction_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustUPSEmail_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustUPSEmail_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustomerAttch_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewCustomerAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewCustomerDiscPriceLst_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewCustomerDiscPriceLst_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewCustomerDocsSH_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewCustomerDocsSH_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewCustomerDocs_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewCustomerDocs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewCustomerFSPriceList_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewCustomerFSPriceList_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewCustomerPriceLst_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewCustomerPriceLst_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewCustomerSettlementDay_input{
   ds:Erp_Tablesets_CustSettlementDayTableset[],
   custNum:number,
}

export interface GetNewCustomerSettlementDay_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustSettlementDayTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface GetNewCustomer_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface GetNewCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param relatedToFile
      @param key1
      @param key2
      @param key3
      @param key4
      @param key5
      @param key6
   */  
export interface GetNewEntityGLC_input{
   ds:Erp_Tablesets_CustomerTableset[],
   relatedToFile:string,
   key1:string,
   key2:string,
   key3:string,
   key4:string,
   key5:string,
   key6:string,
}

export interface GetNewEntityGLC_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewGlbCustCred_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewGlbCustCred_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewMXCustomerFiscalText_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewMXCustomerFiscalText_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewMangCust_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewMangCust_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param partnerNum
      @param partnerType
      @param partnerID
   */  
export interface GetNewPartner_input{
   ds:Erp_Tablesets_CustomerTableset[],
   partnerNum:number,
   partnerType:number,
   partnerID:string,
}

export interface GetNewPartner_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToAttch_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToDiscPriceLst_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToDiscPriceLst_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToLabExpRate_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToLabExpRate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToMFBill_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToMFBill_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToPriceLst_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToPriceLst_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToRestriction_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToRestriction_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetNewShipToUPSEml_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
   shipToNum:string,
}

export interface GetNewShipToUPSEml_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
   */  
export interface GetNewShipTo_input{
   ds:Erp_Tablesets_CustomerTableset[],
   custNum:number,
}

export interface GetNewShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param relatedToFile
      @param key1
      @param key2
      @param taxCode
      @param rateCode
   */  
export interface GetNewTaxExempt_input{
   ds:Erp_Tablesets_CustomerTableset[],
   relatedToFile:string,
   key1:string,
   key2:string,
   taxCode:string,
   rateCode:string,
}

export interface GetNewTaxExempt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param custNum
      @param parentCustID
   */  
export interface GetParentCustInfo_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  The Customer Number  */  
   custNum:number,
      /**  Parent Customer ID  */  
   parentCustID:string,
}

export interface GetParentCustInfo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param whereClauseCustomer
      @param whereClauseCustomerAttch
      @param whereClauseCustomCrdPool
      @param whereClausePartner
      @param whereClauseCustBillTo
      @param whereClauseCustBank
      @param whereClauseCustChild
      @param whereClauseCustDfltDocType
      @param whereClauseCustIC
      @param whereClauseCustLabExpRate
      @param whereClauseCustMandate
      @param whereClauseCustomerDocs
      @param whereClauseCustRestriction
      @param whereClauseCustUPSEmail
      @param whereClauseCustomerDiscPriceLst
      @param whereClauseCustomerFSPriceList
      @param whereClauseGlbCustCred
      @param whereClauseMXCustomerFiscalText
      @param whereClauseNAMember
      @param whereClausePECustWhldHist
      @param whereClauseShipTo
      @param whereClauseShipToAttch
      @param whereClauseShipToRestriction
      @param whereClauseShipToLabExpRate
      @param whereClauseCustomerDocsSH
      @param whereClauseShipToDiscPriceLst
      @param whereClauseShipToMFBill
      @param whereClauseShipToPriceLst
      @param whereClauseShipToUPSEml
      @param whereClauseCustMFBill
      @param whereClauseMangCust
      @param whereClauseShipToSrch
      @param whereClauseCustomerPriceLst
      @param whereClauseEntityGLC
      @param whereClauseTaxExempt
      @param pageSize
      @param absolutePage
   */  
export interface GetRows_input{
   whereClauseCustomer:string,
   whereClauseCustomerAttch:string,
   whereClauseCustomCrdPool:string,
   whereClausePartner:string,
   whereClauseCustBillTo:string,
   whereClauseCustBank:string,
   whereClauseCustChild:string,
   whereClauseCustDfltDocType:string,
   whereClauseCustIC:string,
   whereClauseCustLabExpRate:string,
   whereClauseCustMandate:string,
   whereClauseCustomerDocs:string,
   whereClauseCustRestriction:string,
   whereClauseCustUPSEmail:string,
   whereClauseCustomerDiscPriceLst:string,
   whereClauseCustomerFSPriceList:string,
   whereClauseGlbCustCred:string,
   whereClauseMXCustomerFiscalText:string,
   whereClauseNAMember:string,
   whereClausePECustWhldHist:string,
   whereClauseShipTo:string,
   whereClauseShipToAttch:string,
   whereClauseShipToRestriction:string,
   whereClauseShipToLabExpRate:string,
   whereClauseCustomerDocsSH:string,
   whereClauseShipToDiscPriceLst:string,
   whereClauseShipToMFBill:string,
   whereClauseShipToPriceLst:string,
   whereClauseShipToUPSEml:string,
   whereClauseCustMFBill:string,
   whereClauseMangCust:string,
   whereClauseShipToSrch:string,
   whereClauseCustomerPriceLst:string,
   whereClauseEntityGLC:string,
   whereClauseTaxExempt:string,
   pageSize:number,
   absolutePage:number,
}

export interface GetRows_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param CustID
      @param ShipToNum
   */  
export interface GetShipToForLink_input{
      /**  CustID field on the GlbCustomer record  */  
   CustID:string,
      /**  LinkShipToNum field on the GlbShipTo record  */  
   ShipToNum:string,
}

export interface GetShipToForLink_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param CustNum
      @param ShiptoNum
   */  
export interface GetShipToGlobalFields_input{
   CustNum:number,
   ShiptoNum:string,
}

export interface GetShipToGlobalFields_output{
   returnObj:string,
}

   /** Required : 
      @param whereClauseCustomer
      @param whereClauseShipTo
      @param retrieveBySearch
      @param pageSize
      @param absolutePage
   */  
export interface GetShipToRows_input{
   whereClauseCustomer:string,
   whereClauseShipTo:string,
   retrieveBySearch:boolean,
   pageSize:number,
   absolutePage:number,
}

export interface GetShipToRows_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param ds
      @param custNum
      @param shipToNum
   */  
export interface GetShipToTerritory_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  Customer.CustNum  */  
   custNum:number,
      /**  ShipTo.ShipToNum  */  
   shipToNum:string,
}

export interface GetShipToTerritory_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param CustID
      @param ShipToNum
   */  
export interface GetShipTo_input{
      /**  CustID of the customer for the Ship To  */  
   CustID:string,
      /**  ShipToNum of the ShipTo to return  */  
   ShipToNum:string,
}

export interface GetShipTo_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param _terms
   */  
export interface GetTerms_input{
   _terms:string,
}

export interface GetTerms_output{
   returnObj:string,
}

export interface GlbCustomersExist_output{
parameters : {
      /**  output parameters  */  
   glbCustomersExist:boolean,
}
}

export interface Ice_BOUpdErrorRow{
   TableName:string,
   ErrorLevel:string,
   ErrorType:string,
   ErrorText:string,
   ErrorSysRowID:string,
   SysRowID:string,
   RowMod:string,
}

export interface Ice_BOUpdErrorTableset{
   BOUpdError:Ice_BOUpdErrorRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Ice_Extensions_ExtensionRow{
   ColumnValues:object
   RowMod:string,
   SysRowID:string,
}

export interface Ice_Extensions_ExtensionTableColumn{
   ColumnName:string,
   ColumnType:string,
}

export interface Ice_Extensions_ExtensionTableData{
   Table:Ice_Extensions_ExtensionRow[],
   SystemCode:string,
   TableName:string,
   Columns:Ice_Extensions_ExtensionTableColumn[],
   PrimaryKeyColumns:string,
   PeerTableSystemCode:string,
   PeerTableName:string,
}

   /** Required : 
      @param ipCountryNum
      @param ipBTCountryNum
   */  
export interface IsLocal_input{
      /**  Customer Country Number  */  
   ipCountryNum:number,
      /**  Customer BT Country Number  */  
   ipBTCountryNum:number,
}

export interface IsLocal_output{
parameters : {
      /**  output parameters  */  
   opResult:boolean,
}
}

   /** Required : 
      @param whereClauseCustomer
      @param whereClauseCustomerAttch
      @param whereClauseCustomCrdPool
      @param whereClausePartner
      @param whereClauseCustBillTo
      @param whereClauseCustBank
      @param whereClauseCustChild
      @param whereClauseCustDfltDocType
      @param whereClauseCustIC
      @param whereClauseCustLabExpRate
      @param whereClauseCustMandate
      @param whereClauseCustomerDocs
      @param whereClauseCustRestriction
      @param whereClauseCustUPSEmail
      @param whereClauseCustomerDiscPriceLst
      @param whereClauseCustomerFSPriceList
      @param whereClauseGlbCustCred
      @param whereClauseMXCustomerFiscalText
      @param whereClauseNAMember
      @param whereClausePECustWhldHist
      @param whereClauseShipTo
      @param whereClauseShipToAttch
      @param whereClauseShipToRestriction
      @param whereClauseShipToLabExpRate
      @param whereClauseCustomerDocsSH
      @param whereClauseShipToDiscPriceLst
      @param whereClauseShipToMFBill
      @param whereClauseShipToPriceLst
      @param whereClauseShipToUPSEml
      @param whereClauseCustMFBill
      @param whereClauseMangCust
      @param whereClauseShipToSrch
      @param whereClauseCustomerPriceLst
      @param whereClauseEntityGLC
      @param whereClauseTaxExempt
      @param pageSize
      @param absolutePage
   */  
export interface LandingPageGetRows_input{
   whereClauseCustomer:string,
   whereClauseCustomerAttch:string,
   whereClauseCustomCrdPool:string,
   whereClausePartner:string,
   whereClauseCustBillTo:string,
   whereClauseCustBank:string,
   whereClauseCustChild:string,
   whereClauseCustDfltDocType:string,
   whereClauseCustIC:string,
   whereClauseCustLabExpRate:string,
   whereClauseCustMandate:string,
   whereClauseCustomerDocs:string,
   whereClauseCustRestriction:string,
   whereClauseCustUPSEmail:string,
   whereClauseCustomerDiscPriceLst:string,
   whereClauseCustomerFSPriceList:string,
   whereClauseGlbCustCred:string,
   whereClauseMXCustomerFiscalText:string,
   whereClauseNAMember:string,
   whereClausePECustWhldHist:string,
   whereClauseShipTo:string,
   whereClauseShipToAttch:string,
   whereClauseShipToRestriction:string,
   whereClauseShipToLabExpRate:string,
   whereClauseCustomerDocsSH:string,
   whereClauseShipToDiscPriceLst:string,
   whereClauseShipToMFBill:string,
   whereClauseShipToPriceLst:string,
   whereClauseShipToUPSEml:string,
   whereClauseCustMFBill:string,
   whereClauseMangCust:string,
   whereClauseShipToSrch:string,
   whereClauseCustomerPriceLst:string,
   whereClauseEntityGLC:string,
   whereClauseTaxExempt:string,
   pageSize:number,
   absolutePage:number,
}

export interface LandingPageGetRows_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
      @param ds1
   */  
export interface LinkGlbCustBillTo_input{
      /**  Global Company field on the GlbCustBillTo record to link  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbCustBillTo record to link  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
}

export interface LinkGlbCustBillTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
   warnMsg:string,
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
      @param ds1
   */  
export interface LinkGlbCustomer_input{
      /**  Global Company field on the GlbCustomer record to link  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbCustomer record to link  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
}

export interface LinkGlbCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param glbShipToNum
      @param ds
      @param ds1
   */  
export interface LinkGlbShipTo_input{
      /**  Global Company field on the GlbShipTo record to link  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbShipTo record to link  */  
   glbCustNum:number,
      /**  Global ShipToNum field on the GlbShipTo record to linke  */  
   glbShipToNum:string,
   ds:Erp_Tablesets_GlbCustomerTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
}

export interface LinkGlbShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ModifySearchIDs_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ModifySearchIDs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param custNum
      @param shipToNum
      @param seqNum
      @param moveDir
   */  
export interface MoveOnePositionDisc_input{
      /**  Customer Number  */  
   custNum:number,
      /**  Ship To Number  */  
   shipToNum:string,
      /**  Current Sequence number of price list to move  */  
   seqNum:number,
      /**  Direction to move task, "Up" or "Down"  */  
   moveDir:string,
}

export interface MoveOnePositionDisc_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param custNum
      @param shipToNum
      @param seqNum
      @param moveDir
   */  
export interface MoveOnePosition_input{
      /**  Customer Number  */  
   custNum:number,
      /**  Ship To Number  */  
   shipToNum:string,
      /**  Current Sequence number of price list to move  */  
   seqNum:number,
      /**  Direction to move task, "Up" or "Down"  */  
   moveDir:string,
}

export interface MoveOnePosition_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
}

   /** Required : 
      @param iProposedMasterCustID
      @param iProposedMasterShipToNum
      @param ds
   */  
export interface OnChangeAltShipTo_input{
      /**  The proposed CustID value  */  
   iProposedMasterCustID:string,
      /**  The proposed ShipToNum value  */  
   iProposedMasterShipToNum:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface OnChangeAltShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipCreditCardOrder
      @param ds
   */  
export interface OnChangeCreditCardOrder_input{
      /**  Proposed CreditCardOrder value  */  
   ipCreditCardOrder:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface OnChangeCreditCardOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param bankID
      @param proposedBankBranchCode
   */  
export interface OnChangeCustBankBankBranchCode_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  Bank ID  */  
   bankID:string,
      /**  Proposed bank branch code  */  
   proposedBankBranchCode:string,
}

export interface OnChangeCustBankBankBranchCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param iProposedPMUID
      @param iProposedBankID
   */  
export interface OnChangeCustBankPayMethod_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  The proposed PMUID value  */  
   iProposedPMUID:number,
      /**  The proposed BankID value  */  
   iProposedBankID:string,
}

export interface OnChangeCustBankPayMethod_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param iProposedPrimary
      @param iProposedICCode
   */  
export interface OnChangeCustICPrimary_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  The logic flag to set Primary Industry Class  */  
   iProposedPrimary:boolean,
      /**  The code of current record  */  
   iProposedICCode:string,
}

export interface OnChangeCustICPrimary_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param iProposedTaxRgnCode
   */  
export interface OnChangeCustomerTaxRegion_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  The proposed TaxCode value  */  
   iProposedTaxRgnCode:string,
}

export interface OnChangeCustomerTaxRegion_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param eliDefReportID
      @param ds
   */  
export interface OnChangeELIDefReportID_input{
   eliDefReportID:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface OnChangeELIDefReportID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param iProposedTaxRgnCode
      @param iCustNum
      @param iShipToNum
   */  
export interface OnChangeShipToTaxRegion_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  The proposed TaxCode value  */  
   iProposedTaxRgnCode:string,
      /**  Customer num  */  
   iCustNum:number,
      /**  ShipTo num  */  
   iShipToNum:string,
}

export interface OnChangeShipToTaxRegion_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param iProposedVendorID
   */  
export interface OnChangeVendorID_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  The proposed VendorID value  */  
   iProposedVendorID:string,
}

export interface OnChangeVendorID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param CustID
      @param ds
   */  
export interface OnChangeofAltBT_input{
      /**  CustBillTo CustID  */  
   CustID:string,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface OnChangeofAltBT_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param bankAcctID
   */  
export interface OnChangeofBankAccount_input{
      /**  Bank account ID  */  
   bankAcctID:string,
}

export interface OnChangeofBankAccount_output{
parameters : {
      /**  output parameters  */  
   bankAcctDescription:string,
   bankName:string,
   legalName:string,
   ibanCode:string,
   bankIdentifier:string,
   creditorID:string,
}
}

   /** Required : 
      @param ds
      @param CustNum
      @param ProposedVal
      @param AddrField
   */  
export interface OnChangeofCustomerAddr_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  Customer.CustNum  */  
   CustNum:number,
      /**  Proposed value of change.  */  
   ProposedVal:string,
      /**  Address1, 2, 3, City, State, Zip and CountryNum.  */  
   AddrField:string,
}

export interface OnChangeofCustomerAddr_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param CustNum
      @param ShipToNum
      @param ProposedVal
      @param AddrField
   */  
export interface OnChangeofShipToAddr_input{
   ds:Erp_Tablesets_CustomerTableset[],
      /**  ShipTo.CustNum  */  
   CustNum:number,
      /**  ShipTo.ShipToNum  */  
   ShipToNum:string,
      /**  Proposed value of change.  */  
   ProposedVal:string,
      /**  Address1, 2, 3, City, State, Zip and CountryNum.  */  
   AddrField:string,
}

export interface OnChangeofShipToAddr_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param bankAccountID
   */  
export interface OnMandateBankAccountChanging_input{
      /**  New value of bank account  */  
   bankAccountID:string,
}

export interface OnMandateBankAccountChanging_output{
}

   /** Required : 
      @param dDateFrom
      @param dDateTo
   */  
export interface OnMandateDateChanging_input{
      /**  New value of valid date from  */  
   dDateFrom:string,
      /**  New value of valid date to  */  
   dDateTo:string,
}

export interface OnMandateDateChanging_output{
}

   /** Required : 
      @param signredDate
   */  
export interface OnMandateSignedDateChanging_input{
      /**  New value of signed date  */  
   signredDate:string,
}

export interface OnMandateSignedDateChanging_output{
}

   /** Required : 
      @param custNum
      @param mandateReference
      @param paymentType
      @param mandateStatus
   */  
export interface OnMandateStatusChanging_input{
      /**  Customer  */  
   custNum:number,
      /**  Mandate reference  */  
   mandateReference:string,
      /**  Mandate Payment Type  */  
   paymentType:string,
      /**  New status  */  
   mandateStatus:string,
}

export interface OnMandateStatusChanging_output{
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
   */  
export interface PreLinkGlbCustBillTo_input{
      /**  Global Company field on the GlbCustBillTo record to link  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbCustBillTo record to link  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface PreLinkGlbCustBillTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
   vMessage:string,
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
   */  
export interface PreLinkGlbCustomer_input{
      /**  Global Company field on the GlbCustomer record to link  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbCustomer record to link  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface PreLinkGlbCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
   vMessage:string,
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param glbShipToNum
      @param ds
   */  
export interface PreLinkGlbShipTo_input{
      /**  Global Company field on the GlbShipto record to link  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbShipTo record to link  */  
   glbCustNum:number,
      /**  Global ShipToNum field on the GlbShipto record to link  */  
   glbShipToNum:string,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface PreLinkGlbShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
   vMessage:string,
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param glbShipToNum
      @param ds
   */  
export interface RefreshGlbShipTo_input{
      /**  Global Company  */  
   glbCompany:string,
      /**  Global Customer Number  */  
   glbCustNum:number,
      /**  Global Ship To  */  
   glbShipToNum:string,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface RefreshGlbShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ResetShipToIntl_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ResetShipToIntl_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param btcustNum
   */  
export interface SetOrdersCreditOverride_input{
   btcustNum:number,
}

export interface SetOrdersCreditOverride_output{
}

   /** Required : 
      @param ipQVEnable
      @param ipUpdCustUPS
      @param ipUPDShipToUPS
      @param ds
   */  
export interface SetUPSQVEnable_input{
      /**  logical indicating if the quantum view is to enabled/disabled  */  
   ipQVEnable:boolean,
      /**  Yes, if the CustUPSEmail table is to be updated  */  
   ipUpdCustUPS:boolean,
      /**  Yes, if the ShipToUPSPPEml talbe is to be updated  */  
   ipUPDShipToUPS:boolean,
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface SetUPSQVEnable_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param ds1
      @param ipCustNum
      @param ipShipToNum
   */  
export interface ShipToETCAfterAddrVal_input{
   ds:Erp_Tablesets_ETCAddrValidationTableset[],
   ds1:Erp_Tablesets_CustomerTableset[],
      /**  ShipTo.CustNum  */  
   ipCustNum:number,
      /**  ShipTo.ShipToNum  */  
   ipShipToNum:string,
}

export interface ShipToETCAfterAddrVal_output{
parameters : {
      /**  output parameters  */  
   ds1:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param CustNum
      @param ShipToNum
   */  
export interface ShipToETCValAddr_input{
      /**  ShipTo.CustNum  */  
   CustNum:number,
      /**  ShipTo.ShipToNum  */  
   ShipToNum:string,
}

export interface ShipToETCValAddr_output{
   returnObj:Erp_Tablesets_ETCAddrValidationTableset[],
parameters : {
      /**  output parameters  */  
   StatusFlag:boolean,
   ErrorFlag:boolean,
   ErrorMsg:string,
}
}

   /** Required : 
      @param ds
   */  
export interface ShipToTerrSelectChange_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface ShipToTerrSelectChange_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
   */  
export interface SkipGlbCustomer_input{
      /**  Global Company field on the GlbCustomer record to skip  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbCustomer record to skip  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface SkipGlbCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
   */  
export interface SkipGlbShipTo_input{
      /**  Global Company  */  
   glbCompany:string,
      /**  Global Customer Number  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface SkipGlbShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param glbShipToNum
      @param ds
   */  
export interface SkipSingleGlbShipTo_input{
      /**  Global Company  */  
   glbCompany:string,
      /**  Global Customer Number  */  
   glbCustNum:number,
      /**  Global Ship To  */  
   glbShipToNum:string,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface SkipSingleGlbShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
}
}

   /** Required : 
      @param ipPartnerNum
      @param ipSearchID
   */  
export interface StorePartner_input{
      /**  Partner Num  */  
   ipPartnerNum:number,
      /**  Search ID  */  
   ipSearchID:string,
}

export interface StorePartner_output{
      /**  boolean  */  
   returnObj:boolean,
}

   /** Required : 
      @param glbCompany
      @param glbCustNum
      @param ds
   */  
export interface UnlinkGlbCustomer_input{
      /**  Global Company field on the GlbCustomer record to unlink  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbCustomer record to unlink  */  
   glbCustNum:number,
   ds:Erp_Tablesets_GlbCustomerTableset[],
}

export interface UnlinkGlbCustomer_output{
   returnObj:Erp_Tablesets_CustomerTableset[],
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbCustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface UpdateCreditTotals_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface UpdateCreditTotals_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
      @param continueProcessingOnError
      @param rollbackParentOnChildError
   */  
export interface UpdateExt_input{
   ds:Erp_Tablesets_UpdExtCustomerTableset[],
   continueProcessingOnError:boolean,
   rollbackParentOnChildError:boolean,
}

export interface UpdateExt_output{
   returnObj:Ice_BOUpdErrorTableset[],
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UpdExtCustomerTableset[],
   errorsOccurred:boolean,
}
}

   /** Required : 
      @param ds
   */  
export interface UpdateGlobalLimits_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface UpdateGlobalLimits_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface Update_input{
   ds:Erp_Tablesets_CustomerTableset[],
}

export interface Update_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
}
}

   /** Required : 
      @param ipAgingCode
   */  
export interface ValidateAgingCode_input{
      /**  Aging Code  */  
   ipAgingCode:string,
}

export interface ValidateAgingCode_output{
   returnObj:boolean,
}

   /** Required : 
      @param ds
      @param hmrcFraudPrevHeader
   */  
export interface ValidateAllTaxID_input{
   ds:Erp_Tablesets_CustomerTableset[],
   hmrcFraudPrevHeader:string,
}

export interface ValidateAllTaxID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
   opMessage:string,
}
}

   /** Required : 
      @param ipProposedCountry
   */  
export interface ValidateCountry_input{
      /**  country number to validate  */  
   ipProposedCountry:number,
}

export interface ValidateCountry_output{
}

   /** Required : 
      @param creditSharedPrc
   */  
export interface ValidateGlbNACreditSharedPrc_input{
      /**  Value to be validated  */  
   creditSharedPrc:number,
}

export interface ValidateGlbNACreditSharedPrc_output{
   returnObj:boolean,
}

   /** Required : 
      @param parentCreditPrc
   */  
export interface ValidateGlbNAParentCreditPrc_input{
      /**  Value to be validated  */  
   parentCreditPrc:number,
}

export interface ValidateGlbNAParentCreditPrc_output{
   returnObj:boolean,
}

   /** Required : 
      @param creditSharedPrc
   */  
export interface ValidateNACreditSharedPrc_input{
      /**  Value to be validated  */  
   creditSharedPrc:number,
}

export interface ValidateNACreditSharedPrc_output{
   returnObj:boolean,
}

   /** Required : 
      @param parentCreditPrc
   */  
export interface ValidateNAParentCreditPrc_input{
      /**  Value to be validated  */  
   parentCreditPrc:number,
}

export interface ValidateNAParentCreditPrc_output{
   returnObj:boolean,
}

   /** Required : 
      @param ipPayBTFlag
      @param ipValCust
      @param ipValShipTo
      @param ipCustNum
      @param ipShipTo
   */  
export interface ValidatePayBTFlag_input{
      /**  requested pay bt flag to edit  */  
   ipPayBTFlag:string,
      /**  logical indicating if the pay flag on the CustMFBill is to be checked  */  
   ipValCust:boolean,
      /**  logical indicating if the pay flag on the ShipToMFBill is to be checked  */  
   ipValShipTo:boolean,
      /**  customer  Number  */  
   ipCustNum:number,
      /**  Ship To  */  
   ipShipTo:string,
}

export interface ValidatePayBTFlag_output{
}

   /** Required : 
      @param ds
      @param manualValidation
      @param hmrcFraudPrevHeader
   */  
export interface ValidateTaxIDCustomer_input{
   ds:Erp_Tablesets_CustomerTableset[],
   manualValidation:boolean,
   hmrcFraudPrevHeader:string,
}

export interface ValidateTaxIDCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
   opMessage:string,
}
}

   /** Required : 
      @param ds
      @param manualValidation
      @param hmrcFraudPrevHeader
   */  
export interface ValidateTaxIDShipTo_input{
   ds:Erp_Tablesets_CustomerTableset[],
   manualValidation:boolean,
   hmrcFraudPrevHeader:string,
}

export interface ValidateTaxIDShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_CustomerTableset[],
   opMessage:string,
}
}

