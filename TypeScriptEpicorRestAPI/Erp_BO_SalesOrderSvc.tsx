import * as configEpicorSchemas from "./configEpicorSchemas"


// Title: Erp.BO.SalesOrderSvc
// Description: The Sales order main object
// Version: v1



//////////////////////////////////////////////////////////////////////////
// OData methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Get service document
   Description: Get service document for the service
   OperationID: GetServiceDocument
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => application/json
   */  
export function getServiceDocument(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<JSON>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as JSON)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Get metadata document
   Description: Get service ODATA metadata in XML format
   OperationID: GetMetadata
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: Returns metadata document => content
   */  
export function get_metadata(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/$metadata", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get SalesOrders items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_SalesOrders
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHedRow
   */  
export function get_SalesOrders(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_SalesOrders
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderHedRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderHedRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SalesOrders(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the SalesOrder item
   Description: Calls GetByID to retrieve the SalesOrder item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_SalesOrder
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderHedRow
   */  
export function get_SalesOrders_Company_OrderNum(Company:string, OrderNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderHedRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderHedRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update SalesOrder for the service
   Description: Calls UpdateExt to update SalesOrder. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_SalesOrder
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderHedRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_SalesOrders_Company_OrderNum(Company:string, OrderNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete SalesOrder item
   Description: Call UpdateExt to delete SalesOrder item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_SalesOrder
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_SalesOrders_Company_OrderNum(Company:string, OrderNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OHOrderMscs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OHOrderMscs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OHOrderMscRow
   */  
export function get_SalesOrders_Company_OrderNum_OHOrderMscs(Company:string, OrderNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OHOrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OHOrderMscs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OHOrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OHOrderMsc item
   Description: Calls GetByID to retrieve the OHOrderMsc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OHOrderMsc1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OHOrderMscRow
   */  
export function get_SalesOrders_Company_OrderNum_OHOrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OHOrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OHOrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OHOrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderDtls items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderDtls1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderDtlRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderDtls(Company:string, OrderNum:string, select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderDtls", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderDtl item
   Description: Calls GetByID to retrieve the OrderDtl item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderDtl1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderDtlRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderDtls_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderDtlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderDtlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderHedUPS items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderHedUPS1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHedUPSRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderHedUPS(Company:string, OrderNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedUPSRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderHedUPS", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedUPSRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderHedUP item
   Description: Calls GetByID to retrieve the OrderHedUP item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderHedUP1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderHedUPSRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderHedUPS_Company_OrderNum_UPSQVSeq(Company:string, OrderNum:string, UPSQVSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderHedUPSRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderHedUPS(" + Company + "," + OrderNum + "," + UPSQVSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderHedUPSRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderRepComms items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderRepComms1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderRepCommRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderRepComms(Company:string, OrderNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRepCommRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderRepComms", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRepCommRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderRepComm item
   Description: Calls GetByID to retrieve the OrderRepComm item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderRepComm1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param SalesRepCode Desc: SalesRepCode   Required: True   Allow empty value : True
      @param Seq Desc: Seq   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderRepCommRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderRepComms_Company_OrderNum_SalesRepCode_Seq(Company:string, OrderNum:string, SalesRepCode:string, Seq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderRepCommRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderRepComms(" + Company + "," + OrderNum + "," + SalesRepCode + "," + Seq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderRepCommRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderScheds items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderScheds1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderSchedRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderScheds(Company:string, OrderNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderSchedRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderScheds", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderSchedRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderSched item
   Description: Calls GetByID to retrieve the OrderSched item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderSched1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param PaySeq Desc: PaySeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderSchedRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderScheds_Company_OrderNum_PaySeq(Company:string, OrderNum:string, PaySeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderSchedRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderScheds(" + Company + "," + OrderNum + "," + PaySeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderSchedRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderHedAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderHedAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHedAttchRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderHedAttches(Company:string, OrderNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderHedAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderHedAttch item
   Description: Calls GetByID to retrieve the OrderHedAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderHedAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderHedAttchRow
   */  
export function get_SalesOrders_Company_OrderNum_OrderHedAttches_Company_OrderNum_DrawingSeq(Company:string, OrderNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderHedAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SalesOrders(" + Company + "," + OrderNum + ")/OrderHedAttches(" + Company + "," + OrderNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderHedAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OHOrderMscs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OHOrderMscs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OHOrderMscRow
   */  
export function get_OHOrderMscs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OHOrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OHOrderMscs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OHOrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OHOrderMscs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OHOrderMscRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OHOrderMscRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OHOrderMscs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OHOrderMscs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OHOrderMsc item
   Description: Calls GetByID to retrieve the OHOrderMsc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OHOrderMsc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OHOrderMscRow
   */  
export function get_OHOrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OHOrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OHOrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OHOrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OHOrderMsc for the service
   Description: Calls UpdateExt to update OHOrderMsc. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OHOrderMsc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OHOrderMscRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OHOrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OHOrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OHOrderMsc item
   Description: Call UpdateExt to delete OHOrderMsc item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OHOrderMsc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OHOrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OHOrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderDtls items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderDtls
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderDtlRow
   */  
export function get_OrderDtls(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderDtls
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderDtlRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderDtlRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderDtls(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderDtl item
   Description: Calls GetByID to retrieve the OrderDtl item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderDtl
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderDtlRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderDtlRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderDtlRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderDtl for the service
   Description: Calls UpdateExt to update OrderDtl. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderDtl
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderDtlRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderDtls_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderDtl item
   Description: Call UpdateExt to delete OrderDtl item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderDtl
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderDtls_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderMscs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderMscs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderMscRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine_OrderMscs(Company:string, OrderNum:string, OrderLine:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")/OrderMscs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderMsc item
   Description: Calls GetByID to retrieve the OrderMsc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderMsc1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderMscRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine_OrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")/OrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderRels items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderRels1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderRelRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine_OrderRels(Company:string, OrderNum:string, OrderLine:string, select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")/OrderRels", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderRel item
   Description: Calls GetByID to retrieve the OrderRel item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderRel1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderRelRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine_OrderRels_Company_OrderNum_OrderLine_OrderRelNum(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderRelRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")/OrderRels(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderRelRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderDtlAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderDtlAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderDtlAttchRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine_OrderDtlAttches(Company:string, OrderNum:string, OrderLine:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")/OrderDtlAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderDtlAttch item
   Description: Calls GetByID to retrieve the OrderDtlAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderDtlAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderDtlAttchRow
   */  
export function get_OrderDtls_Company_OrderNum_OrderLine_OrderDtlAttches_Company_OrderNum_OrderLine_DrawingSeq(Company:string, OrderNum:string, OrderLine:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderDtlAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtls(" + Company + "," + OrderNum + "," + OrderLine + ")/OrderDtlAttches(" + Company + "," + OrderNum + "," + OrderLine + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderDtlAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderMscs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderMscs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderMscRow
   */  
export function get_OrderMscs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderMscs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderMscs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderMscRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderMscRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderMscs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderMscs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderMsc item
   Description: Calls GetByID to retrieve the OrderMsc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderMsc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderMscRow
   */  
export function get_OrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderMscRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderMscRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderMsc for the service
   Description: Calls UpdateExt to update OrderMsc. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderMsc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderMscRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderMsc item
   Description: Call UpdateExt to delete OrderMsc item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderMsc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param SeqNum Desc: SeqNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderMscs_Company_OrderNum_OrderLine_SeqNum(Company:string, OrderNum:string, OrderLine:string, SeqNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderMscs(" + Company + "," + OrderNum + "," + OrderLine + "," + SeqNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderRels items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderRels
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderRelRow
   */  
export function get_OrderRels(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderRels
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderRelRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderRelRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderRels(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderRel item
   Description: Calls GetByID to retrieve the OrderRel item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderRel
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderRelRow
   */  
export function get_OrderRels_Company_OrderNum_OrderLine_OrderRelNum(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderRelRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderRelRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderRel for the service
   Description: Calls UpdateExt to update OrderRel. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderRel
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderRelRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderRels_Company_OrderNum_OrderLine_OrderRelNum(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderRel item
   Description: Call UpdateExt to delete OrderRel item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderRel
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderRels_Company_OrderNum_OrderLine_OrderRelNum(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get OrderRelTaxes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_OrderRelTaxes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderRelTaxRow
   */  
export function get_OrderRels_Company_OrderNum_OrderLine_OrderRelNum_OrderRelTaxes(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelTaxRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + ")/OrderRelTaxes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelTaxRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderRelTax item
   Description: Calls GetByID to retrieve the OrderRelTax item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderRelTax1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param ECAcquisitionSeq Desc: ECAcquisitionSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderRelTaxRow
   */  
export function get_OrderRels_Company_OrderNum_OrderLine_OrderRelNum_OrderRelTaxes_Company_OrderNum_OrderLine_OrderRelNum_TaxCode_RateCode_ECAcquisitionSeq(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, TaxCode:string, RateCode:string, ECAcquisitionSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderRelTaxRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRels(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + ")/OrderRelTaxes(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + "," + TaxCode + "," + RateCode + "," + ECAcquisitionSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderRelTaxRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderRelTaxes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderRelTaxes
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderRelTaxRow
   */  
export function get_OrderRelTaxes(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelTaxRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRelTaxes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelTaxRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderRelTaxes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderRelTaxRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderRelTaxRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderRelTaxes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRelTaxes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderRelTax item
   Description: Calls GetByID to retrieve the OrderRelTax item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderRelTax
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param ECAcquisitionSeq Desc: ECAcquisitionSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderRelTaxRow
   */  
export function get_OrderRelTaxes_Company_OrderNum_OrderLine_OrderRelNum_TaxCode_RateCode_ECAcquisitionSeq(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, TaxCode:string, RateCode:string, ECAcquisitionSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderRelTaxRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRelTaxes(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + "," + TaxCode + "," + RateCode + "," + ECAcquisitionSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderRelTaxRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderRelTax for the service
   Description: Calls UpdateExt to update OrderRelTax. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderRelTax
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param ECAcquisitionSeq Desc: ECAcquisitionSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderRelTaxRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderRelTaxes_Company_OrderNum_OrderLine_OrderRelNum_TaxCode_RateCode_ECAcquisitionSeq(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, TaxCode:string, RateCode:string, ECAcquisitionSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRelTaxes(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + "," + TaxCode + "," + RateCode + "," + ECAcquisitionSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderRelTax item
   Description: Call UpdateExt to delete OrderRelTax item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderRelTax
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param OrderRelNum Desc: OrderRelNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param ECAcquisitionSeq Desc: ECAcquisitionSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderRelTaxes_Company_OrderNum_OrderLine_OrderRelNum_TaxCode_RateCode_ECAcquisitionSeq(Company:string, OrderNum:string, OrderLine:string, OrderRelNum:string, TaxCode:string, RateCode:string, ECAcquisitionSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRelTaxes(" + Company + "," + OrderNum + "," + OrderLine + "," + OrderRelNum + "," + TaxCode + "," + RateCode + "," + ECAcquisitionSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderDtlAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderDtlAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderDtlAttchRow
   */  
export function get_OrderDtlAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderDtlAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderDtlAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderDtlAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderDtlAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderDtlAttch item
   Description: Calls GetByID to retrieve the OrderDtlAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderDtlAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderDtlAttchRow
   */  
export function get_OrderDtlAttches_Company_OrderNum_OrderLine_DrawingSeq(Company:string, OrderNum:string, OrderLine:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderDtlAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlAttches(" + Company + "," + OrderNum + "," + OrderLine + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderDtlAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderDtlAttch for the service
   Description: Calls UpdateExt to update OrderDtlAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderDtlAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderDtlAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderDtlAttches_Company_OrderNum_OrderLine_DrawingSeq(Company:string, OrderNum:string, OrderLine:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlAttches(" + Company + "," + OrderNum + "," + OrderLine + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderDtlAttch item
   Description: Call UpdateExt to delete OrderDtlAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderDtlAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderDtlAttches_Company_OrderNum_OrderLine_DrawingSeq(Company:string, OrderNum:string, OrderLine:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlAttches(" + Company + "," + OrderNum + "," + OrderLine + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderHedUPS items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderHedUPS
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHedUPSRow
   */  
export function get_OrderHedUPS(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedUPSRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedUPS", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedUPSRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderHedUPS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderHedUPSRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderHedUPSRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderHedUPS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedUPS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderHedUP item
   Description: Calls GetByID to retrieve the OrderHedUP item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderHedUP
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderHedUPSRow
   */  
export function get_OrderHedUPS_Company_OrderNum_UPSQVSeq(Company:string, OrderNum:string, UPSQVSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderHedUPSRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedUPS(" + Company + "," + OrderNum + "," + UPSQVSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderHedUPSRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderHedUP for the service
   Description: Calls UpdateExt to update OrderHedUP. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderHedUP
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderHedUPSRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderHedUPS_Company_OrderNum_UPSQVSeq(Company:string, OrderNum:string, UPSQVSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedUPS(" + Company + "," + OrderNum + "," + UPSQVSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderHedUP item
   Description: Call UpdateExt to delete OrderHedUP item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderHedUP
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param UPSQVSeq Desc: UPSQVSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderHedUPS_Company_OrderNum_UPSQVSeq(Company:string, OrderNum:string, UPSQVSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedUPS(" + Company + "," + OrderNum + "," + UPSQVSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderRepComms items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderRepComms
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderRepCommRow
   */  
export function get_OrderRepComms(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRepCommRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRepComms", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRepCommRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderRepComms
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderRepCommRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderRepCommRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderRepComms(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRepComms", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderRepComm item
   Description: Calls GetByID to retrieve the OrderRepComm item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderRepComm
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param SalesRepCode Desc: SalesRepCode   Required: True   Allow empty value : True
      @param Seq Desc: Seq   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderRepCommRow
   */  
export function get_OrderRepComms_Company_OrderNum_SalesRepCode_Seq(Company:string, OrderNum:string, SalesRepCode:string, Seq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderRepCommRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRepComms(" + Company + "," + OrderNum + "," + SalesRepCode + "," + Seq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderRepCommRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderRepComm for the service
   Description: Calls UpdateExt to update OrderRepComm. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderRepComm
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param SalesRepCode Desc: SalesRepCode   Required: True   Allow empty value : True
      @param Seq Desc: Seq   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderRepCommRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderRepComms_Company_OrderNum_SalesRepCode_Seq(Company:string, OrderNum:string, SalesRepCode:string, Seq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRepComms(" + Company + "," + OrderNum + "," + SalesRepCode + "," + Seq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderRepComm item
   Description: Call UpdateExt to delete OrderRepComm item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderRepComm
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param SalesRepCode Desc: SalesRepCode   Required: True   Allow empty value : True
      @param Seq Desc: Seq   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderRepComms_Company_OrderNum_SalesRepCode_Seq(Company:string, OrderNum:string, SalesRepCode:string, Seq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderRepComms(" + Company + "," + OrderNum + "," + SalesRepCode + "," + Seq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderScheds items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderScheds
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderSchedRow
   */  
export function get_OrderScheds(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderSchedRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderScheds", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderSchedRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderScheds
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderSchedRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderSchedRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderScheds(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderScheds", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderSched item
   Description: Calls GetByID to retrieve the OrderSched item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderSched
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param PaySeq Desc: PaySeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderSchedRow
   */  
export function get_OrderScheds_Company_OrderNum_PaySeq(Company:string, OrderNum:string, PaySeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderSchedRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderScheds(" + Company + "," + OrderNum + "," + PaySeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderSchedRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderSched for the service
   Description: Calls UpdateExt to update OrderSched. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderSched
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param PaySeq Desc: PaySeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderSchedRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderScheds_Company_OrderNum_PaySeq(Company:string, OrderNum:string, PaySeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderScheds(" + Company + "," + OrderNum + "," + PaySeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderSched item
   Description: Call UpdateExt to delete OrderSched item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderSched
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param PaySeq Desc: PaySeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderScheds_Company_OrderNum_PaySeq(Company:string, OrderNum:string, PaySeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderScheds(" + Company + "," + OrderNum + "," + PaySeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderHedAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderHedAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHedAttchRow
   */  
export function get_OrderHedAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderHedAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderHedAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderHedAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderHedAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderHedAttch item
   Description: Calls GetByID to retrieve the OrderHedAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderHedAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderHedAttchRow
   */  
export function get_OrderHedAttches_Company_OrderNum_DrawingSeq(Company:string, OrderNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderHedAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedAttches(" + Company + "," + OrderNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderHedAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderHedAttch for the service
   Description: Calls UpdateExt to update OrderHedAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderHedAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderHedAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderHedAttches_Company_OrderNum_DrawingSeq(Company:string, OrderNum:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedAttches(" + Company + "," + OrderNum + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderHedAttch item
   Description: Call UpdateExt to delete OrderHedAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderHedAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderHedAttches_Company_OrderNum_DrawingSeq(Company:string, OrderNum:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHedAttches(" + Company + "," + OrderNum + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get HedTaxSums items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_HedTaxSums
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.HedTaxSumRow
   */  
export function get_HedTaxSums(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_HedTaxSumRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/HedTaxSums", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_HedTaxSumRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_HedTaxSums
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.HedTaxSumRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.HedTaxSumRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_HedTaxSums(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/HedTaxSums", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the HedTaxSum item
   Description: Calls GetByID to retrieve the HedTaxSum item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_HedTaxSum
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param HedNum Desc: HedNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param AllocDepInvcNum Desc: AllocDepInvcNum   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.HedTaxSumRow
   */  
export function get_HedTaxSums_Company_HedNum_TaxCode_RateCode_AllocDepInvcNum(Company:string, HedNum:string, TaxCode:string, RateCode:string, AllocDepInvcNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_HedTaxSumRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/HedTaxSums(" + Company + "," + HedNum + "," + TaxCode + "," + RateCode + "," + AllocDepInvcNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_HedTaxSumRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update HedTaxSum for the service
   Description: Calls UpdateExt to update HedTaxSum. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_HedTaxSum
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param HedNum Desc: HedNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param AllocDepInvcNum Desc: AllocDepInvcNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.HedTaxSumRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_HedTaxSums_Company_HedNum_TaxCode_RateCode_AllocDepInvcNum(Company:string, HedNum:string, TaxCode:string, RateCode:string, AllocDepInvcNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/HedTaxSums(" + Company + "," + HedNum + "," + TaxCode + "," + RateCode + "," + AllocDepInvcNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete HedTaxSum item
   Description: Call UpdateExt to delete HedTaxSum item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_HedTaxSum
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param HedNum Desc: HedNum   Required: True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param AllocDepInvcNum Desc: AllocDepInvcNum   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_HedTaxSums_Company_HedNum_TaxCode_RateCode_AllocDepInvcNum(Company:string, HedNum:string, TaxCode:string, RateCode:string, AllocDepInvcNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/HedTaxSums(" + Company + "," + HedNum + "," + TaxCode + "," + RateCode + "," + AllocDepInvcNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get OrderHists items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_OrderHists
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHistRow
   */  
export function get_OrderHists(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHistRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHists", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHistRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_OrderHists
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.OrderHistRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.OrderHistRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderHists(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHists", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the OrderHist item
   Description: Calls GetByID to retrieve the OrderHist item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_OrderHist
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.OrderHistRow
   */  
export function get_OrderHists_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_OrderHistRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHists(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_OrderHistRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update OrderHist for the service
   Description: Calls UpdateExt to update OrderHist. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_OrderHist
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.OrderHistRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_OrderHists_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHists(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete OrderHist item
   Description: Call UpdateExt to delete OrderHist item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_OrderHist
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param OrderNum Desc: OrderNum   Required: True
      @param OrderLine Desc: OrderLine   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_OrderHists_Company_OrderNum_OrderLine(Company:string, OrderNum:string, OrderLine:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderHists(" + Company + "," + OrderNum + "," + OrderLine + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartSubs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartSubs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartSubsRow
   */  
export function get_PartSubs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PartSubs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartSubs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartSubsRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartSubs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PartSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartSub item
   Description: Calls GetByID to retrieve the PartSub item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartSub
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   */  
export function get_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartSubsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartSubsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartSub for the service
   Description: Calls UpdateExt to update PartSub. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartSub
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartSub item
   Description: Call UpdateExt to delete PartSub item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartSub
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get SelectedSerialNumbers items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_SelectedSerialNumbers
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.SelectedSerialNumbersRow
   */  
export function get_SelectedSerialNumbers(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_SelectedSerialNumbersRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SelectedSerialNumbers", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_SelectedSerialNumbersRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_SelectedSerialNumbers
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.SelectedSerialNumbersRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.SelectedSerialNumbersRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SelectedSerialNumbers(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SelectedSerialNumbers", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the SelectedSerialNumber item
   Description: Calls GetByID to retrieve the SelectedSerialNumber item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_SelectedSerialNumber
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SerialNumber Desc: SerialNumber   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.SelectedSerialNumbersRow
   */  
export function get_SelectedSerialNumbers_Company_PartNum_SerialNumber(Company:string, PartNum:string, SerialNumber:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_SelectedSerialNumbersRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SelectedSerialNumbers(" + Company + "," + PartNum + "," + SerialNumber + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_SelectedSerialNumbersRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update SelectedSerialNumber for the service
   Description: Calls UpdateExt to update SelectedSerialNumber. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_SelectedSerialNumber
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SerialNumber Desc: SerialNumber   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.SelectedSerialNumbersRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_SelectedSerialNumbers_Company_PartNum_SerialNumber(Company:string, PartNum:string, SerialNumber:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SelectedSerialNumbers(" + Company + "," + PartNum + "," + SerialNumber + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete SelectedSerialNumber item
   Description: Call UpdateExt to delete SelectedSerialNumber item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_SelectedSerialNumber
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SerialNumber Desc: SerialNumber   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_SelectedSerialNumbers_Company_PartNum_SerialNumber(Company:string, PartNum:string, SerialNumber:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SelectedSerialNumbers(" + Company + "," + PartNum + "," + SerialNumber + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get SNFormats items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_SNFormats
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.SNFormatRow
   */  
export function get_SNFormats(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_SNFormatRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SNFormats", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_SNFormatRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_SNFormats
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.SNFormatRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.SNFormatRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SNFormats(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SNFormats", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the SNFormat item
   Description: Calls GetByID to retrieve the SNFormat item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_SNFormat
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.SNFormatRow
   */  
export function get_SNFormats_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_SNFormatRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SNFormats(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_SNFormatRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update SNFormat for the service
   Description: Calls UpdateExt to update SNFormat. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_SNFormat
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.SNFormatRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_SNFormats_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SNFormats(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete SNFormat item
   Description: Call UpdateExt to delete SNFormat item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_SNFormat
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_SNFormats_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SNFormats(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get TaxConnectStatus items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_TaxConnectStatus
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.TaxConnectStatusRow
   */  
export function get_TaxConnectStatus(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxConnectStatusRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/TaxConnectStatus", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxConnectStatusRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_TaxConnectStatus
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.TaxConnectStatusRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.TaxConnectStatusRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_TaxConnectStatus(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/TaxConnectStatus", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the TaxConnectStatu item
   Description: Calls GetByID to retrieve the TaxConnectStatu item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_TaxConnectStatu
      @param Company Desc: Company   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.TaxConnectStatusRow
   */  
export function get_TaxConnectStatus_Company(Company:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_TaxConnectStatusRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/TaxConnectStatus(" + Company + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_TaxConnectStatusRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update TaxConnectStatu for the service
   Description: Calls UpdateExt to update TaxConnectStatu. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_TaxConnectStatu
      @param Company Desc: Company   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.TaxConnectStatusRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_TaxConnectStatus_Company(Company:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/TaxConnectStatus(" + Company + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete TaxConnectStatu item
   Description: Call UpdateExt to delete TaxConnectStatu item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_TaxConnectStatu
      @param Company Desc: Company   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_TaxConnectStatus_Company(Company:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/TaxConnectStatus(" + Company + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetList for the service
   Description: Get list of items<div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetList
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.OrderHedListRow
   */  
export function get_List(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/List", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
// Custom methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Invoke method GetRows
   Description: Returns a dataset containing all rows that satisfy the where clauses.
   OperationID: Get_GetRows
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRows_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetRows(whereClauseOrderHed:string, whereClauseOrderHedAttch:string, whereClauseOHOrderMsc:string, whereClauseOrderDtl:string, whereClauseOrderDtlAttch:string, whereClauseOrderMsc:string, whereClauseOrderRel:string, whereClauseOrderRelTax:string, whereClauseOrderHedUPS:string, whereClauseOrderRepComm:string, whereClauseOrderSched:string, whereClauseHedTaxSum:string, whereClauseOrderHist:string, whereClausePartSubs:string, whereClauseSelectedSerialNumbers:string, whereClauseSNFormat:string, whereClauseTaxConnectStatus:string, pageSize:string, absolutePage:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof whereClauseOrderHed!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderHed=" + whereClauseOrderHed
   }
   if(typeof whereClauseOrderHedAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderHedAttch=" + whereClauseOrderHedAttch
   }
   if(typeof whereClauseOHOrderMsc!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOHOrderMsc=" + whereClauseOHOrderMsc
   }
   if(typeof whereClauseOrderDtl!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderDtl=" + whereClauseOrderDtl
   }
   if(typeof whereClauseOrderDtlAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderDtlAttch=" + whereClauseOrderDtlAttch
   }
   if(typeof whereClauseOrderMsc!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderMsc=" + whereClauseOrderMsc
   }
   if(typeof whereClauseOrderRel!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderRel=" + whereClauseOrderRel
   }
   if(typeof whereClauseOrderRelTax!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderRelTax=" + whereClauseOrderRelTax
   }
   if(typeof whereClauseOrderHedUPS!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderHedUPS=" + whereClauseOrderHedUPS
   }
   if(typeof whereClauseOrderRepComm!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderRepComm=" + whereClauseOrderRepComm
   }
   if(typeof whereClauseOrderSched!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderSched=" + whereClauseOrderSched
   }
   if(typeof whereClauseHedTaxSum!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseHedTaxSum=" + whereClauseHedTaxSum
   }
   if(typeof whereClauseOrderHist!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseOrderHist=" + whereClauseOrderHist
   }
   if(typeof whereClausePartSubs!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartSubs=" + whereClausePartSubs
   }
   if(typeof whereClauseSelectedSerialNumbers!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseSelectedSerialNumbers=" + whereClauseSelectedSerialNumbers
   }
   if(typeof whereClauseSNFormat!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseSNFormat=" + whereClauseSNFormat
   }
   if(typeof whereClauseTaxConnectStatus!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseTaxConnectStatus=" + whereClauseTaxConnectStatus
   }
   if(typeof pageSize!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "pageSize=" + pageSize
   }
   if(typeof absolutePage!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "absolutePage=" + absolutePage
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRows" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetByID
   Description: Returns a DataSet given the primary key.
   OperationID: Get_GetByID
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetByID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetByID(orderNum:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof orderNum!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "orderNum=" + orderNum
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetByID" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetList
   Description: Returns a list of rows that satisfy the where clause.
   OperationID: Get_GetList
      @param whereClause Desc: An expression used to filter the rows. Can be left blank for all rows.   Required: True   Allow empty value : True
      @param pageSize Desc: The maximum number of rows to return. Leave as zero for no maximum.   Required: True
      @param absolutePage Desc: Page of rows to return.   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetList(whereClause:string, pageSize:string, absolutePage:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof whereClause!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClause=" + whereClause
   }
   if(typeof pageSize!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "pageSize=" + pageSize
   }
   if(typeof absolutePage!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "absolutePage=" + absolutePage
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetList" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCreditCardTranForOrder
   Description: It checks if a sales order already has a Sales Credit Card transaction
   OperationID: CheckCreditCardTranForOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCreditCardTranForOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCreditCardTranForOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCreditCardTranForOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckCreditCardTranForOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CounterSaleValidateInvQty
   Description: Validates inventory quantity for lines on a counter sale
   OperationID: CounterSaleValidateInvQty
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CounterSaleValidateInvQty_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CounterSaleValidateInvQty_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CounterSaleValidateInvQty(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CounterSaleValidateInvQty", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ProcessCounterSaleUsingOrderLinesInDatabase
   Description: Process the counter sale by generating the packing slip and/or the invoice.  This method does not require order lines to be
in the reference dataset.  This method will use the lines that exist in the database for processing.
for the order.
   OperationID: ProcessCounterSaleUsingOrderLinesInDatabase
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ProcessCounterSaleUsingOrderLinesInDatabase_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ProcessCounterSaleUsingOrderLinesInDatabase_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ProcessCounterSaleUsingOrderLinesInDatabase(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ProcessCounterSaleUsingOrderLinesInDatabase", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateCounterSaleSN
   Description: Validate serial numbers are entered for each part.  This method uses OrderRel records from the
database for the validations.
   OperationID: ValidateCounterSaleSN
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateCounterSaleSN_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateCounterSaleSN_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateCounterSaleSN(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateCounterSaleSN", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ProcessPayGateCreditCardStatus
   Description: Process the pay gate credit card status
   OperationID: ProcessPayGateCreditCardStatus
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ProcessPayGateCreditCardStatus_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ProcessPayGateCreditCardStatus_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ProcessPayGateCreditCardStatus(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ProcessPayGateCreditCardStatus", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateOTSTaxID
   Description: Supplier Tax Id validation
   OperationID: ValidateOTSTaxID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateOTSTaxID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateOTSTaxID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateOTSTaxID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateOTSTaxID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ConsolidateOrdersToCounterSale
   Description: Consolidates a list of order numbers into a single counter sale order
   OperationID: ConsolidateOrdersToCounterSale
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ConsolidateOrdersToCounterSale_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ConsolidateOrdersToCounterSale_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ConsolidateOrdersToCounterSale(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ConsolidateOrdersToCounterSale", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderHed
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderHed
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderHed(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderHedAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderHedAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderHedAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderHedAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderHedAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderHedAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOHOrderMsc
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOHOrderMsc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOHOrderMsc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOHOrderMsc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOHOrderMsc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOHOrderMsc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderDtl
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderDtl
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderDtl(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderDtlAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderDtlAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderDtlAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderDtlAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderDtlAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderDtlAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderMsc
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderMsc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderMsc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderMsc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderMsc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderMsc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderRel
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderRel
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderRel_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderRel_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderRel(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderRel", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderRelTax
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderRelTax
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderRelTax_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderRelTax_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderRelTax(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderRelTax", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderHedUPS
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderHedUPS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderHedUPS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderHedUPS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderHedUPS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderHedUPS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewOrderSched
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewOrderSched
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewOrderSched_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewOrderSched_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewOrderSched(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewOrderSched", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeleteByID
   Description: Deletes a row given its ID.
   OperationID: DeleteByID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DeleteByID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeleteByID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeleteByID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/DeleteByID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBySysRowID
   OperationID: Get_GetBySysRowID
   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBySysRowID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetBySysRowID(id:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof id!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "id=" + id
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetBySysRowID" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBySysRowIDs
   OperationID: Get_GetBySysRowIDs
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBySysRowIDs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetBySysRowIDs(ids:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof ids!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "ids=" + ids
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetBySysRowIDs" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method Update
   Description: Commits the DataSet changes to the data store.
   OperationID: Update
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Update_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/Update_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_Update(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/Update", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateExt
   Description: Apply input data to service by calling GetByID/GetNew/Update methods.
   OperationID: UpdateExt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateExt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateExt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateExt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/UpdateExt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateLineMiscChargesFromQuote
   Description: Method to call to create Line Misc Charges when adding a new OrderDtl record from a quote
   OperationID: CreateLineMiscChargesFromQuote
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateLineMiscChargesFromQuote_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateLineMiscChargesFromQuote_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateLineMiscChargesFromQuote(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CreateLineMiscChargesFromQuote", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateLinesFromHistory
   Description: Create new lines for every Order Lines selected from History,
   OperationID: CreateLinesFromHistory
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateLinesFromHistory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateLinesFromHistory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateLinesFromHistory(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CreateLinesFromHistory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateOrderDtlComplements
   Description: Create new lines for every complement selected for a given Line,
   OperationID: CreateOrderDtlComplements
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateOrderDtlComplements_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateOrderDtlComplements_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateOrderDtlComplements(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CreateOrderDtlComplements", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateOrderFromQuote
   Description: Creates an order from a quote.
   OperationID: CreateOrderFromQuote
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateOrderFromQuote_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateOrderFromQuote_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateOrderFromQuote(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CreateOrderFromQuote", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateOrderFromQuoteSaveOTS
   Description: Creates an order from a quote and saves the OTS.
   OperationID: CreateOrderFromQuoteSaveOTS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateOrderFromQuoteSaveOTS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateOrderFromQuoteSaveOTS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateOrderFromQuoteSaveOTS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CreateOrderFromQuoteSaveOTS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ETCValidateAddress
   Description: Call tax integration and loads temp tables from the results.
   OperationID: ETCValidateAddress
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ETCValidateAddress_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ETCValidateAddress_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ETCValidateAddress(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ETCValidateAddress", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ETCAfterAddressValidationOTS
   Description: After the tax integration has been called, update the Sales Order on one time shipment address if it
was changed.
   OperationID: ETCAfterAddressValidationOTS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ETCAfterAddressValidationOTS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ETCAfterAddressValidationOTS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ETCAfterAddressValidationOTS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ETCAfterAddressValidationOTS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ETCAfterRelAddressValidationOTS
   Description: After the tax integration has been called, update the Sales Order Release on one time shipment address if it
was changed.
   OperationID: ETCAfterRelAddressValidationOTS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ETCAfterRelAddressValidationOTS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ETCAfterRelAddressValidationOTS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ETCAfterRelAddressValidationOTS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ETCAfterRelAddressValidationOTS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetByIDLinkedOrder
   Description: Update Order Header information with values from the Ship To when the Ship To is changed.
   OperationID: GetByIDLinkedOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetByIDLinkedOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetByIDLinkedOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetByIDLinkedOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetByIDLinkedOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCalcQtyPref
   OperationID: GetCalcQtyPref
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCalcQtyPref_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCalcQtyPref(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetCalcQtyPref", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetGlbSugPOChg
   Description: Get the GlbSugPOChg records for an Order Release.
   OperationID: GetGlbSugPOChg
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetGlbSugPOChg_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetGlbSugPOChg_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetGlbSugPOChg(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetGlbSugPOChg", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetGlbSugPOChgForOrder
   Description: Get all GlbSugPOChg records for an order
   OperationID: GetGlbSugPOChgForOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetGlbSugPOChgForOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetGlbSugPOChgForOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetGlbSugPOChgForOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetGlbSugPOChgForOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetInventoryQuantities
   Description: Deprecated Method that updates the Available and On Hand Quantity on OrderDtl and/or OrderRel.
   OperationID: GetInventoryQuantities
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetInventoryQuantities_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetInventoryQuantities_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetInventoryQuantities(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetInventoryQuantities", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetJobProd
   Description: Get the JobProd records for an Order Release.
   OperationID: GetJobProd
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetJobProd_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetJobProd_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetJobProd(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetJobProd", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetJobProdForRelease
   Description: Get the JobProd records for an Order Release - overload method with release number.
   OperationID: GetJobProdForRelease
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetJobProdForRelease_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetJobProdForRelease_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetJobProdForRelease(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetJobProdForRelease", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetKitComponents
   Description: Calls GetKitComponents from SalesKitting.p, which creates a list of OrderDtl records
that will be treated as kit components of the given OrderLine.
   OperationID: GetKitComponents
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetKitComponents_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetKitComponents_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetKitComponents(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetKitComponents", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRowsAuthorizedTerritories
   Description: This method returns rows with territory authorization considerations
   OperationID: GetRowsAuthorizedTerritories
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetRowsAuthorizedTerritories_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRowsAuthorizedTerritories_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRowsAuthorizedTerritories(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRowsAuthorizedTerritories", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSalesOrderRelationshipMap
   Description: Returns a serialized json string to show a Relationship Map for Sales Order
   OperationID: GetSalesOrderRelationshipMap
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetSalesOrderRelationshipMap_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSalesOrderRelationshipMap_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSalesOrderRelationshipMap(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetSalesOrderRelationshipMap", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListCustom
   Description: This overload of GetList adds Sales Orders which ShipTo's fall within authorized territories.
   OperationID: GetListCustom
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListCustom_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListCustom_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListCustom(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetListCustom", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewSalesKit
   Description: Creates a new OrderDtl and sets it as a kit component for the given OrderLine
   OperationID: GetNewSalesKit
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewSalesKit_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewSalesKit_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewSalesKit(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetNewSalesKit", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPayBTFlagDefaults
   OperationID: GetPayBTFlagDefaults
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPayBTFlagDefaults_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPayBTFlagDefaults_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPayBTFlagDefaults(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetPayBTFlagDefaults", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPlantConfCtrlInfo
   Description: Retrieves specific data from PlantConfCtrl for sale order form
   OperationID: GetPlantConfCtrlInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPlantConfCtrlInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPlantConfCtrlInfo(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetPlantConfCtrlInfo", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetQuoteQty
   Description: Get the QuoteQty records for an Order Release.
   OperationID: GetQuoteQty
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetQuoteQty_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetQuoteQty_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetQuoteQty(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetQuoteQty", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRowsCustomerTracker
   Description: Calls the normal GetRows method and then constructs a custom data set combining Hed/Dtl fields for the customer tracker.
   OperationID: GetRowsCustomerTracker
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetRowsCustomerTracker_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRowsCustomerTracker_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRowsCustomerTracker(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRowsCustomerTracker", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRowsForCashReceipt
   Description: Invokes GetRows filtering on orders for the specified Cash Receipt
   OperationID: GetRowsForCashReceipt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetRowsForCashReceipt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRowsForCashReceipt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRowsForCashReceipt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRowsForCashReceipt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRowsForInvoice
   Description: Invokes GetRows filtering on orders for the specified Invoice
   OperationID: GetRowsForInvoice
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetRowsForInvoice_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRowsForInvoice_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRowsForInvoice(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRowsForInvoice", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRowsForQuote
   Description: Invokes GetRows filtering on orders for the specified Quote
   OperationID: GetRowsForQuote
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetRowsForQuote_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRowsForQuote_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRowsForQuote(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRowsForQuote", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRowsForShipment
   Description: Invokes GetRows filtering on orders for the specified Customer Shipment
   OperationID: GetRowsForShipment
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetRowsForShipment_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRowsForShipment_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRowsForShipment(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetRowsForShipment", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSelectSerialNumbersParams
   OperationID: GetSelectSerialNumbersParams
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetSelectSerialNumbersParams_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSelectSerialNumbersParams_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSelectSerialNumbersParams(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetSelectSerialNumbersParams", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSmartString
   Description: Generates the SmartString for kit component configured part
   OperationID: GetSmartString
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetSmartString_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSmartString_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSmartString(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetSmartString", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetUIParams
   Description: Get the parameters needed for the UI on startup.
   OperationID: GetUIParams
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetUIParams_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetUIParams(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetUIParams", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GlbSugPOChgDelete
   Description: Delete a new GlbSugPOChg record.
   OperationID: GlbSugPOChgDelete
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GlbSugPOChgDelete_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GlbSugPOChgDelete_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GlbSugPOChgDelete(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GlbSugPOChgDelete", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GlbSugPOChgUpdate
   Description: Update/Add a new GlbSugPOChg record.
   OperationID: GlbSugPOChgUpdate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GlbSugPOChgUpdate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GlbSugPOChgUpdate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GlbSugPOChgUpdate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GlbSugPOChgUpdate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method JobProdDelete
   Description: Delete JobProd records.
   OperationID: JobProdDelete
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/JobProdDelete_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/JobProdDelete_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_JobProdDelete(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/JobProdDelete", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method KitCompPartCreate
   Description: Configured kit component part creation
   OperationID: KitCompPartCreate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/KitCompPartCreate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/KitCompPartCreate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_KitCompPartCreate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/KitCompPartCreate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method MasterUpdate
   Description: Perform all validations associated with the Update.  We have combined all method calls that were being called
at update into this one method.  Making multiple BL calls is a performance issue and this increases performance.
   OperationID: MasterUpdate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/MasterUpdate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/MasterUpdate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_MasterUpdate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/MasterUpdate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeARLOCID
   Description: Validate ARLOCID value
   OperationID: OnChangeARLOCID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeARLOCID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeARLOCID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeARLOCID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeARLOCID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCreditCardOrder
   Description: This method validates field CreditCardOrder
   OperationID: OnChangeCreditCardOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCreditCardOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCreditCardOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCreditCardOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeCreditCardOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateCurrencyCode
   Description: This method is used to validate the proposed Currency Code for a Sales Order.
   OperationID: ValidateCurrencyCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateCurrencyCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateCurrencyCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateCurrencyCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateCurrencyCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateInvCurrCode
   Description: This method is used to validate the proposed Invoice Currency Code for a Sales Order.
   OperationID: ValidateInvCurrCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateInvCurrCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateInvCurrCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateInvCurrCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateInvCurrCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeHeaderShipTo
   Description: Validate changed ShipTo on Order Header
   OperationID: OnChangeHeaderShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeHeaderShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeHeaderShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeHeaderShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeHeaderShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofBTConNum
   Description: This method returns the Bill To Contact info.
   OperationID: OnChangeofBTConNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofBTConNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofBTConNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofBTConNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofBTConNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofBTCustID
   Description: This method returns the Bill To customer info.
   OperationID: OnChangeofBTCustID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofBTCustID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofBTCustID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofBTCustID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofBTCustID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeOfFixedAmount
   Description: This method should be called when the taxable amount on the invoice tax
record is changed.
   OperationID: OnChangeOfFixedAmount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeOfFixedAmount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeOfFixedAmount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeOfFixedAmount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeOfFixedAmount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeOfMktgCampaign
   Description: This method should be called when MktgCampaign changes. It will validate to select an Active
MktgCampaign. This method defaults the Marketing Event field
   OperationID: OnChangeOfMktgCampaign
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeOfMktgCampaign_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeOfMktgCampaign_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeOfMktgCampaign(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeOfMktgCampaign", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeOfMktgEvnt
   Description: This method should be called when MktgEvent changes. It will validate to select an Active MktgEvent.
   OperationID: OnChangeOfMktgEvnt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeOfMktgEvnt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeOfMktgEvnt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeOfMktgEvnt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeOfMktgEvnt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeOfQuoteLine
   Description: This method should be called when QuoteLine changes.
   OperationID: OnChangeOfQuoteLine
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeOfQuoteLine_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeOfQuoteLine_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeOfQuoteLine(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeOfQuoteLine", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofPhaseID
   Description: Check new phase and return phase info.
   OperationID: OnChangeofPhaseID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofPhaseID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofPhaseID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofPhaseID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofPhaseID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeRelShipToNum
   Description: Check new phase and return phase info.
   OperationID: OnChangeRelShipToNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeRelShipToNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeRelShipToNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeRelShipToNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeRelShipToNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateBAQShippingDate
   Description: Validate the date is a working day as set in the Shipping Calendar. Called from a BAQ.
   OperationID: ValidateBAQShippingDate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateBAQShippingDate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateBAQShippingDate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateBAQShippingDate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateBAQShippingDate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateShippingDate
   Description: Validate the date is a working day as set in the Shipping Calendar.
   OperationID: ValidateShippingDate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateShippingDate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateShippingDate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateShippingDate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateShippingDate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofSoldToCreditCheck
   Description: This method should be called when the sold to customer changes. It will validate the default
bill to customer credit.
The method returns a character string if the customer will go over their credit limit
and the user is given the choice of continuing or not.
   OperationID: OnChangeofSoldToCreditCheck
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofSoldToCreditCheck_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofSoldToCreditCheck_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofSoldToCreditCheck(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofSoldToCreditCheck", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeOfTaxAmt
   Description: This method should be called when the taxable amount on the invoice tax
record is changed.
   OperationID: OnChangeOfTaxAmt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeOfTaxAmt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeOfTaxAmt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeOfTaxAmt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeOfTaxAmt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeOfTaxPercent
   Description: This method should be called when the taxable amount on the invoice tax record is changed.
   OperationID: OnChangeOfTaxPercent
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeOfTaxPercent_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeOfTaxPercent_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeOfTaxPercent(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeOfTaxPercent", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofTaxRgn
   Description: Validate Tax Region Code entered by the user.
   OperationID: OnChangeofTaxRgn
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofTaxRgn_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofTaxRgn_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofTaxRgn(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofTaxRgn", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeRateCode
   OperationID: OnChangeRateCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeRateCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeRateCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeRateCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeRateCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeTaxableAmt
   Description: This method should be called when the taxable amount on the invoice tax
record is changed.
   OperationID: OnChangeTaxableAmt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeTaxableAmt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeTaxableAmt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeTaxableAmt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeTaxableAmt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeTaxCode
   OperationID: OnChangeTaxCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeTaxCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeTaxCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeTaxCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeTaxCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeCardType
   Description: OrderDtl after get new logic.
   OperationID: OnChangeCardType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeCardType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeCardType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeCardType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeCardType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateOrderLinesTaxCategoryTypes
   Description: Method to validate that all Order lines have Tax Categories with the same Tax Category Type
   OperationID: ValidateOrderLinesTaxCategoryTypes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateOrderLinesTaxCategoryTypes_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateOrderLinesTaxCategoryTypes_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateOrderLinesTaxCategoryTypes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateOrderLinesTaxCategoryTypes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OrderDtlGetNewContracts
   Description: Method to call when adding a new OrderDtl record for a Contract or a Service Contract
   OperationID: OrderDtlGetNewContracts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OrderDtlGetNewContracts_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OrderDtlGetNewContracts_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderDtlGetNewContracts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlGetNewContracts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OrderDtlGetNewCounterSale
   Description: Method to call when adding a new OrderDtl record for a counter sale
   OperationID: OrderDtlGetNewCounterSale
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OrderDtlGetNewCounterSale_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OrderDtlGetNewCounterSale_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderDtlGetNewCounterSale(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlGetNewCounterSale", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OrderDtlGetNewFromQuote
   Description: Method to call when adding a new OrderDtl record from a quote
   OperationID: OrderDtlGetNewFromQuote
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OrderDtlGetNewFromQuote_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OrderDtlGetNewFromQuote_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderDtlGetNewFromQuote(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlGetNewFromQuote", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangingOrderSchedPercent
   Description: When the PayPercent field is modified this method makes sure the proposed value is valid.
If the proposed value is valid then the PayAmount of the modified payment is recalculated to match the new PayPercent.
After the PayAmount is recalculated it checks for a difference between the summation of the PayPercent and 100%.
If there's a difference it is adjusted on the last payment.
   OperationID: OnChangingOrderSchedPercent
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangingOrderSchedPercent_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangingOrderSchedPercent_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangingOrderSchedPercent(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangingOrderSchedPercent", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangingOrderSchedAmount
   Description: When the PayAmount field is modified this method makes sure the proposed value is valid.
If the proposed value is valid then the PayPercent of the modified payment is recalculated to match the new PayAmount.
After the PayAmount is recalculated it checks for a difference between the summation of the PayPercent and 100%.
If there's a difference it is adjusted on the last payment.
   OperationID: OnChangingOrderSchedAmount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangingOrderSchedAmount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangingOrderSchedAmount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangingOrderSchedAmount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangingOrderSchedAmount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OverCreditLimitUpdateAllowed
   Description: This should be called whenever the user selects an order either by typing the
order number on the screen or picking it via a lookup.  This method checks to
see if the order is over the credit limit, and if it is it then checks a system
setting to see if orders over the credit limit can be updated.  If they cannot,
it returns a value of false and updates cannot occur.
   OperationID: OverCreditLimitUpdateAllowed
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OverCreditLimitUpdateAllowed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OverCreditLimitUpdateAllowed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OverCreditLimitUpdateAllowed(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OverCreditLimitUpdateAllowed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PhantomComponents
   Description: This procedure will explode the BOM of a part set as Phantom
   OperationID: PhantomComponents
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PhantomComponents_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PhantomComponents_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PhantomComponents(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PhantomComponents", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ProcessCounterSale
   Description: Process the counter sale by generating the packing slip and/or the invoice
for the order.
   OperationID: ProcessCounterSale
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ProcessCounterSale_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ProcessCounterSale_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ProcessCounterSale(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ProcessCounterSale", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ProcessQuickEntry
   Description: Process the Quick Entry job options on the order detail lines.
   OperationID: ProcessQuickEntry
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ProcessQuickEntry_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ProcessQuickEntry_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ProcessQuickEntry(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ProcessQuickEntry", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method RebuildShipUPS
   OperationID: RebuildShipUPS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/RebuildShipUPS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/RebuildShipUPS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_RebuildShipUPS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/RebuildShipUPS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method RecalcKitPriceAfterConfig
   Description: When configuring a part, the OrderDtl unit price may change during the configuration
process.  This method is to be called after running product configurator to recalculate
the kit pricing.
   OperationID: RecalcKitPriceAfterConfig
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/RecalcKitPriceAfterConfig_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/RecalcKitPriceAfterConfig_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_RecalcKitPriceAfterConfig(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/RecalcKitPriceAfterConfig", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method RemoveICPOLink
   Description: Removes a PO Link from this order.
   OperationID: RemoveICPOLink
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/RemoveICPOLink_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/RemoveICPOLink_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_RemoveICPOLink(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/RemoveICPOLink", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ReopenOrder
   Description: Reopens an order.
   OperationID: ReopenOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ReopenOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ReopenOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ReopenOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ReopenOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ReopenOrderLine
   Description: Reopens an order line.
   OperationID: ReopenOrderLine
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ReopenOrderLine_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ReopenOrderLine_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ReopenOrderLine(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ReopenOrderLine", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method VerifyReopenRelease
   Description: Precheck before reopening an order release.
   OperationID: VerifyReopenRelease
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/VerifyReopenRelease_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/VerifyReopenRelease_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_VerifyReopenRelease(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/VerifyReopenRelease", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ReopenReleaseSetAttributeSetID
   Description: Reopens an order release.
   OperationID: ReopenReleaseSetAttributeSetID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ReopenReleaseSetAttributeSetID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ReopenReleaseSetAttributeSetID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ReopenReleaseSetAttributeSetID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ReopenReleaseSetAttributeSetID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ReopenRelease
   Description: Reopens an order release.
   OperationID: ReopenRelease
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ReopenRelease_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ReopenRelease_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ReopenRelease(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ReopenRelease", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method REVISIONHISTORY06
   OperationID: REVISIONHISTORY06
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/REVISIONHISTORY06_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_REVISIONHISTORY06(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/REVISIONHISTORY06", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SendLinkedICPOSuggestion
   Description: Send a linked IC PO Suggestion.
   OperationID: SendLinkedICPOSuggestion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/SendLinkedICPOSuggestion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SendLinkedICPOSuggestion(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SendLinkedICPOSuggestion", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetCalcQtysPref
   OperationID: SetCalcQtysPref
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetCalcQtysPref_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetCalcQtysPref_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetCalcQtysPref(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SetCalcQtysPref", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetReadyToCalc
   Description: CALCULATE VANTAGE\TAX CONNECT TAX CALCULATIONS
UI NEEDS TO CALL A SAVE BEFORE CALLING THIS PROCEDURE
   OperationID: SetReadyToCalc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetReadyToCalc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetReadyToCalc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetReadyToCalc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SetReadyToCalc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetUPSQVEnable
   OperationID: SetUPSQVEnable
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetUPSQVEnable_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetUPSQVEnable_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetUPSQVEnable(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SetUPSQVEnable", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeIncotermCode
   Description: This method checks incoterm
   OperationID: ChangeIncotermCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeIncotermCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeIncotermCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeIncotermCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeIncotermCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateInvQty
   Description: Validate that the order detail line transaction does not cause the part
to result in negative on hand quantity.
   OperationID: ValidateInvQty
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateInvQty_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateInvQty_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateInvQty(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateInvQty", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateSN
   OperationID: ValidateSN
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateSN_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateSN_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateSN(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateSN", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateSNs
   Description: Validate serial numbers are entered for each part before calling generatepackslip.
   OperationID: ValidateSNs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateSNs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateSNs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateSNs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateSNs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method VerifySendICPOSugg
   Description: Returns the text of the message to be presented to the user asking if they
are sure they want to continue with the SendICPOSuggestions process or not.
This method should be called after CheckICPOReadyToSend if the user chose to continue
and before the SendICPOSuggestions method.
   OperationID: VerifySendICPOSugg
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/VerifySendICPOSugg_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_VerifySendICPOSugg(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/VerifySendICPOSugg", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method HasMultipleSubs
   OperationID: HasMultipleSubs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/HasMultipleSubs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/HasMultipleSubs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_HasMultipleSubs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/HasMultipleSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method IsRunOutOnHand
   OperationID: IsRunOutOnHand
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/IsRunOutOnHand_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/IsRunOutOnHand_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_IsRunOutOnHand(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/IsRunOutOnHand", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SubmitNewOrder
   OperationID: SubmitNewOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SubmitNewOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SubmitNewOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SubmitNewOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SubmitNewOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateExistingOrder
   OperationID: UpdateExistingOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateExistingOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateExistingOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateExistingOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/UpdateExistingOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateOrderDtlDiscountPercent
   Description: This method updates the DiscountPercent for existing Order Detail Lines in a Sales Order
   OperationID: UpdateOrderDtlDiscountPercent
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateOrderDtlDiscountPercent_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateOrderDtlDiscountPercent_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateOrderDtlDiscountPercent(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/UpdateOrderDtlDiscountPercent", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBasePartForConfig
   Description: This method will retrieve the base configured part number to be passed
to configuration entry
   OperationID: GetBasePartForConfig
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetBasePartForConfig_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBasePartForConfig_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetBasePartForConfig(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetBasePartForConfig", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBasePartAndConfigType
   Description: Retrieve the base configured part and config type
   OperationID: GetBasePartAndConfigType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetBasePartAndConfigType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBasePartAndConfigType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetBasePartAndConfigType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetBasePartAndConfigType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method InvoiceExists
   Description: Check if any invoice exists related to a specific sales order, except for misc and credit memo invoices.
   OperationID: InvoiceExists
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/InvoiceExists_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/InvoiceExists_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_InvoiceExists(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/InvoiceExists", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeTranDocTypeID
   Description: CSF Taiwan. This method should be called when the transaction document type changes.
   OperationID: OnChangeTranDocTypeID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeTranDocTypeID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeTranDocTypeID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeTranDocTypeID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeTranDocTypeID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateProjectID
   Description: This method validate if the project has selected an invoicing method different of Customer Shipment to allow add a sales order into the project.
   OperationID: ValidateProjectID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateProjectID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateProjectID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateProjectID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateProjectID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateCustomer
   Description: This method validate if the project has selected an invoicing method different of Customer Shipment to allow add a sales order into the project.
   OperationID: ValidateCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ValidateCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method EccCalcKitValue
   Description: For web basket valuation (BSV) inquiry purpose.
Calculates kit component pricing because not written to db.
Not intended to be executed from UI
   OperationID: EccCalcKitValue
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/EccCalcKitValue_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/EccCalcKitValue_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_EccCalcKitValue(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/EccCalcKitValue", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method EccProcessPayment
   Description: Processing of ECC payments.
Not intended to be executed from UI
   OperationID: EccProcessPayment
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/EccProcessPayment_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/EccProcessPayment_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_EccProcessPayment(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/EccProcessPayment", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ECCUpdate
   Description: Method specific to ECC.
This method is used by basket valuation (BSV) as a way to add BPM processing because
it is never posted to database and the standard Update will not be fired.
   OperationID: ECCUpdate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ECCUpdate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ECCUpdate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ECCUpdate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ECCUpdate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ECCUpdateFinal
   Description: Method specific to ECC.
This is used as a final process using the XML that was sent from the Web.
   OperationID: ECCUpdateFinal
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ECCUpdateFinal_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ECCUpdateFinal_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ECCUpdateFinal(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ECCUpdateFinal", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdatePartAllocQueue
   Description: Update the fulfillment queue with the releases on this sales order.
   OperationID: UpdatePartAllocQueue
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdatePartAllocQueue_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdatePartAllocQueue_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdatePartAllocQueue(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/UpdatePartAllocQueue", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ConfigurationChangePart
   Description: Update Order details information when the Part Number is changed by Configuration Part Creation.
   OperationID: ConfigurationChangePart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ConfigurationChangePart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ConfigurationChangePart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ConfigurationChangePart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ConfigurationChangePart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ConfigurationRefreshQty
   Description: Update PriceList Qty breaks and set new unit price on those
when the product code is changed by Document Rule.
   OperationID: ConfigurationRefreshQty
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ConfigurationRefreshQty_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ConfigurationRefreshQty_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ConfigurationRefreshQty(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ConfigurationRefreshQty", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ConfigurationChangeUnitPrice
   Description: Update Price fields when the UnitPrice or DocUnitPRice is changed by a Document Rule.
   OperationID: ConfigurationChangeUnitPrice
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ConfigurationChangeUnitPrice_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ConfigurationChangeUnitPrice_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ConfigurationChangeUnitPrice(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ConfigurationChangeUnitPrice", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PreOrder
   Description: Pre-check for UpdateExt to validate and return pricing
   OperationID: PreOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PreOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PreOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PreOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PreOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderHedCustomerCustID
   Description: Method to call when the Order Header CustomerCustID value changes.  This method consolidates the column changing/changed methods for
this field into one method call.
   OperationID: ChangeOrderHedCustomerCustID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderHedCustomerCustID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderHedCustomerCustID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderHedCustomerCustID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderHedCustomerCustID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderHedCurrencyCode
   Description: Method to call when the Order Header CurrencyCode value changes.  This method consolidates the column changing/changed methods for
this field into one method call.
   OperationID: ChangeOrderHedCurrencyCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderHedCurrencyCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderHedCurrencyCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderHedCurrencyCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderHedCurrencyCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderHedIntrntlShip
   Description: Method to call when the Order Header International Shipment flag changes.
   OperationID: ChangeOrderHedIntrntlShip
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderHedIntrntlShip_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderHedIntrntlShip_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderHedIntrntlShip(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderHedIntrntlShip", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderHedOTSSaveAs
   Description: Method to call when the Order Header OTSSaveAs value changes.
   OperationID: ChangeOrderHedOTSSaveAs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderHedOTSSaveAs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderHedOTSSaveAs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderHedOTSSaveAs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderHedOTSSaveAs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelOTSSaveAs
   Description: Method to call when the Order Release OTSSaveAs value changes.
   OperationID: ChangeOrderRelOTSSaveAs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelOTSSaveAs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelOTSSaveAs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelOTSSaveAs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelOTSSaveAs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderHedSalesRepCode
   Description: Called when a sales rep code is changing.  Updates sales rep information in the passed in dataset.
   OperationID: ChangeOrderHedSalesRepCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderHedSalesRepCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderHedSalesRepCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderHedSalesRepCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderHedSalesRepCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderHedShipToNum
   Description: Method to call when the Order Header ShipToNum value changes.  This method consolidates the column changing/changed methods for
this field into one method call.
   OperationID: ChangeOrderHedShipToNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderHedShipToNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderHedShipToNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderHedShipToNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderHedShipToNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderDtlProdCode
   Description: Update Order Detail information when the order line product group is changed.
   OperationID: ChangeOrderDtlProdCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderDtlProdCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderDtlProdCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderDtlProdCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderDtlProdCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OrderDtlQuoteLineChanging
   Description: This method should be called when OrderDtl QuoteLine is changing.
   OperationID: OrderDtlQuoteLineChanging
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OrderDtlQuoteLineChanging_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OrderDtlQuoteLineChanging_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OrderDtlQuoteLineChanging(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OrderDtlQuoteLineChanging", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderDtlProjectID
   Description: Method to call when the Order Detail Project value changes.  This method consolidates the ValidateProjectID and CheckProjectID methods.
   OperationID: ChangeOrderDtlProjectID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderDtlProjectID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderDtlProjectID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderDtlProjectID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderDtlProjectID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AfterChangedOrderDtlProjectID
   Description: Update Order Rel information after the ProjectID has been changed.
   OperationID: AfterChangedOrderDtlProjectID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/AfterChangedOrderDtlProjectID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AfterChangedOrderDtlProjectID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AfterChangedOrderDtlProjectID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/AfterChangedOrderDtlProjectID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofTaxRgnWithColumnName
   Description: Validate Tax Region Code entered by the user.
   OperationID: OnChangeofTaxRgnWithColumnName
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofTaxRgnWithColumnName_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofTaxRgnWithColumnName_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofTaxRgnWithColumnName(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofTaxRgnWithColumnName", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelTaxBaseTaxAmt
   Description: This method should be called when the base taxable amount on the OrderRelTax
record is changed.
   OperationID: ChangeOrderRelTaxBaseTaxAmt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelTaxBaseTaxAmt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelTaxBaseTaxAmt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelTaxBaseTaxAmt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelTaxBaseTaxAmt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelTaxDocTaxAmt
   Description: This method should be called when the doc taxable amount on the OrderRelTax
record is changed.
   OperationID: ChangeOrderRelTaxDocTaxAmt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelTaxDocTaxAmt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelTaxDocTaxAmt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelTaxDocTaxAmt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelTaxDocTaxAmt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelTaxBaseTaxableAmt
   Description: This method should be called when the base taxable amount on the OrderRelTax tax
record is changed.
   OperationID: ChangeOrderRelTaxBaseTaxableAmt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelTaxBaseTaxableAmt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelTaxBaseTaxableAmt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelTaxBaseTaxableAmt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelTaxBaseTaxableAmt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelTaxDocTaxableAmt
   Description: This method should be called when the doc taxable amount on the OrderRelTax tax
record is changed.
   OperationID: ChangeOrderRelTaxDocTaxableAmt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelTaxDocTaxableAmt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelTaxDocTaxableAmt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelTaxDocTaxableAmt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelTaxDocTaxableAmt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelTaxBaseFixedAmount
   Description: This method should be called when the base taxable amount on the OrderRelTax
record is changed.
   OperationID: ChangeOrderRelTaxBaseFixedAmount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelTaxBaseFixedAmount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelTaxBaseFixedAmount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelTaxBaseFixedAmount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelTaxBaseFixedAmount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelTaxDocFixedAmount
   Description: This method should be called when the doc taxable amount on the OrderRelTax
record is changed.
   OperationID: ChangeOrderRelTaxDocFixedAmount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelTaxDocFixedAmount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelTaxDocFixedAmount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelTaxDocFixedAmount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelTaxDocFixedAmount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ApplyOrderHedDiscountToLines
   Description: Apply Order Discount to order lines
   OperationID: ApplyOrderHedDiscountToLines
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ApplyOrderHedDiscountToLines_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ApplyOrderHedDiscountToLines_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ApplyOrderHedDiscountToLines(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ApplyOrderHedDiscountToLines", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CopyOrderCreditLimitAndHoldCheck
   Description: Checks credit limit and hold status prior to copying an order
   OperationID: CopyOrderCreditLimitAndHoldCheck
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CopyOrderCreditLimitAndHoldCheck_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CopyOrderCreditLimitAndHoldCheck_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CopyOrderCreditLimitAndHoldCheck(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CopyOrderCreditLimitAndHoldCheck", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeUOMConfirm
   OperationID: ChangeUOMConfirm
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeUOMConfirm_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeUOMConfirm_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeUOMConfirm(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeUOMConfirm", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method getBreakListCodeDesc
   OperationID: getBreakListCodeDesc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/getBreakListCodeDesc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/getBreakListCodeDesc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_getBreakListCodeDesc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/getBreakListCodeDesc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetReprintSOAckFlag
   OperationID: SetReprintSOAckFlag
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetReprintSOAckFlag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetReprintSOAckFlag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetReprintSOAckFlag(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SetReprintSOAckFlag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ApplyOrderBasedDiscounts
   Description: Apply order based discounts to an order.
   OperationID: ApplyOrderBasedDiscounts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ApplyOrderBasedDiscounts_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ApplyOrderBasedDiscounts_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ApplyOrderBasedDiscounts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ApplyOrderBasedDiscounts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCodeDescList
   OperationID: GetCodeDescList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCodeDescList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCodeDescList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCodeDescList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/GetCodeDescList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method NegativeInventoryTest
   OperationID: NegativeInventoryTest
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/NegativeInventoryTest_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/NegativeInventoryTest_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_NegativeInventoryTest(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/NegativeInventoryTest", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CCClear
   Description: Procedure to Clear the Credit Card Information
   OperationID: CCClear
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CCClear_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CCClear_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CCClear(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CCClear", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CCLoadTranData
   Description: Procedure to be called when selecting a record in the Transaction
            history grid, the data selected is loaded in the OrderHed table
   OperationID: CCLoadTranData
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CCLoadTranData_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CCLoadTranData_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CCLoadTranData(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CCLoadTranData", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CCLoadCardNumbers
   Description: Procedure to be called when selecting a record in the Credit Card Number grid
            the data selected is loaded in the OrderHed table
   OperationID: CCLoadCardNumbers
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CCLoadCardNumbers_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CCLoadCardNumbers_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CCLoadCardNumbers(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CCLoadCardNumbers", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCreditTran
   Description: It checks if a sales order already has a Sales Credit Card transaction
   OperationID: CheckCreditTran
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCreditTran_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCreditTran_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCreditTran(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckCreditTran", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CCProcessCard
   Description: Procedure to attempt to process transaction for the amount specified in
            the "Total" field.
   OperationID: CCProcessCard
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CCProcessCard_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CCProcessCard_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CCProcessCard(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CCProcessCard", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeBTCustIDMaster
   Description: This method returns the Bill To customer info.
   OperationID: ChangeBTCustIDMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeBTCustIDMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeBTCustIDMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeBTCustIDMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeBTCustIDMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCardNumber
   Description: Procedure to validate the Credit Card Number. Validations to be performed:
MOD10, Length and Prefix (according to the credit card type)
   OperationID: ChangeCardNumber
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCardNumber_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCardNumber_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCardNumber(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCardNumber", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCCAmounts
   Description: This procedure should be called when any of the Credit Card
            amounts change (from the Column Changed event in the UI) to calculate the
            total to be charged to the credit card
   OperationID: ChangeCCAmounts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCCAmounts_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCCAmounts_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCCAmounts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCCAmounts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCommissionable
   Description: Update Order Detail commission information when the Commissionable
flag is changed.
   OperationID: ChangeCommissionable
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCommissionable_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCommissionable_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCommissionable(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCommissionable", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCommodityCode
   Description: Validate entered Commodity Code
   OperationID: ChangeCommodityCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCommodityCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCommodityCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCommodityCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCommodityCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeContractNum
   Description: Update Order Detail information when the contract is changed.
   OperationID: ChangeContractNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeContractNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeContractNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeContractNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeContractNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeContractNumMaster
   OperationID: ChangeContractNumMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeContractNumMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeContractNumMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeContractNumMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeContractNumMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCounterSale
   Description: Update Order Header information when the counter sale flag changes.
   OperationID: ChangeCounterSale
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCounterSale_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCounterSale_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCounterSale(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCounterSale", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCreditExp
   Description: Procedure to validate Credit Card Expiration Date
   OperationID: ChangeCreditExp
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCreditExp_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCreditExp_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCreditExp(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCreditExp", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCurrencyCode
   Description: Update Order Header Exchange Rate when the currency code changes.
   OperationID: ChangeCurrencyCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCurrencyCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCurrencyCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCurrencyCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCurrencyCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCustomer
   Description: Update Order Header Credit Card Customer information when the Customer is changed.
   OperationID: ChangeCustomer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCustomer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangedCardNumber
   Description: Procedure to encrypt and mask the Credit Card Number. This method should be
called in the Column Changed event, assuming that the validation
performed in ChangeCardNumber was successful.
   OperationID: ChangedCardNumber
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangedCardNumber_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangedCardNumber_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangedCardNumber(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangedCardNumber", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ProcessPayGateMessage
   Description: Mask CRE Credit Card
   OperationID: ProcessPayGateMessage
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ProcessPayGateMessage_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ProcessPayGateMessage_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ProcessPayGateMessage(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ProcessPayGateMessage", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeDiscBreakListCode
   Description: Change the DiscBreakListCode
   OperationID: ChangeDiscBreakListCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeDiscBreakListCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeDiscBreakListCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeDiscBreakListCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeDiscBreakListCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeDiscountAmount
   Description: Update Order Detail information when the price discount percent is changed.
   OperationID: ChangeDiscountAmount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeDiscountAmount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeDiscountAmount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeDiscountAmount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeDiscountAmount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeDiscountPercent
   Description: Update Order Detail information when the price discount percent is changed.
   OperationID: ChangeDiscountPercent
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeDiscountPercent_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeDiscountPercent_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeDiscountPercent(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeDiscountPercent", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeERSOrder
   Description: Update Order Header information when the ERS Order changes.
   OperationID: ChangeERSOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeERSOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeERSOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeERSOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeERSOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeGroup
   Description: Update Order Detail information when the Group is changed.
   OperationID: ChangeGroup
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeGroup_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeGroup_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeGroup(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeGroup", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeHedOTSCountryNum
   Description: Method to call when changing the OrderHed.OTSCountryNum field.
Update Tax Region Code
   OperationID: ChangeHedOTSCountryNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeHedOTSCountryNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeHedOTSCountryNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeHedOTSCountryNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeHedOTSCountryNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeHedUseOTS
   Description: Method to call when changing the OrderHed.UseOTS field.
Refreshes the address list and contact info
   OperationID: ChangeHedUseOTS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeHedUseOTS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeHedUseOTS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeHedUseOTS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeHedUseOTS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeKitPricing
   Description: Recalculates the parent line's unit price when the kit pricing is set to "P", if the kit pricing is set to "C"
the price will be calculated on the AfterUpdate procedure.
   OperationID: ChangeKitPricing
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeKitPricing_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeKitPricing_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeKitPricing(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeKitPricing", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeKitQtyPer
   Description: Used to recalculate the SellingQty of the component kit line using the parent's SellingQuantity
   OperationID: ChangeKitQtyPer
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeKitQtyPer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeKitQtyPer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeKitQtyPer(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeKitQtyPer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMake
   Description: Update Order Release information when the Make value is changed.
   OperationID: ChangeMake
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMake_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMake_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMake(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeMake", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeManualTaxCalc
   OperationID: ChangeManualTaxCalc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeManualTaxCalc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeManualTaxCalc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeManualTaxCalc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeManualTaxCalc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMiscAmount
   Description: Update Order Miscellaneous information when the amount changes.
   OperationID: ChangeMiscAmount
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMiscAmount_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMiscAmount_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMiscAmount(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeMiscAmount", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMiscCode
   Description: This method returns default information for the MiscChrg.  Method must use
parameters instead of the dataset due to the problem with changing the primary key field.
Also allows OrderMsc and OHOrderMsc to use the same code
   OperationID: ChangeMiscCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMiscCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMiscCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMiscCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeMiscCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMiscPercent
   Description: Update Order Miscellaneous information when the percentage changes.
   OperationID: ChangeMiscPercent
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMiscPercent_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMiscPercent_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMiscPercent(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeMiscPercent", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMiscType
   Description: Update Order Miscellaneous information when the type changes.
   OperationID: ChangeMiscType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMiscType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMiscType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMiscType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeMiscType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeNeedByDate
   Description: Update Order Header information based on the NeedByDate changing.https://localhost/erp10cc/api/help/
   OperationID: ChangeNeedByDate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeNeedByDate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeNeedByDate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeNeedByDate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeNeedByDate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeNewNeedByDate
   Description: Update Global PO information based on the New Need By Date changing.
   OperationID: ChangeNewNeedByDate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeNewNeedByDate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeNewNeedByDate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeNewNeedByDate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeNewNeedByDate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeNewSellingQuantity
   Description: Update Global PO information based on the New Selling Quantity changing.
   OperationID: ChangeNewSellingQuantity
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeNewSellingQuantity_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeNewSellingQuantity_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeNewSellingQuantity(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeNewSellingQuantity", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderDtlPWContract
   OperationID: ChangeOrderDtlPWContract
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderDtlPWContract_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderDtlPWContract_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderDtlPWContract(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderDtlPWContract", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeODtlWarehouse
   Description: Update Order Detail information when the Warehouse changes.  This needs to be
called only for Counter Sales.
   OperationID: ChangeODtlWarehouse
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeODtlWarehouse_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeODtlWarehouse_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeODtlWarehouse(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeODtlWarehouse", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelBuyToOrder
   Description: Update Order Release information when the Buy To Order value is changed.
   OperationID: ChangeOrderRelBuyToOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelBuyToOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelBuyToOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelBuyToOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelBuyToOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelDropShip
   Description: Update Order Release information when the Buy To Order value is changed.
   OperationID: ChangeOrderRelDropShip
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelDropShip_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelDropShip_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelDropShip(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelDropShip", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelFirmRelease
   Description: Update Order Release information when the FirmRelease value is changed.
   OperationID: ChangeOrderRelFirmRelease
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelFirmRelease_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelFirmRelease_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelFirmRelease(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelFirmRelease", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelMarkForNum
   Description: Update OrderRel information with values from the Mark For when the Mark For is changed.
   OperationID: ChangeOrderRelMarkForNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelMarkForNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelMarkForNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelMarkForNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelMarkForNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelMFCustID
   Description: Method to call when changing the Mark For Customer ID on the OrderRel record.
Validates the Mark For Customer ID and resets the ShipToNum to the Customer default.
   OperationID: ChangeOrderRelMFCustID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelMFCustID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelMFCustID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelMFCustID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelMFCustID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelOTSCountryNum
   Description: Method to call when changing the OrderRel.OTSCountryNum field.
Update Order Release Tax Region Code
   OperationID: ChangeOrderRelOTSCountryNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelOTSCountryNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelOTSCountryNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelOTSCountryNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelOTSCountryNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelPWContract
   Description: Update Order Release information with values from the Ship To when the Ship To is changed.
   OperationID: ChangeOrderRelPWContract
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelPWContract_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelPWContract_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelPWContract(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelPWContract", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelShipTo
   Description: Update Order Release information with values from the Ship To when the Ship To is changed.
   OperationID: ChangeOrderRelShipTo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelShipTo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelShipToContact
   Description: Update Order Release ship to contact information when the Release Ship To Contact is changed.
   OperationID: ChangeOrderRelShipToContact
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelShipToContact_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelShipToContact_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelShipToContact(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelShipToContact", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelShipToCustID
   Description: Update Order Rel information with values from the Third Party Ship To when the Ship To is changed.
   OperationID: ChangeOrderRelShipToCustID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelShipToCustID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelShipToCustID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelShipToCustID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelShipToCustID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelUseOTMF
   Description: Method to call when changing the UseOTMF field the OrderRel record.
Refreshes the address list and contact info
   OperationID: ChangeOrderRelUseOTMF
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelUseOTMF_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelUseOTMF_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelUseOTMF(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelUseOTMF", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOrderRelVendorID
   Description: Update Order Release information when the Vendor ID is changed.
   OperationID: ChangeOrderRelVendorID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOrderRelVendorID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOrderRelVendorID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOrderRelVendorID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOrderRelVendorID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeORelWarehouse
   Description: Update Order Release information when the Warehouse changes.  This needs to be
called only for Counter Sales.
   OperationID: ChangeORelWarehouse
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeORelWarehouse_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeORelWarehouse_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeORelWarehouse(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeORelWarehouse", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOverrideDiscPriceList
   Description: Rerun the price break calculation if the override price list flag is changed from
true to false.
   OperationID: ChangeOverrideDiscPriceList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOverrideDiscPriceList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOverrideDiscPriceList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOverrideDiscPriceList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOverrideDiscPriceList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeOverridePriceList
   Description: Rerun the price break calculation if the override price list flag is changed from
true to false.
   OperationID: ChangeOverridePriceList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeOverridePriceList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeOverridePriceList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeOverridePriceList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeOverridePriceList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartNum
   Description: Update Order Detail information when the Part Number is changed.
This method is not currently used in Sales Order UI
   OperationID: ChangePartNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangePartNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartNumMaster
   Description: Perform all validations associated with the Change of the PartNum field.  This method consolidates all the separate methods that were being
called when a partNum changes.  a flag for 'suppressUserPrompts' allows the user to suppress returning to the client for user input.  This
may be useful for webservices etc.  The following 3 bools are used to determine which validations should be run (getPartXRefInfo,
checkPartRevisionChange, and checkChangeKitParent).  From the UI, these are originally defaulted to true but if control is returned to the
UI from this method, the UI changes the setting of these fields when it calls it a subsequent time to only run the necessary code.  From
webservices, this allows more control over which validations are run.
   OperationID: ChangePartNumMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartNumMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartNumMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartNumMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangePartNumMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePlant
   Description: Update Order Release information when the Plant is changed.
   OperationID: ChangePlant
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePlant_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePlant_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePlant(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangePlant", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePriceList
   Description: Update Order Detail information when the price list is changed.
   OperationID: ChangePriceList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePriceList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePriceList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePriceList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangePriceList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePricePerCode
   Description: Update Order Detail information when the price per code is changed.
   OperationID: ChangePricePerCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePricePerCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePricePerCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePricePerCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangePricePerCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeQuickEntryOption
   Description: Update Order Detail Quick Entry options.  This method is called whenever the
CreateNewJob, GetDtls, or SchedJob option is changed.
   OperationID: ChangeQuickEntryOption
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeQuickEntryOption_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeQuickEntryOption_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeQuickEntryOption(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeQuickEntryOption", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeQuoteLine
   Description: Update Order Detail information when selecting a quote line.
   OperationID: ChangeQuoteLine
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeQuoteLine_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeQuoteLine_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeQuoteLine(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeQuoteLine", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeQuoteQtyNum
   Description: Update the Order Detail line with values from the selected QuoteQty record.
This method should be called whenever the action to select a quote quantity
occurs.
   OperationID: ChangeQuoteQtyNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeQuoteQtyNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeQuoteQtyNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeQuoteQtyNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeQuoteQtyNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeofLineRelExemptTax
   Description: This method should be called when the user populates order release Tax Exempt field previously being blank
record is changed.
   OperationID: OnChangeofLineRelExemptTax
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeofLineRelExemptTax_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeofLineRelExemptTax_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeofLineRelExemptTax(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/OnChangeofLineRelExemptTax", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRelUseOTS
   Description: Method to call when changing the OrderRel.UseOTS field.
Refreshes the address list and contact info
   OperationID: ChangeRelUseOTS
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRelUseOTS_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRelUseOTS_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRelUseOTS(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeRelUseOTS", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRenewalNbr
   Description: Update Order Detail information when the renewalnbr is changed.
   OperationID: ChangeRenewalNbr
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRenewalNbr_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRenewalNbr_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRenewalNbr(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeRenewalNbr", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRenewalNbrMaster
   OperationID: ChangeRenewalNbrMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRenewalNbrMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRenewalNbrMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRenewalNbrMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeRenewalNbrMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRevisionNum
   Description: Update Order Detail information when the Part Revision Number is changed.
This method is not currently used in Sales Order UI
   OperationID: ChangeRevisionNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRevisionNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRevisionNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRevisionNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeRevisionNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRevNumMaster
   Description: Update Order Detail information when the Part Revision Number is changed.
   OperationID: ChangeRevNumMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRevNumMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRevNumMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRevNumMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeRevNumMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeRMANum
   Description: Update Order Detail RMALine field when the RMA Number is changed.  This method
needs to be called only if the RMA Number was not selected via a lookup.
   OperationID: ChangeRMANum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeRMANum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeRMANum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeRMANum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeRMANum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSalesRep
   Description: Update rep rate and rep split when the salesrep changes.
   OperationID: ChangeSalesRep
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSalesRep_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSalesRep_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSalesRep(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSalesRep", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSalesUOM
   Description: Update Order Detail information when the SalesUM changes
   OperationID: ChangeSalesUOM
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSalesUOM_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSalesUOM_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSalesUOM(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSalesUOM", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSellingQtyMaster
   Description: Update Order Detail information when the selling quantity is changed.
   OperationID: ChangeSellingQtyMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSellingQtyMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSellingQtyMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSellingQtyMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSellingQtyMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSellingQuantity
   Description: Update Order Detail information when the selling quantity is changed.
   OperationID: ChangeSellingQuantity
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSellingQuantity_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSellingQuantity_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSellingQuantity(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSellingQuantity", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSellingReqQty
   Description: Update Order Release information when the selling quantity is changed.
   OperationID: ChangeSellingReqQty
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSellingReqQty_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSellingReqQty_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSellingReqQty(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSellingReqQty", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeShipToContact
   Description: Update Order Header ship to contact information when the Ship To Contact is changed.
   OperationID: ChangeShipToContact
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeShipToContact_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeShipToContact_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeShipToContact(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeShipToContact", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeShipToCustID
   Description: Update Order Header information with values from the Third Party Ship To when the Ship To is changed.
   OperationID: ChangeShipToCustID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeShipToCustID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeShipToCustID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeShipToCustID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeShipToCustID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeShipToID
   Description: Update Order Header information with values from the Ship To when the Ship To is changed.
   OperationID: ChangeShipToID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeShipToID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeShipToID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeShipToID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeShipToID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSoldToContact
   Description: Update Order Header sold to contact information when the Sold To Contact is changed.
   OperationID: ChangeSoldToContact
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSoldToContact_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSoldToContact_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSoldToContact(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSoldToContact", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSoldToID
   Description: Update Order Header information with values from the Sold To when the Sold To is changed.
   OperationID: ChangeSoldToID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSoldToID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSoldToID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSoldToID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeSoldToID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeTaxRegionCode
   OperationID: ChangeTaxRegionCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeTaxRegionCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeTaxRegionCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeTaxRegionCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeTaxRegionCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePromotionalPrice
   Description: This method recalculates PromotionalPrice when PromotionalPrice was changed.
   OperationID: ChangePromotionalPrice
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePromotionalPrice_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePromotionalPrice_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePromotionalPrice(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangePromotionalPrice", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeUnitPrice
   Description: Update Order Detail information when the unit price changes.
   OperationID: ChangeUnitPrice
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeUnitPrice_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeUnitPrice_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeUnitPrice(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeUnitPrice", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeVendorChange
   Description: Update the suggestion status when the "Ready to Send" box is checked or unchecked.
In the GlbSugPOChg dataset, this is field VendorChange.
   OperationID: ChangeVendorChange
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeVendorChange_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeVendorChange_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeVendorChange(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeVendorChange", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeWhseCodeMaster
   Description: Update Order Detail information when the selling quantity is changed.
   OperationID: ChangeWhseCodeMaster
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeWhseCodeMaster_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeWhseCodeMaster_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeWhseCodeMaster(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeWhseCodeMaster", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeProjectID
   Description: Update Order Rel information when the ProjectID is changed.
   OperationID: ChangeProjectID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeProjectID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeProjectID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeProjectID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeProjectID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeXPartNum
   Description: Update Order Detail information when the xpart changes.
   OperationID: ChangeXPartNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeXPartNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeXPartNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeXPartNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/ChangeXPartNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckComplianceFail
   Description: Check for every line of the Pack if it requires if it is compliant.
   OperationID: CheckComplianceFail
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckComplianceFail_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckComplianceFail_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckComplianceFail(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckComplianceFail", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckComplianceOrderFail
   Description: Check for every line of the Order if it is compliant.
   OperationID: CheckComplianceOrderFail
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckComplianceOrderFail_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckComplianceOrderFail_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckComplianceOrderFail(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckComplianceOrderFail", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckConfiguration
   Description: Checks is part should be configured on a given OrderLine
   OperationID: CheckConfiguration
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckConfiguration_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckConfiguration_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckConfiguration(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckConfiguration", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateKBMaxConfigurator
   Description: Update the KBMax Configurator on the given Order Line.
   OperationID: UpdateKBMaxConfigurator
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateKBMaxConfigurator_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateKBMaxConfigurator_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateKBMaxConfigurator(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/UpdateKBMaxConfigurator", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetKBMaxConfigProdID
   Description: Set the CPQ Quote Product ID on the Order Line.
This will trigger the loading of the method from CPQ onto the Order Assembly.
   OperationID: SetKBMaxConfigProdID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetKBMaxConfigProdID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetKBMaxConfigProdID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetKBMaxConfigProdID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/SetKBMaxConfigProdID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PopulateCallContext
   Description: Allows for assigning of a generic CallContext for integrations.
   OperationID: PopulateCallContext
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PopulateCallContext_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PopulateCallContext_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PopulateCallContext(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PopulateCallContext", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckContractNum
   OperationID: CheckContractNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckContractNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckContractNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckContractNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckContractNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCustomerCreditLimit
   Description: This method should be called before the Update method is called for a detail record.
The method returns a character string if the customer will go over their credit limit
and the user is given the choice of continuing or not.
   OperationID: CheckCustomerCreditLimit
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCustomerCreditLimit_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCustomerCreditLimit_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCustomerCreditLimit(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckCustomerCreditLimit", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCustomerCreditRelease
   Description: This method should be called before the Update method is called for a release record.
The method returns a character string if the customer will go over their credit limit
and the user is given the choice of continuing or not.
   OperationID: CheckCustomerCreditRelease
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCustomerCreditRelease_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCustomerCreditRelease_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCustomerCreditRelease(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckCustomerCreditRelease", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCustOnCreditHold
   Description: On selection of an order or customer, checks to see if the customer is on credit hold
and returns a message string if they are.  iOrderNum and cCustID are optional, but
one or the other should be passed.
   OperationID: CheckCustOnCreditHold
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCustOnCreditHold_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCustOnCreditHold_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCustOnCreditHold(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckCustOnCreditHold", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckICPO
   Description: Method to call when trying to determine whether there are any incoming ICPO entries.
This method will return true or false.  .
   OperationID: CheckICPO
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckICPO_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckICPO(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckICPO", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckICPOReadyToSend
   Description: Checks to see if there are any Intercompany PO's not ready to send for the order.  If
there are, returns message text that should be presented to the user asking if they
would like to continue or not.  This method should be called before
calling the VerifySendICPOSugg and SendICPOSuggestions methods.
   OperationID: CheckICPOReadyToSend
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckICPOReadyToSend_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckICPOReadyToSend_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckICPOReadyToSend(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckICPOReadyToSend", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckKitRevision
   Description: Checks the current selected revision of a kit parent line to see if it has any components
to be generated. If no revision is selected, or there are no mfg details then a return message
will be returned to notify the user about it.
   OperationID: CheckKitRevision
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckKitRevision_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckKitRevision_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckKitRevision(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckKitRevision", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckLtrOfCrdt
   OperationID: CheckLtrOfCrdt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckLtrOfCrdt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckLtrOfCrdt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckLtrOfCrdt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckLtrOfCrdt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckMakeDirectReleases
   Description: Validate whether all make direct releases have jobs if and OrderDtl is checked.
   OperationID: CheckMakeDirectReleases
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckMakeDirectReleases_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckMakeDirectReleases_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckMakeDirectReleases(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckMakeDirectReleases", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckOrderHedChanges
   Description: Checks to see if certain fields changed on the order header.  If they did,
a question is presented to the user asking if these changes should carry over
to the order lines and order releases.  This method returns the text of the message
to ask.  When adding a header it is not necessary to call this method because there
won't be any lines or releases to propagate the changes to.  The user can answer yes
or no, but processing doesn't stop based on the answer.  The answer should be stored
in the dataset in field OrderHed.UpdateDtlAndRelRecords.
   OperationID: CheckOrderHedChanges
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckOrderHedChanges_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckOrderHedChanges_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckOrderHedChanges(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckOrderHedChanges", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckOrderLinkToInterCompanyPO
   Description: Checks to see if the order is linked to a PO.  If it is, an informational message is presented
alerting the user of this.
   OperationID: CheckOrderLinkToInterCompanyPO
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckOrderLinkToInterCompanyPO_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckOrderLinkToInterCompanyPO_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckOrderLinkToInterCompanyPO(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckOrderLinkToInterCompanyPO", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckPartRevisionChange
   Description: The method is to be run on leave of the PartNum and Revision fields
before the ChangePart, ChangeRevision, or Update methods are run.
When run before CreateOrderFromQuote, the Part Number expected is the part number
from the quote.
This returns all the questions that need to be asked before a part can be changed.
   OperationID: CheckPartRevisionChange
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckPartRevisionChange_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckPartRevisionChange_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckPartRevisionChange(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckPartRevisionChange", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckProjectID
   Description: Validate Project ID value
   OperationID: CheckProjectID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckProjectID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckProjectID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckProjectID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckProjectID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckQuoteLinesNoQuantity
   Description: The method is to be run after a Quote Number is obtained for creating an order
from a quote, but before the CreateOrderFromQuote method is executed.  This
method returns the text of the question to be asked to the user if quote lines are found
without an order quantity.
   OperationID: CheckQuoteLinesNoQuantity
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckQuoteLinesNoQuantity_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckQuoteLinesNoQuantity_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckQuoteLinesNoQuantity(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckQuoteLinesNoQuantity", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckRateGrpCode
   Description: Update Check if Rate Group Code entered is valid.
   OperationID: CheckRateGrpCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckRateGrpCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckRateGrpCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckRateGrpCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckRateGrpCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckRenewalNbr
   OperationID: CheckRenewalNbr
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckRenewalNbr_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckRenewalNbr_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckRenewalNbr(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckRenewalNbr", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckSellingFactorDirection
   Description: OBSOLETE METHOD..... Validate Selling Factor Direction value
   OperationID: CheckSellingFactorDirection
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckSellingFactorDirection_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckSellingFactorDirection_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckSellingFactorDirection(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckSellingFactorDirection", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckSellingQuantityChange
   Description: The method is to be run on leave of the SellingQuantity field before the
ChangeSellingQuantity or Update methods are run.  If the unit price will be different
based on the new quantity, this returns the question asking if user would like to
use the new unit price or keep the current one.
Calling this method is necessary only if the Quote Number on the detail
record is not zero.
   OperationID: CheckSellingQuantityChange
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckSellingQuantityChange_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckSellingQuantityChange_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckSellingQuantityChange(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckSellingQuantityChange", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckSONum
   Description: Method to call when entering proposed Sales Order Number.  This method will return
two output variables.  One is a logical field to indicate if the SO number
entered is existing or not.  The other variable is for the error message
in case the proposed SO number is invalid.
   OperationID: CheckSONum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckSONum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckSONum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckSONum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckSONum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckQuoteForCreditLimit
   Description: This method should be called before the Update method is called for a detail record.
The method returns a character string if the customer will go over their credit limit
and the user is given the choice of continuing or not.
   OperationID: CheckQuoteForCreditLimit
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckQuoteForCreditLimit_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckQuoteForCreditLimit_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckQuoteForCreditLimit(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckQuoteForCreditLimit", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method chkCustomerCreditLimitForCopyOrder
   Description: This method validates the Customer Credit Limit when we are performing a Copy Order operation
   OperationID: chkCustomerCreditLimitForCopyOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/chkCustomerCreditLimitForCopyOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/chkCustomerCreditLimitForCopyOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_chkCustomerCreditLimitForCopyOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/chkCustomerCreditLimitForCopyOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckLetterOfCredit
   Description: Before copying an order, check if the new order will cause the LOC value to be exceeded.
   OperationID: CheckLetterOfCredit
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckLetterOfCredit_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckLetterOfCredit_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckLetterOfCredit(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CheckLetterOfCredit", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method chkLtrOfCrdt
   OperationID: chkLtrOfCrdt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/chkLtrOfCrdt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/chkLtrOfCrdt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_chkLtrOfCrdt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/chkLtrOfCrdt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CloseOrder
   Description: Checks to see if the order can be closed and closes it if it is allowed.
   OperationID: CloseOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CloseOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CloseOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CloseOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CloseOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CloseOrderLine
   Description: Checks to see if the order can be closed and closes it if it is allowed.
   OperationID: CloseOrderLine
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CloseOrderLine_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CloseOrderLine_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CloseOrderLine(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CloseOrderLine", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CloseRelease
   Description: Checks to see if the order release can be closed and closes it if it is allowed.
   OperationID: CloseRelease
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CloseRelease_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CloseRelease_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CloseRelease(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CloseRelease", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PreCopyOrder
   Description: Before copying an order, check if any parts are on hold and present user with prompt.
   OperationID: PreCopyOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PreCopyOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PreCopyOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PreCopyOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/PreCopyOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CopyOrder
   Description: Copy an order.
   OperationID: CopyOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CopyOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CopyOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CopyOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CopyOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateGlbSugPOChg
   Description: Create a new ttGlbSugPOChg record for processing.
   OperationID: CreateGlbSugPOChg
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateGlbSugPOChg_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateGlbSugPOChg_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateGlbSugPOChg(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.SalesOrderSvc/CreateGlbSugPOChg", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
// OData Schemas:
//////////////////////////////////////////////////////////////////////////
export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_HedTaxSumRow{
   "odatametadata":string,
   "value":Erp_Tablesets_HedTaxSumRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OHOrderMscRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OHOrderMscRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderDtlAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderDtlRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderDtlRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderHedAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedListRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderHedListRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderHedRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHedUPSRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderHedUPSRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderHistRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderHistRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderMscRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderMscRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderRelRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRelTaxRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderRelTaxRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderRepCommRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderRepCommRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_OrderSchedRow{
   "odatametadata":string,
   "value":Erp_Tablesets_OrderSchedRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartSubsRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_SNFormatRow{
   "odatametadata":string,
   "value":Erp_Tablesets_SNFormatRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_SelectedSerialNumbersRow{
   "odatametadata":string,
   "value":Erp_Tablesets_SelectedSerialNumbersRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxConnectStatusRow{
   "odatametadata":string,
   "value":Erp_Tablesets_TaxConnectStatusRow[],
}

export interface Erp_Tablesets_HedTaxSumRow{
   "Company":string,
      /**  Currency display switch  */  
   "CurrencySwitch":boolean,
      /**  Currency display symbol  */  
   "DisplaySymbol":string,
      /**  Document display symbol  */  
   "DocDisplaySymbol":string,
      /**  Document reportable amount.  */  
   "DocReportableAmt":number,
      /**  Document taxable amount.  */  
   "DocTaxableAmt":number,
      /**  Document tax amount.  */  
   "DocTaxAmt":number,
      /**  Order or Quote number this tax summary relates to.  */  
   "HedNum":number,
      /**  Tax percent  */  
   "Percent":number,
      /**  Reportable amount  */  
   "ReportableAmt":number,
      /**  Taxable amount  */  
   "TaxableAmt":number,
      /**  Tax amount  */  
   "TaxAmt":number,
      /**  Tax code  */  
   "TaxCode":string,
      /**  Sales Tax description  */  
   "TaxDescription":string,
   "GroupID":string,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
   "Rpt1ReportableAmt":number,
   "Rpt2ReportableAmt":number,
   "Rpt3ReportableAmt":number,
   "Rpt1TaxableAmt":number,
   "Rpt2TaxableAmt":number,
   "Rpt3TaxableAmt":number,
   "Rpt1TaxAmt":number,
   "Rpt2TaxAmt":number,
   "Rpt3TaxAmt":number,
      /**  Rate Code on the Header Tax Summary  */  
   "RateCode":string,
      /**  Invoice Number of allocated Deposits  */  
   "AllocDepInvcNum":number,
      /**  Rate Code Description on the Header Tax Summary  */  
   "RateCodeDescription":string,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OHOrderMscRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Sales Order Number  */  
   "OrderNum":number,
      /**  Order line number that this miscellaneous record is related to. If related to the Order then this field is zero. This number is not directly entered by the user; rather it is carried through from the header or detail line that user was on when miscellaneous maintenance was requested.  */  
   "OrderLine":number,
      /**  Sequence Number  */  
   "SeqNum":number,
      /**  The Miscellaneous Charge Code. This must be valid in the MiscChrg master file.  */  
   "MiscCode":string,
      /**  Description of the miscellaneous charge. This will be printed on the acknowledgment and transferred over to invoice processing. The default is provided by MiscChrg.Description, but it's overridable by the user. This can't be blank.  */  
   "Description":string,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   "MiscAmt":number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   "DocMiscAmt":number,
      /**  Sets the frequency of when this miscellaneous charge should be applied. The options are F - First shipment, L = Last shipment, E = every shipment. This defaults from the MiscChrg.FreqCode.  */  
   "FreqCode":string,
      /**  An internally used flag which indicates that this record was created from a Quote via the "Get Quote" function. "Q" = related to the QuoteQty record, "L" = related to the overall QuoteDtl record. This flag is used so that the OrderMsc file can be refreshed from the QuoteMsc when Quantity or Quote/Line # changes occur. The logic is that if a change in order quantity of a order line that is linked to a quote causes a different price break to be selected then all the existing all OrderMsc records where Quoting = "Q" are deleted and then re-pulled in based on the new qty. If the Quote # or QuoteLine are changed then all OrderMsc records where Quoting is either a "Q" or "L" are deleted then re-pulled in from the newly referenced quote.  */  
   "Quoting":string,
      /**  Indicates if this order miscellaneous charge is linked to an inter-company PO misc charge.  */  
   "Linked":boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   "ICPONum":number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   "ICPOLine":number,
      /**  Inter Company PO Sequence Number  */  
   "ICPOSeqNum":number,
      /**  External Trading Company Identifier.  */  
   "ExtCompany":string,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Reporting currency value of this field  */  
   "Rpt1MiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2MiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3MiscAmt":number,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default. - Includes taxes  */  
   "InMiscAmt":number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default. - includes taxes  */  
   "DocInMiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1InMiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2InMiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3InMiscAmt":number,
      /**  This field will be used to define the percentage of the extended amount that will be applied as the 'Miscellaneous charge'.  */  
   "Percentage":number,
      /**  This field will define if the miscellaneous charge is calculated as a flat amount or if is calculated as a percentage of the extended price.  */  
   "Type":string,
      /**  ChangeTrackApproved  */  
   "ChangeTrackApproved":boolean,
      /**  ChangeTrackAmount  */  
   "ChangeTrackAmount":number,
      /**  ChangeTrackMemoDesc  */  
   "ChangeTrackMemoDesc":string,
      /**  ChangeTrackMemoText  */  
   "ChangeTrackMemoText":string,
      /**  ChangeTrackStatus  */  
   "ChangeTrackStatus":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BaseCurrSymbol":string,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
   "CurrencySwitch":boolean,
   "CurrSymbol":string,
      /**  Misc charge amount on display in document currency (may or may not include taxes)  */  
   "DocDspMiscAmt":number,
      /**  Misc charge amount on display (may or may not include taxes)  */  
   "DspMiscAmt":number,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
      /**  Misc charge amount on display in report currency  (may or may not include taxes)  */  
   "Rpt1DspMiscAmt":number,
      /**  Misc charge amount on display in report currency (may or may not include taxes)  */  
   "Rpt2DspMiscAmt":number,
      /**  Misc charge amount on display in report currency (may or may not include taxes)  */  
   "Rpt3DspMiscAmt":number,
      /**  Pass Credit Limit check message to the UI  */  
   "RespMessage":string,
   "BitFlag":number,
   "MiscCodeDescription":string,
   "OrderNumCardMemberName":string,
   "OrderNumCurrencyCode":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderDtlAttchRow{
   "Company":string,
   "OrderNum":number,
   "OrderLine":number,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderDtlRow{
      /**   Indicates that the line item was closed before any shipments were made against it. Normally line items are closed as part of the Shipping process. By using the "Close Line" menu option the user can close the line manually, to provide the function to close the line when the customer cancels there request.  If the line item had no shipments made it is then marked as "voided". Regardless of shipment activity the line is also marked as closed (OpenLine = No).
When an OrderDtl record is 'voided/closed' all of it's related OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   "VoidLine":boolean,
      /**  Indicates if the OrderDtl record is in a "open or closed" status.  This field is not directly maintainable. It can be set to "closed" via the "Close-Line" menu option,  the "Close-Order" menu option, or when all the related OrderRel records are closed, OrderRel records are closed via shipping or by the "Close Release" button within Order Entry. (See VoidLine also).  */  
   "OpenLine":boolean,
      /**  Company Identifier.  */  
   "Company":string,
      /**  Contains the Order Number that ties this detail record back to an OrderHed record.  */  
   "OrderNum":number,
      /**  This field along with Company and OrderNum make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the OrderDtl record for the Order and the adding 1 to it.  The user can override this number if they wish.  */  
   "OrderLine":number,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT".  */  
   "LineType":string,
      /**   The user's Internal Part number used to identify line item part. It cannot  be blank. It does not have to exist in the Part table.

A default should be made when the OrderDtl.XPartNum is changed.  The PartNum and XPartNum fields work together in providing defaults for each other. Default when a valid record is found in the PartXRef table. NOTE THE PART CROSS REFERENCE LOGIC IS NOT INCLUDED IN RELEASE 1.0 ... PLAN FOR FUTURE  */  
   "PartNum":string,
      /**  Line Item description. The Part.Description can be used as a default.  */  
   "LineDesc":string,
      /**  EDI Reference  */  
   "Reference":string,
      /**  Unit Of Measure (how it is sold/issued). Use the default Part.IUM if it's a valid Part.  */  
   "IUM":string,
      /**  Optional field that contains the customers revision. Default from the PartRev.RevisionNum field.  */  
   "RevisionNum":string,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   "POLine":string,
      /**  Controls if line is commissionable. Note if all the OrderHed.SalesRep are blank then this should be "No", also the user should not even see this field when there are no sales reps for the order.  */  
   "Commissionable":boolean,
      /**  The line item discount percent. It has nothing to do with price break discounts. It is a flat discount percent that defaults from the OrderHed.DiscountPercent, which was originally defaulted from the Customer.DiscountPercent.  */  
   "DiscountPercent":number,
      /**   If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "UnitPrice":number,
      /**   Same as Unit price except that this field contains the unit price in
the customer currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "DocUnitPrice":number,
      /**  Total Order Quantity for the line item. This quantity must always be kept in sync with the scheduled ship quantities stored in the OrderRel table. Normally this field is directly maintainable. However when multiple shipping releases have been established for this line ( more than one OrderRel record) the OrderQty is not maintainable. As the user modifies the quantities in the individual release lines the OrderQty field will get adjusted. This ensures that Order quantity and scheduled ship quantity are always in sync.  */  
   "OrderQty":number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Discount":number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "DocDiscount":number,
      /**   Date that the first release needs be shipped by in order to meet the customers due date for the first delivery. Defaulted as OrderHed.RequestDate.
Not directly maintainable when more than one delivery record exists, in which case it gets refreshed as the earliest ReqDate of the related OrderRel records.  */  
   "RequestDate":string,
      /**  Product Group Code. Use the Part.ProdCode as a default.  This can be blank or must be valid in the ProdGrup table.  */  
   "ProdCode":string,
      /**  An optional field that is used if the customer has a different  Part number  than the users internal part number.  The XPartNum and PartNum can provide defaults for each other via the PartXref table.. The XPartNum can be blank, does not have to exist in the PartXref table.  */  
   "XPartNum":string,
      /**  Optional field that contains the customers revision. Default from the CustXPrt.RevisionNum field.  */  
   "XRevisionNum":string,
      /**  Indicates the pricing per quantity. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Used to calculate the extended unit price for the line item. The logic is to divide the OrderDtl.OrderQty by the appropriate "per" value and then multiply by unit price.  Use the  Part.PricePerCode as a default. If Part record does not exist then default as "E".  */  
   "PricePerCode":string,
      /**  Contains comments about the detail order line item. These will be printed on the Sales Acknowledgements.  */  
   "OrderComment":string,
      /**  Used to establish shipping comments about the order line item. These will copied into the packing slip detail  file as defaults.  */  
   "ShipComment":string,
      /**  Used to establish invoice comments about the order line item. These will copied into the Invoice detail  file as defaults.  */  
   "InvoiceComment":string,
      /**  Contains comments for pick list or job about the order line item. These will be printed on the picking lists or copied to the job during the link process.  */  
   "PickListComment":string,
      /**  Indicates the Tax Category for this record. Defaults from the the or from the Part Master.  */  
   "TaxCatID":string,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs. This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering amount in the InvcDetl.  */  
   "AdvanceBillBal":number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   "DocAdvanceBillBal":number,
      /**  Quote number to which this line item detail record is associated with. This is part of the foreign key to QuoteHed file. This field is updated via the "get quote" function within Order Entry.  */  
   "QuoteNum":number,
      /**  Quote Line number from which this order line was created. Updated via the Get Quote function within Order Entry. This field along with Company and QuoteNum make up the link to the QuoteDtl file.  */  
   "QuoteLine":number,
      /**  Indicates if the Order line item is billed based on Time & Material. This flag is copied into the ShipDtl record during the Shipping Entry process. See ShipDtl.TMBilling description for further details.  */  
   "TMBilling":boolean,
      /**  This field is no longer active. It has been replaced by OrderRel.Exempt. The contents were copied into OrderRel.Exempt during the release conversion process. This will be removed in the next release.  */  
   "OrigWhyNoTax":string,
      /**   Date the customer needs the first release to be delivered.
Defaulted as OrderHed.NeedByDate. Not directly maintainable when more than one delivery record exists. In which case it is kept in sync with the OrderRel record which has the earliest ReqDate which are maintained in the shipping release dialog boxes.  */  
   "NeedByDate":string,
      /**  Customer number that the sales order is for. Duplicated from OrderHed.CustNum.  Used to allow efficient browsing of the OrderDtl records for a specific customer.  */  
   "CustNum":number,
      /**   Used to indicate that line item is to be "Reworked" instead of manufactured.  It is shown in the Job Entry Order Activity screens.
When Yes then all related OrderRel records are Make=Yes.  */  
   "Rework":boolean,
      /**   Return Authorization Number that OrderDtl is fulfilling.
If entered, must be valid in RMAHead.  */  
   "RMANum":number,
      /**  The line item of the RMA detail that this order line item is fulfilling.  */  
   "RMALine":number,
      /**  Project ID of the Project table record that this OrderDtl record. Can be blank.  */  
   "ProjectID":string,
      /**  Contract Number of the related Service Contract when the LineType field is "CONTRACT"  */  
   "ContractNum":number,
      /**  A unique code that identifies the Service Contract when the Line Type is "CONTRACT"  */  
   "ContractCode":string,
      /**  The part number used to identify the configured part number initially entered on the line.  */  
   "BasePartNum":string,
      /**  Indicate that the item or the product group has a warranty.  */  
   "Warranty":boolean,
      /**  Unique code for the Warranty that ties this record to a type of warranty.  Found on either the Part or ProdGrup table.  */  
   "WarrantyCode":string,
      /**  The # of days, months, years the material is covered by warranty  */  
   "MaterialDuration":number,
      /**  The # of days, months, years the Labor is covered by warranty  */  
   "LaborDuration":number,
      /**  The # of days, months, years the Misc. Charges are covered by warranty  */  
   "MiscDuration":number,
      /**  Whether the duration of warranty  is for "Days"," Months", "Years".  */  
   "MaterialMod":string,
      /**  Whether the duration of warranty  is "Days"," Months"," years".  */  
   "LaborMod":string,
      /**  Editor widget for Warranty comments.  */  
   "WarrantyComment":string,
      /**  This warranty covers On site visits  */  
   "Onsite":boolean,
      /**  Are Material cost covered  */  
   "MatCovered":boolean,
      /**  Is Labor Cost Covered  */  
   "LabCovered":boolean,
      /**  Are misc. Costs Covered  */  
   "MiscCovered":boolean,
      /**  Unit of measure (how it is sold/issued).  Use the default Part.SUM if its a valid Part else use the global variable Def-UM which is established from XaSyst.DefaultUM.  */  
   "SalesUM":string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   "SellingFactor":number,
      /**  Represents one of the requested Order Quantities for the line item using OrderDtl.SUM.  */  
   "SellingQuantity":number,
      /**  A Cod which uniquely identfies SalesCat record. Can't be blank.  */  
   "SalesCatID":string,
      /**  Indicates if the order line must be shipped complete.  That is, as an orders release are selected for picking during the Auto Pick process of the Order Allocation program, the all releases of the line with a ship date <= the given cutoff date also have to be picked complete otherwise they will not be selected. This is defaulted to Yes when Customer.ShippingQualifier = "L" (Ship Order line 100% complete) and OrderHed.ShipOrderComplete = No. This field is disabled and set to No if the OrderHed.ShipOrderComplete = Yes.  */  
   "ShipLineComplete":boolean,
      /**  Quantity from last EDI update.  */  
   "CumeQty":number,
      /**  Date of last update  */  
   "CumeDate":string,
      /**  The related Marketing Campaign ID. Mirror image of the QuoteHed.MkthCampaignID. Maintainable via order entry if not related to a quote and the CRM module is installed.  */  
   "MktgCampaignID":string,
      /**   Link to the marketing event associated with this record.
The related Marketing Event Sequence. Mirror image of the QuoteHed.MktgEventSeq. Maintainable via order entry if not related to a quote and the CRM module is installed.  */  
   "MktgEvntSeq":number,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the order quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   "LockQty":boolean,
      /**  Indicates if this order line is linked to an inter-company PO line.  */  
   "Linked":boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   "ICPONum":number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   "ICPOLine":number,
      /**  External Trading Company Identifier.  */  
   "ExtCompany":string,
      /**  The date when the configuration was completed for the assembly.  */  
   "LastConfigDate":string,
      /**  The system time when the configuration was completed for the assembly.  */  
   "LastConfigTime":number,
      /**  The User ID of the last user to complete the configuration of the assembly.  */  
   "LastConfigUserID":string,
      /**   Same as Unit price except that this field contains the unit price computed from the input based pricing in a configuration.
If price breaks exist this price should be used as the base price instead of the one found in the part table.  */  
   "ConfigUnitPrice":number,
      /**  This is the base price for inputs based pricing of a configuration.  The price of inputs are added to this price to get the ConfigUnitPrice.  */  
   "ConfigBaseUnitPrice":number,
      /**  This is the Price List used to determine the starting base price.  */  
   "PriceListCode":string,
      /**  This is the Price List used to determine the break % or amount.  */  
   "BreakListCode":string,
      /**  The Order Quantity (total qty of related order lines) used to find price when quantity based discounting is applied.  */  
   "PricingQty":number,
      /**  Indicates if the price of the order line can be changed.  */  
   "LockPrice":boolean,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied.  */  
   "ListPrice":number,
      /**   Same as List price except that this field contains the list price in
the customer currency (converted using the exchange rate on OrderHed).  */  
   "DocListPrice":number,
      /**  This is the unit price after quantity based or order value based discounts are applied.  */  
   "OrdBasedPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency (converted using the exchange rate on OrderHed).  */  
   "DocOrdBasedPrice":number,
      /**  This is the Price Group ID used to price the order line with.  */  
   "PriceGroupCode":string,
      /**  Indicates if the user selected a price list different from the default.  */  
   "OverridePriceList":boolean,
      /**  The revision number used to identify the configured part/revision number initially entered on the line.  */  
   "BaseRevisionNum":string,
      /**  The Order Value (total extended price of related order lines) used to find order value break when value based discounting is applied.  */  
   "PricingValue":number,
      /**  This field controls the order in which Sales Order lines are displayed.  Display Seq is a decimal number where the whole number portion is used to sequence normal sales order lines and the decimal portion is used to sequence kit components under their associated kit parent.  */  
   "DisplaySeq":number,
      /**  The sales order line number of the parent kit item.  This is only relevent for sales order lines which are kit parent or component lines.  If the KitParentLine equals the OrderLine then this is a kit parent line.  */  
   "KitParentLine":number,
      /**  Indicates if component lines can be added, deleted and modified during Sales Order entry.  This field is only relevant for sales order lines which are kit parents.  */  
   "KitAllowUpdate":boolean,
      /**  Indicates if the parent kit part must be shipped complete of if kit components can be shippped in varying degrees of completeness.  This field is only relevant for sales order lines which are kit parents. If this field is set to "No" then KitPricing must be set to "P".  */  
   "KitShipComplete":boolean,
      /**  Indicates if all components are to be backflushed when a kit parent part is shipped.  This field is only relevant for sales order lines which are kit parents.  */  
   "KitBackFlush":boolean,
      /**  Indicates if kit components are to be printed on packing slips.  If KitShipComplete is "Yes", then this field must be set to "YES" as well.  This field is only relevant for sales order lines which are kit parents.  */  
   "KitPrintCompsPS":boolean,
      /**  Indicates if kit components are to be printed on invoices.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  This field is only relevant for sales order lines which are kit parents.  */  
   "KitPrintCompsInv":boolean,
      /**  Indicates how kits will be priced.  Values are P = Parent Pricing (The price is obtained from the sales price for the kit parent item), C = Component Pricing (The price is obtained from a rollup of kit component items).  This field is only relevant for sales order lines which are kit parents.  */  
   "KitPricing":string,
      /**  Component quantity required to fulfill one kit parent.  This field is only relevant on a sales order line which is a kit component.  */  
   "KitQtyPer":number,
      /**  Indicates how Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   "SellingFactorDirection":string,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   "RepRate1":number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   "RepRate2":number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   "RepRate3":number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   "RepRate4":number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   "RepRate5":number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   "RepSplit1":number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   "RepSplit2":number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   "RepSplit3":number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   "RepSplit4":number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   "RepSplit5":number,
      /**  The Demand Contract Detail record this OrderDtl is related to.  */  
   "DemandContractLine":number,
      /**  Create New Job flag  */  
   "CreateNewJob":boolean,
      /**  The date before which the order cannot be shipped.  */  
   "DoNotShipBeforeDate":string,
      /**  Get Details flag  */  
   "GetDtls":boolean,
      /**  The date after which the order cannot be shipped.  */  
   "DoNotShipAfterDate":string,
      /**  Schedule Job flag  */  
   "SchedJob":boolean,
      /**  Release Job flag  */  
   "RelJob":boolean,
      /**  Enable New Job flag  */  
   "EnableCreateNewJob":boolean,
      /**  Enable Get Details flag  */  
   "EnableGetDtls":boolean,
      /**  Enable Schedule Job flag  */  
   "EnableSchedJob":boolean,
      /**  Enable Release Job flag  */  
   "EnableRelJob":boolean,
      /**  Indicates the warehouse selected for a counter sale order line.  */  
   "CounterSaleWarehouse":string,
      /**  Identifies the Bin selected for a counter sale order line.  */  
   "CounterSaleBinNum":string,
      /**  Indicates the lot number selected for a counter sale order line.  */  
   "CounterSaleLotNum":string,
      /**  Indicates the dimension code selected for a counter sales order line.  */  
   "CounterSaleDimCode":string,
      /**  Indicates if the demand detail that created/updated this order line has been rejected.  */  
   "DemandDtlRejected":boolean,
      /**   A character flag field used to differentiate between regular sales order line, Sales Kit parent order line and Sales Kit component order line.
P = Sales Kit Parent line
C = Sales Kit Component Line
Null = regular line  */  
   "KitFlag":string,
      /**  Indicates if the kit components have been automatically loaded.  If set to false the user interface will attempt to load the kit components after the user saves a new order line.  */  
   "KitsLoaded":boolean,
      /**  The demand contract this demand is for.  */  
   "DemandContractNum":number,
      /**  This field along with Company and DemandContractNum make up the unique key to the table. The system should generate this number during entry of new header records. The system determines next available number by finding the last DemandHead for the DemandContractNum and adding 1.  */  
   "DemandHeadSeq":number,
      /**  This field along with Company, DemandContractNum and DemandHeadSeq make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the last DemandDetail record for the DemandHead and the adding 1 to it.  */  
   "DemandDtlSeq":number,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Reverse Charge.  */  
   "ReverseCharge":boolean,
      /**  Total Number of releases for the line  */  
   "TotalReleases":number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "Rpt1UnitPrice":number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "Rpt2UnitPrice":number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "Rpt3UnitPrice":number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Rpt1Discount":number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Rpt2Discount":number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Rpt3Discount":number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   "Rpt1AdvanceBillBal":number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   "Rpt2AdvanceBillBal":number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   "Rpt3AdvanceBillBal":number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt1ListPrice":number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt2ListPrice":number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt3ListPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt1OrdBasedPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt2OrdBasedPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt3OrdBasedPrice":number,
      /**  Extended Price for the order line item, rounded according to the Base currency Round rule  */  
   "ExtPriceDtl":number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule  */  
   "DocExtPriceDtl":number,
      /**  Reporting currency value of this field  */  
   "Rpt1ExtPriceDtl":number,
      /**  Reporting currency value of this field  */  
   "Rpt2ExtPriceDtl":number,
      /**  Reporting currency value of this field  */  
   "Rpt3ExtPriceDtl":number,
      /**  Status of Order Line  */  
   "LineStatus":string,
      /**   If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table. Assumed to include taxes  */  
   "InUnitPrice":number,
      /**  Same as DocUnit price except that this field contains the unit price including taxes  */  
   "DocInUnitPrice":number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * InUnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, InUnitPrice or OrderQty fields are changed.  - includes taxes  */  
   "InDiscount":number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * InUnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, InUnitPrice or OrderQty fields are changed. - includes taxes  */  
   "DocInDiscount":number,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied. including taxes  */  
   "InListPrice":number,
      /**   Same as List price except that this field contains the list price in
the customer currency -including taxes.  */  
   "DocInListPrice":number,
      /**  This is the unit price after quantity based or order value based discounts are applied. including taxes  */  
   "InOrdBasedPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency - including taxes.  */  
   "DocInOrdBasedPrice":number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "Rpt1InUnitPrice":number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "Rpt2InUnitPrice":number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   "Rpt3InUnitPrice":number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Rpt1InDiscount":number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Rpt2InDiscount":number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   "Rpt3InDiscount":number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt1InListPrice":number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt2InListPrice":number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt3InListPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt1InOrdBasedPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt2InOrdBasedPrice":number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   "Rpt3InOrdBasedPrice":number,
      /**  Extended Price for the order line item, rounded according to the Base currency Round rule - Taxes are Included  */  
   "InExtPriceDtl":number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule - Taxes Included  */  
   "DocInExtPriceDtl":number,
      /**  Reporting currency value of this field  */  
   "Rpt1InExtPriceDtl":number,
      /**  Reporting currency value of this field  */  
   "Rpt2InExtPriceDtl":number,
      /**  Reporting currency value of this field  */  
   "Rpt3InExtPriceDtl":number,
      /**  Used to store selling open quantity value setting assigned in product configuration programs  */  
   "OldOurOpenQty":number,
      /**  Used to store selling open quantity value setting assigned in product configuration programs  */  
   "OldSellingOpenQty":number,
      /**  Used to store open value setting assigned in product configuration programs  */  
   "OldOpenValue":number,
      /**  Used to store prod code value assigned in product configuration programs  */  
   "OldProdCode":string,
      /**  Previous Selling Quantity  */  
   "PrevSellQty":number,
      /**  Previous Part Number  */  
   "PrevPartNum":string,
      /**  Previous Customer Part Number  */  
   "PrevXPartNum":string,
      /**  The original material sequence of this kit component under the kit parent part.  */  
   "KitCompOrigSeq":number,
      /**  The original kit component part number prior to processing any configurator rule programs  */  
   "KitCompOrigPart":string,
      /**  If TRUE then this field will mean that the smart string has already been processed  */  
   "SmartStringProcessed":boolean,
      /**  Original smart string passed in for configuration  */  
   "SmartString":string,
      /**  Contract renewal number. If the value is zero then the contract is not for a renewal.  */  
   "RenewalNbr":number,
   "DiscBreakListCode":string,
   "DiscListPrice":number,
   "LockDisc":boolean,
   "OverrideDiscPriceList":boolean,
      /**  GroupSeq  */  
   "GroupSeq":number,
      /**  ECCOrderNum  */  
   "ECCOrderNum":string,
      /**  ECCOrderLine  */  
   "ECCOrderLine":number,
      /**  DupOnJobCrt  */  
   "DupOnJobCrt":boolean,
      /**  UndersPct  */  
   "UndersPct":number,
      /**  Overs  */  
   "Overs":number,
      /**  Unders  */  
   "Unders":number,
      /**  OversUnitPrice  */  
   "OversUnitPrice":number,
      /**  PlanUserID  */  
   "PlanUserID":string,
      /**  PlanGUID  */  
   "PlanGUID":string,
      /**  MOMsourceType  */  
   "MOMsourceType":string,
      /**  MOMsourceEst  */  
   "MOMsourceEst":string,
      /**  DefaultOversPricing  */  
   "DefaultOversPricing":string,
      /**  ECCPlant  */  
   "ECCPlant":string,
      /**  ECCQuoteNum  */  
   "ECCQuoteNum":string,
      /**  ECCQuoteLine  */  
   "ECCQuoteLine":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  MfgJobType  */  
   "MfgJobType":string,
      /**  ProFormaInvComment  */  
   "ProFormaInvComment":string,
      /**  CreateJob  */  
   "CreateJob":boolean,
      /**  The identifier of the planning contract.  */  
   "ContractID":string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the planning of the Contract.  */  
   "LinkToContract":boolean,
      /**  DocInAdvanceBillBal  */  
   "DocInAdvanceBillBal":number,
      /**  InAdvanceBillBal  */  
   "InAdvanceBillBal":number,
      /**  Rpt1InAdvanceBillBal  */  
   "Rpt1InAdvanceBillBal":number,
      /**  Rpt2InAdvanceBillBal  */  
   "Rpt2InAdvanceBillBal":number,
      /**  Rpt3InAdvanceBillBal  */  
   "Rpt3InAdvanceBillBal":number,
      /**  PCLinkRemoved  */  
   "PCLinkRemoved":boolean,
      /**  CommodityCode  */  
   "CommodityCode":string,
      /**  Base price before any price breaks and discounts  */  
   "MSRP":number,
      /**  Same as MSRP except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   "DocMSRP":number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   "Rpt1MSRP":number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   "Rpt2MSRP":number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   "Rpt3MSRP":number,
      /**  Distributor end customer price.  */  
   "EndCustomerPrice":number,
      /**  Same as end customer price except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   "DocEndCustomerPrice":number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   "Rpt1EndCustomerPrice":number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   "Rpt2EndCustomerPrice":number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   "Rpt3EndCustomerPrice":number,
      /**  Promotional Price offered to Dealer and Distributors.  */  
   "PromotionalPrice":number,
      /**  Same as Promotional Price except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   "DocPromotionalPrice":number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   "Rpt1PromotionalPrice":number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   "Rpt2PromotionalPrice":number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   "Rpt3PromotionalPrice":number,
      /**  Current status of line.  This is a maintainable status through Order Line Status maintenance.  Depending on the setting can control is line is updatable from the web.  */  
   "OrderLineStatusCode":string,
      /**  The unique identifier of the related Dynamic Attribute Set.  Used specifically for Deal Portal and Location Inventory, not for Inventory Tracked Attributes.  */  
   "AttributeSetID":number,
      /**  The unique identifier of the related CPQ Configured Quote Product.  */  
   "KBConfigProdID":number,
      /**  The unique identifier of the related original CPQ Configured Quote Product.  */  
   "KBOriginalConfigProdID":number,
      /**  TotalCovenantDiscount  */  
   "TotalCovenantDiscount":number,
      /**  DocCovenantDiscount  */  
   "DocCovenantDiscount":number,
      /**  Rpt1CovenantDiscount  */  
   "Rpt1CovenantDiscount":number,
      /**  Rpt2CovenantDiscount  */  
   "Rpt2CovenantDiscount":number,
      /**  Rpt3CovenantDiscount  */  
   "Rpt3CovenantDiscount":number,
      /**  TotalInCovenantDiscount  */  
   "TotalInCovenantDiscount":number,
      /**  DocInCovenantDiscount  */  
   "DocInCovenantDiscount":number,
      /**  Rpt1InCovenantDiscount  */  
   "Rpt1InCovenantDiscount":number,
      /**  Rpt2InCovenantDiscount  */  
   "Rpt2InCovenantDiscount":number,
      /**  Rpt3InCovenantDiscount  */  
   "Rpt3InCovenantDiscount":number,
   "AvailableQuantity":number,
      /**  Available Price Lists  */  
   "AvailPriceLists":string,
   "AvailUMFromQuote":string,
   "BaseCurrencyID":string,
   "BaseCurrSymbol":string,
      /**  Default calculated unit price for a particular part/customer.  Used with integrations for pre-order price validations.  */  
   "CalcUnitPrice":number,
   "ConfigType":string,
   "Configured":string,
   "CounterSale":boolean,
      /**  The message text returned by the credit check process.  */  
   "CreditLimitMessage":string,
      /**  The source that put the customer on credit hold.  */  
   "CreditLimitSource":string,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
   "CurrencyID":string,
   "CurrencySwitch":boolean,
   "CurrSymbol":string,
   "DemandQuantity":number,
   "DimCode":string,
   "DimConvFactor":number,
      /**  Document currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "DocDspDiscount":number,
      /**  Document currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "DocDspUnitPrice":number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule  */  
   "DocExtPrice":number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in document currency  */  
   "DocInMiscCharges":number,
      /**  The amount of discount for display in document currency which does not include taxes  */  
   "DocLessDiscount":number,
   "DocMiscCharges":number,
      /**  Total tax in Doc currency. The sum of all the tax details for the line (OrderRelTax).  */  
   "DocTaxAmt":number,
   "DocTotalPrice":number,
      /**  Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "DspDiscount":number,
      /**  To display the type of job this is: MFG = Manufacturing, PRJ = Project  */  
   "DspJobType":string,
      /**  Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "DspUnitPrice":number,
   "DUM":string,
      /**  Web basket configuration related SysRowID  */  
   "ECCConfigSysRowId":string,
      /**  Additional discount calculated by ECC  */  
   "ECCDiscount":number,
      /**  Prevents Epicor repricing the unit price coming from ECC.  This usually would be a result of Epicor going off-line and order pricing was performed by ECC.  */  
   "ECCPreventRepricing":boolean,
      /**  Allow enable/disable for the button Attibutes in Order Line  */  
   "EnableDynAttrButton":boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   "EnableKitUnitPrice":boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   "EnableRenewalNbr":boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   "EnableSellingQty":boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
   "ExtPrice":number,
   "FromQuoteLineFlag":boolean,
      /**  Installation price of an equipment that requires installation in Epicor FSA. This value by default is inherited from the part but it could be overridden for another value if it's necessary.  */  
   "FSAInstallationCost":number,
   "FSAInstallationOrderLine":number,
   "FSAInstallationOrderNum":number,
      /**  Indicates if the equipment requires an installation prior being marked as “Installed” on a Location in Epicor FSA. If true, at shipment it will create a service order for the installation service in FSA.  */  
   "FSAInstallationRequired":boolean,
      /**  Indicates the service order template ID that Epicor FSA will use to create the installation service order.  */  
   "FSAInstallationType":string,
   "FSAInstallationTypeDescription":string,
      /**  Indicates whether the part has at least one Complement  */  
   "HasComplement":boolean,
      /**  Indicates whether the part has at least one Downgrade  */  
   "HasDowngrade":boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   "HasSubstitute":boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   "HasUpgrade":boolean,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line  */  
   "InMiscCharges":number,
      /**  The flag to indicate if the Order Header Tax Liability is Tax Inclusive Pricing.  */  
   "InPrice":boolean,
      /**  Unique identifier of related integration record.  */  
   "IntExternalKey":string,
      /**  Inventory UOM that the Order Detail is allocated against.  */  
   "InvtyUOM":string,
   "JobTypeDesc":string,
      /**  If the Job has been already created against this line.  */  
   "JobWasCreated":boolean,
      /**  If Kit Flag = P then sets this field to the value of the related PartPlant.KitAllowChangeParms. If KitFlag <> P then this will be FALSE.  */  
   "KitChangeParms":boolean,
      /**  Will be set to true if the current OrderDtl record is KitFlag = 'C' and the KitParent of this record is KitAllowUpdate = NO  */  
   "KitDisable":boolean,
      /**  Kit Flag Description. "P" = Parent, "C" = Component.  */  
   "KitFlagDescription":string,
   "KitOrderQtyUOM":string,
      /**  If KitFlag = "C" and the parent kit line is configured OR if KitFlag = "P" and Configured = "On" then this field will be TRUE, otherwise it will be false.  */  
   "KitStandard":boolean,
      /**  The amount of discount for display which does not include taxes  */  
   "LessDiscount":number,
   "LotNum":string,
   "MiscCharges":number,
   "MultipleReleases":boolean,
   "OnHandQuantity":number,
   "PartExists":boolean,
   "PartTrackDimension":boolean,
   "PartTrackLots":boolean,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   "POLineRef":string,
   "PriceListCodeDesc":string,
   "ProcessCounterSale":boolean,
   "ProcessQuickEntry":boolean,
   "QuoteQtyNum":number,
      /**  For this Detail line there is Release line that has Project and Phase and these Project or Phase was invoiced or used in revenue recognition.  */  
   "RelWasRecInvoiced":boolean,
      /**  Pass Credit Limit check message to the UI  */  
   "RespMessage":string,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "Rpt1DspDiscount":number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "Rpt1DspUnitPrice":number,
      /**  Extended Price for the Order Line in Rpt1 currency  */  
   "Rpt1ExtPrice":number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   "Rpt1InMiscCharges":number,
      /**  The amount of discount for display which does not include taxes (report currency)  */  
   "Rpt1LessDiscount":number,
      /**  Report currency misc charges  */  
   "Rpt1MiscCharges":number,
      /**  Report currency line tax amount  */  
   "Rpt1TaxAmt":number,
      /**  Report currency line total price  */  
   "Rpt1TotalPrice":number,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "Rpt2DspDiscount":number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "Rpt2DspUnitPrice":number,
      /**  Extended Price for the orderLine in Rpt2 currency.  */  
   "Rpt2ExtPrice":number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   "Rpt2InMiscCharges":number,
      /**  The amount of discount for display in report currency which does not include taxes (report currency)  */  
   "Rpt2LessDiscount":number,
      /**  Report currency misc charges  */  
   "Rpt2MiscCharges":number,
      /**  Report currency line tax amount  */  
   "Rpt2TaxAmt":number,
      /**  Report currency line total price  */  
   "Rpt2TotalPrice":number,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "Rpt3DspDiscount":number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   "Rpt3DspUnitPrice":number,
      /**  Extended price for the order line in Rpt3 currency  */  
   "Rpt3ExtPrice":number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   "Rpt3InMiscCharges":number,
      /**  The amount of discount for display in report currency which does not include taxes (report currency)  */  
   "Rpt3LessDiscount":number,
      /**  Report Currency misc charges  */  
   "Rpt3MiscCharges":number,
      /**  Report currency line tax amount  */  
   "Rpt3TaxAmt":number,
      /**  Report currency line total price  */  
   "Rpt3TotalPrice":number,
   "SalesRepName1":string,
   "SalesRepName2":string,
   "SalesRepName3":string,
   "SalesRepName4":string,
   "SalesRepName5":string,
      /**  Total tax in base currency. The sum of all the tax details for the line.  */  
   "TaxAmt":number,
      /**  The Sales Order Quantity expressed in the Inventory Unit of Measure  */  
   "ThisOrderInvtyQty":number,
   "TotalPrice":number,
   "TotalShipped":number,
   "WarehouseCode":string,
   "WarehouseDesc":string,
   "BinNum":string,
      /**  Attribute class is MRP Planned but AttributeSetID has not been set on releases.  */  
   "AttributeMismatch":boolean,
      /**  A string containing the parameters needed to run Job Manager  */  
   "JobManagerString":string,
      /**  Default calculated order value based discounts unit price for a particular part/customer.  Used with integrations for pre-order price validations.  */  
   "CalcOrdBasedPrice":number,
      /**  At least 1 OrderRel for OrderDtl has a PONum assigned.  */  
   "SalesOrderLinked":boolean,
      /**  This external column is to be used for the purpose of adding an OrderDtl for a part that has Track Inventory Attributes, allowing the AttributeSetID to be passed in with the line to be included on the OrderRel within the same update method call.  */  
   "InventoryAttributeSetID":number,
   "BitFlag":number,
   "CommodityCodeDescription":string,
   "ContractCodeContractDescription":string,
   "CustNumSendToFSA":boolean,
   "CustNumBTName":string,
   "CustNumCustID":string,
   "CustNumName":string,
   "DiscBreakListCodeListDescription":string,
   "DiscBreakListCodeEndDate":string,
   "DiscBreakListCodeStartDate":string,
   "MktgCampaignIDCampDescription":string,
   "MktgEvntEvntDescription":string,
   "OrderNumBTCustNum":number,
   "OrderNumCurrencyCode":string,
   "OrderNumCardMemberName":string,
   "PartNumSendToFSA":boolean,
   "PartNumTrackInventoryByRevision":boolean,
   "PartNumAttrClassID":string,
   "PartNumSalesUM":string,
   "PartNumPricePerCode":string,
   "PartNumTrackSerialNum":boolean,
   "PartNumPartDescription":string,
   "PartNumIUM":string,
   "PartNumTrackLots":boolean,
   "PartNumSellingFactor":number,
   "PartNumTrackDimension":boolean,
   "PartNumDefaultAttributeSetID":number,
   "PartNumFSAEquipment":boolean,
   "PartNumTrackInventoryAttributes":boolean,
   "PriceBreakListDescription":string,
   "PriceBreakStartDate":string,
   "PriceBreakEndDate":string,
   "ProdCodeDescription":string,
   "ProjectIDDescription":string,
   "QuoteNumCurrencyCode":string,
   "SalesCatIDDescription":string,
   "TaxCatIDDescription":string,
   "WarrantyCodeWarrDescription":string,
      /**  RowMod  */  
   "RowMod":string,
   "UD_SysRevID":string,
   "Phase_c":string,
   "ItemID_c":string,
   "TypeCode_c":string,
   "OrigTypeCode_c":string,
   "PhaseID_c":string,
   "SalesCatID_c":string,
   "IndustryShipDate_c":string,
   "CreateDate_c":string,
   "PriceUpdateDate_c":string,
   "CreatedBy_c":string,
   "UpdatedBy_c":string,
}

export interface Erp_Tablesets_OrderHedAttchRow{
   "Company":string,
   "OrderNum":number,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderHedListRow{
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   "OpenOrder":boolean,
      /**   Indicates that the Order item was closed before any shipments were made against it. Normally the Orders are closed as part of the Shipping process when all the releases have been closed.  By using the "Close Order" menu option the user can close the Order manually, to provide the function to "Cancel"  the order when the customer cancels there request.  If the Order item had no shipments made it is then marked as "voided". Regardless of shipment activity the Order is always marked as closed (OpenOrder = No).
When an OrderHed record is 'voided/closed' all of it's related OrderDtl and OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   "VoidOrder":boolean,
      /**  Company Identifier.  */  
   "Company":string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   "OrderNum":number,
      /**  Contains the Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   "CustNum":number,
      /**  This is an optional field used to enter the customers Purchase Order Number.  This will be used as an alternate index for searching Orders by PO number.  */  
   "PONum":string,
      /**  Indicates if an order is flagged as being "HELD" , this  is primarily used as a visual indicator in shipping entry. It does not prevent shipments from being entered for this order.  */  
   "OrderHeld":boolean,
      /**  Mandatory entry and must be valid. Default as the system date.  */  
   "OrderDate":string,
      /**  Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "DepositBal":number,
      /**  Display value contains the deposit balance in the customer's currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "DocDepositBal":number,
      /**  Date customer needs the items on this order to arrive.  This is used only as the default value for the NeedByDate when creating order detail line items.  This can be left blank.  */  
   "NeedByDate":string,
      /**  A unique code that identifies the currency.  */  
   "CurrencyCode":string,
      /**  Bill To Customer Number  */  
   "BTCustNum":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "CustOnCreditHold":boolean,
   "CustomerBTName":string,
   "CustomerCustID":string,
   "CustomerName":string,
      /**  BTCustNumCustID  */  
   "BTCustNumCustID":string,
      /**  BTCustNumName  */  
   "BTCustNumName":string,
      /**  DemandContract  */  
   "DemandContract":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderHedRow{
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   "OpenOrder":boolean,
      /**   Indicates that the Order item was closed before any shipments were made against it. Normally the Orders are closed as part of the Shipping process when all the releases have been closed.  By using the "Close Order" menu option the user can close the Order manually, to provide the function to "Cancel"  the order when the customer cancels there request.  If the Order item had no shipments made it is then marked as "voided". Regardless of shipment activity the Order is always marked as closed (OpenOrder = No).
When an OrderHed record is 'voided/closed' all of it's related OrderDtl and OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   "VoidOrder":boolean,
      /**  Company Identifier.  */  
   "Company":string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   "OrderNum":number,
      /**  Contains the Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   "CustNum":number,
      /**  This is an optional field used to enter the customers Purchase Order Number.  This will be used as an alternate index for searching Orders by PO number.  */  
   "PONum":string,
      /**  Indicates if an order is flagged as being "HELD" , this  is primarily used as a visual indicator in shipping entry. It does not prevent shipments from being entered for this order.  */  
   "OrderHeld":boolean,
      /**   This is used as one of the selection parameters on the Order entry edit reports. The intent is for users to be able to select orders that they have entered for hard copy edit.

On new orders use the users login ID as the default. They can override this if they wish to enter something more meaningful.  */  
   "EntryPerson":string,
      /**  Indicates which customer ship to is to be used as the default for the Order release records for this order. It  can be blank or it must be valid in the SHIPTO table. Use the CUSTOMER.SHIPTONUM as the default on new orders or when the ORDERHED.CUSTNUM is changed.  */  
   "ShipToNum":string,
      /**  Date that the items need to be shipped by to meet the customers NeedByDate.  This can be left blank, it is only used to supply a default for OrderDtl.RequestDate.  */  
   "RequestDate":string,
      /**  Mandatory entry and must be valid. Default as the system date.  */  
   "OrderDate":string,
      /**  An optional field that describes the FOB policy.  */  
   "FOB":string,
      /**  Contains the key value of the record in the "SHIPVIA" table. It can be left blank or must be valid in the 'SHIPTO"  table.
Use the CUSTOMER.SHIPVIA as the default when the ORDER.CUSTNUM field is changed and the ORDERHED.SHIPTO is blank. Use SHIPTO.SHIPVIA when ORDER.CUSTNUM or ORDERHED.SHIPTO fields are changed and the ORDERHED.SHIPTO is not blank.  */  
   "ShipViaCode":string,
      /**   Contains the key value of the record in the TERMS table which indicates the sales terms established for this order. On change of ORDERHED.CUSTNUM use the CUSTOMER.TERMS

field as the default.  */  
   "TermsCode":string,
      /**  Used to establish a discount percent value which will be used as a default during order detail line entry. It can be left as zero.  Use the CUSTOMER.DISCOUNTPERCENT field as a default. Refreshed whenever ORDERHED.CUSTOMER field changes.  */  
   "DiscountPercent":number,
      /**  Contains the key  value for the Purchasing Contact. This can be blank or it must be valid in the CUSTCNT  table. Use the CUSTOMER.PRIMPCON as the default.  */  
   "PrcConNum":number,
      /**  Establishes the Shipping Contact to be used as default on the Order release records. Contains the key value for the shipping contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table. Use the Customer.PrimScon as a default.  */  
   "ShpConNum":number,
      /**  Stores the Sales Rep Codes for the order. Up to five codes can be  established. This field is not directly maintainable. Instead temp widgets are used for entry of each individual code and then put together as one comma delimited string field and assigned to this field.  This field will have a Word index, it then will make reporting and data base integrity checking much easier through the use of the "contains phrase" when retrieving records. These codes can be left blank or must be valid in the SalesRep master. The first one is defaulted from the Customer master if ship to is blank; otherwise, from the Ship To.  */  
   "SalesRepList":string,
      /**  Contains comments about the overall order. These will be printed on the Sales Acknowledgements.  */  
   "OrderComment":string,
      /**  Used to establish shipping comments about the overall order. These will copied into the packing slip header file as defaults.  */  
   "ShipComment":string,
      /**  Used to establish invoice comments about the overall order. These will copied into the Invoice detail file as defaults.  */  
   "InvoiceComment":string,
      /**  Contains picking  comments about the overall order. These will be printed on the picking lists.  */  
   "PickListComment":string,
      /**  Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "DepositBal":number,
      /**  Display value contains the deposit balance in the customer's currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "DocDepositBal":number,
      /**  Date customer needs the items on this order to arrive.  This is used only as the default value for the NeedByDate when creating order detail line items.  This can be left blank.  */  
   "NeedByDate":string,
      /**  Indicates that the credit hold was overridden for this order.  */  
   "CreditOverride":boolean,
      /**  The USERID of the user that overrode an order credit hold (system set).  */  
   "CreditOverrideUserID":string,
      /**  The date that the user last overrode the customer credit hold (system set).  */  
   "CreditOverrideDate":string,
      /**  The time that the user last overrode the customer credit hold in HH:MM:SS format (system set).  */  
   "CreditOverrideTime":string,
      /**  The authorized maximum dollar limit that an order for a credit held customer is approved for.  Initially defaulted to the current order amount when the order is credit hold overridden.  The order amount is calculated by using line information only (i.e. extended amount and discounts) - deposits, advance billings, shipments and miscellaneous charges are NOT considered.  */  
   "CreditOverrideLimit":number,
      /**  Controls if an alert is to be sent when shipments are made for this order.  */  
   "SndAlrtShp":boolean,
      /**   Exchange rate that will be used for this order.  Defaults from
CurrRate.CurrentRate. Conversion rates will be calculated as System Base = Foreign value * rate, Foreign value = system base * (1/rate). This is the dollar in foreign currency from the exchange rate tables in the newspapers.  */  
   "ExchangeRate":number,
      /**  A unique code that identifies the currency.  */  
   "CurrencyCode":string,
      /**  Used with the currency module.  When TRUE the currency rate can be changed by the user and cannot be changed by the system.  This will also be the default for the invoice.  */  
   "LockRate":boolean,
      /**  The member's name on the credit card.  */  
   "CardMemberName":string,
      /**  The credit card account identifier.  */  
   "CardNumber":string,
      /**  A code assigned by the user to uniquely identify a Credit Card Type master. This can't be blank.  */  
   "CardType":string,
      /**  The expiration month of the credit card.  */  
   "ExpirationMonth":number,
      /**  The expiration year of the credit card.  */  
   "ExpirationYear":number,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention.  */  
   "CardID":string,
      /**  Up to 17 alphnumeric characters provided by customer. This is used to track information on customer spending (e.g., cost center, project code). This field is especially critical, since inaccurate information will affect the general ledger. If no reference number is provided, leave this field blank.  */  
   "CardmemberReference":string,
      /**  Code used to relate a AllocPri record to the order.  Defaulted from Customer.AllocPriorityCode.  */  
   "AllocPriorityCode":string,
      /**  Code used to relate a ReservePri record to the order.  Defaulted from Customer.ReservePriorityCode.  */  
   "ReservePriorityCode":string,
      /**  Indicates if the order must be shipped complete.  That is, as an orders release are selected for picking during the Auto Pick process of the Order Allocation program, the all releases with a ship date <= the given cutoff date alos have to be picked complete otherwise they will not be selected. This is defaulted to Yes when Customer.ShippingQualifier = "O" (Ship Order 100% complete)  */  
   "ShipOrderComplete":boolean,
      /**  Not editable, When SF Synch creates orders, this flag is set to YES.  */  
   "WebOrder":boolean,
      /**  Updated Via SF Synch.  This is the authorization number from a third party credit card validation service.  */  
   "CCApprovalNum":string,
      /**  Order created from EDI interfaced module.  */  
   "EDIOrder":boolean,
      /**  Updated from EDI module if 855 or 865 created.  */  
   "EDIAck":boolean,
      /**  Indicates if this order header is linked to an inter-company PO header.  */  
   "Linked":boolean,
      /**  Inter-Company Purchase order number that uniquely identifies the purchase order.  */  
   "ICPONum":number,
      /**  External Trading Company Identifier.  */  
   "ExtCompany":string,
      /**  This is the web-login-id (email address) of the person that placed the order.  */  
   "WebEntryPerson":string,
      /**  Indicates whether the email acknowledgement of the order has been sent.  (For web orders)  */  
   "AckEmailSent":boolean,
      /**  Indicates if order based discounting needs to be applied to the order.  */  
   "ApplyOrderBasedDisc":boolean,
      /**  Indicates if order based discounting should be applied automatically or manually triggered by user as menu option.  */  
   "AutoOrderBasedDisc":boolean,
      /**   Indicates Entry method program that used to create the order.
S = Standard, Q = Quick Entry,  C = Counter Sales, D = Demand/EDI  */  
   "EntryMethod":string,
      /**  The help desk case that created this order.  */  
   "HDCaseNum":number,
      /**  Flag used in sales order entry for counter sales orders.  */  
   "CounterSale":boolean,
      /**  Create AR Invoice for counter sales order.  */  
   "CreateInvoice":boolean,
      /**  Create Packing Slip for counter sale.  */  
   "CreatePackingSlip":boolean,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the order quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   "LockQty":boolean,
      /**  Stores the encrypted credit card number  */  
   "ProcessCard":string,
      /**  Credit Transaction Amount, makes up part of CCTotal  */  
   "CCAmount":number,
      /**  Credit Card transaction freight amount, part of CCTotal  */  
   "CCFreight":number,
      /**  Credit Card Transaction Tax amount, part of CCTotal  */  
   "CCTax":number,
      /**  Total amount being sent to the credit card processor  */  
   "CCTotal":number,
      /**  See CCAmount  */  
   "CCDocAmount":number,
      /**  See CCFreight  */  
   "CCDocFreight":number,
      /**  See CCTax  */  
   "CCDocTax":number,
      /**  See CCTotal  */  
   "CCDocTotal":number,
      /**  Address used during AVS validation for credit transactions  */  
   "CCStreetAddr":string,
      /**  Zip used during AVS validation in credit transactions  */  
   "CCZip":string,
      /**  Bill To Customer Number  */  
   "BTCustNum":number,
      /**  New database field as it can be changed by user.  Default is set to BTCustNum?s primary billing contact.  If a primary billing contact is not set, default is ?None Selected?.  Keep in mind the BTCustNum field may be the same as CustNum (SoldTo) but the default would still be this customer?s primary billing contact where the ConNum field (Contact for sold to) is defaulting the primary purchasing contact.  */  
   "BTConNum":number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   "RepRate4":number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   "RepRate5":number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   "RepSplit1":number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   "RepSplit2":number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   "RepSplit3":number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   "RepSplit4":number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   "RepSplit5":number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   "RepRate1":number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   "RepRate2":number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   "RepRate3":number,
      /**  Incremented whenever an outbound sales document is generated from the order, i.e. Sales Order Acknowledgement, Response to Change, etc.  */  
   "OutboundSalesDocCtr":number,
      /**  Incremented whenever an outbound shipping document is generated from the order, i.e. ASN.  */  
   "OutboundShipDocsCtr":number,
      /**  The demand contract this OrderHed is related to.  */  
   "DemandContractNum":number,
      /**  The date before which the order cannot be shipped.  */  
   "DoNotShipBeforeDate":string,
      /**  Is this a residential delivery  */  
   "ResDelivery":boolean,
      /**  The date after which the order cannot be shipped.  */  
   "DoNotShipAfterDate":string,
      /**  Is a Saturday delivery acceptable  */  
   "SatDelivery":boolean,
      /**  Is a Saturday pickup available  */  
   "SatPickup":boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   "Hazmat":boolean,
      /**  Documents Only delivery  */  
   "DocOnly":boolean,
      /**  Reference Notes for the delivery  */  
   "RefNotes":string,
      /**  Apply Handling Charge to shipment  */  
   "ApplyChrg":boolean,
      /**  Handling Charge Amount  */  
   "ChrgAmount":number,
      /**  Prefer COD delivery  */  
   "COD":boolean,
      /**  Add Freight COD Amount owed  */  
   "CODFreight":boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   "CODCheck":boolean,
      /**  Amount due on Cashier's check or money order  */  
   "CODAmount":number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   "GroundType":string,
      /**  Indicates whether to send an email notification of delivery  */  
   "NotifyFlag":boolean,
      /**  The list of email address to notify about a delivery  */  
   "NotifyEMail":string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   "DeclaredIns":boolean,
      /**  Declared Insurance Amount  */  
   "DeclaredAmt":number,
      /**  The date after which the sales order should be canceled.  */  
   "CancelAfterDate":string,
      /**  Indicates if the demand that created/updated this order has been rejected.  */  
   "DemandRejected":boolean,
      /**  Override Carrier Defaults.  If not checked then the Site values will be used  */  
   "OverrideCarrier":boolean,
      /**  Override Service Options.  If not checked then the Site values will be used  */  
   "OverrideService":boolean,
      /**  Indicates if the Order is a credit card order  */  
   "CreditCardOrder":boolean,
      /**  This field along with Company and DemandContractNum make up the unique key to the table. The system should generate this number during entry of new header records. The system determines next available number by finding the last DemandHead for the DemandContractNum and adding 1.  */  
   "DemandHeadSeq":number,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   "PayFlag":string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   "PayAccount":string,
      /**  Shipping Bill To. The first line of the Payers main address. Required when Pay Flag is Third party.  */  
   "PayBTAddress1":string,
      /**  Shipping Bill To.  The second line of the Payers main address. An address is required when Pay Flag is Third party  */  
   "PayBTAddress2":string,
      /**  Shipping, The city portion of the Payer main address.  */  
   "PayBTCity":string,
      /**  The state or province portion of the shipment payer main address.  */  
   "PayBTState":string,
      /**  The zip or postal code portion of the shipping payers main address.  */  
   "PayBTZip":string,
      /**  The country of the main shipping payers address.  */  
   "PayBTCountry":string,
      /**  Freight charges will not be returned if 'yes'  */  
   "DropShip":boolean,
      /**  Added for international shipping  */  
   "CommercialInvoice":boolean,
      /**  Added for international shipping. Shipper's Export Declaration  */  
   "ShipExprtDeclartn":boolean,
      /**  For International shipping.  Certificate of Orgin.  */  
   "CertOfOrigin":boolean,
      /**  For International shipping.  Shipper's Letter of Instruction.  */  
   "LetterOfInstr":boolean,
      /**  International Shipping. Frieght Forwarder ID  */  
   "FFID":string,
      /**  International Shipping. The first line of the Frieght Forwarder main address.  */  
   "FFAddress1":string,
      /**  International Shipping. The second line of the Frieght Forwarder main address.  */  
   "FFAddress2":string,
      /**  Shipping, The city portion of the Frieght Forwarder main address.  */  
   "FFCity":string,
      /**  International Shipping. The state or province portion of the shipment Frieght Forwarder main address.  */  
   "FFState":string,
      /**  International Shipping. The zip or postal code portion of the shipping Frieght Forwarder main address.  */  
   "FFZip":string,
      /**  International shipping. The country of the Frieght Forwarder .  */  
   "FFCountry":string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   "FFContact":string,
      /**  International Shipping. Frieght Forwarder company name  */  
   "FFCompName":string,
      /**  International Shipping. Frieght Forwarder Phone number  */  
   "FFPhoneNum":string,
      /**  Is this an International shipment  */  
   "IntrntlShip":boolean,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   "AutoPrintReady":boolean,
      /**  Defines if this document is marked as EDI Ready  */  
   "EDIReady":boolean,
      /**  Indicates whether or not all freight charges sent or received are for individual pack DIs or the master pack.  */  
   "IndividualPackIDs":boolean,
      /**  Freight Forwarder third address line.  */  
   "FFAddress3":string,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   "DeliveryConf":number,
      /**  Additional Handling Required flag  */  
   "AddlHdlgFlag":boolean,
      /**  Non Standard Package flag.  */  
   "NonStdPkg":boolean,
      /**  Service delivery requires signature  */  
   "ServSignature":boolean,
      /**  Service Priority Alert flag  */  
   "ServAlert":boolean,
      /**  Service Home Delivery allowed  */  
   "ServHomeDel":boolean,
      /**  Service Home Delivery Type Code  */  
   "DeliveryType":string,
      /**  Service Home Delivery date  */  
   "ServDeliveryDate":string,
      /**  Service Delivery Instructions  */  
   "ServInstruct":string,
      /**  Service Reference 1  */  
   "ServRef1":string,
      /**  Service Reference 2  */  
   "ServRef2":string,
      /**  Service Reference 3  */  
   "ServRef3":string,
      /**  Service Reference 4  */  
   "ServRef4":string,
      /**  Service Reference 5  */  
   "ServRef5":string,
      /**  Freight Forwarder country portion of the address  */  
   "FFCountryNum":number,
      /**  Home delivery phone number  */  
   "ServPhone":string,
      /**  Service Signature release is on file  */  
   "ServRelease":boolean,
      /**  Service Signature Release authorization number  */  
   "ServAuthNum":string,
      /**  Payer Bill To  third address line  */  
   "PayBTAddress3":string,
      /**  Payer Bill To country portion of the address  */  
   "PayBTCountryNum":number,
      /**  Payer Bill To phone number  */  
   "PayBTPhone":string,
      /**  UPS Quantity View  */  
   "UPSQuantumView":boolean,
      /**  UPS Quantum View Ship from Nam  */  
   "UPSQVShipFromName":string,
      /**  UPS Quantity View Memo  */  
   "UPSQVMemo":string,
      /**  This flag will be used to indicate if the order is ready for calculations. When set to true, tax calculations will take place whenever a save takes place for any tables tied to the order which could affect taxes (OrderDtl, OrderHed, OrderMisc, etc). It defaults from XASyst.SOReadyToCalcDflt field when an order is created.  */  
   "ReadyToCalc":boolean,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "TotalCharges":number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "TotalMisc":number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "TotalDiscount":number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "TotalComm":number,
      /**  Total Advance Billable Balance  */  
   "TotalAdvBill":number,
      /**  Total number of lines on the order  */  
   "TotalLines":number,
      /**  Total Number of releases on order  */  
   "TotalReleases":number,
      /**  Total number of distinct release dates on order  */  
   "TotalRelDates":number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "DocTotalCharges":number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "DocTotalMisc":number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "DocTotalDiscount":number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "DocTotalComm":number,
      /**   Order Total Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "TotalTax":number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "DocTotalTax":number,
      /**  Total Advance Billable Balance  */  
   "DocTotalAdvBill":number,
      /**  Total Shipped amount  */  
   "TotalShipped":number,
      /**  Total amount of order that has been invoiced  */  
   "TotalInvoiced":number,
      /**  Total number of lines that were commissionable  */  
   "TotalCommLines":number,
      /**  Commission earned for first sales rep  */  
   "SRCommAmt1":number,
      /**  Commission earned for second sales rep  */  
   "SRCommAmt2":number,
      /**  Commission earned for third sales rep  */  
   "SRCommAmt3":number,
      /**  Commission earned for fourth sales rep  */  
   "SRCommAmt4":number,
      /**  Commission earned for fifth sales rep  */  
   "SRCommAmt5":number,
      /**  Total Commissionable Amount for first salesrep  */  
   "SRCommableAmt1":number,
      /**  Total Commissionable Amount for second salesrep  */  
   "SRCommableAmt2":number,
      /**  Total Commissionable Amount for third salesrep  */  
   "SRCommableAmt3":number,
      /**  Total Commissionable Amount for fourth salesrep  */  
   "SRCommableAmt4":number,
      /**  Total Commissionable Amount for fifth salesrep  */  
   "SRCommableAmt5":number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   "Rounding":number,
      /**  Display value contains the deposit balance in a reporting currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "Rpt1DepositBal":number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   "DocRounding":number,
      /**  Display value contains the deposit balance in a report currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "Rpt2DepositBal":number,
      /**  Display value contains the deposit balance in a report currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   "Rpt3DepositBal":number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalCharges":number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalCharges":number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalCharges":number,
      /**  Total Advance Billable Balance  */  
   "Rpt1TotalAdvBill":number,
      /**  Total Advance Billable Balance  */  
   "Rpt2TotalAdvBill":number,
      /**  Total Advance Billable Balance  */  
   "Rpt3TotalAdvBill":number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalMisc":number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalMisc":number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalMisc":number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalDiscount":number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalDiscount":number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalDiscount":number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalComm":number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalComm":number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalComm":number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax +TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalTax":number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalTax":number,
      /**  Reporting currency value of this field  */  
   "Rpt1Rounding":number,
      /**  Reporting currency value of this field  */  
   "Rpt2Rounding":number,
      /**  Reporting currency value of this field  */  
   "Rpt3Rounding":number,
      /**  Unique identifier  */  
   "RateGrpCode":string,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalTax":number,
      /**  See CCAmount  */  
   "Rpt1CCAmount":number,
      /**  See CCAmount  */  
   "Rpt2CCAmount":number,
      /**  See CCAmount  */  
   "Rpt3CCAmount":number,
      /**  See CCFreight  */  
   "Rpt1CCFreight":number,
      /**  See CCFreight  */  
   "Rpt2CCFreight":number,
      /**  See CCFreight  */  
   "Rpt3CCFreight":number,
      /**  See CCTax  */  
   "Rpt1CCTax":number,
      /**  See CCTax  */  
   "Rpt2CCTax":number,
      /**  See CCTax  */  
   "Rpt3CCTax":number,
      /**  See CCTotal  */  
   "Rpt1CCTotal":number,
      /**  See CCTotal  */  
   "Rpt2CCTotal":number,
      /**  See CCTotal  */  
   "Rpt3CCTotal":number,
      /**  Total order Amount. This field is an accumulation of the extended net amounts of the detail line items  */  
   "OrderAmt":number,
      /**  Total order Amount in customer currency. This field is an accumulation of the extended net amounts of the detail line items and rounded according to the Doc currency Round rule  */  
   "DocOrderAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1OrderAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2OrderAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3OrderAmt":number,
      /**  Tax Point  */  
   "TaxPoint":string,
      /**  Date Used to calculate Tax Rates  */  
   "TaxRateDate":string,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   "TaxRegionCode":string,
      /**   Indicates if the One Time Shipto information is to be used.
Note: This can only be true when if the OTSName is not blank. 
UI disables this when Customer.AllowQTS = False,  */  
   "UseOTS":boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   "OTSName":string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   "OTSAddress1":string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   "OTSAddress2":string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   "OTSAddress3":string,
      /**  City portion of the One Time Shipto  address.  */  
   "OTSCity":string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   "OTSState":string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   "OTSZIP":string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   "OTSResaleID":string,
      /**  One Time Ship To Contact Name  */  
   "OTSContact":string,
      /**  Fax number for the One Time ShipTo.  */  
   "OTSFaxNum":string,
      /**  Phone number for the One Time ShipTo  */  
   "OTSPhoneNum":string,
      /**  One Time Shipment country  */  
   "OTSCountryNum":number,
      /**   Order Total Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "TotalWHTax":number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "DocTotalWHTax":number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalWHTax":number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalWHTax":number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalWHTax":number,
      /**   Order Total Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "TotalSATax":number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "DocTotalSATax":number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt1TotalSATax":number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt2TotalSATax":number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   "Rpt3TotalSATax":number,
      /**  Indicates if/how the OTS is saved. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   "OTSSaveAs":string,
      /**  CustID to be used if the OTS is used to create a customer record.  */  
   "OTSSaveCustID":string,
      /**  True if Customer or ShipTo record was created using the  OTS info.  */  
   "OTSCustSaved":boolean,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   "ShipToCustNum":number,
      /**  Status of Order  */  
   "OrderStatus":string,
      /**  Hold Set by Demand  */  
   "HoldSetByDemand":boolean,
      /**  Indicates that the tax is included in the unit price  */  
   "InPrice":boolean,
      /**  Reserved for future use  */  
   "InTotalCharges":number,
      /**  Reserved for future use  */  
   "InTotalMisc":number,
      /**  Reserved for future use  */  
   "InTotalDiscount":number,
      /**  Reserved for future use  */  
   "DocInTotalCharges":number,
      /**  Reserved for future use  */  
   "DocInTotalMisc":number,
      /**  Reserved for future use  */  
   "DocInTotalDiscount":number,
      /**  Reserved for future use  */  
   "Rpt1InTotalCharges":number,
      /**  Reserved for future use  */  
   "Rpt2InTotalCharges":number,
      /**  Reserved for future use  */  
   "Rpt3InTotalCharges":number,
      /**  Reserved for future use  */  
   "Rpt1InTotalMisc":number,
      /**  Reserved for future use  */  
   "Rpt2InTotalMisc":number,
      /**  Reserved for future use  */  
   "Rpt3InTotalMisc":number,
      /**  Reserved for future use  */  
   "Rpt1InTotalDiscount":number,
      /**  Reserved for future use  */  
   "Rpt2InTotalDiscount":number,
      /**  Reserved for future use  */  
   "Rpt3InTotalDiscount":number,
      /**  Letter of Credit ID.  */  
   "ARLOCID":string,
      /**  Bank for Cash Receipts. Default is from Customer(Bill To).  */  
   "OurBank":string,
      /**  It will be used to identify SO that will generate an invoice at the shipment.  If the order is created manually the default for this order will be taken from the customer master file. If the order is created via DM, the default will be taken from the value in the DM records.  */  
   "ERSOrder":boolean,
      /**  Indicates that order is on hold due to amount exceeding value on Letter of Credit.  */  
   "LOCHold":boolean,
      /**  Currency code used in further packing slips.  */  
   "PSCurrCode":string,
      /**  Currency code used in further AR invoices.  */  
   "InvCurrCode":string,
      /**  Legal Number for the record.  */  
   "LegalNumber":string,
      /**  Transaction Document for the record.  */  
   "TranDocTypeID":string,
      /**  Cross Reference Contract Number.  */  
   "XRefContractNum":string,
      /**  Cross Reference Contract Date.  */  
   "XRefContractDate":string,
      /**  Date in which the related demand was last processed.  */  
   "DemandProcessDate":string,
      /**  System Time when demand was last processed.  */  
   "DemandProcessTime":number,
      /**  Last Schedule Number in which the demand was processed.  */  
   "LastScheduleNumber":string,
      /**  EDI Transaction Control Number  */  
   "LastTCtrlNum":string,
      /**  EDI Batch Control Number  */  
   "LastBatchNum":string,
      /**  ECCOrderNum  */  
   "ECCOrderNum":string,
      /**  ECCPONum  */  
   "ECCPONum":string,
      /**  WIOrder  */  
   "WIOrder":string,
      /**  WIApplication  */  
   "WIApplication":string,
      /**  WIUsername  */  
   "WIUsername":string,
      /**  WIUserID  */  
   "WIUserID":string,
      /**  WICreditCardorder  */  
   "WICreditCardorder":boolean,
      /**  OrderCSR  */  
   "OrderCSR":string,
      /**  UserChar1  */  
   "UserChar1":string,
      /**  UserChar2  */  
   "UserChar2":string,
      /**  UserChar3  */  
   "UserChar3":string,
      /**  UserChar4  */  
   "UserChar4":string,
      /**  UserDate1  */  
   "UserDate1":string,
      /**  UserDate2  */  
   "UserDate2":string,
      /**  UserDate3  */  
   "UserDate3":string,
      /**  UserDate4  */  
   "UserDate4":string,
      /**  UserDecimal1  */  
   "UserDecimal1":number,
      /**  UserDecimal2  */  
   "UserDecimal2":number,
      /**  UserInteger1  */  
   "UserInteger1":number,
      /**  UserInteger2  */  
   "UserInteger2":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  IsCSRSet  */  
   "IsCSRSet":boolean,
      /**  ECCPaymentMethod  */  
   "ECCPaymentMethod":string,
      /**  AGUseGoodDefaultMark  */  
   "AGUseGoodDefaultMark":boolean,
      /**  OTSShipToNum  */  
   "OTSShipToNum":string,
      /**  ProFormaInvComment  */  
   "ProFormaInvComment":string,
      /**  ccToken  */  
   "ccToken":string,
      /**  InvcOrderCmp  */  
   "InvcOrderCmp":boolean,
      /**  ReprintSOAck  */  
   "ReprintSOAck":boolean,
      /**  CounterSOAck  */  
   "CounterSOAck":number,
      /**  DispatchReason  */  
   "DispatchReason":string,
      /**  Plant  */  
   "Plant":string,
      /**  This flag will be used to indicate if the sales order is ready to be fulfilled.  */  
   "ReadyToFulfill":boolean,
      /**  Ship the good by this time  */  
   "ShipByTime":number,
      /**  Taiwan GUI Calendar Fiscal Year  */  
   "TWFiscalYear":number,
      /**  Taiwan GUI Calendar Fiscal Year Suffix  */  
   "TWFiscalYearSuffix":string,
      /**  Taiwan GUI Calendar Fiscal Period  */  
   "TWFiscalPeriod":number,
      /**  GUI Group of Legal Numbers  */  
   "TWGUIGroup":string,
      /**  Seller GUI Code  */  
   "TWGUIRegNumSeller":string,
      /**  Buyer GUI Code  */  
   "TWGUIRegNumBuyer":string,
      /**  OrderOpenCredit  */  
   "OrderOpenCredit":number,
      /**  ClosedNotShipped  */  
   "ClosedNotShipped":number,
      /**  InvCurrDepositBal  */  
   "InvCurrDepositBal":number,
      /**  Article. 106c  */  
   "PLArticle106c":boolean,
      /**  Invoices are issued by a taxpayer's representative  */  
   "PLInvIssuedByTaxpayer":boolean,
      /**  Invoices issued by the second taxpayer  */  
   "PLInvIssuedBySecondTaxpayer":boolean,
      /**  Tourist Services  */  
   "PLTouristService":boolean,
      /**  Second hand goods, works of art, collectibles or antiques  */  
   "PLSecondHandOrArts":boolean,
      /**  Appropriate Legal Article of the Act  */  
   "PLLegalArticleAct":string,
      /**  Appropriate Legal Article of 2006/112/WE Directive  */  
   "PLLegalArticleWEDirective":string,
      /**  Other Legal Article  */  
   "PLLegalArticleOther":string,
      /**  Name of the Enforcement Authority or the Name of the Judicial Officer  */  
   "PLEnforcementAuthName":string,
      /**  Address of the Enforcement Authority or Judicial Officer  */  
   "PLEnforcementAuthAddr":string,
      /**  Tax Representative Name  */  
   "PLTaxRepresentativeName":string,
      /**  Tax Representative Address  */  
   "PLTaxRepresentativeAddr":string,
      /**  Tax ID of the Tax Representative  */  
   "PLTaxRepresentativeTaxID":string,
      /**  Margin Scheme  */  
   "PLMarginScheme":number,
      /**  Goods or Service VAT exempt  */  
   "PLGoodsOrServiceVATExempt":boolean,
      /**  Credit Card Holder City  */  
   "CCCity":string,
      /**  Credit Card Holder State  */  
   "CCState":string,
      /**  ExtAOEUserID  */  
   "ExtAOEUserID":string,
      /**  ExtAOE  */  
   "ExtAOE":string,
      /**  OTSTaxValidationStatus  */  
   "OTSTaxValidationStatus":number,
      /**  OTSTaxValidationDate  */  
   "OTSTaxValidationDate":string,
      /**  FSMSendTo  */  
   "FSMSendTo":boolean,
      /**  Incoterm Code  */  
   "IncotermCode":string,
      /**  Incoterm Location  */  
   "IncotermLocation":string,
      /**  CovenantDiscPercent  */  
   "CovenantDiscPercent":number,
      /**  TotalCovenantDiscount  */  
   "TotalCovenantDiscount":number,
      /**  DocCovenantDiscount  */  
   "DocCovenantDiscount":number,
      /**  Rpt1CovenantDiscount  */  
   "Rpt1CovenantDiscount":number,
      /**  Rpt2CovenantDiscount  */  
   "Rpt2CovenantDiscount":number,
      /**  Rpt3CovenantDiscount  */  
   "Rpt3CovenantDiscount":number,
      /**  TotalInCovenantDiscount  */  
   "TotalInCovenantDiscount":number,
      /**  DocInCovenantDiscount  */  
   "DocInCovenantDiscount":number,
      /**  Rpt1InCovenantDiscount  */  
   "Rpt1InCovenantDiscount":number,
      /**  Rpt2InCovenantDiscount  */  
   "Rpt2InCovenantDiscount":number,
      /**  Delimited list of available bill to customers (CustID`CustomerName~CustID`CustomerName)  */  
   "AvailBTCustList":string,
      /**  AVSADDR returned by a 3rd party credit card processing company  for a credit card transaction. This value represents the results of the Address Verification System (AVS) address test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   "AVSAddr":string,
      /**  Rpt3InCovenantDiscount  */  
   "Rpt3InCovenantDiscount":number,
      /**  AVSZIP returned by a 3rd party credit card processing company  for a credit card transaction. This value represents the results of the Address Verification System (AVS) zip code test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   "AVSZip":string,
   "BaseCurrencyID":string,
   "BaseCurrSymbol":string,
      /**  Bill to customer name.  */  
   "BillToCustomerName":string,
      /**  Bill To Address List.  */  
   "BTAddressList":string,
   "BTContactEMailAddress":string,
      /**  Bill to contact fax number.  */  
   "BTContactFaxNum":string,
      /**  Bill to contact name.  */  
   "BTContactName":string,
      /**  Bill to contact phone number.  */  
   "BTContactPhoneNum":string,
      /**  Bill To Customer ID  */  
   "BTCustID":string,
      /**  The flag to indicate if the user can change Tax Liability on the header level after adding a detail line.  */  
   "CanChangeTaxLiab":boolean,
      /**  Stored Credit Card Number  */  
   "CardStore":string,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention  */  
   "CCCSCID":string,
      /**  Tokenized value of CSCID  */  
   "CCCSCIDToken":string,
      /**   Indicates if the credit card setup will be using a testing Paygate instance for transactions.
Force requests to use Paygate test url: paygate-test1.eaglesoa.com  */  
   "CCIsTraining":boolean,
      /**  RESPMSG returned by  a 3rd party credit card processing company for a credit card transaction. This is a brief description of the status of the credit card transaction.  */  
   "CCResponse":string,
   "CCRounding":number,
      /**  PNREF returned by a 3rd party credit card processing company for a credit card transaction. This is a unique number that identifies the transaction and is often referenced we performing related transactions.  */  
   "CCTranID":string,
      /**  Credit Card Transaction Type  */  
   "CCTranType":string,
      /**  CVV2MATCH returned by a 3rd party credit card processing company for a credit card transaction. This value represents the results of the Card Security Code test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   "CSCResult":string,
   "CurrencySwitch":boolean,
   "CustAllowOTS":boolean,
   "CustomerPrintAck":boolean,
      /**  If true the customer requires a unique PO on Sales Orders  */  
   "CustomerRequiresPO":boolean,
      /**  When set to true, indicates that this customer does not have credit available from your company.  */  
   "CustOnCreditHold":boolean,
   "CustTradePartnerName":string,
      /**  DemandContract  */  
   "DemandContract":string,
   "DocCCRounding":number,
   "DocTotalNet":number,
   "DocTotalOrder":number,
      /**  If SoldTo and Alt-Bill to are the same, this displays as null.  */  
   "dspBTCustID":string,
      /**  ECC Contact Email - Contains the email address of the ECC login that placed the sales order. This only applies for B2C Orders.  */  
   "ECCEmail":string,
      /**  ECC Payment Description  */  
   "ECCPaymentDesc":string,
      /**  True when Credit Card Procesing module is enabled  */  
   "EnableCreditCard":boolean,
      /**  True when Job Wizard must be enabled  */  
   "EnableJobWizard":boolean,
      /**  True when SoldTo ID must be enabled  */  
   "EnableSoldToID":boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
      /**  It will be displayed when the value of the ERS flag at the sales order is different from the value in the customer master file.  */  
   "ERSOverride":boolean,
      /**  Used by UI to disable CurrencyCode  */  
   "HasMiscCharges":boolean,
   "HasOrderLines":boolean,
      /**  Unique identifier of related integration record.  */  
   "IntExternalKey":string,
   "LinkMsg":string,
      /**  Internal field which indicates if Order Tax Liability is not going to be changed even though Ship To is changed.  Related to Tax inclusive pricing. Depends on user response.  */  
   "NoTaxRgnChange":boolean,
   "OTSSaved":boolean,
      /**  OTS Tax Liability Code (Header)  */  
   "OTSTaxRegionCode":string,
      /**  Contains the Parent Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   "ParentCustNum":number,
   "ProposedTaxRgn":string,
      /**  PNRef number referred to in the transaction.  If Deposit transaction must referenece prior Authorization using the PNRef  */  
   "ReferencePNRef":string,
      /**  Internal field toindicate if the system should reset Bill to Customer address.  Based on the  user reply for LOC.  */  
   "ResetBTCustAddr":boolean,
      /**  Internal field which indicates if existing Release Tax Region should be se-set to the new Order Header Tax Liability.  Depends on the user reply.  */  
   "ResetRelTaxRgn":boolean,
   "Rpt1CCRounding":number,
   "Rpt1TotalNet":number,
   "Rpt2CCRounding":number,
   "Rpt2TotalNet":number,
   "Rpt3CCRounding":number,
   "Rpt3TotalNet":number,
      /**  Element 1 of SalesRepList  */  
   "SalesRepCode1":string,
      /**  Element 2 of SalesRepList  */  
   "SalesRepCode2":string,
      /**  Element 3 of SalesRepList  */  
   "SalesRepCode3":string,
      /**  Element 4 of SalesRepList  */  
   "SalesRepCode4":string,
      /**  Element 5 of SalesRepList  */  
   "SalesRepCode5":string,
   "SalesRepName1":string,
   "SalesRepName2":string,
   "SalesRepName3":string,
   "SalesRepName4":string,
   "SalesRepName5":string,
   "ShipToAddressList":string,
   "ShipToContactEMailAddress":string,
   "ShipToContactFaxNum":string,
   "ShipToContactName":string,
   "ShipToContactPhoneNum":string,
      /**  Customer Id of the third-party Ship To  */  
   "ShipToCustId":string,
   "ShowApplyOrderDiscountsControl":boolean,
   "SoldToAddressList":string,
   "SoldToContactEMailAddress":string,
   "SoldToContactFaxNum":string,
   "SoldToContactName":string,
   "SoldToContactPhoneNum":string,
      /**  This field defines the type of the term  */  
   "TermsType":string,
   "TotalNet":number,
   "TotalOrder":number,
   "TranDocTypeDescr":string,
      /**  the true discount percent from the order total  */  
   "TrueDiscountPercent":number,
      /**  Taiwan GUI Legal Number Generation Type  */  
   "TWGenerationType":string,
   "UpdateDtlAndRelRecords":boolean,
      /**  Indicates if one or more invoices exist for this order  */  
   "InvoicesExist":boolean,
   "BTAddressFormatted":string,
      /**  The formatted ship to address  */  
   "ShipToAddressFormatted":string,
      /**  The formatted Sold To Address  */  
   "SoldToAddressFormatted":string,
   "TranDate":string,
   "TranNum":number,
   "TranTime":number,
      /**  Indicates there is an OrderRel record that has a non-null NeedByDate  */  
   "OrderRelNeedByDateNotNull":boolean,
      /**  Indicates a customer referenced on the order is inactive.  */  
   "InactiveCustomer":boolean,
      /**  Enable Fulfillment Queue Actions  */  
   "EnableAllocationQueueActions":boolean,
      /**  CREProcessor is true when Credit Card Configuration is CRE Server.  */  
   "CREProcessor":boolean,
      /**  Flag indicating whether to enable Incoterm Location  */  
   "EnableIncotermLocation":boolean,
   "BitFlag":number,
   "BTCustNumCustID":string,
   "BTCustNumName":string,
   "BTCustNumBTName":string,
   "CardTypeDescription":string,
   "CurrencyCodeCurrName":string,
   "CurrencyCodeCurrSymbol":string,
   "CurrencyCodeDocumentDesc":string,
   "CurrencyCodeCurrencyID":string,
   "CurrencyCodeCurrDesc":string,
   "CustomerBTName":string,
   "CustomerCustID":string,
   "CustomerName":string,
   "CustomerAllowShipTo3":boolean,
   "FOBDescription":string,
   "HDCaseDescription":string,
   "IncotermsDescription":string,
   "InvCurrCurrDesc":string,
   "OTSCntryISOCode":string,
   "OTSCntryDescription":string,
   "OTSCntryEUMember":boolean,
   "OurBankDescription":string,
   "OurBankBankName":string,
   "PlantName":string,
   "PSCurrCurrDesc":string,
   "RateGrpDescription":string,
   "ReservePriDescription":string,
   "ShipToNumInactive":boolean,
   "ShipViaCodeInactive":boolean,
   "ShipViaCodeDescription":string,
   "ShipViaCodeWebDesc":string,
   "TaxRegionCodeDescription":string,
   "TermsCodeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
   "UD_SysRevID":string,
   "Project_c":string,
   "OriginalOrderNo_c":number,
   "MASFlag_c":boolean,
   "Estimate_c":boolean,
   "ShipOrderComplete_c":boolean,
   "ProjectID_c":string,
   "PhaseID_c":string,
   "SalesCatID__c":string,
   "TaxCatID_c":string,
   "MfgOrder_c":boolean,
}

export interface Erp_Tablesets_OrderHedUPSRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   "OrderNum":number,
      /**  UPS Quantum View Sequence  */  
   "UPSQVSeq":number,
      /**  Email address to notify for a UPS shipment  */  
   "EmailAddress":string,
      /**  Logical indicating if the EmailAddress is to be updated at shipping.  */  
   "ShipmentNotify":boolean,
      /**  Logical indicating if the Email Address is to be notified of a failed shipment.  */  
   "FailureNotify":boolean,
      /**  Logical indicating if the Email Address is to be notified of delivery.  */  
   "DeliveryNotify":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Logical indicating if the UPS quantum view email data is to be enabled.  */  
   "EnableQuantumView":boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderHistRow{
      /**  Company  */  
   "Company":string,
      /**  Sales Order Number  */  
   "OrderNum":number,
      /**  Order Line  */  
   "OrderLine":number,
      /**  Order Date  */  
   "OrderDate":string,
      /**  Part Number  */  
   "PartNum":string,
      /**  Part Description  */  
   "PartDescription":string,
      /**  Order Quantity  */  
   "OrderQty":number,
      /**  Selling Unit of Measure  */  
   "UOM":string,
      /**  Original Price  */  
   "OriginalPrice":number,
      /**  New Price  */  
   "NewPrice":number,
      /**  New Quantity  */  
   "NewQty":number,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderMscRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Sales Order Number  */  
   "OrderNum":number,
      /**  Order line number that this miscellaneous record is related to. If related to the Order then this field is zero. This number is not directly entered by the user; rather it is carried through from the header or detail line that user was on when miscellaneous maintenance was requested.  */  
   "OrderLine":number,
      /**  Sequence Number  */  
   "SeqNum":number,
      /**  The Miscellaneous Charge Code. This must be valid in the MiscChrg master file.  */  
   "MiscCode":string,
      /**  Description of the miscellaneous charge. This will be printed on the acknowledgment and transferred over to invoice processing. The default is provided by MiscChrg.Description, but it's overridable by the user. This can't be blank.  */  
   "Description":string,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   "MiscAmt":number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   "DocMiscAmt":number,
      /**  Sets the frequency of when this miscellaneous charge should be applied. The options are F - First shipment, L = Last shipment, E = every shipment. This defaults from the MiscChrg.FreqCode.  */  
   "FreqCode":string,
      /**  An internally used flag which indicates that this record was created from a Quote via the "Get Quote" function. "Q" = related to the QuoteQty record, "L" = related to the overall QuoteDtl record. This flag is used so that the OrderMsc file can be refreshed from the QuoteMsc when Quantity or Quote/Line # changes occur. The logic is that if a change in order quantity of a order line that is linked to a quote causes a different price break to be selected then all the existing all OrderMsc records where Quoting = "Q" are deleted and then re-pulled in based on the new qty. If the Quote # or QuoteLine are changed then all OrderMsc records where Quoting is either a "Q" or "L" are deleted then re-pulled in from the newly referenced quote.  */  
   "Quoting":string,
      /**  Indicates if this order miscellaneous charge is linked to an inter-company PO misc charge.  */  
   "Linked":boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   "ICPONum":number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   "ICPOLine":number,
      /**  Inter Company PO Sequence Number  */  
   "ICPOSeqNum":number,
      /**  External Trading Company Identifier.  */  
   "ExtCompany":string,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Reporting currency value of this field  */  
   "Rpt1MiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2MiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3MiscAmt":number,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default. - Includes taxes  */  
   "InMiscAmt":number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default. - includes taxes  */  
   "DocInMiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1InMiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2InMiscAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3InMiscAmt":number,
      /**  This field will be used to define the percentage of the extended amount that will be applied as the 'Miscellaneous charge'.  */  
   "Percentage":number,
      /**  This field will define if the miscellaneous charge is calculated as a flat amount or if is calculated as a percentage of the extended price.  */  
   "Type":string,
      /**  ChangeTrackApproved  */  
   "ChangeTrackApproved":boolean,
      /**  ChangeTrackAmount  */  
   "ChangeTrackAmount":number,
      /**  ChangeTrackMemoDesc  */  
   "ChangeTrackMemoDesc":string,
      /**  ChangeTrackMemoText  */  
   "ChangeTrackMemoText":string,
      /**  ChangeTrackStatus  */  
   "ChangeTrackStatus":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BaseCurrSymbol":string,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
   "CurrencySwitch":boolean,
   "CurrSymbol":string,
      /**  Misc charge amount on display in document currency (may or may not include taxes)  */  
   "DocDspMiscAmt":number,
      /**  Misc charge amount on display (may or may not include taxes)  */  
   "DspMiscAmt":number,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
   "OpenLine":boolean,
      /**  Misc charge amount on display in report currency  (may or may not include taxes)  */  
   "Rpt1DspMiscAmt":number,
      /**  Misc charge amount on display in report currency  (may or may not include taxes)  */  
   "Rpt2DspMiscAmt":number,
      /**  Misc charge amount on display in document currency (may or may not include taxes)  */  
   "Rpt3DspMiscAmt":number,
      /**  Pass Credit Limit check message to the UI  */  
   "RespMessage":string,
   "BitFlag":number,
   "MiscCodeDescription":string,
   "OrderLineLineDesc":string,
   "OrderNumCurrencyCode":string,
   "OrderNumCardMemberName":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderRelRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Sales Order Number  */  
   "OrderNum":number,
      /**  Sales order Line number that this order release is linked to.  */  
   "OrderLine":number,
      /**  The release number assigned by the system.  The user never sees this field. It  is used as a foreign key in other files (such as ShipDtl) to tie those records back to the release record.  */  
   "OrderRelNum":number,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT".  */  
   "LineType":string,
      /**  Date which the item needs to be shipped by in order to meet the customers due date. Initially defaulted as OrderHed.ReqDate.  */  
   "ReqDate":string,
      /**  Quantity ,using Our U/M, that is requested to be shipped for this release. This MUST BE > ZERO.  */  
   "OurReqQty":number,
      /**  The ShipTo ID to be used for this scheduled release record. This MUST BE VALID IN THE SHIPTO file. Use the OrderHead.ShiptoNum as the default when creating new records.  */  
   "ShipToNum":string,
      /**  Ship Via ID that is used for this shipment release. THIS CAN BE BLANK or MUST BE VALID IN THE SHIPVIA master file. Use the OrderHead.ShipViaCode as the default.  */  
   "ShipViaCode":string,
      /**  Indicates if this release is open.  This is normally set to closed via the shipping program. But can be changed indirectly  by the user during order entry when they "Void" the release..  */  
   "OpenRelease":boolean,
      /**  Indicates if this release is  "FIRM". The opposite is an uncommitted release, that is when the customer gives releases that are just 'Best Guesses' of what they will require in the future, such as in blanket order situations. This type of  releases is no different to the system, except that the FirmRelease field will be printed on reports such as TimePhase requirements.  */  
   "FirmRelease":boolean,
      /**   Indicates if this requirement or any part of it will be manufactured. Default the setting to "No" if valid Part and the Part.Type is "S" or "P".

Default the setting to "Yes" if the part is not found in Part master or the Part.Type = "J".  This flag also gets set if this release gets linked to a Job via Job Entry. There is an Index on this field so that we can display releases that need have a job assigned to them. This display is part of Job Entry.  */  
   "Make":boolean,
      /**  The planned production quantity, using Our U/M, for the Job. This is not maintainable in order entry. It gets updated via Job Entry.  */  
   "OurJobQty":number,
      /**  Actual quantity, using our U/M, shipped from the Job.  Updated via the shipping process.  */  
   "OurJobShippedQty":number,
      /**   Indicates if the release was voided. Voided releases items are not maintainable, can't "unvoid". This field is not directly maintainable. Instead the void function will be performed via a "Void Release" button. Which then presents a verification dialog box.

When an OrderRel record is 'voided' any outstanding inventory allocations are relieved, OrderRel.OpenRelease is set to "no" and records are created/updated in the OrdJobMsg file for all the related  open OrderRel records if the OrderDtl that was tied to a Job to indicate that the line item was voided.  */  
   "VoidRelease":boolean,
      /**  Quantity, using Our U/M, of the Sales Order release that is planned to be filled (pulled) from stock. This quantity is assigned = to the ReqQty when this item is not manufactured (Make = No).  For manufactured items this quantity can be updated by job entry when the user decides to pull some from stock and manufacture some. This value is used to  allocate to the designated warehouse.  */  
   "OurStockQty":number,
      /**  Indicates the inventory warehouse. This field is only relevant if this line references a valid Part record. Use the PrimWhse in the Part table as a default.  */  
   "WarehouseCode":string,
      /**  Actual quantity, using our U/M, shipped from Stock.  Updated via the shipping process.  */  
   "OurStockShippedQty":number,
      /**  The part number the release quantity is currently allocated to (if it exists in the part master file).  This is a duplicate of the OrderDtl part number and is not user maintainable.  */  
   "PartNum":string,
      /**  Part Revision number.  Mirror image of OrderDtl.RevisionNum.  Not directly maintainable.  */  
   "RevisionNum":string,
      /**  Indicates if this customer/shipto  is exempt from sales tax for this line item. If field is non-blank it is considered exempt. Defaults from the Customer/Shipto file.  This code is totally user definable and no validation is required. This field will be printed on the Tax report if this item is reportable .  */  
   "TaxExempt":string,
      /**  Contains the key value for the shipping contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table. Enter via a DDSL fill-in for contact name. Use OrderHed.ShpConNum when the OrderRel.ShipToNum = OrderHed.ShipToNum else use ShipTo.PrimScon as a default.  */  
   "ShpConNum":number,
      /**  Date customer needs the item to be delivered. Defaulted as OrderHed.NeedByDate.  */  
   "NeedByDate":string,
      /**  EDI Reference  */  
   "Reference":string,
      /**  Site Identifier.  */  
   "Plant":string,
      /**  Quantity ,using Selling U/M, that is requested to be shipped for this release. This MUST BE > ZERO.  */  
   "SellingReqQty":number,
      /**  The planned production quantity, using selling U/M, for the Job. This is not maintainable in order entry. It gets updated via Job Entry.  */  
   "SellingJobQty":number,
      /**  Actual quantity, using selling U/M, shipped from the Job.  Updated via the shipping process.  */  
   "SellingJobShippedQty":number,
      /**  Quantity, using selling U/M, of the Sales Order release that is planned to be filled (pulled) from stock. This quantity is assigned = to the ReqQty when this item is not manufactured (Make = No).  For manufactured items this quantity can be updated by job entry when the user decides to pull some from stock and manufacture some. This value is used to  allocate to the designated warehouse.  */  
   "SellingStockQty":number,
      /**  Actual quantity, using selling U/M, shipped from Stock.  Updated via the shipping process.  */  
   "SellingStockShippedQty":number,
      /**  Indicates if the release is selected to be submitted to the picking queue. When submitted for picking a record is written to the MtlQueue table and then SelectForPicking is reset to NO.  */  
   "SelectForPicking":boolean,
      /**  The shipping "Staging" warehouse for the release.  Defaults from the system default shipping area (Site.DefShippingWhse). This is maintainable in the Sales Allocation program.  */  
   "StagingWarehouseCode":string,
      /**  The shipping "Staging" bin for the release.  Defaults from the system default shipping area (Site.DefShippingBin). This is maintainable in the Sales Allocation program.  */  
   "StagingBinNum":string,
      /**   A non blank character indicates that the release could not be picked by the Auto Pick process.
The possible values are;
"L" - Order Line can't be shipped complete.
"O" - Order can't be shipped complete.
"I" - Insufficient quantity reserved
"Z" - Zero quantity reserved.  */  
   "PickError":string,
      /**  Quantity from last EDI update.  */  
   "CumeQty":number,
      /**  Date of last update  */  
   "CumeDate":string,
      /**  Indicates if this order release is linked to an inter-company PO release.  */  
   "Linked":boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   "ICPONum":number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   "ICPOLine":number,
      /**  Purchase order release number uniquely identifies a purchase release requirement record for a specific line item on an order. This is assigned by the system.  */  
   "ICPORelNum":number,
      /**  External Trading Company Identifier.  */  
   "ExtCompany":string,
      /**  A link to the demand schedule that created/updated this OrderRel.  */  
   "ScheduleNumber":string,
      /**  The Mark For to be used for this order release record. This MUST BE VALID IN THE SHIPTO file.  */  
   "MarkForNum":string,
      /**  Full name for the drop shipment.  */  
   "DropShipName":string,
      /**  RAN Number.  Used for informational purposes.  Supplied by EDI.  */  
   "RAN":string,
      /**  Demand Reference.  Used for informational purposes and to aide in matching demand schedules with existing OrderRel records.  Supplied by EDI.  */  
   "DemandReference":string,
      /**  Indicates if the demand schedule that created/updated this order release has been rejected.  */  
   "DemandSchedRejected":boolean,
      /**  The last date that the Material Queue Report was run for this release.  This field will be null until the Material Queue Report is run.  */  
   "DatePickTicketPrinted":string,
      /**  Is this a residential delivery  */  
   "ResDelivery":boolean,
      /**  Is a Saturday delivery acceptable  */  
   "SatDelivery":boolean,
      /**  Is a Saturday pickup available  */  
   "SatPickup":boolean,
      /**  Verbal Confirmation required  */  
   "VerbalConf":boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   "Hazmat":boolean,
      /**  Documents Only delivery  */  
   "DocOnly":boolean,
      /**  Reference Notes for the delivery  */  
   "RefNotes":string,
      /**  Apply Handling Charge to shipment  */  
   "ApplyChrg":boolean,
      /**  Handling Charge Amount  */  
   "ChrgAmount":number,
      /**  Prefer COD delivery  */  
   "COD":boolean,
      /**  Add Freight COD Amount owed  */  
   "CODFreight":boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   "CODCheck":boolean,
      /**  Amount due on Cashier's check or money order  */  
   "CODAmount":number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   "GroundType":string,
      /**  Indicates whether to send an email notification of delivery  */  
   "NotifyFlag":boolean,
      /**  The list of email address to notify about a delivery  */  
   "NotifyEMail":string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   "DeclaredIns":boolean,
      /**  Declared Insurance Amount  */  
   "DeclaredAmt":number,
      /**  Is a Service Saturday delivery acceptable  */  
   "ServSatDelivery":boolean,
      /**  Is a Service Saturday pickup available  */  
   "ServSatPickup":boolean,
      /**  Service delivery requires signature  */  
   "ServSignature":boolean,
      /**  Service Priority Alert flag  */  
   "ServAlert":boolean,
      /**  Service Auto POD flag  */  
   "ServPOD":boolean,
      /**  AOD  */  
   "ServAOD":boolean,
      /**  Service Home Delivery allowed  */  
   "ServHomeDel":boolean,
      /**  Service Home Delivery Type Code  */  
   "DeliveryType":string,
      /**  Service Home Delivery date  */  
   "ServDeliveryDate":string,
      /**  Home delivery phone number  */  
   "ServPhone":string,
      /**  Service Delivery Instructions  */  
   "ServInstruct":string,
      /**  Service Signature release is on file  */  
   "ServRelease":boolean,
      /**  Service Signature Release authorization number  */  
   "ServAuthNum":string,
      /**  Service Reference 1  */  
   "ServRef1":string,
      /**  Service Reference 2  */  
   "ServRef2":string,
      /**  Service Reference 3  */  
   "ServRef3":string,
      /**  Service Reference 4  */  
   "ServRef4":string,
      /**  Service Reference 5  */  
   "ServRef5":string,
      /**  Override Carrier Defaults.  If not checked then the Site values will be used  */  
   "OverrideCarrier":boolean,
      /**  Override Service Options.  If not checked then the Site values will be used  */  
   "OverrideService":boolean,
      /**  The dockingstation of the shipto address.  For future use.  */  
   "DockingStation":string,
      /**  The location within the customer shipto address.  For future use.  */  
   "Location":string,
      /**  The code of the transport routing/time. For future use.  */  
   "TransportID":string,
      /**  Ship the good by this time.  */  
   "ShipbyTime":number,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  If true, the OrderRelTax records tied to this release are calculated using Tax Connect logic. If  false, taxes are calculated using the standard calc methods.  */  
   "TaxConnectCalc":boolean,
      /**  If set to true, the tax calculation logic will retrieve the default SalesTax ids for the release before calculating taxes. It will also be reset to true if the TaxConnectCalc flag switches from true to false.  */  
   "GetDfltTaxIds":boolean,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   "TaxRegionCode":string,
      /**  Indicates that the One Time ShipTO information defined for this release should be used.  */  
   "UseOTS":boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   "OTSName":string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   "OTSAddress1":string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   "OTSAddress2":string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   "OTSAddress3":string,
      /**  City portion of the One Time Shipto  address.  */  
   "OTSCity":string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   "OTSState":string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   "OTSZIP":string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   "OTSResaleID":string,
      /**  One Time Ship To Contact Name  */  
   "OTSContact":string,
      /**  Fax number for the One Time ShipTo.  */  
   "OTSFaxNum":string,
      /**  Phone number for the One Time ShipTo  */  
   "OTSPhoneNum":string,
      /**  One Time Shipment country  */  
   "OTSCountryNum":number,
      /**   Free form. Can be used to further identify the shipping destination. Example, ship to a distribution site, this could contain a store description.
Will be printed on the packing slip  */  
   "SubShipTo":string,
      /**   Free form. Can be used to further identify the shipping destination. Example, ship to a distribution site, this could contain a routing description.
Will be printed on the packing slip  */  
   "ShipRouting":string,
      /**  This field identifies Buy To Order releases.  */  
   "BuyToOrder":boolean,
      /**  The value for this field will be defaulted from the Supplier defined in the Part Site sub tab at the Part form. Used only for Buy To Order releases.  */  
   "VendorNum":number,
      /**  Supplier Purchase Point. Used only for Buy To Order releases.  */  
   "PurPoint":string,
      /**  This field identifies Drop Ship releases. Used only for Buy To Order releases.  */  
   "DropShip":boolean,
      /**  Purchase order related to this Buy To Order release. Used only for Buy To Order releases.  */  
   "PONum":number,
      /**  The line number of the purchase order related to this Buy To Order release. Used only for Buy To Order releases.  */  
   "POLine":number,
      /**  The release number of the purchase order line related to this Buy To Order release. Used only for Buy To Order releases.  */  
   "PORelNum":number,
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   "OpenOrder":boolean,
      /**  Indicates if/how the OTS can be saved. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   "OTSSaveAs":string,
      /**  CustID to be used if the OTS is used to create a customer record.  */  
   "OTSSaveCustID":string,
      /**  True if Customer or ShipTo record was created using the OTS info.  */  
   "OTSCustSaved":boolean,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   "ShipToCustNum":number,
      /**   Unit of Measure that qualifies the "our" quantity fields.
If a valid part then it is the Base Stocking UOM (Part.IUM).
A mirror image of OrderDtl.IUM. Not directly maintainable  */  
   "IUM":string,
      /**   Selling Unit of measure. Qualifies the "Selling" quantity fields.
A mirror image of OrderDtl.SalesUM. Not directly maintainable.  */  
   "SalesUM":string,
      /**  Status of Order Release  */  
   "RelStatus":string,
      /**  Displays the cause why the item is not compliant.  */  
   "ComplianceMsg":string,
      /**  Previous Selling Quantity  */  
   "PrevSellQty":number,
      /**  Previous Part Number  */  
   "PrevPartNum":string,
      /**  Previous Customer Part Number  */  
   "PrevXPartNum":string,
      /**  Previous Need By Date  */  
   "PrevNeedByDate":string,
      /**  Previous Require Date  */  
   "PrevReqDate":string,
      /**  Previous Ship To Num  */  
   "PrevShipToNum":string,
      /**  Mark For Customer Number. This along with Mark For ShipToNum provides the foreign key field to a given ShipTo.  */  
   "MFCustNum":number,
      /**  Indicates that the One Time Mark For information defined for this record should be used.  */  
   "UseOTMF":boolean,
      /**  One Time Mark For Name of the ShipTo.  */  
   "OTMFName":string,
      /**  One Time Mark For first line of the ShipTo address.  */  
   "OTMFAddress1":string,
      /**  One Time Mark For second line of the ShipTo address.  */  
   "OTMFAddress2":string,
      /**  One Time Mark For third line of the ShipTo address.  */  
   "OTMFAddress3":string,
      /**  City portion of the One Time Mark For address.  */  
   "OTMFCity":string,
      /**  The state or province portion of the One Time Mark For address.  */  
   "OTMFState":string,
      /**  The zip or postal code portion of the One Time Mark For address.  */  
   "OTMFZIP":string,
      /**  One Time Mark For Contact Name  */  
   "OTMFContact":string,
      /**  Fax number for the One Time Mark For.  */  
   "OTMFFaxNum":string,
      /**  Phone number for the One Time Mark For  */  
   "OTMFPhoneNum":string,
      /**  Country number for the One Time Mark For  */  
   "OTMFCountryNum":number,
      /**  ECCPlant  */  
   "ECCPlant":string,
      /**  WIOrderLine  */  
   "WIOrderLine":string,
      /**  WIOrder  */  
   "WIOrder":string,
      /**  WebSKU  */  
   "WebSKU":string,
      /**  ShipOvers  */  
   "ShipOvers":boolean,
      /**  WIItemPrice  */  
   "WIItemPrice":number,
      /**  WIItemShipCost  */  
   "WIItemShipCost":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  EntityUseCode  */  
   "EntityUseCode":string,
      /**  PhaseID  */  
   "PhaseID":string,
      /**  OTSShipToNum  */  
   "OTSShipToNum":string,
      /**  WasRecInvoiced  */  
   "WasRecInvoiced":boolean,
      /**  The identifier of the planning contract.  */  
   "ContractID":string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the planning of the Contract.  */  
   "LinkToContract":boolean,
      /**  This flag indicates if the sales order release is ready to be fulfilled.  */  
   "ReadyToFulfill":boolean,
      /**  One Time ShipTo email address.  */  
   "OTSEMailAddress":string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   "AttributeSetID":number,
      /**  Number of pieces for this attribute set.  */  
   "NumberOfPieces":number,
      /**  Unit of measure for the NumberOfPieces.  */  
   "NumberOfPiecesUOM":string,
      /**  Planning number of pieces for this attribute set.  */  
   "PlanningNumberOfPieces":number,
      /**  Indicates if the release should be added or removed from the fulfillment queue.  */  
   "PartAllocQueueAction":string,
      /**  OTSTaxValidationStatus  */  
   "OTSTaxValidationStatus":number,
      /**  OTSTaxValidationDate  */  
   "OTSTaxValidationDate":string,
   "AvailableQuantity":number,
      /**  BuyOverride  */  
   "BuyOverride":boolean,
      /**  The message returned when checking a customer credit limit.  */  
   "CreditLimitMessage":string,
      /**  The source that put the customer on credit hold.  */  
   "CreditLimitSource":string,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
      /**  Is OTS allowed by the Sold to Customer?  */  
   "CustAllowOTS":boolean,
      /**  True when Customer allows shipping to a Third-Party  */  
   "CustomerAllowShipTo3":boolean,
   "CustomerCustID":string,
   "CustomerName":string,
   "DisablePlantWhse":boolean,
   "DocSelfAssessTax":number,
   "DocTotalTax":number,
   "DocWithholdTax":number,
      /**  DropShipOverride  */  
   "DropShipOverride":boolean,
      /**   Invoicing Method. If advanced billing is not licensed the only options are CS and MB. Code/Desc: CS = Customer Shipment, MB = Milestone Billing, PB = Progress Billing, TM = Time and aterials
'CP' = Cost Plus
The default is Customer Shipment.  */  
   "DspInvMeth":string,
      /**  Revenue Recognition Method has system list of the following options: LBR = Labor Booking Recognition, MAN = Manual Recognition, BDN = Actual Burden Recognition, PCC = POC-Cost-to-Cost, PCE = POC-Efforts, PCU = POC-Units-of-Delivery  */  
   "DspRevMethod":string,
   "EnableBuyToOrder":boolean,
   "EnableMake":boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
      /**  ExistPOSugg, external field to show/hide an epishape  */  
   "ExistPOSugg":boolean,
   "HdrOTS":boolean,
      /**  Unique identifier of related integration record.  */  
   "IntExternalKey":string,
      /**  Inventory UOM that the Order Release is allocated against. It is the similare column to the OrderDtl InvtyUOM and should always has the same value as in OrderDtl  */  
   "InvtyUOM":string,
      /**  Will be set to true if the current OrderDtl record is KitFlag = 'C' and the KitParent of this record is KitAllowUpdate = NO  */  
   "KitDisable":boolean,
      /**  LinkToPONum, external field to show/hide an epishape  */  
   "LinkToPONum":boolean,
   "MakeOverride":boolean,
      /**  The formatted mark for address  */  
   "MarkForAddrFormatted":string,
      /**  Contains the Mark For Address  */  
   "MarkForAddrList":string,
   "MFCustID":string,
      /**  The flag based on the user anwer if Ship To of the release is supposed be changed but Tax info is not changed because of the conflict in tax pricing  */  
   "NoRelTaxRgnChange":boolean,
      /**  Indicates if the item on the line is not compliant on its source, that can be Inventory, PO or Job.  */  
   "NotCompliant":boolean,
   "OnHandQuantity":number,
   "OTSSaved":boolean,
      /**  OTS Tax Liability Code (Order Release)  */  
   "OTSTaxRegionCode":string,
   "PartExists":boolean,
      /**  If the phase has been recognized or invoiced.  */  
   "PhaseWasRecInvoiced":boolean,
   "ProjectID":string,
   "ReleaseStatus":string,
      /**  the flag to indicate if all previously creaded manually added and manual tax relcords related to Order line release should be deleted if the user populates Tax Exempt field.  */  
   "RemoveManAdTax":boolean,
   "Rpt1SelfAssessTax":number,
   "Rpt1TotalTax":number,
   "Rpt1WithholdTax":number,
   "Rpt2SelfAssessTax":number,
   "Rpt2TotalTax":number,
   "Rpt2WithholdTax":number,
   "Rpt3SelfAssessTax":number,
   "Rpt3TotalTax":number,
   "Rpt3WithholdTax":number,
      /**  SalesOrderLinked  */  
   "SalesOrderLinked":boolean,
      /**  Self-Assessed Tax  */  
   "SelfAssessTax":number,
      /**  Selling Factor for display only  */  
   "SellingFactor":number,
      /**  Selling Factor Direction for display oly  */  
   "SellingFactorDirection":string,
      /**  The formatted ship to address  */  
   "ShipToAddressFormatted":string,
   "ShipToAddressList":string,
   "ShipToContactEMailAddress":string,
   "ShipToContactName":string,
   "ShipToSelected":boolean,
   "SNEnable":boolean,
   "ThisRelInvtyQty":number,
   "TotalJobStockShipped":number,
      /**  Invoice Tax  */  
   "TotalTax":number,
   "UpdateMarkForRecords":boolean,
   "VoidOrder":boolean,
      /**  Withholding Tax  */  
   "WithholdTax":number,
   "AllowTaxCodeUpd":boolean,
      /**  Allow enable/disable for the button Attibutes in Order Release  */  
   "EnableDynAttrButton":boolean,
      /**  Attribute class is MRP Planned but AttributeSetID has not been set on release.  */  
   "AttributeMismatch":boolean,
      /**  The total allocated quantity for this release.  */  
   "AllocatedQuantity":number,
      /**  Error Status Display  */  
   "ErrorStatusDisplay":string,
      /**  True if this release is in the fulfillment queue.  */  
   "InPartAllocQueue":boolean,
      /**  Show Fulfillment Queue Actions  */  
   "ShowAllocationQueueActions":boolean,
   "BitFlag":number,
   "DynAttrValueSetShortDescription":string,
   "DynAttrValueSetDescription":string,
   "MarkForNumInactive":boolean,
   "MFCustNumInactive":boolean,
   "OrderLineLineDesc":string,
   "OrderNumCurrencyCode":string,
   "OrderNumCardMemberName":string,
   "OTMFCountryDescription":string,
   "OTSCntryISOCode":string,
   "OTSCntryEUMember":boolean,
   "OTSCntryDescription":string,
   "PartNumTrackInventoryByRevision":boolean,
   "PartNumTrackInventoryAttributes":boolean,
   "PartNumAttrClassID":string,
   "PartNumPricePerCode":string,
   "PartNumTrackDimension":boolean,
   "PartNumIUM":string,
   "PartNumTrackSerialNum":boolean,
   "PartNumPartDescription":string,
   "PartNumTrackLots":boolean,
   "PartNumSellingFactor":number,
   "PartNumSalesUM":string,
   "PlantName":string,
   "PurPointAddress3":string,
   "PurPointZip":string,
   "PurPointName":string,
   "PurPointCountry":string,
   "PurPointAddress1":string,
   "PurPointState":string,
   "PurPointCity":string,
   "PurPointAddress2":string,
   "PurPointPrimPCon":number,
   "ShipToNumInactive":boolean,
   "ShipViaCodeWebDesc":string,
   "ShipViaCodeDescription":string,
   "TaxRegionCodeDescription":string,
   "TPShipToName":string,
   "TPShipToBTName":string,
   "TPShipToCustID":string,
   "VendorNumState":string,
   "VendorNumZIP":string,
   "VendorNumName":string,
   "VendorNumAddress2":string,
   "VendorNumCountry":string,
   "VendorNumCurrencyCode":string,
   "VendorNumCity":string,
   "VendorNumAddress3":string,
   "VendorNumVendorID":string,
   "VendorNumDefaultFOB":string,
   "VendorNumTermsCode":string,
   "VendorNumAddress1":string,
   "WarehouseCodeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
   "UD_SysRevID":string,
   "JobNum_c":string,
}

export interface Erp_Tablesets_OrderRelTaxRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   "TaxCode":string,
      /**  The reportable sales amount to the tax jurisdiction. Set the value as follows; first determine if the item needs to be reported to the tax jurisdiction.  This is done by using the  InvcDtl.TaxCode and InvcDtl/InvcMisc.TaxCat to find a record in the SalesTxC. If a record is not found or SalesTxC.Reportable = Yes then add in the line item extended amount ((Qty*unitprice)-discount) or if this is for a InvcMisc record InvcMisc.Amount.  */  
   "ReportableAmt":number,
      /**  The reportable sales amount to the tax jurisdiction. Set the value as follows; first determine if the item needs to be reported to the tax jurisdiction.  This is done by using the  InvcDtl.TaxCode and InvcDtl/InvcMisc.TaxCat to find a record in the SalesTxC. If a record is not found or SalesTxC.Reportable = Yes then add in the line item extended amount ((Qty*unitprice)-discount) or if this is for a InvcMisc record InvcMisc.Amount.  */  
   "DocReportableAmt":number,
      /**  Taxable Amount for this line item/Misc charge. This value is set as an accumulation of non-exempt sales amount from the line and its associated miscellaneous records.  It could be tax exempt for two reasons, either the customer is exempt (invcdtl.TaxExempt > blank) or the item is exempt. In either case the detail amounts would not be added into the taxable amount.  To see if the item is exempt use the InvcDt/InvcMisc.TaxCat and the InvcTax.TaxCode to find a record in the SalesTxC. If a record is  found then it is exempt.  */  
   "TaxableAmt":number,
      /**  Taxable Amount for this line item/Misc charge. This value is set as an accumulation of non-exempt sales amount from the line and its associated miscellaneous records.  It could be tax exempt for two reasons, either the customer is exempt (invcdtl.TaxExempt > blank) or the item is exempt. In either case the detail amounts would not be added into the taxable amount.  To see if the item is exempt use the InvcDt/InvcMisc.TaxCat and the InvcTax.TaxCode to find a record in the SalesTxC. If a record is  found then it is exempt.  */  
   "DocTaxableAmt":number,
      /**  The tax percentage rate that is used for this invoice. This is defaulted from the SalesTax.Percent.  */  
   "Percent":number,
      /**  Sales Tax amount for the corresponding taxable sales amount. This is user maintainable and also defaulted when/if the user changes the tax code, tax percent or the taxable amount or the tax classification changes to non-taxable when the InvcDtl.TaxCat is changed.  They can override the calculated figure to provide for any tax calculations other than the simple percent of taxable. No tax is calculated when the InvcDtl.TaxExempt <> blank or a record is found in the SalesTxC file indicating that this item is not taxable. Otherwise it is calculated as TaxableAmt * Percent.  */  
   "TaxAmt":number,
      /**  Sales Tax amount for the corresponding taxable sales amount. This is user maintainable and also defaulted when/if the user changes the tax code, tax percent or the taxable amount or the tax classification changes to non-taxable when the InvcDtl.TaxCat is changed.  They can override the calculated figure to provide for any tax calculations other than the simple percent of taxable. No tax is calculated when the InvcDtl.TaxExempt <> blank or a record is found in the SalesTxC file indicating that this item is not taxable. Otherwise it is calculated as TaxableAmt * Percent.  */  
   "DocTaxAmt":number,
      /**  Indicates if the tax calculations are to be performed manually.  When this field is set the Reportable, Taxable, and TaxAmount fields are enabled.  When it is NOT set these fields are DISABLED and the system will perform all of the Reportable, Taxable, and TaxAmount calculations.  Defaults from the SalesTax.Manual field.  */  
   "Manual":boolean,
      /**  Userid of user who made the last change to this record.  */  
   "ChangedBy":string,
      /**  The date that the record was last changed  */  
   "ChangeDate":string,
      /**  The time that the record was last change (seconds since midnight)  */  
   "ChangeTime":number,
      /**  Reverse Charge.  */  
   "ReverseCharge":boolean,
      /**  Sales Order Number  */  
   "OrderNum":number,
      /**  Sales order Line number that this order release is linked to.  */  
   "OrderLine":number,
      /**  The release number assigned by the system.  The user never sees this field. It  is used as a foreign key in other files (such as ShipDtl) to tie those records back to the release record.  */  
   "OrderRelNum":number,
      /**  A flat discount amount for the tax.  */  
   "Discount":number,
      /**  A flat discount amount for the tax converted to the customers currency.  */  
   "DocDiscount":number,
      /**  Reporting currency value of this field  */  
   "Rpt1Discount":number,
      /**  Reporting currency value of this field  */  
   "Rpt2Discount":number,
      /**  Reporting currency value of this field  */  
   "Rpt3Discount":number,
      /**  Reporting currency value of this field  */  
   "Rpt1ReportableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2ReportableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3ReportableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1TaxableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2TaxableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3TaxableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1TaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2TaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3TaxAmt":number,
      /**  Rate Code  */  
   "RateCode":string,
      /**  Collection Type  */  
   "CollectionType":number,
      /**  Timing of when to report taxes  */  
   "Timing":number,
      /**  Exemption Type  */  
   "ExemptType":number,
      /**  Exemption Percent  */  
   "ExemptPercent":number,
      /**  Resolution Number  */  
   "ResolutionNum":string,
      /**  Resolution Date  */  
   "ResolutionDate":string,
      /**  Tax Rate Date  */  
   "TaxRateDate":string,
      /**  Balance of the Taxable amount that has been deferred until payment  */  
   "DefTaxableAmt":number,
      /**  Balance of the Taxable amount that has been deferred until payment  */  
   "DocDefTaxableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1DefTaxableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2DefTaxableAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3DefTaxableAmt":number,
      /**  Balance of the Tax amount that has been deferred until payment  */  
   "DefTaxAmt":number,
      /**  Balance of the Tax amount that has been deferred until payment  */  
   "DocDefTaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1DefTaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2DefTaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3DefTaxAmt":number,
      /**  This record was manually added (not in Liability) but will use the standard calculations  */  
   "ManAdd":boolean,
      /**  Deducatable Tax Amount  */  
   "DedTaxAmt":number,
      /**  Deducatable Tax Amount  */  
   "DocDedTaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt1DedTaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt2DedTaxAmt":number,
      /**  Reporting currency value of this field  */  
   "Rpt3DedTaxAmt":number,
      /**   Used to allow a second tax record using the same tax code on an invoice.  When the sales tax field EcAquisition is checked then 2 invoice tax records are created.
NOTE:  This field is now used in VAT Reverse Charge logic.  If an invoice line is marked for Reverse Charge, a second line is created just like in the ECAcquisition logic. To distinguish the two scenarios, the ReverseCharge flag will be set to true if the second line is for Reverse Charge.  */  
   "ECAcquisitionSeq":number,
      /**  Fixed Tax Amount  */  
   "FixedAmount":number,
      /**  Document Fixed Tax Amount  */  
   "DocFixedAmount":number,
      /**  Reporting currency value of this field  */  
   "Rpt1FixedAmount":number,
      /**  Reporting currency value of this field  */  
   "Rpt2FixedAmount":number,
      /**  Reporting currency value of this field  */  
   "Rpt3FixedAmount":number,
      /**  Unique Identifier for Legal Text  */  
   "TextCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "SalesTaxDescDescription":string,
   "DocDisplaySymbol":string,
   "CurrencySwitch":boolean,
      /**  Currency Code of the related record  */  
   "CurrencyCode":string,
   "CollectionTypeDescription":string,
   "DisplaySymbol":string,
      /**  If Tax Liability is In Price then the user should not be able to change Manual flag on Tax Record  */  
   "NoChangeManual":boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   "EntryProcess":string,
   "BitFlag":number,
   "RateCodeDescDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderRepCommRow{
      /**  Company Identifier  */  
   "Company":string,
      /**  Order Number this sales rep commission is tied to  */  
   "OrderNum":number,
      /**  Sales rep code for this commission data  */  
   "SalesRepCode":string,
      /**  Sales Rep name  */  
   "Name":string,
      /**  Number of commission lines this sales rep has for this order  */  
   "CommLines":number,
      /**  Commission sale amount  */  
   "CommSaleAmt":number,
      /**  Commission amount  */  
   "CommAmt":number,
      /**  Seq number to keep key unique if sales rep is repeated  */  
   "Seq":string,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_OrderSchedRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Contains the Order Number that ties this detail record back to an OrderHed record.  */  
   "OrderNum":number,
      /**  Specifies the number of payment of the Payment Schedule. This is an auto-generated sequence number.  */  
   "PaySeq":number,
      /**  Specifies the number of days for the payment to be paid.  */  
   "PayDays":number,
      /**  Specifies the percent of the payment to be paid. This is used to calculate amount to be paid per payment.  */  
   "PayPercent":number,
      /**  Amount in Base Currency to be paid for the payment. This amount calculates by default based on Order total and Payment's Percentage.  */  
   "PayAmount":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Amount in Document Currency to be paid for the payment. This amount calculates by default based on Order total and Payment's Percentage.  */  
   "DocPayAmount":number,
      /**  Reporting currency value of this field  */  
   "Rpt1PayAmount":number,
      /**  Reporting currency value of this field  */  
   "Rpt2PayAmount":number,
      /**  Reporting currency value of this field  */  
   "Rpt3PayAmount":number,
   "CurrencySwitch":boolean,
      /**  A unique code that identifies the currency.  */  
   "CurrencyCode":string,
      /**  Indicates if this is the last OrderSched row for the order  */  
   "IsLastRow":boolean,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartSubsRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Part number that this substitute Part is for.  */  
   "PartNum":string,
      /**  Substitute Part  */  
   "SubPart":string,
      /**  Indicates the record type. "S" = Substitute, "C" = Compliment  */  
   "RecType":string,
      /**  Pertains only to Substitute Parts (RecType = "S"). Values are "C" - Comparable, "D" - Downgrade, "U" - Upgrade  */  
   "SubType":string,
      /**   The quantity of the alternate part per 1 of the parent part in the parents base inventory uom. Cannot be zero.
To convert an existing OrderDtl.SellingQty to a PartSubs. It is converted to the Parents Part Base Inventory UOM  then multiply PartSubs.QtyPer, then converted to  PartSub.SalesUM.  */  
   "QtyPer":number,
      /**  Selling Unit of measure used when this part is used as a substitute/compliment with the parent part (partsubs.partnum).  Defaults as Part.SUM of the PartSub.SubPart.  */  
   "SalesUM":string,
      /**  Optional Comment  */  
   "Comment":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "DefaultSub":boolean,
      /**  Price for the Suggested Quantity  */  
   "Price":number,
      /**  Suggested Quantity  */  
   "SuggestedQty":number,
      /**  Selected Row  */  
   "Selected":boolean,
      /**  Suggested Quantity for Order Qty in Quote Detail  */  
   "SugOrderQty":number,
   "BitFlag":number,
   "PartNumPricePerCode":string,
   "PartNumTrackLots":boolean,
   "PartNumPartDescription":string,
   "PartNumSalesUM":string,
   "PartNumIUM":string,
   "PartNumSellingFactor":number,
   "PartNumTrackSerialNum":boolean,
   "PartNumTrackDimension":boolean,
   "SubPartSellingFactor":number,
   "SubPartTrackSerialNum":boolean,
   "SubPartTrackDimension":boolean,
   "SubPartPartDescription":string,
   "SubPartIUM":string,
   "SubPartSalesUM":string,
   "SubPartTrackLots":boolean,
   "SubPartPricePerCode":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_SNFormatRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Site Identifier. This field cannot be blank.  */  
   "Plant":string,
      /**  The PartNum field identifies the Part and is used in the primary key.  */  
   "PartNum":string,
      /**  Number of digits in the serial number  */  
   "NumberOfDigits":number,
      /**  If the SNBaseDataType is Mask this is the Serial Mask ID assigned for format validation/generation.  */  
   "SNMask":string,
      /**   Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer, Mask
Code/desc required:
CHARACTER`Alphanumeric
INTEGER`NumericOnly
MASK`Serial Mask
This field should be flagged as Include = true in Object Designer.  */  
   "SNBaseDataType":string,
   "SNFormat1":string,
      /**  Whether or not to have leading zeroes  */  
   "LeadingZeroes":boolean,
      /**   Current setting for the prefix that will be attached to all new Serial Numbers as they are generated for Character and Integer format types.
This field should be flagged as Include = true in Object Designer.  */  
   "SNPrefix":string,
      /**  A standard suffix that will be attached to all serial numbers generated for the PartSite currently used only by SNBaseStructure Mask types  */  
   "SNMaskSuffix":string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types  */  
   "SNMaskPrefix":string,
      /**  This is the last used serial sequence. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It can be altered by the user and several PartSites can have the same counter values defined, but  */  
   "SNLastUsedSeq":string,
   "HasSerialNumbers":boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PartPricePerCode":string,
   "PartTrackLots":boolean,
   "PartTrackSerialNum":boolean,
   "PartTrackDimension":boolean,
   "PartSalesUM":string,
   "PartIUM":string,
   "PartSellingFactor":number,
   "PartPartDescription":string,
   "SerialMaskMaskType":number,
   "SerialMaskMask":string,
   "SerialMaskExample":string,
   "SerialMaskDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_SelectedSerialNumbersRow{
      /**  Company  */  
   "Company":string,
      /**  SerialNumber  */  
   "SerialNumber":string,
      /**  Scrapped flag  */  
   "Scrapped":boolean,
      /**  Scrapped reason code  */  
   "ScrappedReasonCode":string,
      /**  Voided flag  */  
   "Voided":boolean,
      /**  Reference field  */  
   "Reference":string,
      /**  Reason code type = s  */  
   "ReasonCodeType":string,
      /**  Reason code description  */  
   "ReasonCodeDesc":string,
      /**  PartNumber  */  
   "PartNum":string,
      /**  Serial number prefix  */  
   "SNPrefix":string,
      /**  Base number used to create the serial number  */  
   "SNBaseNumber":string,
      /**  RowID of the source record for this serial number  */  
   "SourceRowID":string,
      /**  TransType of the record that created this serial number  */  
   "TransType":string,
      /**  True if this serial numbered part passed inspection  */  
   "PassedInspection":boolean,
      /**  Used to flag previously selected serial numbers as deselected  */  
   "Deselected":boolean,
   "KitWhseList":string,
      /**  This will be the raw serial number as it was scanned or entered into the system. This would only differ from the SerialNumber field if a validate type mask was being used where characters were stripped (using ~ in the mask).  */  
   "RawSerialNum":string,
      /**  Action type field used for Kanban receipts to indicate if the new serial number status is Inventory, Scrapped or NonConf.  This requires Code/desc:  1 ` inventory 2 ` Scrapped 3 ` Nonconformance  */  
   "KBLbrAction":number,
      /**  Description field for KBLbrAction ? holds the translated description for the KBLbrAction code for UI display and combo box.  */  
   "KBLbrActionDesc":string,
      /**  If true, then users can not deselect this serial number.  This is used by applications that allow maintenance to the Selected Serial Numbers after update.  */  
   "PreventDeselect":boolean,
      /**  Used only by SN Assignment  */  
   "XRefPartNum":string,
      /**  Used only by SN Assignment: C = Customer Part / I = Internal Part XRef  */  
   "XRefPartType":string,
   "PreDeselected":boolean,
      /**  temporary field used to link the packout lines to ship detail lines  */  
   "poLinkValues":string,
      /**  The mask the was used to generate the serial number  */  
   "SNMask":string,
      /**  Flag to indicate that the SelectedSerialNumbers entry has not yet been saved to the DB for the related transaction. Used to keep track of which deselected serial numbers need to be passed to the transaction update logic.  */  
   "NotSavedToDB":boolean,
   "RowSelected":boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   "AttributeSetID":number,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_TaxConnectStatusRow{
      /**  Company  */  
   "Company":string,
      /**  If true, service is down. If false, service is up.  */  
   "ETCOffline":boolean,
      /**  Error message returned from the call to the tax service.  */  
   "ErrorMessage":string,
      /**  This is the success/failure status of the call to tax connect. If false, the call failed, if true it was successful  */  
   "TCStatus":boolean,
   "SysRowID":string,
      /**  RowMod  */  
   "RowMod":string,
}




//////////////////////////////////////////////////////////////////////////
// Custom Schemas:
//////////////////////////////////////////////////////////////////////////
   /** Required : 
      @param ds
   */  
export interface AfterChangedOrderDtlProjectID_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface AfterChangedOrderDtlProjectID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
   */  
export interface ApplyOrderBasedDiscounts_input{
      /**  The order to apply the discounts to  */  
   iOrderNum:number,
}

export interface ApplyOrderBasedDiscounts_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param orderNum
   */  
export interface ApplyOrderHedDiscountToLines_input{
      /**  The Order Number  */  
   orderNum:number,
}

export interface ApplyOrderHedDiscountToLines_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param ds
   */  
export interface CCClear_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CCClear_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param inTranDate
      @param inTranTime
      @param inTranNum
   */  
export interface CCLoadCardNumbers_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  TranDate from the CreditTran table  */  
   inTranDate:string,
      /**  TranTime from the CreditTran table  */  
   inTranTime:number,
      /**  TranNum from the CreditTran table  */  
   inTranNum:number,
}

export interface CCLoadCardNumbers_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param inTranDate
      @param inTranTime
      @param inTranNum
   */  
export interface CCLoadTranData_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  TranDate from the CreditTran table  */  
   inTranDate:string,
      /**  TranTime from the CreditTran table  */  
   inTranTime:number,
      /**  TranNum from the CreditTran table  */  
   inTranNum:number,
}

export interface CCLoadTranData_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param inTranType
      @param ds
   */  
export interface CCProcessCard_input{
      /**  The transaction type to apply to the credit card.
            Valid transaction types : D (Deposit), S (Sale), A (Authorize),
            C (Credit - 803), V (Void).  */  
   inTranType:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CCProcessCard_output{
parameters : {
      /**  output parameters  */  
   opMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param NewBillToCustID
      @param lchkCustCredHold
      @param iOrderNum
      @param ds
   */  
export interface ChangeBTCustIDMaster_input{
      /**  Proposed bill to custid  */  
   NewBillToCustID:string,
      /**  flag to determine if we run CheckCustomerCreditHold  */  
   lchkCustCredHold:boolean,
      /**  The Order Number - optional  */  
   iOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeBTCustIDMaster_output{
parameters : {
      /**  output parameters  */  
   cCreditLimitMessage:string,
   cAgingMessage:string,
   lCustomerAllowed:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeCCAmounts_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCCAmounts_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param inCardNumber
      @param ds
   */  
export interface ChangeCardNumber_input{
      /**  Proposed Card Number  */  
   inCardNumber:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCardNumber_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeCommissionable_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCommissionable_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param newCommodityCode
      @param ds
   */  
export interface ChangeCommodityCode_input{
      /**  New Commodity Code  */  
   newCommodityCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCommodityCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iContractNum
      @param ds
   */  
export interface ChangeContractNumMaster_input{
   iOrderNum:number,
   iOrderLine:number,
   iContractNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeContractNumMaster_output{
parameters : {
      /**  output parameters  */  
   outMsg:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeContractNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeContractNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeCounterSale_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCounterSale_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipExpMonth
      @param ipExpYear
      @param ds
   */  
export interface ChangeCreditExp_input{
      /**  Expiration Month  */  
   ipExpMonth:number,
      /**  Expiration Year  */  
   ipExpYear:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCreditExp_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeCurrencyCode_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCurrencyCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeCustomer_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeDiscBreakListCode_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeDiscBreakListCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeDiscountAmount_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeDiscountAmount_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeDiscountPercent_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeDiscountPercent_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param proposedERSOrder
      @param ds
   */  
export interface ChangeERSOrder_input{
      /**  The proposed ERS Order  */  
   proposedERSOrder:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeERSOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeGroup_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeGroup_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeHedOTSCountryNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeHedOTSCountryNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeHedUseOTS_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeHedUseOTS_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeIncotermCode_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeIncotermCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeKitPricing_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeKitPricing_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeKitQtyPer_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeKitQtyPer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipMake
      @param ds
   */  
export interface ChangeMake_input{
      /**  The new Make value.  */  
   ipMake:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeMake_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipOrderNum
      @param ipLineNum
      @param ipRelNum
      @param ipTaxCode
      @param ipRateCode
      @param ds
   */  
export interface ChangeManualTaxCalc_input{
      /**  Order Number.  */  
   ipOrderNum:number,
      /**  Order line number.  */  
   ipLineNum:number,
      /**  Order Rel number.  */  
   ipRelNum:number,
      /**  Release tax code.  */  
   ipTaxCode:string,
      /**  Release rate code.  */  
   ipRateCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeManualTaxCalc_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param tableName
   */  
export interface ChangeMiscAmount_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  name of table being passed in  */  
   tableName:string,
}

export interface ChangeMiscAmount_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param tableName
   */  
export interface ChangeMiscCode_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  name of table being passed in  */  
   tableName:string,
}

export interface ChangeMiscCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param tableName
   */  
export interface ChangeMiscPercent_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  name of table being passed in  */  
   tableName:string,
}

export interface ChangeMiscPercent_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param tableName
   */  
export interface ChangeMiscType_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  name of table being passed in  */  
   tableName:string,
}

export interface ChangeMiscType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param cTableName
   */  
export interface ChangeNeedByDate_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  The table that is changed: OrderHed,OrderDtl, or OrderRel  */  
   cTableName:string,
}

export interface ChangeNeedByDate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeNewNeedByDate_input{
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}

export interface ChangeNewNeedByDate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeNewSellingQuantity_input{
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}

export interface ChangeNewSellingQuantity_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeODtlWarehouse_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeODtlWarehouse_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeORelWarehouse_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeORelWarehouse_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipContractID
      @param ds
   */  
export interface ChangeOrderDtlPWContract_input{
   ipContractID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderDtlPWContract_output{
parameters : {
      /**  output parameters  */  
   ipContractID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOrderDtlProdCode_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderDtlProdCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param projectID
      @param ds
   */  
export interface ChangeOrderDtlProjectID_input{
      /**  The Project ID value  */  
   projectID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderDtlProjectID_output{
parameters : {
      /**  output parameters  */  
   projectMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param currencyCode
      @param ds
   */  
export interface ChangeOrderHedCurrencyCode_input{
      /**  The proposed currency code value  */  
   currencyCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderHedCurrencyCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param orderNum
      @param proposedCustomerCustID
      @param ds
   */  
export interface ChangeOrderHedCustomerCustID_input{
      /**  The order number  */  
   orderNum:number,
   proposedCustomerCustID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderHedCustomerCustID_output{
parameters : {
      /**  output parameters  */  
   creditLimitMessage:string,
   agingMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param intrntlShip
      @param ds
   */  
export interface ChangeOrderHedIntrntlShip_input{
      /**  The proposed international shipment value  */  
   intrntlShip:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderHedIntrntlShip_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param otsSaveAs
      @param ds
   */  
export interface ChangeOrderHedOTSSaveAs_input{
      /**  The proposed OTS Save As value  */  
   otsSaveAs:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderHedOTSSaveAs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param salesRepCode
      @param columnName
      @param ds
   */  
export interface ChangeOrderHedSalesRepCode_input{
      /**  The proposed SalesRep code  */  
   salesRepCode:string,
      /**  The column name of the sales rep column that is changing  */  
   columnName:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderHedSalesRepCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param shipToNum
      @param ds
   */  
export interface ChangeOrderHedShipToNum_input{
      /**  The proposed Ship To Num  */  
   shipToNum:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderHedShipToNum_output{
parameters : {
      /**  output parameters  */  
   keepShipToWithoutTaxRegionMessage:string,
   taxRecalcMessage:string,
   defaultTaxLiabilityMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipBuyToOrder
      @param ds
   */  
export interface ChangeOrderRelBuyToOrder_input{
      /**  The new Buy To Order value.  */  
   ipBuyToOrder:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelBuyToOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipDropShip
      @param ds
   */  
export interface ChangeOrderRelDropShip_input{
      /**  The new DropShip value.  */  
   ipDropShip:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelDropShip_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param firmRelease
      @param ds
   */  
export interface ChangeOrderRelFirmRelease_input{
      /**  The new FirmRelease value.  */  
   firmRelease:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelFirmRelease_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipMFCustID
      @param ds
   */  
export interface ChangeOrderRelMFCustID_input{
      /**  The proposed Mark For Customer ID  */  
   ipMFCustID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelMFCustID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ProposedMarkForNum
      @param ds
   */  
export interface ChangeOrderRelMarkForNum_input{
      /**  The Proposed ShipToNum  */  
   ProposedMarkForNum:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelMarkForNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOrderRelOTSCountryNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelOTSCountryNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param otsSaveAs
      @param ds
   */  
export interface ChangeOrderRelOTSSaveAs_input{
      /**  The proposed OTS Save As value  */  
   otsSaveAs:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelOTSSaveAs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipContractID
      @param ds
   */  
export interface ChangeOrderRelPWContract_input{
      /**  The proposed ContractID  */  
   ipContractID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelPWContract_output{
parameters : {
      /**  output parameters  */  
   ipContractID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOrderRelShipToContact_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelShipToContact_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iShipToCustID
      @param ds
   */  
export interface ChangeOrderRelShipToCustID_input{
      /**  Proposed Third-Party Ship To  */  
   iShipToCustID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelShipToCustID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOrderRelShipTo_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelShipTo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param RateCode
      @param NewFixedAmount
      @param ds
   */  
export interface ChangeOrderRelTaxBaseFixedAmount_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Release rate code.  */  
   RateCode:string,
      /**  Proposed Fixed AMount.  */  
   NewFixedAmount:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelTaxBaseFixedAmount_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param NewTaxAmt
      @param ds
   */  
export interface ChangeOrderRelTaxBaseTaxAmt_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Proposed Taxable amount.  */  
   NewTaxAmt:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelTaxBaseTaxAmt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param RateCode
      @param NewTaxableAmt
      @param ds
   */  
export interface ChangeOrderRelTaxBaseTaxableAmt_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Release rate code.  */  
   RateCode:string,
      /**  Proposed Taxable amount.  */  
   NewTaxableAmt:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelTaxBaseTaxableAmt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param RateCode
      @param NewFixedAmount
      @param ds
   */  
export interface ChangeOrderRelTaxDocFixedAmount_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Release rate code.  */  
   RateCode:string,
      /**  Proposed Fixed AMount.  */  
   NewFixedAmount:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelTaxDocFixedAmount_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param NewTaxAmt
      @param ds
   */  
export interface ChangeOrderRelTaxDocTaxAmt_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Proposed Taxable amount.  */  
   NewTaxAmt:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelTaxDocTaxAmt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param RateCode
      @param NewTaxableAmt
      @param ds
   */  
export interface ChangeOrderRelTaxDocTaxableAmt_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Release rate code.  */  
   RateCode:string,
      /**  Proposed Taxable amount.  */  
   NewTaxableAmt:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelTaxDocTaxableAmt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOrderRelUseOTMF_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelUseOTMF_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipVendorID
      @param ds
   */  
export interface ChangeOrderRelVendorID_input{
      /**  The new Vendor ID value.  */  
   ipVendorID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOrderRelVendorID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOverrideDiscPriceList_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOverrideDiscPriceList_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeOverridePriceList_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeOverridePriceList_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param partNum
      @param lSubstitutePartExist
      @param lIsPhantom
      @param uomCode
      @param SysRowID
      @param rowType
      @param salesKitView
      @param removeKitComponents
      @param suppressUserPrompts
      @param getPartXRefInfo
      @param checkPartRevisionChange
      @param checkChangeKitParent
      @param ds
   */  
export interface ChangePartNumMaster_input{
      /**  proposed PartNum  */  
   partNum:string,
      /**  bool which identifies whether a substitute part exists.  set in 'checkPartRevisionChange' logic  */  
   lSubstitutePartExist:boolean,
      /**  bool which identifies whether this is a phantom part.  set in 'getPartXRefInfo' logic  */  
   lIsPhantom:boolean,
      /**  associated uomCode for this part.  maybe overwritten in chkPartXRefInfo  */  
   uomCode:string,
      /**  sysRowID for current row  */  
   SysRowID:string,
      /**  current rowType  */  
   rowType:string,
      /**  flag to identify whether this OrderDtl record is from salesKitView (or OrderDtlView)  */  
   salesKitView:boolean,
      /**  flag (set by user unless suppressUserPrompts is true) to OK removing kit components if kit parent changes  */  
   removeKitComponents:boolean,
      /**  flag to determine is user wants to be able to respond to messages and return to UI  */  
   suppressUserPrompts:boolean,
      /**  flag to determine whether a particular part of validation logic is run  */  
   getPartXRefInfo:boolean,
      /**  flag to determine whether a particular part of validation logic is run  */  
   checkPartRevisionChange:boolean,
      /**  flag to determine whether a particular part of validation logic is run  */  
   checkChangeKitParent:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangePartNumMaster_output{
parameters : {
      /**  output parameters  */  
   partNum:string,
   lSubstitutePartExist:boolean,
   lIsPhantom:boolean,
   uomCode:string,
   cDeleteComponentsMessage:string,
   questionString:string,
   cWarningMessage:string,
   multipleMatch:boolean,
   promptToExplodeBOM:boolean,
   cConfigPartMessage:string,
   cSubPartMessage:string,
   explodeBOMerrMessage:string,
   cMsgType:string,
   multiSubsAvail:boolean,
   runOutQtyAvail:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param lSubstitutePartsExist
      @param uomCode
   */  
export interface ChangePartNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  Flag to indicate if a substitute part exists  */  
   lSubstitutePartsExist:boolean,
      /**  UOM Code (only used for Product Codes)  */  
   uomCode:string,
}

export interface ChangePartNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ProposedPlant
      @param ds
   */  
export interface ChangePlant_input{
      /**  The proposed plant  */  
   ProposedPlant:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangePlant_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangePriceList_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangePriceList_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangePricePerCode_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangePricePerCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeProjectID_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeProjectID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangePromotionalPrice_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangePromotionalPrice_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeQuickEntryOption_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeQuickEntryOption_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeQuoteLine_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeQuoteLine_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeQuoteQtyNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeQuoteQtyNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeRMANum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeRMANum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeRelUseOTS_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeRelUseOTS_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iContractNum
      @param iRenewalNbr
      @param ds
   */  
export interface ChangeRenewalNbrMaster_input{
   iOrderNum:number,
   iOrderLine:number,
   iContractNum:number,
   iRenewalNbr:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeRenewalNbrMaster_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeRenewalNbr_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeRenewalNbr_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param checkPartRevChange
      @param checkComponents
      @param removeKitComponents
      @param suppressUserPrompts
      @param proposedRev
      @param ds
   */  
export interface ChangeRevNumMaster_input{
      /**  bool to determine whether we run the CheckPartRevChange logic  */  
   checkPartRevChange:boolean,
      /**  bool to determine whether we attempt to delete existing child parts  */  
   checkComponents:boolean,
      /**  bool to determine whether we delete existing child parts  */  
   removeKitComponents:boolean,
      /**  flag to determine is user wants to be able to respond to messages and return to UI  */  
   suppressUserPrompts:boolean,
      /**  proposed RevisionNum  */  
   proposedRev:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeRevNumMaster_output{
parameters : {
      /**  output parameters  */  
   cConfigPartMessage:string,
   cDeleteComponentsMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeRevisionNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeRevisionNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param cSalesRepCode
   */  
export interface ChangeSalesRep_input{
      /**  The SalesRep code  */  
   cSalesRepCode:string,
}

export interface ChangeSalesRep_output{
parameters : {
      /**  output parameters  */  
   dRepRate:number,
   iRepSplit:number,
   cRepName:string,
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeSalesUOM_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeSalesUOM_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param ipSellingQuantity
      @param chkSellQty
      @param negInvTest
      @param chgSellQty
      @param chgDiscPer
      @param suppressUserPrompts
      @param lKeepUnitPrice
      @param pcPartNum
      @param pcWhseCode
      @param pcBinNum
      @param pcLotNum
      @param pcAttributeSetID
      @param pcDimCode
      @param pdDimConvFactor
   */  
export interface ChangeSellingQtyMaster_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  New value for SellingQuantity  */  
   ipSellingQuantity:number,
      /**  flag to determine if we run checkSellingQuantityChange logic  */  
   chkSellQty:boolean,
      /**  flag to determine if we run negativeInventoryTest logic  */  
   negInvTest:boolean,
      /**  flag to determine if we run changeSellingQuantity logic  */  
   chgSellQty:boolean,
      /**  flag to determine if we run changeDiscountPercent logic  */  
   chgDiscPer:boolean,
      /**  flag to determine if we suppress any user input  */  
   suppressUserPrompts:boolean,
      /**  Keep the current unit price even if it will be recalcuated based on the new quantity  */  
   lKeepUnitPrice:boolean,
      /**  partNum for negativeInventoryTest  */  
   pcPartNum:string,
      /**  whseCode for negativeInventoryTest  */  
   pcWhseCode:string,
      /**  binNum for negativeInventoryTest  */  
   pcBinNum:string,
      /**  lotNum for negativeInventoryTest  */  
   pcLotNum:string,
      /**  attributeSetID for negativeInventoryTest  */  
   pcAttributeSetID:number,
      /**  dimcode for negativeInventoryTest  */  
   pcDimCode:string,
      /**  dimConvFactor for negativeInventoryTest  */  
   pdDimConvFactor:number,
}

export interface ChangeSellingQtyMaster_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   pcMessage:string,
   pcNeqQtyAction:string,
   opWarningMsg:string,
   cSellingQuantityChangedMsgText:string,
}
}

   /** Required : 
      @param ds
      @param lKeepUnitPrice
      @param ipSellingQuantity
   */  
export interface ChangeSellingQuantity_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  Keep the current unit price even if it will be recalcuated based on the new quantity  */  
   lKeepUnitPrice:boolean,
      /**  New value for SellingReqQty  */  
   ipSellingQuantity:number,
}

export interface ChangeSellingQuantity_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   opWarningMsg:string,
}
}

   /** Required : 
      @param ds
      @param ipSellingReqQty
   */  
export interface ChangeSellingReqQty_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  New value for SellingReqQty  */  
   ipSellingReqQty:number,
}

export interface ChangeSellingReqQty_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   opWarningMsg:string,
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeShipToContact_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeShipToContact_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iShipToCustID
      @param ds
   */  
export interface ChangeShipToCustID_input{
      /**  Proposed Third-Party Ship To  */  
   iShipToCustID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeShipToCustID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeShipToID_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeShipToID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeSoldToContact_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeSoldToContact_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeSoldToID_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeSoldToID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipOrderNum
      @param ipNewCode
   */  
export interface ChangeTaxRegionCode_input{
      /**  OrderNum  */  
   ipOrderNum:number,
      /**  New Tax Region Code  */  
   ipNewCode:string,
}

export interface ChangeTaxRegionCode_output{
}

   /** Required : 
      @param orderNum
      @param orderLine
   */  
export interface ChangeUOMConfirm_input{
   orderNum:number,
   orderLine:number,
}

export interface ChangeUOMConfirm_output{
parameters : {
      /**  output parameters  */  
   msg:string,
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeUnitPrice_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeUnitPrice_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeVendorChange_input{
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}

export interface ChangeVendorChange_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}
}

   /** Required : 
      @param ds
      @param negInvTest
      @param chgDtlWhse
      @param suppressUserPrompts
      @param pcPartNum
      @param pcWhseCode
      @param pcBinNum
      @param pcLotNum
      @param pcAttributeSetID
      @param pcDimCode
      @param pdDimConvFactor
      @param pdSellingQuantity
   */  
export interface ChangeWhseCodeMaster_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  flag to determine if we run negativeInventoryTest logic  */  
   negInvTest:boolean,
      /**  flag to determine if we run changeODtlWarehouse logic  */  
   chgDtlWhse:boolean,
      /**  flag to determine if we suppress any user input  */  
   suppressUserPrompts:boolean,
      /**  partNum for negativeInventoryTest  */  
   pcPartNum:string,
      /**  whseCode for negativeInventoryTest  */  
   pcWhseCode:string,
      /**  binNum for negativeInventoryTest  */  
   pcBinNum:string,
      /**  lotNum for negativeInventoryTest  */  
   pcLotNum:string,
      /**  attributeSetID for negativeInventoryTest  */  
   pcAttributeSetID:number,
      /**  dimcode for negativeInventoryTest  */  
   pcDimCode:string,
      /**  dimConvFactor for negativeInventoryTest  */  
   pdDimConvFactor:number,
      /**  sellingQty for negativeInventoryTest  */  
   pdSellingQuantity:number,
}

export interface ChangeWhseCodeMaster_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   pcMessage:string,
   pcNeqQtyAction:string,
}
}

   /** Required : 
      @param ds
   */  
export interface ChangeXPartNum_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangeXPartNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangedCardNumber_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ChangedCardNumber_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param orderNum
      @param orderLine
      @param orderRelNum
   */  
export interface CheckComplianceFail_input{
      /**  Current Order Number.  */  
   orderNum:number,
      /**  Current Order Line.  */  
   orderLine:number,
      /**  Current Order Release.  */  
   orderRelNum:number,
}

export interface CheckComplianceFail_output{
parameters : {
      /**  output parameters  */  
   compliant:boolean,
}
}

   /** Required : 
      @param orderNum
   */  
export interface CheckComplianceOrderFail_input{
      /**  Current Order Number  */  
   orderNum:number,
}

export interface CheckComplianceOrderFail_output{
parameters : {
      /**  output parameters  */  
   compliantMsg:string,
}
}

   /** Required : 
      @param orderNum
      @param orderLine
      @param sourcePart
      @param sourceRev
      @param findRevision
   */  
export interface CheckConfiguration_input{
      /**  Order number to be searched  */  
   orderNum:number,
      /**  Order Line to be checked  */  
   orderLine:number,
      /**  Part Num to get details from (populated when sourceFile = "Method")  */  
   sourcePart:string,
      /**  Revision number to get details from (populated when sourceFile = "Method")  */  
   sourceRev:string,
      /**  If true the revision number will be looked up rather than using the sourceRev  */  
   findRevision:boolean,
}

export interface CheckConfiguration_output{
parameters : {
      /**  output parameters  */  
   canGetDetails:boolean,
   needsConfiguration:boolean,
   configureRevision:string,
   reasonMessage:string,
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iContractNum
   */  
export interface CheckContractNum_input{
   iOrderNum:number,
   iOrderLine:number,
   iContractNum:number,
}

export interface CheckContractNum_output{
}

   /** Required : 
      @param orderNum
      @param tranType
   */  
export interface CheckCreditCardTranForOrder_input{
   orderNum:number,
   tranType:string,
}

export interface CheckCreditCardTranForOrder_output{
parameters : {
      /**  output parameters  */  
   returnMessage:string,
}
}

   /** Required : 
      @param inTranType
      @param ds
   */  
export interface CheckCreditTran_input{
      /**  The transaction type to apply to the credit card.
            Valid transaction types : D (Deposit), S (Sale), A (Authorize),
            C (Credit - 803), V (Void).  */  
   inTranType:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckCreditTran_output{
parameters : {
      /**  output parameters  */  
   outMsg:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param cCustID
   */  
export interface CheckCustOnCreditHold_input{
      /**  The Order Number - optional  */  
   iOrderNum:number,
      /**  The Customer ID - optional  */  
   cCustID:string,
}

export interface CheckCustOnCreditHold_output{
parameters : {
      /**  output parameters  */  
   cCreditLimitMessage:string,
   cAgingMessage:string,
   lCustomerAllowed:boolean,
}
}

   /** Required : 
      @param iOrderNum
      @param iCustNum
      @param ds
   */  
export interface CheckCustomerCreditLimit_input{
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The Customer Number  */  
   iCustNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckCustomerCreditLimit_output{
parameters : {
      /**  output parameters  */  
   cCreditLimitMessage:string,
   cAgingMessage:string,
   cCreditShipAction:string,
   lContinue:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderDtlNum
      @param iCustNum
      @param ds
   */  
export interface CheckCustomerCreditRelease_input{
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The line number.  */  
   iOrderDtlNum:number,
      /**  The Customer Number  */  
   iCustNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckCustomerCreditRelease_output{
parameters : {
      /**  output parameters  */  
   cCreditLimitMessage:string,
   lContinue:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
   */  
export interface CheckICPOReadyToSend_input{
      /**  The order number to check against  */  
   iOrderNum:number,
}

export interface CheckICPOReadyToSend_output{
parameters : {
      /**  output parameters  */  
   cReadyToSendMsgText:string,
}
}

export interface CheckICPO_output{
parameters : {
      /**  output parameters  */  
   icpoFound:boolean,
}
}

   /** Required : 
      @param iPartNum
      @param iRevisionNum
   */  
export interface CheckKitRevision_input{
      /**  Part number  */  
   iPartNum:string,
      /**  Revision number  */  
   iRevisionNum:string,
}

export interface CheckKitRevision_output{
parameters : {
      /**  output parameters  */  
   outMsg:string,
}
}

   /** Required : 
      @param locID
      @param totalAmt
   */  
export interface CheckLetterOfCredit_input{
      /**  ID of the letter of credit  */  
   locID:string,
      /**  Amount in Doc currency for the new order  */  
   totalAmt:number,
}

export interface CheckLetterOfCredit_output{
parameters : {
      /**  output parameters  */  
   locHoldMessage:string,
}
}

   /** Required : 
      @param iOrderNum
      @param cARLOCID
      @param dTotalCharges
   */  
export interface CheckLtrOfCrdt_input{
      /**  Sales Order number  */  
   iOrderNum:number,
      /**  Letter of Credit ID  */  
   cARLOCID:string,
      /**  OrderHed.TotalCharges  */  
   dTotalCharges:number,
}

export interface CheckLtrOfCrdt_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   outMsg:string,
}
}

   /** Required : 
      @param ipOrderNum
   */  
export interface CheckMakeDirectReleases_input{
      /**  Order Number  */  
   ipOrderNum:number,
}

export interface CheckMakeDirectReleases_output{
parameters : {
      /**  output parameters  */  
   opIssueWarning:boolean,
}
}

   /** Required : 
      @param ds
   */  
export interface CheckOrderHedChanges_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckOrderHedChanges_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   cOrderChangedMsgText:string,
}
}

   /** Required : 
      @param iOrderNum
   */  
export interface CheckOrderLinkToInterCompanyPO_input{
      /**  The Order Number  */  
   iOrderNum:number,
}

export interface CheckOrderLinkToInterCompanyPO_output{
parameters : {
      /**  output parameters  */  
   cICPOLinkMessage:string,
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param cFieldName
      @param cPartNum
   */  
export interface CheckPartRevisionChange_input{
      /**  The current OrderHed.OrderNum field  */  
   iOrderNum:number,
      /**  The current OrderDtl.OrderLine field  */  
   iOrderLine:number,
      /**  The name of the field you are leaving  */  
   cFieldName:string,
      /**  The new PartNum if a substitute part is found, partNum will be the substitute part  */  
   cPartNum:string,
}

export interface CheckPartRevisionChange_output{
parameters : {
      /**  output parameters  */  
   cPartNum:string,
   cConfigPartMessage:string,
   cSubPartMessage:string,
   lSubAvail:boolean,
   cMsgType:string,
}
}

   /** Required : 
      @param ipProjectID
      @param ds
   */  
export interface CheckProjectID_input{
      /**  The Project ID value  */  
   ipProjectID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckProjectID_output{
parameters : {
      /**  output parameters  */  
   opProjMsg:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iQuoteNum
      @param iCustNum
   */  
export interface CheckQuoteForCreditLimit_input{
   iQuoteNum:number,
      /**  The Customer Number  */  
   iCustNum:number,
}

export interface CheckQuoteForCreditLimit_output{
parameters : {
      /**  output parameters  */  
   cCreditLimitMessage:string,
   cAgingMessage:string,
   cCreditStatus:string,
}
}

   /** Required : 
      @param iQuoteNum
   */  
export interface CheckQuoteLinesNoQuantity_input{
      /**  The Quote Number  */  
   iQuoteNum:number,
}

export interface CheckQuoteLinesNoQuantity_output{
parameters : {
      /**  output parameters  */  
   cQuoteLineWOQtyMsgText:string,
}
}

   /** Required : 
      @param ipRateGrpCode
      @param ds
   */  
export interface CheckRateGrpCode_input{
      /**  Currency Rate Group Code  */  
   ipRateGrpCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckRateGrpCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iContractNum
      @param iRenewalNbr
   */  
export interface CheckRenewalNbr_input{
   iOrderNum:number,
   iOrderLine:number,
   iContractNum:number,
   iRenewalNbr:number,
}

export interface CheckRenewalNbr_output{
}

   /** Required : 
      @param ProposedSONum
   */  
export interface CheckSONum_input{
      /**  The proposed SO Number  */  
   ProposedSONum:number,
}

export interface CheckSONum_output{
parameters : {
      /**  output parameters  */  
   opFoundSO:boolean,
   opMessage:string,
}
}

   /** Required : 
      @param ip_SellingFactorDirection
      @param ds
   */  
export interface CheckSellingFactorDirection_input{
      /**  The Selling Factor Direction value  */  
   ip_SellingFactorDirection:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CheckSellingFactorDirection_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param dSellingQuantity
   */  
export interface CheckSellingQuantityChange_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  The proposed selling quantity  */  
   dSellingQuantity:number,
}

export interface CheckSellingQuantityChange_output{
parameters : {
      /**  output parameters  */  
   cSellingQuantityChangedMsgText:string,
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
   */  
export interface CloseOrderLine_input{
      /**  The Order Number of the Order Line to close  */  
   iOrderNum:number,
      /**  The Order Line Number to close  */  
   iOrderLine:number,
}

export interface CloseOrderLine_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param iOrderNum
   */  
export interface CloseOrder_input{
      /**  The Order Number to close  */  
   iOrderNum:number,
}

export interface CloseOrder_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iOrderRelNum
   */  
export interface CloseRelease_input{
      /**  The Order Number of the Order Release to close  */  
   iOrderNum:number,
      /**  The Order Line of the Release to close  */  
   iOrderLine:number,
      /**  The Order Release Number of the release to close  */  
   iOrderRelNum:number,
}

export interface CloseRelease_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param orderDtlSysRowID
   */  
export interface ConfigurationChangePart_input{
      /**  OrderDtl SysRowID  */  
   orderDtlSysRowID:string,
}

export interface ConfigurationChangePart_output{
}

   /** Required : 
      @param orderDtlSysRowID
      @param commitValues
      @param currencySwitch
   */  
export interface ConfigurationChangeUnitPrice_input{
      /**  OrderDtl SysRowID  */  
   orderDtlSysRowID:string,
      /**  True to indicate if the changes should be committed to the DB. False if the logic only needs to compare the entity before and after the changes without commit them.  */  
   commitValues:boolean,
      /**  Flag to indicate which currency was affected by the Document Rule, true for Base Currency and false for Document Currency.  */  
   currencySwitch:boolean,
}

export interface ConfigurationChangeUnitPrice_output{
}

   /** Required : 
      @param orderDtlSysRowID
   */  
export interface ConfigurationRefreshQty_input{
      /**  OrderDtl SysRowID  */  
   orderDtlSysRowID:string,
}

export interface ConfigurationRefreshQty_output{
}

   /** Required : 
      @param orderList
   */  
export interface ConsolidateOrdersToCounterSale_input{
      /**  List of order numbers  */  
   orderList:string,
}

export interface ConsolidateOrdersToCounterSale_output{
      /**  The counter sale order number  */  
   returnObj:number,
}

   /** Required : 
      @param orderNum
   */  
export interface CopyOrderCreditLimitAndHoldCheck_input{
   orderNum:number,
}

export interface CopyOrderCreditLimitAndHoldCheck_output{
parameters : {
      /**  output parameters  */  
   creditLimitMessage:string,
   letterOfCreditHoldMessage:string,
   holdMessage:string,
   attributeValidationMsg:string,
}
}

   /** Required : 
      @param orderNum
      @param ipPONum
      @param ipOpenRel
      @param ipReNbr
      @param ipPreserve
      @param ipCalc
   */  
export interface CopyOrder_input{
      /**  The order to apply the discounts to  */  
   orderNum:number,
   ipPONum:string,
   ipOpenRel:boolean,
   ipReNbr:boolean,
   ipPreserve:boolean,
   ipCalc:boolean,
}

export interface CopyOrder_output{
parameters : {
      /**  output parameters  */  
   NewOrderNum:number,
   OutMessage:string,
}
}

   /** Required : 
      @param orderNum
   */  
export interface CounterSaleValidateInvQty_input{
      /**  The Order Number of the counter sale order to process  */  
   orderNum:number,
}

export interface CounterSaleValidateInvQty_output{
parameters : {
      /**  output parameters  */  
   negativeInventoryMessage:string,
   negativeInventoryAction:string,
}
}

   /** Required : 
      @param ds
      @param iOrderNum
      @param iOrderLine
      @param iOrderRel
   */  
export interface CreateGlbSugPOChg_input{
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The Order Line Number  */  
   iOrderLine:number,
      /**  The Order Release Number  */  
   iOrderRel:number,
}

export interface CreateGlbSugPOChg_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}
}

   /** Required : 
      @param ipOrderNum
      @param ipOrderLine
      @param ipQuoteNum
      @param ipQuoteLine
      @param ipQtyNum
      @param ds
   */  
export interface CreateLineMiscChargesFromQuote_input{
      /**  The Order Number  */  
   ipOrderNum:number,
      /**  The Line Number  */  
   ipOrderLine:number,
      /**  The Quote Number  */  
   ipQuoteNum:number,
      /**  The Quote Line  */  
   ipQuoteLine:number,
      /**  The Quote Quantity  */  
   ipQtyNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CreateLineMiscChargesFromQuote_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param ds
   */  
export interface CreateLinesFromHistory_input{
      /**  The Order Number  */  
   iOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CreateLinesFromHistory_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param ds
   */  
export interface CreateOrderDtlComplements_input{
      /**  The Order Number  */  
   iOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface CreateOrderDtlComplements_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iQuoteNum
      @param ds
   */  
export interface CreateOrderFromQuoteSaveOTS_input{
      /**  The Quote Number with which to create the order  */  
   iQuoteNum:number,
   ds:Erp_Tablesets_SaveOTSParamsTableset[],
}

export interface CreateOrderFromQuoteSaveOTS_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param iQuoteNum
      @param iPoNum
      @param iCreditStatus
      @param iCreditHold
   */  
export interface CreateOrderFromQuote_input{
      /**  The Quote Number with which to create the order  */  
   iQuoteNum:number,
   iPoNum:string,
   iCreditStatus:string,
   iCreditHold:boolean,
}

export interface CreateOrderFromQuote_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param orderNum
   */  
export interface DeleteByID_input{
   orderNum:number,
}

export interface DeleteByID_output{
}

   /** Required : 
      @param ds
      @param reqType
      @param xmlDoc
   */  
export interface ECCUpdateFinal_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   reqType:string,
   xmlDoc:string,
}

export interface ECCUpdateFinal_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ECCUpdate_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ECCUpdate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param ds1
      @param OrderNum
   */  
export interface ETCAfterAddressValidationOTS_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   ds1:Erp_Tablesets_ETCAddrValidationTableset[],
      /**  OrderHed.OrderNum  */  
   OrderNum:number,
}

export interface ETCAfterAddressValidationOTS_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param ds1
      @param OrderNum
      @param OrderLine
      @param OrderRelNum
   */  
export interface ETCAfterRelAddressValidationOTS_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   ds1:Erp_Tablesets_ETCAddrValidationTableset[],
      /**  OrderHed.OrderNum  */  
   OrderNum:number,
      /**  OrderRel.OrderLine  */  
   OrderLine:number,
      /**  OrderRel.OrderRelNum  */  
   OrderRelNum:number,
}

export interface ETCAfterRelAddressValidationOTS_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param isOrderReleaseVal
      @param OrderNum
      @param OrderLine
      @param OrderRelNum
   */  
export interface ETCValidateAddress_input{
      /**  If true, the validation is for One Time Ship To on Line/Release level.  */  
   isOrderReleaseVal:boolean,
      /**  OrderHed.OrderNum  */  
   OrderNum:number,
      /**  OrderDtl.OrderLine  */  
   OrderLine:number,
      /**  OrderRel.OrderRelNum  */  
   OrderRelNum:number,
}

export interface ETCValidateAddress_output{
   returnObj:Erp_Tablesets_ETCAddrValidationTableset[],
parameters : {
      /**  output parameters  */  
   StatusFlag:boolean,
   ErrorFlag:boolean,
   ErrorMsg:string,
   ExceptionFlag:boolean,
}
}

   /** Required : 
      @param newOrder
      @param orderNum
      @param lineNum
   */  
export interface EccCalcKitValue_input{
   newOrder:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
   lineNum:number,
}

export interface EccCalcKitValue_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   newOrder:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param ds
   */  
export interface EccProcessPayment_input{
   iOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface EccProcessPayment_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   opMessage:string,
}
}

export interface Erp_Tablesets_ETCAddrValidationTableset{
   ETCAddress:Erp_Tablesets_ETCAddressRow[],
   ETCMessage:Erp_Tablesets_ETCMessageRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ETCAddressRow{
      /**  Company  */  
   Company:string,
      /**  City name  */  
   City:string,
      /**  Country name  */  
   Country:string,
      /**  Address line 1  */  
   Line1:string,
      /**  Address line 2  */  
   Line2:string,
      /**  Address line 3  */  
   Line3:string,
      /**  Postal or ZIP code  */  
   PostalCode:string,
      /**  State or province name  */  
   Region:string,
      /**  This is an additional field that will be required to designate the type of address that is being validated (customer, plant, etc)  */  
   AddrSource:string,
      /**  This is an additional field to contain an appropriate piece of data to be used with the AddrSource for display in the UI to clarify for the user what data the validated address relates to. Such as AddrSource = Customer and AddrSourceID = ?Addison?  */  
   AddrSourceID:string,
      /**  This is an additional field that will be set if the user has indicated that the Vantage address should be updated from the address validation results.  */  
   UpdateAddr:boolean,
      /**  This value will come from Avalara ValidateResult TransactionID and identifies a unique specific request/response set. It will be used to tie the ETCValidAddress and ETCMessage rows to ETCAddress.  */  
   TransactionID:string,
      /**  This field will be set if by the process calling address validation to indicate whether the user should have the option to update the original address within the address validation UI.  */  
   UpdateAllowed:boolean,
      /**  Programmatically assign unique key to tie the ETCAddress table, the ETCValidAddress table and the ETCMessages table together.  */  
   RequestID:string,
      /**  Programmatically determined value used internally by the adapter. Defaults to the hash code of the Address object.  */  
   AddressCode:string,
      /**  The type of address that was coded (PO Box, Rural Route, and so on), using the input address. This probably needs Code/desc data  Avalara will return F = Firm or company address; G = General Delivery address; H= High-rise or business complex; P = PO Box address; R = Rural route address; S = Street or residential address  */  
   AddressType:string,
      /**  The carrier route associated with the input address (USA). This probably needs Code/desc data  Avalara will return B = PO Box; C = City Delivery; G= General Delivery; H = Highway Contract; R = Rural route.  */  
   CarrierRoute:string,
      /**  City name  */  
   ValidCity:string,
      /**  Country name  */  
   ValidCountry:string,
      /**  County name  */  
   County:string,
      /**  Federal Information Processing Standards Code (USA). This is a unique code representing each geographic combination of state, county, and city. The code is made up of the Federal Information Processing Code (FIPS) that uniquely identifies each state, county, and city in the U.S. See Federal Information Processing Standards (FIPS) Codes for more details. Digits 1-2 are the state code, digits 3-5 are the county code and digits 6-10 are the city code.  */  
   FipsCode:string,
      /**  Line one of the valid address returned by the tax integration.  */  
   ValidLine1:string,
      /**  Line two of the valid address returned by the tax integration.  */  
   ValidLine2:string,
      /**  Line three of the valid address returned by the tax integration.  */  
   ValidLine3:string,
      /**  Line four of the valid address returned by the tax integration.  */  
   ValidLine4:string,
      /**  Postal code returned by the tax integration.  */  
   ValidPostalCode:string,
      /**  A 12-digit POSTNet barcode (USA). Digits 1-5 = ZIP code, digits 6-9 = Plus4 Code, digits 10-11 = delivery point, digit 12 = check digit  */  
   PostNet:string,
      /**  State or province name or abbreviation returned by the tax integration.  */  
   ValidRegion:string,
      /**  This needs Code/desc data.  Avalara will return a single code for each address validation request. We will include the result code in each ETCValidAddress row. Success = Operation Succeeded; Warning = Warnings occured, operation succeeded, Error = Errors occured, operation failed; Exception = Unexpected exceptions occurred, operation failed.  */  
   ResultCode:string,
      /**  This is an additional field to set a unique sequence for each ValidMessage returned for a specific TransactionId.  */  
   ResultSeq:number,
      /**  Carrier Route description  */  
   CarrierRouteDesc:string,
      /**  Address type description  */  
   AddressTypeDesc:string,
   OTSCountry:string,
      /**  A  unique integer assigned by the system to new countries by the  maintenance program. This field is used as the foreign key to identify the country in other files such as Customer, or vendor. The end user should never need to know about the value of this field.  */  
   CountryNum:number,
      /**  Foreign key to the InvcHead.  */  
   InvoiceNum:number,
      /**  This field along with Company and InvoiceNum make up the unique key to the table.  The system generates this number during entry of new detail records.  The system determines next available number by finding the last InvcDtl record for the Invoice and adding 1 to it.  */  
   InvoiceLine:number,
      /**   Auto consume window percentage: this is a percentage to calculate the auto consume window days  that scheduling engine will take in consideration to look for available quantity to consume.
The purpose of this is to look ahead for a few days that will save more time than building the goods, so unless we get the full qty “current date” we need to use the window to look for the remaining.  */  
   ACWPercentage:number,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ETCMessageRow{
      /**  Company  */  
   Company:string,
   Details:string,
      /**  URL to help page for this message  */  
   Helplink:string,
      /**  Gets the name of the message  */  
   Name:string,
      /**  The item the message refers to, if applicable. Used to indicate a missing or incorrect value  */  
   RefersTo:string,
      /**  This probably needs Code/desc data  Avalara will return Success = Operation Succeeded; Warning = Warnings occured, operation succeeded, Error = Errors occured, operation failed; Exception = Unexpected exceptions occurred, operation failed.  */  
   Severity:string,
      /**  source of the message  */  
   Source:string,
      /**  concise summary of the message  */  
   Summary:string,
      /**  This value will come from Avalara ValidateResult TransactionID and identifies a unique specific request/response set. It will be used to tie the ETCMessage row to ETCAddress.  */  
   TransactionID:string,
      /**  This is an additional field that will be required to designate the type of address that is being validated (customer, plant, etc)  */  
   AddrSource:string,
      /**  This is an additional field to contain an appropriate piece of data to be used with the AddrSource for display in the UI to clarify for the user what data the validated address relates to. Such as AddrSource = Customer and AddrSourceID = ?Addison?  */  
   AddrSourceID:string,
      /**  Programitically assigned.  */  
   RequestID:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbSugPOChgRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Purchase order that this release record is related to.  */  
   PONum:number,
      /**  The line # of  PoDetail record that the PORel record is related to.  */  
   POLine:number,
      /**  Purchase order release number uniquely identifies a purchase release requirement record for a specific line item on an order. This is assigned by the system.  */  
   PORelNum:number,
      /**   Suggested action to be taken for this Purchase Order release.
"X" = Expedite, "P" = Postpone,  "C" = Cancel, "I"= increase qty, R = Reduce Qty. This field is a 8 char. field it could contain "IP' increase and postpone.  */  
   SuggestionCode:string,
      /**   The Buyer Id that is on the related PO.
Duplicate of POHeader.BuyerID  */  
   BuyerID:string,
      /**  Requirement Due Date.  For suggested Cancels or Reduce Quantity this is set to Today.  */  
   RequireDate:string,
      /**  Human formatted string that contains the original source document of this entry.  */  
   SourceName:string,
      /**  New Suggested qty (in our UOM). This is the true amount suggested, not the difference between actual and suggested.  This only pertains to increase and reduce qty suggestions.  */  
   SurplusQty:number,
      /**   Reason for "Cancel" suggestion.  Purchase for stock which
1. OverMax - Stock purchase which surpasses the maximum.
2. No Requirement - Job purchase no open job record.  */  
   CancelReason:string,
      /**  Site Identifier. This field can not be blank.  */  
   Plant:string,
      /**  Supplier contact linked to this record.  */  
   ConNum:number,
      /**  Comment  */  
   Comment:string,
      /**  Indicates that this suggestion was initiated from the supplier Wb.  It is a reference field on time phase and does not add or subtract from the balance.  */  
   VendorChange:boolean,
      /**  Linked Inter-Company sales order.  */  
   OrderNum:number,
      /**  Linked Inter-Company Sales order Line number that this order release is linked to.  */  
   OrderLine:number,
      /**  The linked Inter-Company sale order release.  */  
   OrderRelNum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
   TransDate:string,
   GlbCompany:string,
   ABCCode:string,
      /**  SuggestionStatus  */  
   SuggestionStatus:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Review  */  
   Review:boolean,
      /**  LockDate  */  
   LockDate:boolean,
      /**  LockQty  */  
   LockQty:boolean,
      /**  The translated suggestion status for display  */  
   DisplaySuggestionStatus:string,
      /**  it's the UOM for the field NewOurQuantity  */  
   IUM:string,
   NewOurQuantity:number,
   NewShipByDate:string,
      /**  it's the UOM value of SurPlusQty  */  
   SalesIUM:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbSugPOChgTableset{
   GlbSugPOChg:Erp_Tablesets_GlbSugPOChgRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_HedTaxSumRow{
   Company:string,
      /**  Currency display switch  */  
   CurrencySwitch:boolean,
      /**  Currency display symbol  */  
   DisplaySymbol:string,
      /**  Document display symbol  */  
   DocDisplaySymbol:string,
      /**  Document reportable amount.  */  
   DocReportableAmt:number,
      /**  Document taxable amount.  */  
   DocTaxableAmt:number,
      /**  Document tax amount.  */  
   DocTaxAmt:number,
      /**  Order or Quote number this tax summary relates to.  */  
   HedNum:number,
      /**  Tax percent  */  
   Percent:number,
      /**  Reportable amount  */  
   ReportableAmt:number,
      /**  Taxable amount  */  
   TaxableAmt:number,
      /**  Tax amount  */  
   TaxAmt:number,
      /**  Tax code  */  
   TaxCode:string,
      /**  Sales Tax description  */  
   TaxDescription:string,
   GroupID:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   Rpt1ReportableAmt:number,
   Rpt2ReportableAmt:number,
   Rpt3ReportableAmt:number,
   Rpt1TaxableAmt:number,
   Rpt2TaxableAmt:number,
   Rpt3TaxableAmt:number,
   Rpt1TaxAmt:number,
   Rpt2TaxAmt:number,
   Rpt3TaxAmt:number,
      /**  Rate Code on the Header Tax Summary  */  
   RateCode:string,
      /**  Invoice Number of allocated Deposits  */  
   AllocDepInvcNum:number,
      /**  Rate Code Description on the Header Tax Summary  */  
   RateCodeDescription:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_JobProdRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Job Number. Used in tying record back to its parent JobHead record.  */  
   JobNum:string,
      /**  Related sales order number. For build to stock demands the OrderNum, OrderLine and OrderRel fields are all zero  */  
   OrderNum:number,
      /**  Related Sales order line number.  */  
   OrderLine:number,
      /**  Related sales order release number.  */  
   OrderRelNum:number,
      /**   The planned production quantity for a  Job to fill the demand.
Note: updates the JobHead.ProdQty via JobProd write trigger.  */  
   ProdQty:number,
      /**   Inventory warehouse that job is producing for.
Only relevant for build to stock demands (ordernum = 0). In this case a valid Part must be referenced.  */  
   WarehouseCode:string,
      /**  Production Demands can be from other jobs.  That is, one job can be building parts that are required by another job. The demand is defined by a JobMtl record on some other job.  "TargetJobNum" is the job that this job is making parts for.  */  
   TargetJobNum:string,
      /**  Assembly Sequence of the JobMtl record that is making the production demand. (See "TargetJobNum")  */  
   TargetAssemblySeq:number,
      /**  Material Sequence of the JobMtl record that is making the production demand. (See "TargetJobNum")  */  
   TargetMtlSeq:number,
      /**   Quantity Shipped against this allocation.
Updated via the ShipDtl write triggers.  */  
   ShippedQty:number,
      /**   Total quantity received to stock for this production allocation.
Updated via the Manufacturing Receipts process  */  
   ReceivedQty:number,
      /**   Represents the "outstanding" WIP production quantity.
WIPQty = JobProd.Quantity - (ShippedQty +ReceivedQty) if negative then it is set to zero. If related Order Release is closed then reservation is zero.
Updated via the JobProd, OrderRel triggers.  */  
   WIPQty:number,
      /**  The Service Call number that this Job is linked to.  */  
   CallNum:number,
      /**  The Service Call Line that this Job is linked to.  */  
   CallLine:number,
      /**  This is the unique key for this table.  It will have a prefix like Job to indicate firm or unfirm orders.  The record can be linked to an Order Header by using the TFOrdNum TFOrdSeq keys.  */  
   TFLineNum:string,
      /**   Part number of the manufactured item.  Does not have to be valid in the Part master.  Cannot be blank.
With verion 8.0 and Advanced Production License a job can have multiple end parts. These are defined in the JobPart table.
This field has not changed. But will now be used to indicate the primary end part that is being produced. That is, the JobPart record where JobPart.PartNum = JobHead.PartNum will be considered as the primary end part. A primary part is only significant on Concurrent mode of production, because it?s quantity drives the material/operation requirements.  */  
   PartNum:string,
      /**  Site Identifier.  */  
   Plant:string,
      /**  The demand contract this demand schedule is for.  */  
   DemandContractNum:number,
      /**  The sequence from the DemandHead record this DemandSchedule is related to.  */  
   DemandHeadSeq:number,
      /**  The sequence from the DemandDetail record this DemandSchedule is related to.  */  
   DemandDtlSeq:number,
      /**  This field along with Company, DemandContractNum, DemandHeadSeq, and DemandDetailSeq make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the last DemandSchedulel record for the DemandDetail and the adding 1 to it.  */  
   DemandScheduleSeq:number,
      /**  PlanUserID  */  
   PlanUserID:string,
      /**  PlanID  */  
   PlanID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Job will be shipped through a Misc Shipment directly from WIP when job is closed.  */  
   WIPToMiscShipment:boolean,
      /**  RMA Num linked from RMA Disposition.  */  
   RMANum:number,
      /**  RMA Line linked from RMA Disposition.  */  
   RMALine:number,
      /**  RMA Receipt linked from RMA Disposition.  */  
   RMAReceipt:number,
      /**  RMA Disposition linked from RMA Disposition.  */  
   RMADisp:number,
      /**  DMRNum  */  
   DMRNum:number,
      /**  DMRActionNum  */  
   DMRActionNum:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  Planning number of pieces for this attribute set.  */  
   PlanningNumberOfPieces:number,
      /**  Revision number which is used to uniquely identify the revision of the part.  */  
   RevisionNum:string,
      /**  The customer ID  */  
   CustID:string,
      /**  The customer name.  */  
   CustName:string,
      /**  The demand linke source  */  
   DemandLinkSource:string,
      /**  The demand link status  */  
   DemandLinkStatus:string,
      /**  IUM  */  
   IUM:string,
      /**  The jobhead part description  */  
   JHPartDesc:string,
      /**  The jobhead part number  */  
   JHPartNum:string,
      /**  The make to job quantity  */  
   MakeToJobQty:number,
      /**  The make to stock quantity  */  
   MakeToStockQty:number,
      /**  The Make to type (i.e. Stock, Job, Order)  */  
   MakeToType:string,
      /**  Calculated quantity that could come from allocatedqty or accumulation from parttran.  */  
   MaxAllowedQty:number,
      /**  The jobmtl part description.  */  
   MtlPartDesc:string,
      /**  The jobmtl part number.  */  
   MtlPartNum:string,
      /**  The order WIP quantity  */  
   OrdWIPQty:number,
      /**  Calculated field OurStockQty, will update OrderRel.OurStockQty  */  
   OurStockQty:number,
      /**  Pull from Stock warehouse code (orderrel.warehousecode  */  
   PullFromStockWarehouseCode:string,
      /**  The pull from stock warehouse description  */  
   PullFromStockWarehouseDesc:string,
      /**  The Demand Link Due Date - Ship By  */  
   ShipBy:string,
      /**  The split quantity for the demand.  */  
   SplitQty:number,
      /**  The stock WIP quantity  */  
   StkWIPQty:number,
   TFOrdLine:number,
   TFOrdNum:string,
      /**  Temp field so UI has a column to bind to for calculation of Total Split Quantity.  */  
   TotalSplitQuantity:number,
   TrackSerialNumbers:boolean,
      /**  This is a field used in Split Job to determine if record has been validated.  */  
   Valid:boolean,
      /**  The jobasmbl part description.  */  
   AsmPartDesc:string,
      /**  The jobasmbl part number.  */  
   AsmPartNum:string,
   EnableAttributeSetSearch:boolean,
      /**  Number of pieces for inventory attribute tracked parts.  */  
   DispNumberOfPieces:number,
      /**  Indicates a customer referenced on the record is inactive.  */  
   CustInactive:boolean,
      /**  Indicates if a ShipTo referenced on the record is inactive.  */  
   ShipToNumInactive:boolean,
   BitFlag:number,
   CallLineLineDesc:string,
   DynAttrValueSetShortDescription:string,
   DynAttrValueSetDescription:string,
   JobNumPartDescription:string,
   OrderLineLineDesc:string,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
   PartAttrClassID:string,
   PartTrackInventoryByRevision:boolean,
   PartSalesUM:string,
   PartTrackSerialNum:boolean,
   PartSellingFactor:number,
   PartTrackLots:boolean,
   PartIUM:string,
   PartTrackDimension:boolean,
   PartPricePerCode:string,
   PartPartDescription:string,
   PartTrackInventoryAttributes:boolean,
   WarehouseCodeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OHOrderMscRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Sales Order Number  */  
   OrderNum:number,
      /**  Order line number that this miscellaneous record is related to. If related to the Order then this field is zero. This number is not directly entered by the user; rather it is carried through from the header or detail line that user was on when miscellaneous maintenance was requested.  */  
   OrderLine:number,
      /**  Sequence Number  */  
   SeqNum:number,
      /**  The Miscellaneous Charge Code. This must be valid in the MiscChrg master file.  */  
   MiscCode:string,
      /**  Description of the miscellaneous charge. This will be printed on the acknowledgment and transferred over to invoice processing. The default is provided by MiscChrg.Description, but it's overridable by the user. This can't be blank.  */  
   Description:string,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   MiscAmt:number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   DocMiscAmt:number,
      /**  Sets the frequency of when this miscellaneous charge should be applied. The options are F - First shipment, L = Last shipment, E = every shipment. This defaults from the MiscChrg.FreqCode.  */  
   FreqCode:string,
      /**  An internally used flag which indicates that this record was created from a Quote via the "Get Quote" function. "Q" = related to the QuoteQty record, "L" = related to the overall QuoteDtl record. This flag is used so that the OrderMsc file can be refreshed from the QuoteMsc when Quantity or Quote/Line # changes occur. The logic is that if a change in order quantity of a order line that is linked to a quote causes a different price break to be selected then all the existing all OrderMsc records where Quoting = "Q" are deleted and then re-pulled in based on the new qty. If the Quote # or QuoteLine are changed then all OrderMsc records where Quoting is either a "Q" or "L" are deleted then re-pulled in from the newly referenced quote.  */  
   Quoting:string,
      /**  Indicates if this order miscellaneous charge is linked to an inter-company PO misc charge.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   ICPONum:number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   ICPOLine:number,
      /**  Inter Company PO Sequence Number  */  
   ICPOSeqNum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Reporting currency value of this field  */  
   Rpt1MiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2MiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3MiscAmt:number,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default. - Includes taxes  */  
   InMiscAmt:number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default. - includes taxes  */  
   DocInMiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1InMiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2InMiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3InMiscAmt:number,
      /**  This field will be used to define the percentage of the extended amount that will be applied as the 'Miscellaneous charge'.  */  
   Percentage:number,
      /**  This field will define if the miscellaneous charge is calculated as a flat amount or if is calculated as a percentage of the extended price.  */  
   Type:string,
      /**  ChangeTrackApproved  */  
   ChangeTrackApproved:boolean,
      /**  ChangeTrackAmount  */  
   ChangeTrackAmount:number,
      /**  ChangeTrackMemoDesc  */  
   ChangeTrackMemoDesc:string,
      /**  ChangeTrackMemoText  */  
   ChangeTrackMemoText:string,
      /**  ChangeTrackStatus  */  
   ChangeTrackStatus:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BaseCurrSymbol:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencySwitch:boolean,
   CurrSymbol:string,
      /**  Misc charge amount on display in document currency (may or may not include taxes)  */  
   DocDspMiscAmt:number,
      /**  Misc charge amount on display (may or may not include taxes)  */  
   DspMiscAmt:number,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
      /**  Misc charge amount on display in report currency  (may or may not include taxes)  */  
   Rpt1DspMiscAmt:number,
      /**  Misc charge amount on display in report currency (may or may not include taxes)  */  
   Rpt2DspMiscAmt:number,
      /**  Misc charge amount on display in report currency (may or may not include taxes)  */  
   Rpt3DspMiscAmt:number,
      /**  Pass Credit Limit check message to the UI  */  
   RespMessage:string,
   BitFlag:number,
   MiscCodeDescription:string,
   OrderNumCardMemberName:string,
   OrderNumCurrencyCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrdDtlQuoteQtyTableset{
   QuoteQty:Erp_Tablesets_QuoteQtyRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_OrdRelJobProdTableset{
   JobProd:Erp_Tablesets_JobProdRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_OrderCustTrkRow{
      /**  from OrderHed.OrderNum  */  
   OrderNum:number,
      /**  from OrderHed.OpenOrder  */  
   OpenOrder:boolean,
      /**  from OrderHed.Company  */  
   Company:string,
      /**  from OrderHed.OrderHeld  */  
   OrderHeld:boolean,
      /**  from OrderHed.PONum  */  
   PONum:string,
      /**  from OrderHed.CustNum  */  
   CustNum:number,
      /**  from OrderHed.ShipToNum  */  
   ShipToNum:string,
      /**  from OrderHed.ShpConNum  */  
   ShpConNum:number,
      /**  from OrderHed.PrcConNum  */  
   PrcConNum:number,
      /**  from OrderHed.OrderDate  */  
   OrderDate:string,
      /**  from OrderHed.NeedByDate  */  
   OrderHedNeedByDate:string,
      /**  from OrderHed.RequestDate  */  
   OrderHedRequestDate:string,
      /**  from OrderHed.Currency  */  
   CurrencyCode:string,
      /**  from OrderDtl.OrderLine  */  
   OrderLine:number,
      /**  from OrderDtl.OpenLine  */  
   OpenLine:boolean,
      /**  from OrderDtl.POLine  */  
   POLine:string,
      /**  from OrderDtl.PartNum  */  
   PartNum:string,
      /**  from OrderDtl.LineDesc  */  
   LineDesc:string,
      /**  from OrderDtl.SellingQuantity  */  
   SellingQuantity:number,
      /**  from OrderDtl.SalesUM  */  
   SalesUM:string,
      /**  from OrderDtl.DocUnitPrice  */  
   DocUnitPrice:number,
      /**  from OrderDtl.ProdCode  */  
   ProdCode:string,
      /**  from OrderDtl.ProdCodeDescription  */  
   ProdCodeDescription:string,
      /**  from OrderDtl.NeedByDate  */  
   OrderDtlNeedByDate:string,
      /**  from OrderDtl.RequestDate  */  
   OrderDtlRequestDate:string,
      /**  from OrderHed.WebOrder  */  
   WebOrder:boolean,
      /**  If OrderHed.CustOnCreditHold = true and OrderHed.CreditOverride = false and OrderHed.OpenOrder = true then true otherwise false  */  
   OnCreditHold:boolean,
      /**  from OrderDtl.RevisionNum  */  
   RevisionNum:string,
      /**  from OrderDtl.XPartNum  */  
   XPartNum:string,
      /**  from OrderDtl.XRevisionNum  */  
   XRevisionNum:string,
      /**  Bill To customer number from OrderHed.  */  
   BTCustNum:number,
      /**  Bill To Customer ID from OrderHed.  */  
   BTCustID:string,
      /**  Bill To Customer Name.  */  
   BTCustomerName:string,
      /**  Bill to address list.  */  
   BTAddressList:string,
      /**  Bill to contact fax number.  */  
   BTContactFaxNum:string,
      /**  Bill to contact phone number  */  
   BTContactPhoneNum:string,
      /**  Bill To Contact name.  */  
   BTContactName:string,
      /**  Bill to contact num.  */  
   BTConNum:number,
   CreditOverride:boolean,
      /**  Sold to customer id.  */  
   SoldToCustID:string,
      /**  Sold to customer name.  */  
   SoldToCustName:string,
      /**  The full customer's name.  */  
   CustomerName:string,
      /**  The name for the ship to location.  */  
   ShipToName:string,
      /**  The customer ID.  */  
   CustID:string,
      /**  from OrderDtl.POLineRef  */  
   POLineRef:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderCustTrkTableset{
   OrderCustTrk:Erp_Tablesets_OrderCustTrkRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_OrderDtlAttchRow{
   Company:string,
   OrderNum:number,
   OrderLine:number,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderDtlRow{
      /**   Indicates that the line item was closed before any shipments were made against it. Normally line items are closed as part of the Shipping process. By using the "Close Line" menu option the user can close the line manually, to provide the function to close the line when the customer cancels there request.  If the line item had no shipments made it is then marked as "voided". Regardless of shipment activity the line is also marked as closed (OpenLine = No).
When an OrderDtl record is 'voided/closed' all of it's related OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   VoidLine:boolean,
      /**  Indicates if the OrderDtl record is in a "open or closed" status.  This field is not directly maintainable. It can be set to "closed" via the "Close-Line" menu option,  the "Close-Order" menu option, or when all the related OrderRel records are closed, OrderRel records are closed via shipping or by the "Close Release" button within Order Entry. (See VoidLine also).  */  
   OpenLine:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  Contains the Order Number that ties this detail record back to an OrderHed record.  */  
   OrderNum:number,
      /**  This field along with Company and OrderNum make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the OrderDtl record for the Order and the adding 1 to it.  The user can override this number if they wish.  */  
   OrderLine:number,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT".  */  
   LineType:string,
      /**   The user's Internal Part number used to identify line item part. It cannot  be blank. It does not have to exist in the Part table.

A default should be made when the OrderDtl.XPartNum is changed.  The PartNum and XPartNum fields work together in providing defaults for each other. Default when a valid record is found in the PartXRef table. NOTE THE PART CROSS REFERENCE LOGIC IS NOT INCLUDED IN RELEASE 1.0 ... PLAN FOR FUTURE  */  
   PartNum:string,
      /**  Line Item description. The Part.Description can be used as a default.  */  
   LineDesc:string,
      /**  EDI Reference  */  
   Reference:string,
      /**  Unit Of Measure (how it is sold/issued). Use the default Part.IUM if it's a valid Part.  */  
   IUM:string,
      /**  Optional field that contains the customers revision. Default from the PartRev.RevisionNum field.  */  
   RevisionNum:string,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   POLine:string,
      /**  Controls if line is commissionable. Note if all the OrderHed.SalesRep are blank then this should be "No", also the user should not even see this field when there are no sales reps for the order.  */  
   Commissionable:boolean,
      /**  The line item discount percent. It has nothing to do with price break discounts. It is a flat discount percent that defaults from the OrderHed.DiscountPercent, which was originally defaulted from the Customer.DiscountPercent.  */  
   DiscountPercent:number,
      /**   If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in
the customer currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   DocUnitPrice:number,
      /**  Total Order Quantity for the line item. This quantity must always be kept in sync with the scheduled ship quantities stored in the OrderRel table. Normally this field is directly maintainable. However when multiple shipping releases have been established for this line ( more than one OrderRel record) the OrderQty is not maintainable. As the user modifies the quantities in the individual release lines the OrderQty field will get adjusted. This ensures that Order quantity and scheduled ship quantity are always in sync.  */  
   OrderQty:number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Discount:number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   DocDiscount:number,
      /**   Date that the first release needs be shipped by in order to meet the customers due date for the first delivery. Defaulted as OrderHed.RequestDate.
Not directly maintainable when more than one delivery record exists, in which case it gets refreshed as the earliest ReqDate of the related OrderRel records.  */  
   RequestDate:string,
      /**  Product Group Code. Use the Part.ProdCode as a default.  This can be blank or must be valid in the ProdGrup table.  */  
   ProdCode:string,
      /**  An optional field that is used if the customer has a different  Part number  than the users internal part number.  The XPartNum and PartNum can provide defaults for each other via the PartXref table.. The XPartNum can be blank, does not have to exist in the PartXref table.  */  
   XPartNum:string,
      /**  Optional field that contains the customers revision. Default from the CustXPrt.RevisionNum field.  */  
   XRevisionNum:string,
      /**  Indicates the pricing per quantity. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Used to calculate the extended unit price for the line item. The logic is to divide the OrderDtl.OrderQty by the appropriate "per" value and then multiply by unit price.  Use the  Part.PricePerCode as a default. If Part record does not exist then default as "E".  */  
   PricePerCode:string,
      /**  Contains comments about the detail order line item. These will be printed on the Sales Acknowledgements.  */  
   OrderComment:string,
      /**  Used to establish shipping comments about the order line item. These will copied into the packing slip detail  file as defaults.  */  
   ShipComment:string,
      /**  Used to establish invoice comments about the order line item. These will copied into the Invoice detail  file as defaults.  */  
   InvoiceComment:string,
      /**  Contains comments for pick list or job about the order line item. These will be printed on the picking lists or copied to the job during the link process.  */  
   PickListComment:string,
      /**  Indicates the Tax Category for this record. Defaults from the the or from the Part Master.  */  
   TaxCatID:string,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs. This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering amount in the InvcDetl.  */  
   AdvanceBillBal:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   DocAdvanceBillBal:number,
      /**  Quote number to which this line item detail record is associated with. This is part of the foreign key to QuoteHed file. This field is updated via the "get quote" function within Order Entry.  */  
   QuoteNum:number,
      /**  Quote Line number from which this order line was created. Updated via the Get Quote function within Order Entry. This field along with Company and QuoteNum make up the link to the QuoteDtl file.  */  
   QuoteLine:number,
      /**  Indicates if the Order line item is billed based on Time & Material. This flag is copied into the ShipDtl record during the Shipping Entry process. See ShipDtl.TMBilling description for further details.  */  
   TMBilling:boolean,
      /**  This field is no longer active. It has been replaced by OrderRel.Exempt. The contents were copied into OrderRel.Exempt during the release conversion process. This will be removed in the next release.  */  
   OrigWhyNoTax:string,
      /**   Date the customer needs the first release to be delivered.
Defaulted as OrderHed.NeedByDate. Not directly maintainable when more than one delivery record exists. In which case it is kept in sync with the OrderRel record which has the earliest ReqDate which are maintained in the shipping release dialog boxes.  */  
   NeedByDate:string,
      /**  Customer number that the sales order is for. Duplicated from OrderHed.CustNum.  Used to allow efficient browsing of the OrderDtl records for a specific customer.  */  
   CustNum:number,
      /**   Used to indicate that line item is to be "Reworked" instead of manufactured.  It is shown in the Job Entry Order Activity screens.
When Yes then all related OrderRel records are Make=Yes.  */  
   Rework:boolean,
      /**   Return Authorization Number that OrderDtl is fulfilling.
If entered, must be valid in RMAHead.  */  
   RMANum:number,
      /**  The line item of the RMA detail that this order line item is fulfilling.  */  
   RMALine:number,
      /**  Project ID of the Project table record that this OrderDtl record. Can be blank.  */  
   ProjectID:string,
      /**  Contract Number of the related Service Contract when the LineType field is "CONTRACT"  */  
   ContractNum:number,
      /**  A unique code that identifies the Service Contract when the Line Type is "CONTRACT"  */  
   ContractCode:string,
      /**  The part number used to identify the configured part number initially entered on the line.  */  
   BasePartNum:string,
      /**  Indicate that the item or the product group has a warranty.  */  
   Warranty:boolean,
      /**  Unique code for the Warranty that ties this record to a type of warranty.  Found on either the Part or ProdGrup table.  */  
   WarrantyCode:string,
      /**  The # of days, months, years the material is covered by warranty  */  
   MaterialDuration:number,
      /**  The # of days, months, years the Labor is covered by warranty  */  
   LaborDuration:number,
      /**  The # of days, months, years the Misc. Charges are covered by warranty  */  
   MiscDuration:number,
      /**  Whether the duration of warranty  is for "Days"," Months", "Years".  */  
   MaterialMod:string,
      /**  Whether the duration of warranty  is "Days"," Months"," years".  */  
   LaborMod:string,
      /**  Editor widget for Warranty comments.  */  
   WarrantyComment:string,
      /**  This warranty covers On site visits  */  
   Onsite:boolean,
      /**  Are Material cost covered  */  
   MatCovered:boolean,
      /**  Is Labor Cost Covered  */  
   LabCovered:boolean,
      /**  Are misc. Costs Covered  */  
   MiscCovered:boolean,
      /**  Unit of measure (how it is sold/issued).  Use the default Part.SUM if its a valid Part else use the global variable Def-UM which is established from XaSyst.DefaultUM.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  Represents one of the requested Order Quantities for the line item using OrderDtl.SUM.  */  
   SellingQuantity:number,
      /**  A Cod which uniquely identfies SalesCat record. Can't be blank.  */  
   SalesCatID:string,
      /**  Indicates if the order line must be shipped complete.  That is, as an orders release are selected for picking during the Auto Pick process of the Order Allocation program, the all releases of the line with a ship date <= the given cutoff date also have to be picked complete otherwise they will not be selected. This is defaulted to Yes when Customer.ShippingQualifier = "L" (Ship Order line 100% complete) and OrderHed.ShipOrderComplete = No. This field is disabled and set to No if the OrderHed.ShipOrderComplete = Yes.  */  
   ShipLineComplete:boolean,
      /**  Quantity from last EDI update.  */  
   CumeQty:number,
      /**  Date of last update  */  
   CumeDate:string,
      /**  The related Marketing Campaign ID. Mirror image of the QuoteHed.MkthCampaignID. Maintainable via order entry if not related to a quote and the CRM module is installed.  */  
   MktgCampaignID:string,
      /**   Link to the marketing event associated with this record.
The related Marketing Event Sequence. Mirror image of the QuoteHed.MktgEventSeq. Maintainable via order entry if not related to a quote and the CRM module is installed.  */  
   MktgEvntSeq:number,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the order quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   LockQty:boolean,
      /**  Indicates if this order line is linked to an inter-company PO line.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   ICPONum:number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   ICPOLine:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  The date when the configuration was completed for the assembly.  */  
   LastConfigDate:string,
      /**  The system time when the configuration was completed for the assembly.  */  
   LastConfigTime:number,
      /**  The User ID of the last user to complete the configuration of the assembly.  */  
   LastConfigUserID:string,
      /**   Same as Unit price except that this field contains the unit price computed from the input based pricing in a configuration.
If price breaks exist this price should be used as the base price instead of the one found in the part table.  */  
   ConfigUnitPrice:number,
      /**  This is the base price for inputs based pricing of a configuration.  The price of inputs are added to this price to get the ConfigUnitPrice.  */  
   ConfigBaseUnitPrice:number,
      /**  This is the Price List used to determine the starting base price.  */  
   PriceListCode:string,
      /**  This is the Price List used to determine the break % or amount.  */  
   BreakListCode:string,
      /**  The Order Quantity (total qty of related order lines) used to find price when quantity based discounting is applied.  */  
   PricingQty:number,
      /**  Indicates if the price of the order line can be changed.  */  
   LockPrice:boolean,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied.  */  
   ListPrice:number,
      /**   Same as List price except that this field contains the list price in
the customer currency (converted using the exchange rate on OrderHed).  */  
   DocListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied.  */  
   OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency (converted using the exchange rate on OrderHed).  */  
   DocOrdBasedPrice:number,
      /**  This is the Price Group ID used to price the order line with.  */  
   PriceGroupCode:string,
      /**  Indicates if the user selected a price list different from the default.  */  
   OverridePriceList:boolean,
      /**  The revision number used to identify the configured part/revision number initially entered on the line.  */  
   BaseRevisionNum:string,
      /**  The Order Value (total extended price of related order lines) used to find order value break when value based discounting is applied.  */  
   PricingValue:number,
      /**  This field controls the order in which Sales Order lines are displayed.  Display Seq is a decimal number where the whole number portion is used to sequence normal sales order lines and the decimal portion is used to sequence kit components under their associated kit parent.  */  
   DisplaySeq:number,
      /**  The sales order line number of the parent kit item.  This is only relevent for sales order lines which are kit parent or component lines.  If the KitParentLine equals the OrderLine then this is a kit parent line.  */  
   KitParentLine:number,
      /**  Indicates if component lines can be added, deleted and modified during Sales Order entry.  This field is only relevant for sales order lines which are kit parents.  */  
   KitAllowUpdate:boolean,
      /**  Indicates if the parent kit part must be shipped complete of if kit components can be shippped in varying degrees of completeness.  This field is only relevant for sales order lines which are kit parents. If this field is set to "No" then KitPricing must be set to "P".  */  
   KitShipComplete:boolean,
      /**  Indicates if all components are to be backflushed when a kit parent part is shipped.  This field is only relevant for sales order lines which are kit parents.  */  
   KitBackFlush:boolean,
      /**  Indicates if kit components are to be printed on packing slips.  If KitShipComplete is "Yes", then this field must be set to "YES" as well.  This field is only relevant for sales order lines which are kit parents.  */  
   KitPrintCompsPS:boolean,
      /**  Indicates if kit components are to be printed on invoices.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  This field is only relevant for sales order lines which are kit parents.  */  
   KitPrintCompsInv:boolean,
      /**  Indicates how kits will be priced.  Values are P = Parent Pricing (The price is obtained from the sales price for the kit parent item), C = Component Pricing (The price is obtained from a rollup of kit component items).  This field is only relevant for sales order lines which are kit parents.  */  
   KitPricing:string,
      /**  Component quantity required to fulfill one kit parent.  This field is only relevant on a sales order line which is a kit component.  */  
   KitQtyPer:number,
      /**  Indicates how Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate1:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate2:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate3:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate4:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate5:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit1:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit2:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit3:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit4:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit5:number,
      /**  The Demand Contract Detail record this OrderDtl is related to.  */  
   DemandContractLine:number,
      /**  Create New Job flag  */  
   CreateNewJob:boolean,
      /**  The date before which the order cannot be shipped.  */  
   DoNotShipBeforeDate:string,
      /**  Get Details flag  */  
   GetDtls:boolean,
      /**  The date after which the order cannot be shipped.  */  
   DoNotShipAfterDate:string,
      /**  Schedule Job flag  */  
   SchedJob:boolean,
      /**  Release Job flag  */  
   RelJob:boolean,
      /**  Enable New Job flag  */  
   EnableCreateNewJob:boolean,
      /**  Enable Get Details flag  */  
   EnableGetDtls:boolean,
      /**  Enable Schedule Job flag  */  
   EnableSchedJob:boolean,
      /**  Enable Release Job flag  */  
   EnableRelJob:boolean,
      /**  Indicates the warehouse selected for a counter sale order line.  */  
   CounterSaleWarehouse:string,
      /**  Identifies the Bin selected for a counter sale order line.  */  
   CounterSaleBinNum:string,
      /**  Indicates the lot number selected for a counter sale order line.  */  
   CounterSaleLotNum:string,
      /**  Indicates the dimension code selected for a counter sales order line.  */  
   CounterSaleDimCode:string,
      /**  Indicates if the demand detail that created/updated this order line has been rejected.  */  
   DemandDtlRejected:boolean,
      /**   A character flag field used to differentiate between regular sales order line, Sales Kit parent order line and Sales Kit component order line.
P = Sales Kit Parent line
C = Sales Kit Component Line
Null = regular line  */  
   KitFlag:string,
      /**  Indicates if the kit components have been automatically loaded.  If set to false the user interface will attempt to load the kit components after the user saves a new order line.  */  
   KitsLoaded:boolean,
      /**  The demand contract this demand is for.  */  
   DemandContractNum:number,
      /**  This field along with Company and DemandContractNum make up the unique key to the table. The system should generate this number during entry of new header records. The system determines next available number by finding the last DemandHead for the DemandContractNum and adding 1.  */  
   DemandHeadSeq:number,
      /**  This field along with Company, DemandContractNum and DemandHeadSeq make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the last DemandDetail record for the DemandHead and the adding 1 to it.  */  
   DemandDtlSeq:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Reverse Charge.  */  
   ReverseCharge:boolean,
      /**  Total Number of releases for the line  */  
   TotalReleases:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt1UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt2UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt3UnitPrice:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt1Discount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt2Discount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt3Discount:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   Rpt1AdvanceBillBal:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   Rpt2AdvanceBillBal:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   Rpt3AdvanceBillBal:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1ListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2ListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3ListPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3OrdBasedPrice:number,
      /**  Extended Price for the order line item, rounded according to the Base currency Round rule  */  
   ExtPriceDtl:number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule  */  
   DocExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt1ExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt2ExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt3ExtPriceDtl:number,
      /**  Status of Order Line  */  
   LineStatus:string,
      /**   If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table. Assumed to include taxes  */  
   InUnitPrice:number,
      /**  Same as DocUnit price except that this field contains the unit price including taxes  */  
   DocInUnitPrice:number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * InUnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, InUnitPrice or OrderQty fields are changed.  - includes taxes  */  
   InDiscount:number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * InUnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, InUnitPrice or OrderQty fields are changed. - includes taxes  */  
   DocInDiscount:number,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied. including taxes  */  
   InListPrice:number,
      /**   Same as List price except that this field contains the list price in
the customer currency -including taxes.  */  
   DocInListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied. including taxes  */  
   InOrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency - including taxes.  */  
   DocInOrdBasedPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt1InUnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt2InUnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt3InUnitPrice:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt1InDiscount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt2InDiscount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt3InDiscount:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1InListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2InListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3InListPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1InOrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2InOrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3InOrdBasedPrice:number,
      /**  Extended Price for the order line item, rounded according to the Base currency Round rule - Taxes are Included  */  
   InExtPriceDtl:number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule - Taxes Included  */  
   DocInExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt1InExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt2InExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt3InExtPriceDtl:number,
      /**  Used to store selling open quantity value setting assigned in product configuration programs  */  
   OldOurOpenQty:number,
      /**  Used to store selling open quantity value setting assigned in product configuration programs  */  
   OldSellingOpenQty:number,
      /**  Used to store open value setting assigned in product configuration programs  */  
   OldOpenValue:number,
      /**  Used to store prod code value assigned in product configuration programs  */  
   OldProdCode:string,
      /**  Previous Selling Quantity  */  
   PrevSellQty:number,
      /**  Previous Part Number  */  
   PrevPartNum:string,
      /**  Previous Customer Part Number  */  
   PrevXPartNum:string,
      /**  The original material sequence of this kit component under the kit parent part.  */  
   KitCompOrigSeq:number,
      /**  The original kit component part number prior to processing any configurator rule programs  */  
   KitCompOrigPart:string,
      /**  If TRUE then this field will mean that the smart string has already been processed  */  
   SmartStringProcessed:boolean,
      /**  Original smart string passed in for configuration  */  
   SmartString:string,
      /**  Contract renewal number. If the value is zero then the contract is not for a renewal.  */  
   RenewalNbr:number,
   DiscBreakListCode:string,
   DiscListPrice:number,
   LockDisc:boolean,
   OverrideDiscPriceList:boolean,
      /**  GroupSeq  */  
   GroupSeq:number,
      /**  ECCOrderNum  */  
   ECCOrderNum:string,
      /**  ECCOrderLine  */  
   ECCOrderLine:number,
      /**  DupOnJobCrt  */  
   DupOnJobCrt:boolean,
      /**  UndersPct  */  
   UndersPct:number,
      /**  Overs  */  
   Overs:number,
      /**  Unders  */  
   Unders:number,
      /**  OversUnitPrice  */  
   OversUnitPrice:number,
      /**  PlanUserID  */  
   PlanUserID:string,
      /**  PlanGUID  */  
   PlanGUID:string,
      /**  MOMsourceType  */  
   MOMsourceType:string,
      /**  MOMsourceEst  */  
   MOMsourceEst:string,
      /**  DefaultOversPricing  */  
   DefaultOversPricing:string,
      /**  ECCPlant  */  
   ECCPlant:string,
      /**  ECCQuoteNum  */  
   ECCQuoteNum:string,
      /**  ECCQuoteLine  */  
   ECCQuoteLine:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  MfgJobType  */  
   MfgJobType:string,
      /**  ProFormaInvComment  */  
   ProFormaInvComment:string,
      /**  CreateJob  */  
   CreateJob:boolean,
      /**  The identifier of the planning contract.  */  
   ContractID:string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the planning of the Contract.  */  
   LinkToContract:boolean,
      /**  DocInAdvanceBillBal  */  
   DocInAdvanceBillBal:number,
      /**  InAdvanceBillBal  */  
   InAdvanceBillBal:number,
      /**  Rpt1InAdvanceBillBal  */  
   Rpt1InAdvanceBillBal:number,
      /**  Rpt2InAdvanceBillBal  */  
   Rpt2InAdvanceBillBal:number,
      /**  Rpt3InAdvanceBillBal  */  
   Rpt3InAdvanceBillBal:number,
      /**  PCLinkRemoved  */  
   PCLinkRemoved:boolean,
      /**  CommodityCode  */  
   CommodityCode:string,
      /**  Base price before any price breaks and discounts  */  
   MSRP:number,
      /**  Same as MSRP except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   DocMSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   Rpt1MSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   Rpt2MSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   Rpt3MSRP:number,
      /**  Distributor end customer price.  */  
   EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   DocEndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   Rpt1EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   Rpt2EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   Rpt3EndCustomerPrice:number,
      /**  Promotional Price offered to Dealer and Distributors.  */  
   PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   DocPromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   Rpt1PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   Rpt2PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   Rpt3PromotionalPrice:number,
      /**  Current status of line.  This is a maintainable status through Order Line Status maintenance.  Depending on the setting can control is line is updatable from the web.  */  
   OrderLineStatusCode:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  Used specifically for Deal Portal and Location Inventory, not for Inventory Tracked Attributes.  */  
   AttributeSetID:number,
      /**  The unique identifier of the related CPQ Configured Quote Product.  */  
   KBConfigProdID:number,
      /**  The unique identifier of the related original CPQ Configured Quote Product.  */  
   KBOriginalConfigProdID:number,
      /**  TotalCovenantDiscount  */  
   TotalCovenantDiscount:number,
      /**  DocCovenantDiscount  */  
   DocCovenantDiscount:number,
      /**  Rpt1CovenantDiscount  */  
   Rpt1CovenantDiscount:number,
      /**  Rpt2CovenantDiscount  */  
   Rpt2CovenantDiscount:number,
      /**  Rpt3CovenantDiscount  */  
   Rpt3CovenantDiscount:number,
      /**  TotalInCovenantDiscount  */  
   TotalInCovenantDiscount:number,
      /**  DocInCovenantDiscount  */  
   DocInCovenantDiscount:number,
      /**  Rpt1InCovenantDiscount  */  
   Rpt1InCovenantDiscount:number,
      /**  Rpt2InCovenantDiscount  */  
   Rpt2InCovenantDiscount:number,
      /**  Rpt3InCovenantDiscount  */  
   Rpt3InCovenantDiscount:number,
   AvailableQuantity:number,
      /**  Available Price Lists  */  
   AvailPriceLists:string,
   AvailUMFromQuote:string,
   BaseCurrencyID:string,
   BaseCurrSymbol:string,
      /**  Default calculated unit price for a particular part/customer.  Used with integrations for pre-order price validations.  */  
   CalcUnitPrice:number,
   ConfigType:string,
   Configured:string,
   CounterSale:boolean,
      /**  The message text returned by the credit check process.  */  
   CreditLimitMessage:string,
      /**  The source that put the customer on credit hold.  */  
   CreditLimitSource:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencyID:string,
   CurrencySwitch:boolean,
   CurrSymbol:string,
   DemandQuantity:number,
   DimCode:string,
   DimConvFactor:number,
      /**  Document currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DocDspDiscount:number,
      /**  Document currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DocDspUnitPrice:number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule  */  
   DocExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in document currency  */  
   DocInMiscCharges:number,
      /**  The amount of discount for display in document currency which does not include taxes  */  
   DocLessDiscount:number,
   DocMiscCharges:number,
      /**  Total tax in Doc currency. The sum of all the tax details for the line (OrderRelTax).  */  
   DocTaxAmt:number,
   DocTotalPrice:number,
      /**  Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DspDiscount:number,
      /**  To display the type of job this is: MFG = Manufacturing, PRJ = Project  */  
   DspJobType:string,
      /**  Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DspUnitPrice:number,
   DUM:string,
      /**  Web basket configuration related SysRowID  */  
   ECCConfigSysRowId:string,
      /**  Additional discount calculated by ECC  */  
   ECCDiscount:number,
      /**  Prevents Epicor repricing the unit price coming from ECC.  This usually would be a result of Epicor going off-line and order pricing was performed by ECC.  */  
   ECCPreventRepricing:boolean,
      /**  Allow enable/disable for the button Attibutes in Order Line  */  
   EnableDynAttrButton:boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   EnableKitUnitPrice:boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   EnableRenewalNbr:boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   EnableSellingQty:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
   ExtPrice:number,
   FromQuoteLineFlag:boolean,
      /**  Installation price of an equipment that requires installation in Epicor FSA. This value by default is inherited from the part but it could be overridden for another value if it's necessary.  */  
   FSAInstallationCost:number,
   FSAInstallationOrderLine:number,
   FSAInstallationOrderNum:number,
      /**  Indicates if the equipment requires an installation prior being marked as “Installed” on a Location in Epicor FSA. If true, at shipment it will create a service order for the installation service in FSA.  */  
   FSAInstallationRequired:boolean,
      /**  Indicates the service order template ID that Epicor FSA will use to create the installation service order.  */  
   FSAInstallationType:string,
   FSAInstallationTypeDescription:string,
      /**  Indicates whether the part has at least one Complement  */  
   HasComplement:boolean,
      /**  Indicates whether the part has at least one Downgrade  */  
   HasDowngrade:boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   HasSubstitute:boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   HasUpgrade:boolean,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line  */  
   InMiscCharges:number,
      /**  The flag to indicate if the Order Header Tax Liability is Tax Inclusive Pricing.  */  
   InPrice:boolean,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
      /**  Inventory UOM that the Order Detail is allocated against.  */  
   InvtyUOM:string,
   JobTypeDesc:string,
      /**  If the Job has been already created against this line.  */  
   JobWasCreated:boolean,
      /**  If Kit Flag = P then sets this field to the value of the related PartPlant.KitAllowChangeParms. If KitFlag <> P then this will be FALSE.  */  
   KitChangeParms:boolean,
      /**  Will be set to true if the current OrderDtl record is KitFlag = 'C' and the KitParent of this record is KitAllowUpdate = NO  */  
   KitDisable:boolean,
      /**  Kit Flag Description. "P" = Parent, "C" = Component.  */  
   KitFlagDescription:string,
   KitOrderQtyUOM:string,
      /**  If KitFlag = "C" and the parent kit line is configured OR if KitFlag = "P" and Configured = "On" then this field will be TRUE, otherwise it will be false.  */  
   KitStandard:boolean,
      /**  The amount of discount for display which does not include taxes  */  
   LessDiscount:number,
   LotNum:string,
   MiscCharges:number,
   MultipleReleases:boolean,
   OnHandQuantity:number,
   PartExists:boolean,
   PartTrackDimension:boolean,
   PartTrackLots:boolean,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   POLineRef:string,
   PriceListCodeDesc:string,
   ProcessCounterSale:boolean,
   ProcessQuickEntry:boolean,
   QuoteQtyNum:number,
      /**  For this Detail line there is Release line that has Project and Phase and these Project or Phase was invoiced or used in revenue recognition.  */  
   RelWasRecInvoiced:boolean,
      /**  Pass Credit Limit check message to the UI  */  
   RespMessage:string,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt1DspDiscount:number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt1DspUnitPrice:number,
      /**  Extended Price for the Order Line in Rpt1 currency  */  
   Rpt1ExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   Rpt1InMiscCharges:number,
      /**  The amount of discount for display which does not include taxes (report currency)  */  
   Rpt1LessDiscount:number,
      /**  Report currency misc charges  */  
   Rpt1MiscCharges:number,
      /**  Report currency line tax amount  */  
   Rpt1TaxAmt:number,
      /**  Report currency line total price  */  
   Rpt1TotalPrice:number,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt2DspDiscount:number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt2DspUnitPrice:number,
      /**  Extended Price for the orderLine in Rpt2 currency.  */  
   Rpt2ExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   Rpt2InMiscCharges:number,
      /**  The amount of discount for display in report currency which does not include taxes (report currency)  */  
   Rpt2LessDiscount:number,
      /**  Report currency misc charges  */  
   Rpt2MiscCharges:number,
      /**  Report currency line tax amount  */  
   Rpt2TaxAmt:number,
      /**  Report currency line total price  */  
   Rpt2TotalPrice:number,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt3DspDiscount:number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt3DspUnitPrice:number,
      /**  Extended price for the order line in Rpt3 currency  */  
   Rpt3ExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   Rpt3InMiscCharges:number,
      /**  The amount of discount for display in report currency which does not include taxes (report currency)  */  
   Rpt3LessDiscount:number,
      /**  Report Currency misc charges  */  
   Rpt3MiscCharges:number,
      /**  Report currency line tax amount  */  
   Rpt3TaxAmt:number,
      /**  Report currency line total price  */  
   Rpt3TotalPrice:number,
   SalesRepName1:string,
   SalesRepName2:string,
   SalesRepName3:string,
   SalesRepName4:string,
   SalesRepName5:string,
      /**  Total tax in base currency. The sum of all the tax details for the line.  */  
   TaxAmt:number,
      /**  The Sales Order Quantity expressed in the Inventory Unit of Measure  */  
   ThisOrderInvtyQty:number,
   TotalPrice:number,
   TotalShipped:number,
   WarehouseCode:string,
   WarehouseDesc:string,
   BinNum:string,
      /**  Attribute class is MRP Planned but AttributeSetID has not been set on releases.  */  
   AttributeMismatch:boolean,
      /**  A string containing the parameters needed to run Job Manager  */  
   JobManagerString:string,
      /**  Default calculated order value based discounts unit price for a particular part/customer.  Used with integrations for pre-order price validations.  */  
   CalcOrdBasedPrice:number,
      /**  At least 1 OrderRel for OrderDtl has a PONum assigned.  */  
   SalesOrderLinked:boolean,
      /**  This external column is to be used for the purpose of adding an OrderDtl for a part that has Track Inventory Attributes, allowing the AttributeSetID to be passed in with the line to be included on the OrderRel within the same update method call.  */  
   InventoryAttributeSetID:number,
   BitFlag:number,
   CommodityCodeDescription:string,
   ContractCodeContractDescription:string,
   CustNumSendToFSA:boolean,
   CustNumBTName:string,
   CustNumCustID:string,
   CustNumName:string,
   DiscBreakListCodeListDescription:string,
   DiscBreakListCodeEndDate:string,
   DiscBreakListCodeStartDate:string,
   MktgCampaignIDCampDescription:string,
   MktgEvntEvntDescription:string,
   OrderNumBTCustNum:number,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
   PartNumSendToFSA:boolean,
   PartNumTrackInventoryByRevision:boolean,
   PartNumAttrClassID:string,
   PartNumSalesUM:string,
   PartNumPricePerCode:string,
   PartNumTrackSerialNum:boolean,
   PartNumPartDescription:string,
   PartNumIUM:string,
   PartNumTrackLots:boolean,
   PartNumSellingFactor:number,
   PartNumTrackDimension:boolean,
   PartNumDefaultAttributeSetID:number,
   PartNumFSAEquipment:boolean,
   PartNumTrackInventoryAttributes:boolean,
   PriceBreakListDescription:string,
   PriceBreakStartDate:string,
   PriceBreakEndDate:string,
   ProdCodeDescription:string,
   ProjectIDDescription:string,
   QuoteNumCurrencyCode:string,
   SalesCatIDDescription:string,
   TaxCatIDDescription:string,
   WarrantyCodeWarrDescription:string,
      /**  RowMod  */  
   RowMod:string,
   UD_SysRevID:string,
   Phase_c:string,
   ItemID_c:string,
   TypeCode_c:string,
   OrigTypeCode_c:string,
   PhaseID_c:string,
   SalesCatID_c:string,
   IndustryShipDate_c:string,
   CreateDate_c:string,
   PriceUpdateDate_c:string,
   CreatedBy_c:string,
   UpdatedBy_c:string,
}

export interface Erp_Tablesets_OrderHedAttchRow{
   Company:string,
   OrderNum:number,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderHedListRow{
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   OpenOrder:boolean,
      /**   Indicates that the Order item was closed before any shipments were made against it. Normally the Orders are closed as part of the Shipping process when all the releases have been closed.  By using the "Close Order" menu option the user can close the Order manually, to provide the function to "Cancel"  the order when the customer cancels there request.  If the Order item had no shipments made it is then marked as "voided". Regardless of shipment activity the Order is always marked as closed (OpenOrder = No).
When an OrderHed record is 'voided/closed' all of it's related OrderDtl and OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   VoidOrder:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   OrderNum:number,
      /**  Contains the Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   CustNum:number,
      /**  This is an optional field used to enter the customers Purchase Order Number.  This will be used as an alternate index for searching Orders by PO number.  */  
   PONum:string,
      /**  Indicates if an order is flagged as being "HELD" , this  is primarily used as a visual indicator in shipping entry. It does not prevent shipments from being entered for this order.  */  
   OrderHeld:boolean,
      /**  Mandatory entry and must be valid. Default as the system date.  */  
   OrderDate:string,
      /**  Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   DepositBal:number,
      /**  Display value contains the deposit balance in the customer's currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   DocDepositBal:number,
      /**  Date customer needs the items on this order to arrive.  This is used only as the default value for the NeedByDate when creating order detail line items.  This can be left blank.  */  
   NeedByDate:string,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**  Bill To Customer Number  */  
   BTCustNum:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   CustOnCreditHold:boolean,
   CustomerBTName:string,
   CustomerCustID:string,
   CustomerName:string,
      /**  BTCustNumCustID  */  
   BTCustNumCustID:string,
      /**  BTCustNumName  */  
   BTCustNumName:string,
      /**  DemandContract  */  
   DemandContract:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderHedListTableset{
   OrderHedList:Erp_Tablesets_OrderHedListRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_OrderHedRow{
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   OpenOrder:boolean,
      /**   Indicates that the Order item was closed before any shipments were made against it. Normally the Orders are closed as part of the Shipping process when all the releases have been closed.  By using the "Close Order" menu option the user can close the Order manually, to provide the function to "Cancel"  the order when the customer cancels there request.  If the Order item had no shipments made it is then marked as "voided". Regardless of shipment activity the Order is always marked as closed (OpenOrder = No).
When an OrderHed record is 'voided/closed' all of it's related OrderDtl and OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   VoidOrder:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   OrderNum:number,
      /**  Contains the Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   CustNum:number,
      /**  This is an optional field used to enter the customers Purchase Order Number.  This will be used as an alternate index for searching Orders by PO number.  */  
   PONum:string,
      /**  Indicates if an order is flagged as being "HELD" , this  is primarily used as a visual indicator in shipping entry. It does not prevent shipments from being entered for this order.  */  
   OrderHeld:boolean,
      /**   This is used as one of the selection parameters on the Order entry edit reports. The intent is for users to be able to select orders that they have entered for hard copy edit.

On new orders use the users login ID as the default. They can override this if they wish to enter something more meaningful.  */  
   EntryPerson:string,
      /**  Indicates which customer ship to is to be used as the default for the Order release records for this order. It  can be blank or it must be valid in the SHIPTO table. Use the CUSTOMER.SHIPTONUM as the default on new orders or when the ORDERHED.CUSTNUM is changed.  */  
   ShipToNum:string,
      /**  Date that the items need to be shipped by to meet the customers NeedByDate.  This can be left blank, it is only used to supply a default for OrderDtl.RequestDate.  */  
   RequestDate:string,
      /**  Mandatory entry and must be valid. Default as the system date.  */  
   OrderDate:string,
      /**  An optional field that describes the FOB policy.  */  
   FOB:string,
      /**  Contains the key value of the record in the "SHIPVIA" table. It can be left blank or must be valid in the 'SHIPTO"  table.
Use the CUSTOMER.SHIPVIA as the default when the ORDER.CUSTNUM field is changed and the ORDERHED.SHIPTO is blank. Use SHIPTO.SHIPVIA when ORDER.CUSTNUM or ORDERHED.SHIPTO fields are changed and the ORDERHED.SHIPTO is not blank.  */  
   ShipViaCode:string,
      /**   Contains the key value of the record in the TERMS table which indicates the sales terms established for this order. On change of ORDERHED.CUSTNUM use the CUSTOMER.TERMS

field as the default.  */  
   TermsCode:string,
      /**  Used to establish a discount percent value which will be used as a default during order detail line entry. It can be left as zero.  Use the CUSTOMER.DISCOUNTPERCENT field as a default. Refreshed whenever ORDERHED.CUSTOMER field changes.  */  
   DiscountPercent:number,
      /**  Contains the key  value for the Purchasing Contact. This can be blank or it must be valid in the CUSTCNT  table. Use the CUSTOMER.PRIMPCON as the default.  */  
   PrcConNum:number,
      /**  Establishes the Shipping Contact to be used as default on the Order release records. Contains the key value for the shipping contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table. Use the Customer.PrimScon as a default.  */  
   ShpConNum:number,
      /**  Stores the Sales Rep Codes for the order. Up to five codes can be  established. This field is not directly maintainable. Instead temp widgets are used for entry of each individual code and then put together as one comma delimited string field and assigned to this field.  This field will have a Word index, it then will make reporting and data base integrity checking much easier through the use of the "contains phrase" when retrieving records. These codes can be left blank or must be valid in the SalesRep master. The first one is defaulted from the Customer master if ship to is blank; otherwise, from the Ship To.  */  
   SalesRepList:string,
      /**  Contains comments about the overall order. These will be printed on the Sales Acknowledgements.  */  
   OrderComment:string,
      /**  Used to establish shipping comments about the overall order. These will copied into the packing slip header file as defaults.  */  
   ShipComment:string,
      /**  Used to establish invoice comments about the overall order. These will copied into the Invoice detail file as defaults.  */  
   InvoiceComment:string,
      /**  Contains picking  comments about the overall order. These will be printed on the picking lists.  */  
   PickListComment:string,
      /**  Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   DepositBal:number,
      /**  Display value contains the deposit balance in the customer's currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   DocDepositBal:number,
      /**  Date customer needs the items on this order to arrive.  This is used only as the default value for the NeedByDate when creating order detail line items.  This can be left blank.  */  
   NeedByDate:string,
      /**  Indicates that the credit hold was overridden for this order.  */  
   CreditOverride:boolean,
      /**  The USERID of the user that overrode an order credit hold (system set).  */  
   CreditOverrideUserID:string,
      /**  The date that the user last overrode the customer credit hold (system set).  */  
   CreditOverrideDate:string,
      /**  The time that the user last overrode the customer credit hold in HH:MM:SS format (system set).  */  
   CreditOverrideTime:string,
      /**  The authorized maximum dollar limit that an order for a credit held customer is approved for.  Initially defaulted to the current order amount when the order is credit hold overridden.  The order amount is calculated by using line information only (i.e. extended amount and discounts) - deposits, advance billings, shipments and miscellaneous charges are NOT considered.  */  
   CreditOverrideLimit:number,
      /**  Controls if an alert is to be sent when shipments are made for this order.  */  
   SndAlrtShp:boolean,
      /**   Exchange rate that will be used for this order.  Defaults from
CurrRate.CurrentRate. Conversion rates will be calculated as System Base = Foreign value * rate, Foreign value = system base * (1/rate). This is the dollar in foreign currency from the exchange rate tables in the newspapers.  */  
   ExchangeRate:number,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**  Used with the currency module.  When TRUE the currency rate can be changed by the user and cannot be changed by the system.  This will also be the default for the invoice.  */  
   LockRate:boolean,
      /**  The member's name on the credit card.  */  
   CardMemberName:string,
      /**  The credit card account identifier.  */  
   CardNumber:string,
      /**  A code assigned by the user to uniquely identify a Credit Card Type master. This can't be blank.  */  
   CardType:string,
      /**  The expiration month of the credit card.  */  
   ExpirationMonth:number,
      /**  The expiration year of the credit card.  */  
   ExpirationYear:number,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention.  */  
   CardID:string,
      /**  Up to 17 alphnumeric characters provided by customer. This is used to track information on customer spending (e.g., cost center, project code). This field is especially critical, since inaccurate information will affect the general ledger. If no reference number is provided, leave this field blank.  */  
   CardmemberReference:string,
      /**  Code used to relate a AllocPri record to the order.  Defaulted from Customer.AllocPriorityCode.  */  
   AllocPriorityCode:string,
      /**  Code used to relate a ReservePri record to the order.  Defaulted from Customer.ReservePriorityCode.  */  
   ReservePriorityCode:string,
      /**  Indicates if the order must be shipped complete.  That is, as an orders release are selected for picking during the Auto Pick process of the Order Allocation program, the all releases with a ship date <= the given cutoff date alos have to be picked complete otherwise they will not be selected. This is defaulted to Yes when Customer.ShippingQualifier = "O" (Ship Order 100% complete)  */  
   ShipOrderComplete:boolean,
      /**  Not editable, When SF Synch creates orders, this flag is set to YES.  */  
   WebOrder:boolean,
      /**  Updated Via SF Synch.  This is the authorization number from a third party credit card validation service.  */  
   CCApprovalNum:string,
      /**  Order created from EDI interfaced module.  */  
   EDIOrder:boolean,
      /**  Updated from EDI module if 855 or 865 created.  */  
   EDIAck:boolean,
      /**  Indicates if this order header is linked to an inter-company PO header.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number that uniquely identifies the purchase order.  */  
   ICPONum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  This is the web-login-id (email address) of the person that placed the order.  */  
   WebEntryPerson:string,
      /**  Indicates whether the email acknowledgement of the order has been sent.  (For web orders)  */  
   AckEmailSent:boolean,
      /**  Indicates if order based discounting needs to be applied to the order.  */  
   ApplyOrderBasedDisc:boolean,
      /**  Indicates if order based discounting should be applied automatically or manually triggered by user as menu option.  */  
   AutoOrderBasedDisc:boolean,
      /**   Indicates Entry method program that used to create the order.
S = Standard, Q = Quick Entry,  C = Counter Sales, D = Demand/EDI  */  
   EntryMethod:string,
      /**  The help desk case that created this order.  */  
   HDCaseNum:number,
      /**  Flag used in sales order entry for counter sales orders.  */  
   CounterSale:boolean,
      /**  Create AR Invoice for counter sales order.  */  
   CreateInvoice:boolean,
      /**  Create Packing Slip for counter sale.  */  
   CreatePackingSlip:boolean,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the order quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   LockQty:boolean,
      /**  Stores the encrypted credit card number  */  
   ProcessCard:string,
      /**  Credit Transaction Amount, makes up part of CCTotal  */  
   CCAmount:number,
      /**  Credit Card transaction freight amount, part of CCTotal  */  
   CCFreight:number,
      /**  Credit Card Transaction Tax amount, part of CCTotal  */  
   CCTax:number,
      /**  Total amount being sent to the credit card processor  */  
   CCTotal:number,
      /**  See CCAmount  */  
   CCDocAmount:number,
      /**  See CCFreight  */  
   CCDocFreight:number,
      /**  See CCTax  */  
   CCDocTax:number,
      /**  See CCTotal  */  
   CCDocTotal:number,
      /**  Address used during AVS validation for credit transactions  */  
   CCStreetAddr:string,
      /**  Zip used during AVS validation in credit transactions  */  
   CCZip:string,
      /**  Bill To Customer Number  */  
   BTCustNum:number,
      /**  New database field as it can be changed by user.  Default is set to BTCustNum?s primary billing contact.  If a primary billing contact is not set, default is ?None Selected?.  Keep in mind the BTCustNum field may be the same as CustNum (SoldTo) but the default would still be this customer?s primary billing contact where the ConNum field (Contact for sold to) is defaulting the primary purchasing contact.  */  
   BTConNum:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate4:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate5:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit1:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit2:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit3:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit4:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit5:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate1:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate2:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate3:number,
      /**  Incremented whenever an outbound sales document is generated from the order, i.e. Sales Order Acknowledgement, Response to Change, etc.  */  
   OutboundSalesDocCtr:number,
      /**  Incremented whenever an outbound shipping document is generated from the order, i.e. ASN.  */  
   OutboundShipDocsCtr:number,
      /**  The demand contract this OrderHed is related to.  */  
   DemandContractNum:number,
      /**  The date before which the order cannot be shipped.  */  
   DoNotShipBeforeDate:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  The date after which the order cannot be shipped.  */  
   DoNotShipAfterDate:string,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  The date after which the sales order should be canceled.  */  
   CancelAfterDate:string,
      /**  Indicates if the demand that created/updated this order has been rejected.  */  
   DemandRejected:boolean,
      /**  Override Carrier Defaults.  If not checked then the Site values will be used  */  
   OverrideCarrier:boolean,
      /**  Override Service Options.  If not checked then the Site values will be used  */  
   OverrideService:boolean,
      /**  Indicates if the Order is a credit card order  */  
   CreditCardOrder:boolean,
      /**  This field along with Company and DemandContractNum make up the unique key to the table. The system should generate this number during entry of new header records. The system determines next available number by finding the last DemandHead for the DemandContractNum and adding 1.  */  
   DemandHeadSeq:number,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   PayFlag:string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   PayAccount:string,
      /**  Shipping Bill To. The first line of the Payers main address. Required when Pay Flag is Third party.  */  
   PayBTAddress1:string,
      /**  Shipping Bill To.  The second line of the Payers main address. An address is required when Pay Flag is Third party  */  
   PayBTAddress2:string,
      /**  Shipping, The city portion of the Payer main address.  */  
   PayBTCity:string,
      /**  The state or province portion of the shipment payer main address.  */  
   PayBTState:string,
      /**  The zip or postal code portion of the shipping payers main address.  */  
   PayBTZip:string,
      /**  The country of the main shipping payers address.  */  
   PayBTCountry:string,
      /**  Freight charges will not be returned if 'yes'  */  
   DropShip:boolean,
      /**  Added for international shipping  */  
   CommercialInvoice:boolean,
      /**  Added for international shipping. Shipper's Export Declaration  */  
   ShipExprtDeclartn:boolean,
      /**  For International shipping.  Certificate of Orgin.  */  
   CertOfOrigin:boolean,
      /**  For International shipping.  Shipper's Letter of Instruction.  */  
   LetterOfInstr:boolean,
      /**  International Shipping. Frieght Forwarder ID  */  
   FFID:string,
      /**  International Shipping. The first line of the Frieght Forwarder main address.  */  
   FFAddress1:string,
      /**  International Shipping. The second line of the Frieght Forwarder main address.  */  
   FFAddress2:string,
      /**  Shipping, The city portion of the Frieght Forwarder main address.  */  
   FFCity:string,
      /**  International Shipping. The state or province portion of the shipment Frieght Forwarder main address.  */  
   FFState:string,
      /**  International Shipping. The zip or postal code portion of the shipping Frieght Forwarder main address.  */  
   FFZip:string,
      /**  International shipping. The country of the Frieght Forwarder .  */  
   FFCountry:string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   FFContact:string,
      /**  International Shipping. Frieght Forwarder company name  */  
   FFCompName:string,
      /**  International Shipping. Frieght Forwarder Phone number  */  
   FFPhoneNum:string,
      /**  Is this an International shipment  */  
   IntrntlShip:boolean,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**  Defines if this document is marked as EDI Ready  */  
   EDIReady:boolean,
      /**  Indicates whether or not all freight charges sent or received are for individual pack DIs or the master pack.  */  
   IndividualPackIDs:boolean,
      /**  Freight Forwarder third address line.  */  
   FFAddress3:string,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Additional Handling Required flag  */  
   AddlHdlgFlag:boolean,
      /**  Non Standard Package flag.  */  
   NonStdPkg:boolean,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Freight Forwarder country portion of the address  */  
   FFCountryNum:number,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Payer Bill To  third address line  */  
   PayBTAddress3:string,
      /**  Payer Bill To country portion of the address  */  
   PayBTCountryNum:number,
      /**  Payer Bill To phone number  */  
   PayBTPhone:string,
      /**  UPS Quantity View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View Ship from Nam  */  
   UPSQVShipFromName:string,
      /**  UPS Quantity View Memo  */  
   UPSQVMemo:string,
      /**  This flag will be used to indicate if the order is ready for calculations. When set to true, tax calculations will take place whenever a save takes place for any tables tied to the order which could affect taxes (OrderDtl, OrderHed, OrderMisc, etc). It defaults from XASyst.SOReadyToCalcDflt field when an order is created.  */  
   ReadyToCalc:boolean,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalCharges:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalMisc:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalDiscount:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalComm:number,
      /**  Total Advance Billable Balance  */  
   TotalAdvBill:number,
      /**  Total number of lines on the order  */  
   TotalLines:number,
      /**  Total Number of releases on order  */  
   TotalReleases:number,
      /**  Total number of distinct release dates on order  */  
   TotalRelDates:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalCharges:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalMisc:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalDiscount:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalComm:number,
      /**   Order Total Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   TotalTax:number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   DocTotalTax:number,
      /**  Total Advance Billable Balance  */  
   DocTotalAdvBill:number,
      /**  Total Shipped amount  */  
   TotalShipped:number,
      /**  Total amount of order that has been invoiced  */  
   TotalInvoiced:number,
      /**  Total number of lines that were commissionable  */  
   TotalCommLines:number,
      /**  Commission earned for first sales rep  */  
   SRCommAmt1:number,
      /**  Commission earned for second sales rep  */  
   SRCommAmt2:number,
      /**  Commission earned for third sales rep  */  
   SRCommAmt3:number,
      /**  Commission earned for fourth sales rep  */  
   SRCommAmt4:number,
      /**  Commission earned for fifth sales rep  */  
   SRCommAmt5:number,
      /**  Total Commissionable Amount for first salesrep  */  
   SRCommableAmt1:number,
      /**  Total Commissionable Amount for second salesrep  */  
   SRCommableAmt2:number,
      /**  Total Commissionable Amount for third salesrep  */  
   SRCommableAmt3:number,
      /**  Total Commissionable Amount for fourth salesrep  */  
   SRCommableAmt4:number,
      /**  Total Commissionable Amount for fifth salesrep  */  
   SRCommableAmt5:number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   Rounding:number,
      /**  Display value contains the deposit balance in a reporting currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   Rpt1DepositBal:number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   DocRounding:number,
      /**  Display value contains the deposit balance in a report currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   Rpt2DepositBal:number,
      /**  Display value contains the deposit balance in a report currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   Rpt3DepositBal:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalCharges:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalCharges:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalCharges:number,
      /**  Total Advance Billable Balance  */  
   Rpt1TotalAdvBill:number,
      /**  Total Advance Billable Balance  */  
   Rpt2TotalAdvBill:number,
      /**  Total Advance Billable Balance  */  
   Rpt3TotalAdvBill:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalMisc:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalMisc:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalMisc:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalDiscount:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalDiscount:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalDiscount:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalComm:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalComm:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalComm:number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax +TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt1TotalTax:number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt2TotalTax:number,
      /**  Reporting currency value of this field  */  
   Rpt1Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt2Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt3Rounding:number,
      /**  Unique identifier  */  
   RateGrpCode:string,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt3TotalTax:number,
      /**  See CCAmount  */  
   Rpt1CCAmount:number,
      /**  See CCAmount  */  
   Rpt2CCAmount:number,
      /**  See CCAmount  */  
   Rpt3CCAmount:number,
      /**  See CCFreight  */  
   Rpt1CCFreight:number,
      /**  See CCFreight  */  
   Rpt2CCFreight:number,
      /**  See CCFreight  */  
   Rpt3CCFreight:number,
      /**  See CCTax  */  
   Rpt1CCTax:number,
      /**  See CCTax  */  
   Rpt2CCTax:number,
      /**  See CCTax  */  
   Rpt3CCTax:number,
      /**  See CCTotal  */  
   Rpt1CCTotal:number,
      /**  See CCTotal  */  
   Rpt2CCTotal:number,
      /**  See CCTotal  */  
   Rpt3CCTotal:number,
      /**  Total order Amount. This field is an accumulation of the extended net amounts of the detail line items  */  
   OrderAmt:number,
      /**  Total order Amount in customer currency. This field is an accumulation of the extended net amounts of the detail line items and rounded according to the Doc currency Round rule  */  
   DocOrderAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1OrderAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2OrderAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3OrderAmt:number,
      /**  Tax Point  */  
   TaxPoint:string,
      /**  Date Used to calculate Tax Rates  */  
   TaxRateDate:string,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**   Indicates if the One Time Shipto information is to be used.
Note: This can only be true when if the OTSName is not blank. 
UI disables this when Customer.AllowQTS = False,  */  
   UseOTS:boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   OTSName:string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   OTSAddress1:string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   OTSAddress2:string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   OTSAddress3:string,
      /**  City portion of the One Time Shipto  address.  */  
   OTSCity:string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   OTSState:string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   OTSZIP:string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   OTSResaleID:string,
      /**  One Time Ship To Contact Name  */  
   OTSContact:string,
      /**  Fax number for the One Time ShipTo.  */  
   OTSFaxNum:string,
      /**  Phone number for the One Time ShipTo  */  
   OTSPhoneNum:string,
      /**  One Time Shipment country  */  
   OTSCountryNum:number,
      /**   Order Total Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   TotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   DocTotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt1TotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt2TotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt3TotalWHTax:number,
      /**   Order Total Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   TotalSATax:number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   DocTotalSATax:number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt1TotalSATax:number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt2TotalSATax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt3TotalSATax:number,
      /**  Indicates if/how the OTS is saved. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   OTSSaveAs:string,
      /**  CustID to be used if the OTS is used to create a customer record.  */  
   OTSSaveCustID:string,
      /**  True if Customer or ShipTo record was created using the  OTS info.  */  
   OTSCustSaved:boolean,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  Status of Order  */  
   OrderStatus:string,
      /**  Hold Set by Demand  */  
   HoldSetByDemand:boolean,
      /**  Indicates that the tax is included in the unit price  */  
   InPrice:boolean,
      /**  Reserved for future use  */  
   InTotalCharges:number,
      /**  Reserved for future use  */  
   InTotalMisc:number,
      /**  Reserved for future use  */  
   InTotalDiscount:number,
      /**  Reserved for future use  */  
   DocInTotalCharges:number,
      /**  Reserved for future use  */  
   DocInTotalMisc:number,
      /**  Reserved for future use  */  
   DocInTotalDiscount:number,
      /**  Reserved for future use  */  
   Rpt1InTotalCharges:number,
      /**  Reserved for future use  */  
   Rpt2InTotalCharges:number,
      /**  Reserved for future use  */  
   Rpt3InTotalCharges:number,
      /**  Reserved for future use  */  
   Rpt1InTotalMisc:number,
      /**  Reserved for future use  */  
   Rpt2InTotalMisc:number,
      /**  Reserved for future use  */  
   Rpt3InTotalMisc:number,
      /**  Reserved for future use  */  
   Rpt1InTotalDiscount:number,
      /**  Reserved for future use  */  
   Rpt2InTotalDiscount:number,
      /**  Reserved for future use  */  
   Rpt3InTotalDiscount:number,
      /**  Letter of Credit ID.  */  
   ARLOCID:string,
      /**  Bank for Cash Receipts. Default is from Customer(Bill To).  */  
   OurBank:string,
      /**  It will be used to identify SO that will generate an invoice at the shipment.  If the order is created manually the default for this order will be taken from the customer master file. If the order is created via DM, the default will be taken from the value in the DM records.  */  
   ERSOrder:boolean,
      /**  Indicates that order is on hold due to amount exceeding value on Letter of Credit.  */  
   LOCHold:boolean,
      /**  Currency code used in further packing slips.  */  
   PSCurrCode:string,
      /**  Currency code used in further AR invoices.  */  
   InvCurrCode:string,
      /**  Legal Number for the record.  */  
   LegalNumber:string,
      /**  Transaction Document for the record.  */  
   TranDocTypeID:string,
      /**  Cross Reference Contract Number.  */  
   XRefContractNum:string,
      /**  Cross Reference Contract Date.  */  
   XRefContractDate:string,
      /**  Date in which the related demand was last processed.  */  
   DemandProcessDate:string,
      /**  System Time when demand was last processed.  */  
   DemandProcessTime:number,
      /**  Last Schedule Number in which the demand was processed.  */  
   LastScheduleNumber:string,
      /**  EDI Transaction Control Number  */  
   LastTCtrlNum:string,
      /**  EDI Batch Control Number  */  
   LastBatchNum:string,
      /**  ECCOrderNum  */  
   ECCOrderNum:string,
      /**  ECCPONum  */  
   ECCPONum:string,
      /**  WIOrder  */  
   WIOrder:string,
      /**  WIApplication  */  
   WIApplication:string,
      /**  WIUsername  */  
   WIUsername:string,
      /**  WIUserID  */  
   WIUserID:string,
      /**  WICreditCardorder  */  
   WICreditCardorder:boolean,
      /**  OrderCSR  */  
   OrderCSR:string,
      /**  UserChar1  */  
   UserChar1:string,
      /**  UserChar2  */  
   UserChar2:string,
      /**  UserChar3  */  
   UserChar3:string,
      /**  UserChar4  */  
   UserChar4:string,
      /**  UserDate1  */  
   UserDate1:string,
      /**  UserDate2  */  
   UserDate2:string,
      /**  UserDate3  */  
   UserDate3:string,
      /**  UserDate4  */  
   UserDate4:string,
      /**  UserDecimal1  */  
   UserDecimal1:number,
      /**  UserDecimal2  */  
   UserDecimal2:number,
      /**  UserInteger1  */  
   UserInteger1:number,
      /**  UserInteger2  */  
   UserInteger2:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  IsCSRSet  */  
   IsCSRSet:boolean,
      /**  ECCPaymentMethod  */  
   ECCPaymentMethod:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  OTSShipToNum  */  
   OTSShipToNum:string,
      /**  ProFormaInvComment  */  
   ProFormaInvComment:string,
      /**  ccToken  */  
   ccToken:string,
      /**  InvcOrderCmp  */  
   InvcOrderCmp:boolean,
      /**  ReprintSOAck  */  
   ReprintSOAck:boolean,
      /**  CounterSOAck  */  
   CounterSOAck:number,
      /**  DispatchReason  */  
   DispatchReason:string,
      /**  Plant  */  
   Plant:string,
      /**  This flag will be used to indicate if the sales order is ready to be fulfilled.  */  
   ReadyToFulfill:boolean,
      /**  Ship the good by this time  */  
   ShipByTime:number,
      /**  Taiwan GUI Calendar Fiscal Year  */  
   TWFiscalYear:number,
      /**  Taiwan GUI Calendar Fiscal Year Suffix  */  
   TWFiscalYearSuffix:string,
      /**  Taiwan GUI Calendar Fiscal Period  */  
   TWFiscalPeriod:number,
      /**  GUI Group of Legal Numbers  */  
   TWGUIGroup:string,
      /**  Seller GUI Code  */  
   TWGUIRegNumSeller:string,
      /**  Buyer GUI Code  */  
   TWGUIRegNumBuyer:string,
      /**  OrderOpenCredit  */  
   OrderOpenCredit:number,
      /**  ClosedNotShipped  */  
   ClosedNotShipped:number,
      /**  InvCurrDepositBal  */  
   InvCurrDepositBal:number,
      /**  Article. 106c  */  
   PLArticle106c:boolean,
      /**  Invoices are issued by a taxpayer's representative  */  
   PLInvIssuedByTaxpayer:boolean,
      /**  Invoices issued by the second taxpayer  */  
   PLInvIssuedBySecondTaxpayer:boolean,
      /**  Tourist Services  */  
   PLTouristService:boolean,
      /**  Second hand goods, works of art, collectibles or antiques  */  
   PLSecondHandOrArts:boolean,
      /**  Appropriate Legal Article of the Act  */  
   PLLegalArticleAct:string,
      /**  Appropriate Legal Article of 2006/112/WE Directive  */  
   PLLegalArticleWEDirective:string,
      /**  Other Legal Article  */  
   PLLegalArticleOther:string,
      /**  Name of the Enforcement Authority or the Name of the Judicial Officer  */  
   PLEnforcementAuthName:string,
      /**  Address of the Enforcement Authority or Judicial Officer  */  
   PLEnforcementAuthAddr:string,
      /**  Tax Representative Name  */  
   PLTaxRepresentativeName:string,
      /**  Tax Representative Address  */  
   PLTaxRepresentativeAddr:string,
      /**  Tax ID of the Tax Representative  */  
   PLTaxRepresentativeTaxID:string,
      /**  Margin Scheme  */  
   PLMarginScheme:number,
      /**  Goods or Service VAT exempt  */  
   PLGoodsOrServiceVATExempt:boolean,
      /**  Credit Card Holder City  */  
   CCCity:string,
      /**  Credit Card Holder State  */  
   CCState:string,
      /**  ExtAOEUserID  */  
   ExtAOEUserID:string,
      /**  ExtAOE  */  
   ExtAOE:string,
      /**  OTSTaxValidationStatus  */  
   OTSTaxValidationStatus:number,
      /**  OTSTaxValidationDate  */  
   OTSTaxValidationDate:string,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  Incoterm Code  */  
   IncotermCode:string,
      /**  Incoterm Location  */  
   IncotermLocation:string,
      /**  CovenantDiscPercent  */  
   CovenantDiscPercent:number,
      /**  TotalCovenantDiscount  */  
   TotalCovenantDiscount:number,
      /**  DocCovenantDiscount  */  
   DocCovenantDiscount:number,
      /**  Rpt1CovenantDiscount  */  
   Rpt1CovenantDiscount:number,
      /**  Rpt2CovenantDiscount  */  
   Rpt2CovenantDiscount:number,
      /**  Rpt3CovenantDiscount  */  
   Rpt3CovenantDiscount:number,
      /**  TotalInCovenantDiscount  */  
   TotalInCovenantDiscount:number,
      /**  DocInCovenantDiscount  */  
   DocInCovenantDiscount:number,
      /**  Rpt1InCovenantDiscount  */  
   Rpt1InCovenantDiscount:number,
      /**  Rpt2InCovenantDiscount  */  
   Rpt2InCovenantDiscount:number,
      /**  Delimited list of available bill to customers (CustID`CustomerName~CustID`CustomerName)  */  
   AvailBTCustList:string,
      /**  AVSADDR returned by a 3rd party credit card processing company  for a credit card transaction. This value represents the results of the Address Verification System (AVS) address test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   AVSAddr:string,
      /**  Rpt3InCovenantDiscount  */  
   Rpt3InCovenantDiscount:number,
      /**  AVSZIP returned by a 3rd party credit card processing company  for a credit card transaction. This value represents the results of the Address Verification System (AVS) zip code test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   AVSZip:string,
   BaseCurrencyID:string,
   BaseCurrSymbol:string,
      /**  Bill to customer name.  */  
   BillToCustomerName:string,
      /**  Bill To Address List.  */  
   BTAddressList:string,
   BTContactEMailAddress:string,
      /**  Bill to contact fax number.  */  
   BTContactFaxNum:string,
      /**  Bill to contact name.  */  
   BTContactName:string,
      /**  Bill to contact phone number.  */  
   BTContactPhoneNum:string,
      /**  Bill To Customer ID  */  
   BTCustID:string,
      /**  The flag to indicate if the user can change Tax Liability on the header level after adding a detail line.  */  
   CanChangeTaxLiab:boolean,
      /**  Stored Credit Card Number  */  
   CardStore:string,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention  */  
   CCCSCID:string,
      /**  Tokenized value of CSCID  */  
   CCCSCIDToken:string,
      /**   Indicates if the credit card setup will be using a testing Paygate instance for transactions.
Force requests to use Paygate test url: paygate-test1.eaglesoa.com  */  
   CCIsTraining:boolean,
      /**  RESPMSG returned by  a 3rd party credit card processing company for a credit card transaction. This is a brief description of the status of the credit card transaction.  */  
   CCResponse:string,
   CCRounding:number,
      /**  PNREF returned by a 3rd party credit card processing company for a credit card transaction. This is a unique number that identifies the transaction and is often referenced we performing related transactions.  */  
   CCTranID:string,
      /**  Credit Card Transaction Type  */  
   CCTranType:string,
      /**  CVV2MATCH returned by a 3rd party credit card processing company for a credit card transaction. This value represents the results of the Card Security Code test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   CSCResult:string,
   CurrencySwitch:boolean,
   CustAllowOTS:boolean,
   CustomerPrintAck:boolean,
      /**  If true the customer requires a unique PO on Sales Orders  */  
   CustomerRequiresPO:boolean,
      /**  When set to true, indicates that this customer does not have credit available from your company.  */  
   CustOnCreditHold:boolean,
   CustTradePartnerName:string,
      /**  DemandContract  */  
   DemandContract:string,
   DocCCRounding:number,
   DocTotalNet:number,
   DocTotalOrder:number,
      /**  If SoldTo and Alt-Bill to are the same, this displays as null.  */  
   dspBTCustID:string,
      /**  ECC Contact Email - Contains the email address of the ECC login that placed the sales order. This only applies for B2C Orders.  */  
   ECCEmail:string,
      /**  ECC Payment Description  */  
   ECCPaymentDesc:string,
      /**  True when Credit Card Procesing module is enabled  */  
   EnableCreditCard:boolean,
      /**  True when Job Wizard must be enabled  */  
   EnableJobWizard:boolean,
      /**  True when SoldTo ID must be enabled  */  
   EnableSoldToID:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
      /**  It will be displayed when the value of the ERS flag at the sales order is different from the value in the customer master file.  */  
   ERSOverride:boolean,
      /**  Used by UI to disable CurrencyCode  */  
   HasMiscCharges:boolean,
   HasOrderLines:boolean,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
   LinkMsg:string,
      /**  Internal field which indicates if Order Tax Liability is not going to be changed even though Ship To is changed.  Related to Tax inclusive pricing. Depends on user response.  */  
   NoTaxRgnChange:boolean,
   OTSSaved:boolean,
      /**  OTS Tax Liability Code (Header)  */  
   OTSTaxRegionCode:string,
      /**  Contains the Parent Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   ParentCustNum:number,
   ProposedTaxRgn:string,
      /**  PNRef number referred to in the transaction.  If Deposit transaction must referenece prior Authorization using the PNRef  */  
   ReferencePNRef:string,
      /**  Internal field toindicate if the system should reset Bill to Customer address.  Based on the  user reply for LOC.  */  
   ResetBTCustAddr:boolean,
      /**  Internal field which indicates if existing Release Tax Region should be se-set to the new Order Header Tax Liability.  Depends on the user reply.  */  
   ResetRelTaxRgn:boolean,
   Rpt1CCRounding:number,
   Rpt1TotalNet:number,
   Rpt2CCRounding:number,
   Rpt2TotalNet:number,
   Rpt3CCRounding:number,
   Rpt3TotalNet:number,
      /**  Element 1 of SalesRepList  */  
   SalesRepCode1:string,
      /**  Element 2 of SalesRepList  */  
   SalesRepCode2:string,
      /**  Element 3 of SalesRepList  */  
   SalesRepCode3:string,
      /**  Element 4 of SalesRepList  */  
   SalesRepCode4:string,
      /**  Element 5 of SalesRepList  */  
   SalesRepCode5:string,
   SalesRepName1:string,
   SalesRepName2:string,
   SalesRepName3:string,
   SalesRepName4:string,
   SalesRepName5:string,
   ShipToAddressList:string,
   ShipToContactEMailAddress:string,
   ShipToContactFaxNum:string,
   ShipToContactName:string,
   ShipToContactPhoneNum:string,
      /**  Customer Id of the third-party Ship To  */  
   ShipToCustId:string,
   ShowApplyOrderDiscountsControl:boolean,
   SoldToAddressList:string,
   SoldToContactEMailAddress:string,
   SoldToContactFaxNum:string,
   SoldToContactName:string,
   SoldToContactPhoneNum:string,
      /**  This field defines the type of the term  */  
   TermsType:string,
   TotalNet:number,
   TotalOrder:number,
   TranDocTypeDescr:string,
      /**  the true discount percent from the order total  */  
   TrueDiscountPercent:number,
      /**  Taiwan GUI Legal Number Generation Type  */  
   TWGenerationType:string,
   UpdateDtlAndRelRecords:boolean,
      /**  Indicates if one or more invoices exist for this order  */  
   InvoicesExist:boolean,
   BTAddressFormatted:string,
      /**  The formatted ship to address  */  
   ShipToAddressFormatted:string,
      /**  The formatted Sold To Address  */  
   SoldToAddressFormatted:string,
   TranDate:string,
   TranNum:number,
   TranTime:number,
      /**  Indicates there is an OrderRel record that has a non-null NeedByDate  */  
   OrderRelNeedByDateNotNull:boolean,
      /**  Indicates a customer referenced on the order is inactive.  */  
   InactiveCustomer:boolean,
      /**  Enable Fulfillment Queue Actions  */  
   EnableAllocationQueueActions:boolean,
      /**  CREProcessor is true when Credit Card Configuration is CRE Server.  */  
   CREProcessor:boolean,
      /**  Flag indicating whether to enable Incoterm Location  */  
   EnableIncotermLocation:boolean,
   BitFlag:number,
   BTCustNumCustID:string,
   BTCustNumName:string,
   BTCustNumBTName:string,
   CardTypeDescription:string,
   CurrencyCodeCurrName:string,
   CurrencyCodeCurrSymbol:string,
   CurrencyCodeDocumentDesc:string,
   CurrencyCodeCurrencyID:string,
   CurrencyCodeCurrDesc:string,
   CustomerBTName:string,
   CustomerCustID:string,
   CustomerName:string,
   CustomerAllowShipTo3:boolean,
   FOBDescription:string,
   HDCaseDescription:string,
   IncotermsDescription:string,
   InvCurrCurrDesc:string,
   OTSCntryISOCode:string,
   OTSCntryDescription:string,
   OTSCntryEUMember:boolean,
   OurBankDescription:string,
   OurBankBankName:string,
   PlantName:string,
   PSCurrCurrDesc:string,
   RateGrpDescription:string,
   ReservePriDescription:string,
   ShipToNumInactive:boolean,
   ShipViaCodeInactive:boolean,
   ShipViaCodeDescription:string,
   ShipViaCodeWebDesc:string,
   TaxRegionCodeDescription:string,
   TermsCodeDescription:string,
      /**  RowMod  */  
   RowMod:string,
   UD_SysRevID:string,
   Project_c:string,
   OriginalOrderNo_c:number,
   MASFlag_c:boolean,
   Estimate_c:boolean,
   ShipOrderComplete_c:boolean,
   ProjectID_c:string,
   PhaseID_c:string,
   SalesCatID__c:string,
   TaxCatID_c:string,
   MfgOrder_c:boolean,
}

export interface Erp_Tablesets_OrderHedUPSRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   OrderNum:number,
      /**  UPS Quantum View Sequence  */  
   UPSQVSeq:number,
      /**  Email address to notify for a UPS shipment  */  
   EmailAddress:string,
      /**  Logical indicating if the EmailAddress is to be updated at shipping.  */  
   ShipmentNotify:boolean,
      /**  Logical indicating if the Email Address is to be notified of a failed shipment.  */  
   FailureNotify:boolean,
      /**  Logical indicating if the Email Address is to be notified of delivery.  */  
   DeliveryNotify:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Logical indicating if the UPS quantum view email data is to be enabled.  */  
   EnableQuantumView:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderHistRow{
      /**  Company  */  
   Company:string,
      /**  Sales Order Number  */  
   OrderNum:number,
      /**  Order Line  */  
   OrderLine:number,
      /**  Order Date  */  
   OrderDate:string,
      /**  Part Number  */  
   PartNum:string,
      /**  Part Description  */  
   PartDescription:string,
      /**  Order Quantity  */  
   OrderQty:number,
      /**  Selling Unit of Measure  */  
   UOM:string,
      /**  Original Price  */  
   OriginalPrice:number,
      /**  New Price  */  
   NewPrice:number,
      /**  New Quantity  */  
   NewQty:number,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderMscRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Sales Order Number  */  
   OrderNum:number,
      /**  Order line number that this miscellaneous record is related to. If related to the Order then this field is zero. This number is not directly entered by the user; rather it is carried through from the header or detail line that user was on when miscellaneous maintenance was requested.  */  
   OrderLine:number,
      /**  Sequence Number  */  
   SeqNum:number,
      /**  The Miscellaneous Charge Code. This must be valid in the MiscChrg master file.  */  
   MiscCode:string,
      /**  Description of the miscellaneous charge. This will be printed on the acknowledgment and transferred over to invoice processing. The default is provided by MiscChrg.Description, but it's overridable by the user. This can't be blank.  */  
   Description:string,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   MiscAmt:number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default.  */  
   DocMiscAmt:number,
      /**  Sets the frequency of when this miscellaneous charge should be applied. The options are F - First shipment, L = Last shipment, E = every shipment. This defaults from the MiscChrg.FreqCode.  */  
   FreqCode:string,
      /**  An internally used flag which indicates that this record was created from a Quote via the "Get Quote" function. "Q" = related to the QuoteQty record, "L" = related to the overall QuoteDtl record. This flag is used so that the OrderMsc file can be refreshed from the QuoteMsc when Quantity or Quote/Line # changes occur. The logic is that if a change in order quantity of a order line that is linked to a quote causes a different price break to be selected then all the existing all OrderMsc records where Quoting = "Q" are deleted and then re-pulled in based on the new qty. If the Quote # or QuoteLine are changed then all OrderMsc records where Quoting is either a "Q" or "L" are deleted then re-pulled in from the newly referenced quote.  */  
   Quoting:string,
      /**  Indicates if this order miscellaneous charge is linked to an inter-company PO misc charge.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   ICPONum:number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   ICPOLine:number,
      /**  Inter Company PO Sequence Number  */  
   ICPOSeqNum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Reporting currency value of this field  */  
   Rpt1MiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2MiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3MiscAmt:number,
      /**  The amount of the Miscellaneous Charge/Credit. Can't be zero. Use MiscChrg.MiscAmt as a default. - Includes taxes  */  
   InMiscAmt:number,
      /**  The amount of the Miscellaneous Charge/Credit(display value). Can't be zero. Use MiscChrg.MiscAmt as a default. - includes taxes  */  
   DocInMiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1InMiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2InMiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3InMiscAmt:number,
      /**  This field will be used to define the percentage of the extended amount that will be applied as the 'Miscellaneous charge'.  */  
   Percentage:number,
      /**  This field will define if the miscellaneous charge is calculated as a flat amount or if is calculated as a percentage of the extended price.  */  
   Type:string,
      /**  ChangeTrackApproved  */  
   ChangeTrackApproved:boolean,
      /**  ChangeTrackAmount  */  
   ChangeTrackAmount:number,
      /**  ChangeTrackMemoDesc  */  
   ChangeTrackMemoDesc:string,
      /**  ChangeTrackMemoText  */  
   ChangeTrackMemoText:string,
      /**  ChangeTrackStatus  */  
   ChangeTrackStatus:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BaseCurrSymbol:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencySwitch:boolean,
   CurrSymbol:string,
      /**  Misc charge amount on display in document currency (may or may not include taxes)  */  
   DocDspMiscAmt:number,
      /**  Misc charge amount on display (may or may not include taxes)  */  
   DspMiscAmt:number,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
   OpenLine:boolean,
      /**  Misc charge amount on display in report currency  (may or may not include taxes)  */  
   Rpt1DspMiscAmt:number,
      /**  Misc charge amount on display in report currency  (may or may not include taxes)  */  
   Rpt2DspMiscAmt:number,
      /**  Misc charge amount on display in document currency (may or may not include taxes)  */  
   Rpt3DspMiscAmt:number,
      /**  Pass Credit Limit check message to the UI  */  
   RespMessage:string,
   BitFlag:number,
   MiscCodeDescription:string,
   OrderLineLineDesc:string,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderRelRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Sales Order Number  */  
   OrderNum:number,
      /**  Sales order Line number that this order release is linked to.  */  
   OrderLine:number,
      /**  The release number assigned by the system.  The user never sees this field. It  is used as a foreign key in other files (such as ShipDtl) to tie those records back to the release record.  */  
   OrderRelNum:number,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT".  */  
   LineType:string,
      /**  Date which the item needs to be shipped by in order to meet the customers due date. Initially defaulted as OrderHed.ReqDate.  */  
   ReqDate:string,
      /**  Quantity ,using Our U/M, that is requested to be shipped for this release. This MUST BE > ZERO.  */  
   OurReqQty:number,
      /**  The ShipTo ID to be used for this scheduled release record. This MUST BE VALID IN THE SHIPTO file. Use the OrderHead.ShiptoNum as the default when creating new records.  */  
   ShipToNum:string,
      /**  Ship Via ID that is used for this shipment release. THIS CAN BE BLANK or MUST BE VALID IN THE SHIPVIA master file. Use the OrderHead.ShipViaCode as the default.  */  
   ShipViaCode:string,
      /**  Indicates if this release is open.  This is normally set to closed via the shipping program. But can be changed indirectly  by the user during order entry when they "Void" the release..  */  
   OpenRelease:boolean,
      /**  Indicates if this release is  "FIRM". The opposite is an uncommitted release, that is when the customer gives releases that are just 'Best Guesses' of what they will require in the future, such as in blanket order situations. This type of  releases is no different to the system, except that the FirmRelease field will be printed on reports such as TimePhase requirements.  */  
   FirmRelease:boolean,
      /**   Indicates if this requirement or any part of it will be manufactured. Default the setting to "No" if valid Part and the Part.Type is "S" or "P".

Default the setting to "Yes" if the part is not found in Part master or the Part.Type = "J".  This flag also gets set if this release gets linked to a Job via Job Entry. There is an Index on this field so that we can display releases that need have a job assigned to them. This display is part of Job Entry.  */  
   Make:boolean,
      /**  The planned production quantity, using Our U/M, for the Job. This is not maintainable in order entry. It gets updated via Job Entry.  */  
   OurJobQty:number,
      /**  Actual quantity, using our U/M, shipped from the Job.  Updated via the shipping process.  */  
   OurJobShippedQty:number,
      /**   Indicates if the release was voided. Voided releases items are not maintainable, can't "unvoid". This field is not directly maintainable. Instead the void function will be performed via a "Void Release" button. Which then presents a verification dialog box.

When an OrderRel record is 'voided' any outstanding inventory allocations are relieved, OrderRel.OpenRelease is set to "no" and records are created/updated in the OrdJobMsg file for all the related  open OrderRel records if the OrderDtl that was tied to a Job to indicate that the line item was voided.  */  
   VoidRelease:boolean,
      /**  Quantity, using Our U/M, of the Sales Order release that is planned to be filled (pulled) from stock. This quantity is assigned = to the ReqQty when this item is not manufactured (Make = No).  For manufactured items this quantity can be updated by job entry when the user decides to pull some from stock and manufacture some. This value is used to  allocate to the designated warehouse.  */  
   OurStockQty:number,
      /**  Indicates the inventory warehouse. This field is only relevant if this line references a valid Part record. Use the PrimWhse in the Part table as a default.  */  
   WarehouseCode:string,
      /**  Actual quantity, using our U/M, shipped from Stock.  Updated via the shipping process.  */  
   OurStockShippedQty:number,
      /**  The part number the release quantity is currently allocated to (if it exists in the part master file).  This is a duplicate of the OrderDtl part number and is not user maintainable.  */  
   PartNum:string,
      /**  Part Revision number.  Mirror image of OrderDtl.RevisionNum.  Not directly maintainable.  */  
   RevisionNum:string,
      /**  Indicates if this customer/shipto  is exempt from sales tax for this line item. If field is non-blank it is considered exempt. Defaults from the Customer/Shipto file.  This code is totally user definable and no validation is required. This field will be printed on the Tax report if this item is reportable .  */  
   TaxExempt:string,
      /**  Contains the key value for the shipping contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table. Enter via a DDSL fill-in for contact name. Use OrderHed.ShpConNum when the OrderRel.ShipToNum = OrderHed.ShipToNum else use ShipTo.PrimScon as a default.  */  
   ShpConNum:number,
      /**  Date customer needs the item to be delivered. Defaulted as OrderHed.NeedByDate.  */  
   NeedByDate:string,
      /**  EDI Reference  */  
   Reference:string,
      /**  Site Identifier.  */  
   Plant:string,
      /**  Quantity ,using Selling U/M, that is requested to be shipped for this release. This MUST BE > ZERO.  */  
   SellingReqQty:number,
      /**  The planned production quantity, using selling U/M, for the Job. This is not maintainable in order entry. It gets updated via Job Entry.  */  
   SellingJobQty:number,
      /**  Actual quantity, using selling U/M, shipped from the Job.  Updated via the shipping process.  */  
   SellingJobShippedQty:number,
      /**  Quantity, using selling U/M, of the Sales Order release that is planned to be filled (pulled) from stock. This quantity is assigned = to the ReqQty when this item is not manufactured (Make = No).  For manufactured items this quantity can be updated by job entry when the user decides to pull some from stock and manufacture some. This value is used to  allocate to the designated warehouse.  */  
   SellingStockQty:number,
      /**  Actual quantity, using selling U/M, shipped from Stock.  Updated via the shipping process.  */  
   SellingStockShippedQty:number,
      /**  Indicates if the release is selected to be submitted to the picking queue. When submitted for picking a record is written to the MtlQueue table and then SelectForPicking is reset to NO.  */  
   SelectForPicking:boolean,
      /**  The shipping "Staging" warehouse for the release.  Defaults from the system default shipping area (Site.DefShippingWhse). This is maintainable in the Sales Allocation program.  */  
   StagingWarehouseCode:string,
      /**  The shipping "Staging" bin for the release.  Defaults from the system default shipping area (Site.DefShippingBin). This is maintainable in the Sales Allocation program.  */  
   StagingBinNum:string,
      /**   A non blank character indicates that the release could not be picked by the Auto Pick process.
The possible values are;
"L" - Order Line can't be shipped complete.
"O" - Order can't be shipped complete.
"I" - Insufficient quantity reserved
"Z" - Zero quantity reserved.  */  
   PickError:string,
      /**  Quantity from last EDI update.  */  
   CumeQty:number,
      /**  Date of last update  */  
   CumeDate:string,
      /**  Indicates if this order release is linked to an inter-company PO release.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   ICPONum:number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   ICPOLine:number,
      /**  Purchase order release number uniquely identifies a purchase release requirement record for a specific line item on an order. This is assigned by the system.  */  
   ICPORelNum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  A link to the demand schedule that created/updated this OrderRel.  */  
   ScheduleNumber:string,
      /**  The Mark For to be used for this order release record. This MUST BE VALID IN THE SHIPTO file.  */  
   MarkForNum:string,
      /**  Full name for the drop shipment.  */  
   DropShipName:string,
      /**  RAN Number.  Used for informational purposes.  Supplied by EDI.  */  
   RAN:string,
      /**  Demand Reference.  Used for informational purposes and to aide in matching demand schedules with existing OrderRel records.  Supplied by EDI.  */  
   DemandReference:string,
      /**  Indicates if the demand schedule that created/updated this order release has been rejected.  */  
   DemandSchedRejected:boolean,
      /**  The last date that the Material Queue Report was run for this release.  This field will be null until the Material Queue Report is run.  */  
   DatePickTicketPrinted:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Verbal Confirmation required  */  
   VerbalConf:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  Is a Service Saturday delivery acceptable  */  
   ServSatDelivery:boolean,
      /**  Is a Service Saturday pickup available  */  
   ServSatPickup:boolean,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Auto POD flag  */  
   ServPOD:boolean,
      /**  AOD  */  
   ServAOD:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Override Carrier Defaults.  If not checked then the Site values will be used  */  
   OverrideCarrier:boolean,
      /**  Override Service Options.  If not checked then the Site values will be used  */  
   OverrideService:boolean,
      /**  The dockingstation of the shipto address.  For future use.  */  
   DockingStation:string,
      /**  The location within the customer shipto address.  For future use.  */  
   Location:string,
      /**  The code of the transport routing/time. For future use.  */  
   TransportID:string,
      /**  Ship the good by this time.  */  
   ShipbyTime:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  If true, the OrderRelTax records tied to this release are calculated using Tax Connect logic. If  false, taxes are calculated using the standard calc methods.  */  
   TaxConnectCalc:boolean,
      /**  If set to true, the tax calculation logic will retrieve the default SalesTax ids for the release before calculating taxes. It will also be reset to true if the TaxConnectCalc flag switches from true to false.  */  
   GetDfltTaxIds:boolean,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**  Indicates that the One Time ShipTO information defined for this release should be used.  */  
   UseOTS:boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   OTSName:string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   OTSAddress1:string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   OTSAddress2:string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   OTSAddress3:string,
      /**  City portion of the One Time Shipto  address.  */  
   OTSCity:string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   OTSState:string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   OTSZIP:string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   OTSResaleID:string,
      /**  One Time Ship To Contact Name  */  
   OTSContact:string,
      /**  Fax number for the One Time ShipTo.  */  
   OTSFaxNum:string,
      /**  Phone number for the One Time ShipTo  */  
   OTSPhoneNum:string,
      /**  One Time Shipment country  */  
   OTSCountryNum:number,
      /**   Free form. Can be used to further identify the shipping destination. Example, ship to a distribution site, this could contain a store description.
Will be printed on the packing slip  */  
   SubShipTo:string,
      /**   Free form. Can be used to further identify the shipping destination. Example, ship to a distribution site, this could contain a routing description.
Will be printed on the packing slip  */  
   ShipRouting:string,
      /**  This field identifies Buy To Order releases.  */  
   BuyToOrder:boolean,
      /**  The value for this field will be defaulted from the Supplier defined in the Part Site sub tab at the Part form. Used only for Buy To Order releases.  */  
   VendorNum:number,
      /**  Supplier Purchase Point. Used only for Buy To Order releases.  */  
   PurPoint:string,
      /**  This field identifies Drop Ship releases. Used only for Buy To Order releases.  */  
   DropShip:boolean,
      /**  Purchase order related to this Buy To Order release. Used only for Buy To Order releases.  */  
   PONum:number,
      /**  The line number of the purchase order related to this Buy To Order release. Used only for Buy To Order releases.  */  
   POLine:number,
      /**  The release number of the purchase order line related to this Buy To Order release. Used only for Buy To Order releases.  */  
   PORelNum:number,
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   OpenOrder:boolean,
      /**  Indicates if/how the OTS can be saved. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   OTSSaveAs:string,
      /**  CustID to be used if the OTS is used to create a customer record.  */  
   OTSSaveCustID:string,
      /**  True if Customer or ShipTo record was created using the OTS info.  */  
   OTSCustSaved:boolean,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**   Unit of Measure that qualifies the "our" quantity fields.
If a valid part then it is the Base Stocking UOM (Part.IUM).
A mirror image of OrderDtl.IUM. Not directly maintainable  */  
   IUM:string,
      /**   Selling Unit of measure. Qualifies the "Selling" quantity fields.
A mirror image of OrderDtl.SalesUM. Not directly maintainable.  */  
   SalesUM:string,
      /**  Status of Order Release  */  
   RelStatus:string,
      /**  Displays the cause why the item is not compliant.  */  
   ComplianceMsg:string,
      /**  Previous Selling Quantity  */  
   PrevSellQty:number,
      /**  Previous Part Number  */  
   PrevPartNum:string,
      /**  Previous Customer Part Number  */  
   PrevXPartNum:string,
      /**  Previous Need By Date  */  
   PrevNeedByDate:string,
      /**  Previous Require Date  */  
   PrevReqDate:string,
      /**  Previous Ship To Num  */  
   PrevShipToNum:string,
      /**  Mark For Customer Number. This along with Mark For ShipToNum provides the foreign key field to a given ShipTo.  */  
   MFCustNum:number,
      /**  Indicates that the One Time Mark For information defined for this record should be used.  */  
   UseOTMF:boolean,
      /**  One Time Mark For Name of the ShipTo.  */  
   OTMFName:string,
      /**  One Time Mark For first line of the ShipTo address.  */  
   OTMFAddress1:string,
      /**  One Time Mark For second line of the ShipTo address.  */  
   OTMFAddress2:string,
      /**  One Time Mark For third line of the ShipTo address.  */  
   OTMFAddress3:string,
      /**  City portion of the One Time Mark For address.  */  
   OTMFCity:string,
      /**  The state or province portion of the One Time Mark For address.  */  
   OTMFState:string,
      /**  The zip or postal code portion of the One Time Mark For address.  */  
   OTMFZIP:string,
      /**  One Time Mark For Contact Name  */  
   OTMFContact:string,
      /**  Fax number for the One Time Mark For.  */  
   OTMFFaxNum:string,
      /**  Phone number for the One Time Mark For  */  
   OTMFPhoneNum:string,
      /**  Country number for the One Time Mark For  */  
   OTMFCountryNum:number,
      /**  ECCPlant  */  
   ECCPlant:string,
      /**  WIOrderLine  */  
   WIOrderLine:string,
      /**  WIOrder  */  
   WIOrder:string,
      /**  WebSKU  */  
   WebSKU:string,
      /**  ShipOvers  */  
   ShipOvers:boolean,
      /**  WIItemPrice  */  
   WIItemPrice:number,
      /**  WIItemShipCost  */  
   WIItemShipCost:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  PhaseID  */  
   PhaseID:string,
      /**  OTSShipToNum  */  
   OTSShipToNum:string,
      /**  WasRecInvoiced  */  
   WasRecInvoiced:boolean,
      /**  The identifier of the planning contract.  */  
   ContractID:string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the planning of the Contract.  */  
   LinkToContract:boolean,
      /**  This flag indicates if the sales order release is ready to be fulfilled.  */  
   ReadyToFulfill:boolean,
      /**  One Time ShipTo email address.  */  
   OTSEMailAddress:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  Number of pieces for this attribute set.  */  
   NumberOfPieces:number,
      /**  Unit of measure for the NumberOfPieces.  */  
   NumberOfPiecesUOM:string,
      /**  Planning number of pieces for this attribute set.  */  
   PlanningNumberOfPieces:number,
      /**  Indicates if the release should be added or removed from the fulfillment queue.  */  
   PartAllocQueueAction:string,
      /**  OTSTaxValidationStatus  */  
   OTSTaxValidationStatus:number,
      /**  OTSTaxValidationDate  */  
   OTSTaxValidationDate:string,
   AvailableQuantity:number,
      /**  BuyOverride  */  
   BuyOverride:boolean,
      /**  The message returned when checking a customer credit limit.  */  
   CreditLimitMessage:string,
      /**  The source that put the customer on credit hold.  */  
   CreditLimitSource:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
      /**  Is OTS allowed by the Sold to Customer?  */  
   CustAllowOTS:boolean,
      /**  True when Customer allows shipping to a Third-Party  */  
   CustomerAllowShipTo3:boolean,
   CustomerCustID:string,
   CustomerName:string,
   DisablePlantWhse:boolean,
   DocSelfAssessTax:number,
   DocTotalTax:number,
   DocWithholdTax:number,
      /**  DropShipOverride  */  
   DropShipOverride:boolean,
      /**   Invoicing Method. If advanced billing is not licensed the only options are CS and MB. Code/Desc: CS = Customer Shipment, MB = Milestone Billing, PB = Progress Billing, TM = Time and aterials
'CP' = Cost Plus
The default is Customer Shipment.  */  
   DspInvMeth:string,
      /**  Revenue Recognition Method has system list of the following options: LBR = Labor Booking Recognition, MAN = Manual Recognition, BDN = Actual Burden Recognition, PCC = POC-Cost-to-Cost, PCE = POC-Efforts, PCU = POC-Units-of-Delivery  */  
   DspRevMethod:string,
   EnableBuyToOrder:boolean,
   EnableMake:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
      /**  ExistPOSugg, external field to show/hide an epishape  */  
   ExistPOSugg:boolean,
   HdrOTS:boolean,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
      /**  Inventory UOM that the Order Release is allocated against. It is the similare column to the OrderDtl InvtyUOM and should always has the same value as in OrderDtl  */  
   InvtyUOM:string,
      /**  Will be set to true if the current OrderDtl record is KitFlag = 'C' and the KitParent of this record is KitAllowUpdate = NO  */  
   KitDisable:boolean,
      /**  LinkToPONum, external field to show/hide an epishape  */  
   LinkToPONum:boolean,
   MakeOverride:boolean,
      /**  The formatted mark for address  */  
   MarkForAddrFormatted:string,
      /**  Contains the Mark For Address  */  
   MarkForAddrList:string,
   MFCustID:string,
      /**  The flag based on the user anwer if Ship To of the release is supposed be changed but Tax info is not changed because of the conflict in tax pricing  */  
   NoRelTaxRgnChange:boolean,
      /**  Indicates if the item on the line is not compliant on its source, that can be Inventory, PO or Job.  */  
   NotCompliant:boolean,
   OnHandQuantity:number,
   OTSSaved:boolean,
      /**  OTS Tax Liability Code (Order Release)  */  
   OTSTaxRegionCode:string,
   PartExists:boolean,
      /**  If the phase has been recognized or invoiced.  */  
   PhaseWasRecInvoiced:boolean,
   ProjectID:string,
   ReleaseStatus:string,
      /**  the flag to indicate if all previously creaded manually added and manual tax relcords related to Order line release should be deleted if the user populates Tax Exempt field.  */  
   RemoveManAdTax:boolean,
   Rpt1SelfAssessTax:number,
   Rpt1TotalTax:number,
   Rpt1WithholdTax:number,
   Rpt2SelfAssessTax:number,
   Rpt2TotalTax:number,
   Rpt2WithholdTax:number,
   Rpt3SelfAssessTax:number,
   Rpt3TotalTax:number,
   Rpt3WithholdTax:number,
      /**  SalesOrderLinked  */  
   SalesOrderLinked:boolean,
      /**  Self-Assessed Tax  */  
   SelfAssessTax:number,
      /**  Selling Factor for display only  */  
   SellingFactor:number,
      /**  Selling Factor Direction for display oly  */  
   SellingFactorDirection:string,
      /**  The formatted ship to address  */  
   ShipToAddressFormatted:string,
   ShipToAddressList:string,
   ShipToContactEMailAddress:string,
   ShipToContactName:string,
   ShipToSelected:boolean,
   SNEnable:boolean,
   ThisRelInvtyQty:number,
   TotalJobStockShipped:number,
      /**  Invoice Tax  */  
   TotalTax:number,
   UpdateMarkForRecords:boolean,
   VoidOrder:boolean,
      /**  Withholding Tax  */  
   WithholdTax:number,
   AllowTaxCodeUpd:boolean,
      /**  Allow enable/disable for the button Attibutes in Order Release  */  
   EnableDynAttrButton:boolean,
      /**  Attribute class is MRP Planned but AttributeSetID has not been set on release.  */  
   AttributeMismatch:boolean,
      /**  The total allocated quantity for this release.  */  
   AllocatedQuantity:number,
      /**  Error Status Display  */  
   ErrorStatusDisplay:string,
      /**  True if this release is in the fulfillment queue.  */  
   InPartAllocQueue:boolean,
      /**  Show Fulfillment Queue Actions  */  
   ShowAllocationQueueActions:boolean,
   BitFlag:number,
   DynAttrValueSetShortDescription:string,
   DynAttrValueSetDescription:string,
   MarkForNumInactive:boolean,
   MFCustNumInactive:boolean,
   OrderLineLineDesc:string,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
   OTMFCountryDescription:string,
   OTSCntryISOCode:string,
   OTSCntryEUMember:boolean,
   OTSCntryDescription:string,
   PartNumTrackInventoryByRevision:boolean,
   PartNumTrackInventoryAttributes:boolean,
   PartNumAttrClassID:string,
   PartNumPricePerCode:string,
   PartNumTrackDimension:boolean,
   PartNumIUM:string,
   PartNumTrackSerialNum:boolean,
   PartNumPartDescription:string,
   PartNumTrackLots:boolean,
   PartNumSellingFactor:number,
   PartNumSalesUM:string,
   PlantName:string,
   PurPointAddress3:string,
   PurPointZip:string,
   PurPointName:string,
   PurPointCountry:string,
   PurPointAddress1:string,
   PurPointState:string,
   PurPointCity:string,
   PurPointAddress2:string,
   PurPointPrimPCon:number,
   ShipToNumInactive:boolean,
   ShipViaCodeWebDesc:string,
   ShipViaCodeDescription:string,
   TaxRegionCodeDescription:string,
   TPShipToName:string,
   TPShipToBTName:string,
   TPShipToCustID:string,
   VendorNumState:string,
   VendorNumZIP:string,
   VendorNumName:string,
   VendorNumAddress2:string,
   VendorNumCountry:string,
   VendorNumCurrencyCode:string,
   VendorNumCity:string,
   VendorNumAddress3:string,
   VendorNumVendorID:string,
   VendorNumDefaultFOB:string,
   VendorNumTermsCode:string,
   VendorNumAddress1:string,
   WarehouseCodeDescription:string,
      /**  RowMod  */  
   RowMod:string,
   UD_SysRevID:string,
   JobNum_c:string,
}

export interface Erp_Tablesets_OrderRelTaxRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   TaxCode:string,
      /**  The reportable sales amount to the tax jurisdiction. Set the value as follows; first determine if the item needs to be reported to the tax jurisdiction.  This is done by using the  InvcDtl.TaxCode and InvcDtl/InvcMisc.TaxCat to find a record in the SalesTxC. If a record is not found or SalesTxC.Reportable = Yes then add in the line item extended amount ((Qty*unitprice)-discount) or if this is for a InvcMisc record InvcMisc.Amount.  */  
   ReportableAmt:number,
      /**  The reportable sales amount to the tax jurisdiction. Set the value as follows; first determine if the item needs to be reported to the tax jurisdiction.  This is done by using the  InvcDtl.TaxCode and InvcDtl/InvcMisc.TaxCat to find a record in the SalesTxC. If a record is not found or SalesTxC.Reportable = Yes then add in the line item extended amount ((Qty*unitprice)-discount) or if this is for a InvcMisc record InvcMisc.Amount.  */  
   DocReportableAmt:number,
      /**  Taxable Amount for this line item/Misc charge. This value is set as an accumulation of non-exempt sales amount from the line and its associated miscellaneous records.  It could be tax exempt for two reasons, either the customer is exempt (invcdtl.TaxExempt > blank) or the item is exempt. In either case the detail amounts would not be added into the taxable amount.  To see if the item is exempt use the InvcDt/InvcMisc.TaxCat and the InvcTax.TaxCode to find a record in the SalesTxC. If a record is  found then it is exempt.  */  
   TaxableAmt:number,
      /**  Taxable Amount for this line item/Misc charge. This value is set as an accumulation of non-exempt sales amount from the line and its associated miscellaneous records.  It could be tax exempt for two reasons, either the customer is exempt (invcdtl.TaxExempt > blank) or the item is exempt. In either case the detail amounts would not be added into the taxable amount.  To see if the item is exempt use the InvcDt/InvcMisc.TaxCat and the InvcTax.TaxCode to find a record in the SalesTxC. If a record is  found then it is exempt.  */  
   DocTaxableAmt:number,
      /**  The tax percentage rate that is used for this invoice. This is defaulted from the SalesTax.Percent.  */  
   Percent:number,
      /**  Sales Tax amount for the corresponding taxable sales amount. This is user maintainable and also defaulted when/if the user changes the tax code, tax percent or the taxable amount or the tax classification changes to non-taxable when the InvcDtl.TaxCat is changed.  They can override the calculated figure to provide for any tax calculations other than the simple percent of taxable. No tax is calculated when the InvcDtl.TaxExempt <> blank or a record is found in the SalesTxC file indicating that this item is not taxable. Otherwise it is calculated as TaxableAmt * Percent.  */  
   TaxAmt:number,
      /**  Sales Tax amount for the corresponding taxable sales amount. This is user maintainable and also defaulted when/if the user changes the tax code, tax percent or the taxable amount or the tax classification changes to non-taxable when the InvcDtl.TaxCat is changed.  They can override the calculated figure to provide for any tax calculations other than the simple percent of taxable. No tax is calculated when the InvcDtl.TaxExempt <> blank or a record is found in the SalesTxC file indicating that this item is not taxable. Otherwise it is calculated as TaxableAmt * Percent.  */  
   DocTaxAmt:number,
      /**  Indicates if the tax calculations are to be performed manually.  When this field is set the Reportable, Taxable, and TaxAmount fields are enabled.  When it is NOT set these fields are DISABLED and the system will perform all of the Reportable, Taxable, and TaxAmount calculations.  Defaults from the SalesTax.Manual field.  */  
   Manual:boolean,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Reverse Charge.  */  
   ReverseCharge:boolean,
      /**  Sales Order Number  */  
   OrderNum:number,
      /**  Sales order Line number that this order release is linked to.  */  
   OrderLine:number,
      /**  The release number assigned by the system.  The user never sees this field. It  is used as a foreign key in other files (such as ShipDtl) to tie those records back to the release record.  */  
   OrderRelNum:number,
      /**  A flat discount amount for the tax.  */  
   Discount:number,
      /**  A flat discount amount for the tax converted to the customers currency.  */  
   DocDiscount:number,
      /**  Reporting currency value of this field  */  
   Rpt1Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt2Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt3Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt1ReportableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2ReportableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3ReportableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1TaxableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2TaxableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3TaxableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1TaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2TaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3TaxAmt:number,
      /**  Rate Code  */  
   RateCode:string,
      /**  Collection Type  */  
   CollectionType:number,
      /**  Timing of when to report taxes  */  
   Timing:number,
      /**  Exemption Type  */  
   ExemptType:number,
      /**  Exemption Percent  */  
   ExemptPercent:number,
      /**  Resolution Number  */  
   ResolutionNum:string,
      /**  Resolution Date  */  
   ResolutionDate:string,
      /**  Tax Rate Date  */  
   TaxRateDate:string,
      /**  Balance of the Taxable amount that has been deferred until payment  */  
   DefTaxableAmt:number,
      /**  Balance of the Taxable amount that has been deferred until payment  */  
   DocDefTaxableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1DefTaxableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2DefTaxableAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3DefTaxableAmt:number,
      /**  Balance of the Tax amount that has been deferred until payment  */  
   DefTaxAmt:number,
      /**  Balance of the Tax amount that has been deferred until payment  */  
   DocDefTaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1DefTaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2DefTaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3DefTaxAmt:number,
      /**  This record was manually added (not in Liability) but will use the standard calculations  */  
   ManAdd:boolean,
      /**  Deducatable Tax Amount  */  
   DedTaxAmt:number,
      /**  Deducatable Tax Amount  */  
   DocDedTaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1DedTaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2DedTaxAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3DedTaxAmt:number,
      /**   Used to allow a second tax record using the same tax code on an invoice.  When the sales tax field EcAquisition is checked then 2 invoice tax records are created.
NOTE:  This field is now used in VAT Reverse Charge logic.  If an invoice line is marked for Reverse Charge, a second line is created just like in the ECAcquisition logic. To distinguish the two scenarios, the ReverseCharge flag will be set to true if the second line is for Reverse Charge.  */  
   ECAcquisitionSeq:number,
      /**  Fixed Tax Amount  */  
   FixedAmount:number,
      /**  Document Fixed Tax Amount  */  
   DocFixedAmount:number,
      /**  Reporting currency value of this field  */  
   Rpt1FixedAmount:number,
      /**  Reporting currency value of this field  */  
   Rpt2FixedAmount:number,
      /**  Reporting currency value of this field  */  
   Rpt3FixedAmount:number,
      /**  Unique Identifier for Legal Text  */  
   TextCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   SalesTaxDescDescription:string,
   DocDisplaySymbol:string,
   CurrencySwitch:boolean,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CollectionTypeDescription:string,
   DisplaySymbol:string,
      /**  If Tax Liability is In Price then the user should not be able to change Manual flag on Tax Record  */  
   NoChangeManual:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
   BitFlag:number,
   RateCodeDescDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderRepCommRow{
      /**  Company Identifier  */  
   Company:string,
      /**  Order Number this sales rep commission is tied to  */  
   OrderNum:number,
      /**  Sales rep code for this commission data  */  
   SalesRepCode:string,
      /**  Sales Rep name  */  
   Name:string,
      /**  Number of commission lines this sales rep has for this order  */  
   CommLines:number,
      /**  Commission sale amount  */  
   CommSaleAmt:number,
      /**  Commission amount  */  
   CommAmt:number,
      /**  Seq number to keep key unique if sales rep is repeated  */  
   Seq:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderSchedRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Contains the Order Number that ties this detail record back to an OrderHed record.  */  
   OrderNum:number,
      /**  Specifies the number of payment of the Payment Schedule. This is an auto-generated sequence number.  */  
   PaySeq:number,
      /**  Specifies the number of days for the payment to be paid.  */  
   PayDays:number,
      /**  Specifies the percent of the payment to be paid. This is used to calculate amount to be paid per payment.  */  
   PayPercent:number,
      /**  Amount in Base Currency to be paid for the payment. This amount calculates by default based on Order total and Payment's Percentage.  */  
   PayAmount:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Amount in Document Currency to be paid for the payment. This amount calculates by default based on Order total and Payment's Percentage.  */  
   DocPayAmount:number,
      /**  Reporting currency value of this field  */  
   Rpt1PayAmount:number,
      /**  Reporting currency value of this field  */  
   Rpt2PayAmount:number,
      /**  Reporting currency value of this field  */  
   Rpt3PayAmount:number,
   CurrencySwitch:boolean,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**  Indicates if this is the last OrderSched row for the order  */  
   IsLastRow:boolean,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartSubsRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Part number that this substitute Part is for.  */  
   PartNum:string,
      /**  Substitute Part  */  
   SubPart:string,
      /**  Indicates the record type. "S" = Substitute, "C" = Compliment  */  
   RecType:string,
      /**  Pertains only to Substitute Parts (RecType = "S"). Values are "C" - Comparable, "D" - Downgrade, "U" - Upgrade  */  
   SubType:string,
      /**   The quantity of the alternate part per 1 of the parent part in the parents base inventory uom. Cannot be zero.
To convert an existing OrderDtl.SellingQty to a PartSubs. It is converted to the Parents Part Base Inventory UOM  then multiply PartSubs.QtyPer, then converted to  PartSub.SalesUM.  */  
   QtyPer:number,
      /**  Selling Unit of measure used when this part is used as a substitute/compliment with the parent part (partsubs.partnum).  Defaults as Part.SUM of the PartSub.SubPart.  */  
   SalesUM:string,
      /**  Optional Comment  */  
   Comment:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   DefaultSub:boolean,
      /**  Price for the Suggested Quantity  */  
   Price:number,
      /**  Suggested Quantity  */  
   SuggestedQty:number,
      /**  Selected Row  */  
   Selected:boolean,
      /**  Suggested Quantity for Order Qty in Quote Detail  */  
   SugOrderQty:number,
   BitFlag:number,
   PartNumPricePerCode:string,
   PartNumTrackLots:boolean,
   PartNumPartDescription:string,
   PartNumSalesUM:string,
   PartNumIUM:string,
   PartNumSellingFactor:number,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   SubPartSellingFactor:number,
   SubPartTrackSerialNum:boolean,
   SubPartTrackDimension:boolean,
   SubPartPartDescription:string,
   SubPartIUM:string,
   SubPartSalesUM:string,
   SubPartTrackLots:boolean,
   SubPartPricePerCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_QuoteQtyRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Quote # that this record is linked to.  */  
   QuoteNum:number,
      /**  The QuoteLine to which this QuoteQty record is related to.  */  
   QuoteLine:number,
      /**  An internally used integer assigned by the system to provide a unique key to the QuoteQty file. Allowing virtually unlimited quantities to be quoted for each detail line on a quote. This number is assigned as one greater than last one on file for the given QuoteDtl record.  */  
   QtyNum:number,
      /**  Represents one of the requested Quote Quantities for the line item using QuoteQty.IUM.  */  
   OurQuantity:number,
      /**  Quoted unit price for the given quantity. This value is entered by the user.  */  
   UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in
the customer currency (converted using the exchange rate on OrderHed).
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   DocUnitPrice:number,
      /**   Indicates the pricing per quantity. It can be "E" = per each,
"C" = per hundred,  "M" = per thousand. Used to calculate the extended unit price for the line item. The logic is to divide the QuoteQty.Quantity by the appropriate "per" value and then multiply by unit price.  Use the  Part.PricePerCode as a default. If Part record does not exist then default as "E"  */  
   PricePerCode:string,
      /**  Material Bur Markup Percent for this quoted quantity. May default from the QMarkUp file. By either using the default established for the customer (Customer.QMarkUpID) or the one established for the system (EQSyst.QMarkUpID) otherwise zero.  */  
   MtlBurMarkUp:number,
      /**  Material Markup Percent for this quoted quantity. May default from the QMarkUp file. By either using the default established for the customer (Customer.QMarkUpID) or the one established for the system (EQSyst.QMarkUpID) otherwise zero.  */  
   MaterialMarkUp:number,
      /**  SubContract Markup Percent for this quoted quantity. May default from the QMarkUp file. By either using the default established for the customer (Customer.QMarkUpID) or the one established for the system (EQSyst.QMarkUpID) otherwise zero.  */  
   SubcontractMarkUp:number,
      /**  Labor Markup Percent for this quoted quantity. May default from the QMarkUp file. By either using the default established for the customer (Customer.QMarkUpID) or the one established for the system (EQSyst.QMarkUpID) otherwise zero.  */  
   LaborMarkUp:number,
      /**  Labor Markup Percent for this quoted quantity. May default from the QMarkUp file. By either using the default established for the customer (Customer.QMarkUpID) or the one established for the system (EQSyst.QMarkUpID) otherwise zero.  */  
   BurdenMarkUp:number,
      /**  Miscellaneous Cost description.  */  
   MiscCostDesc:string,
      /**  Miscellaneous Cost amount that will be considered in the unit price calculations.  */  
   MiscCost:number,
      /**  Miscellaneous Cost Markup Percent for this quoted quantity. May default from the QMarkUp file. By either using the default established for the customer (Customer.QMarkUpID) or the one established for the system (EQSyst.QMarkUpID) otherwise zero.  */  
   MiscCostMarkUp:number,
      /**  Allows entry of commission percent so that it will be considered in the final calculated unit price. The commission percent is calculated as a percent of the "net unit price". Net unit price is the material, subcontract, labor, burden and miscellaneous costs plus their corresponding markups.  */  
   CommissionPct:number,
      /**  A qualifier of the Material, SubContract, Labor, Burden and Miscellaneous markup percent values. Prices can be calculated either as a straight markup of cost ( Cost + (Cost *  x %)) or a percent of profit ( Cost / (100% -  x%).   PercentType "M" = straight markup, "P" = Profit Percent. Defaulted from referenced QMarkup, from EQSyst.PercentType if not blank, else default as "M".  */  
   PercentType:string,
      /**  Unit of Measure (how it is stocked).  Use the default Part.IUM if its a valid part else use the global variable Def-UM which is established from XaSyst.DefaultUM.  */  
   IUM:string,
      /**  Unit of measure (how it is sold/issued).  Use the default Part.SUM if its a valid Part else use the global variable Def-UM which is established from XaSyst.DefaultUM.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  Represents one of the requested Quote Quantities for the line item using QuoteQty.SUM.  */  
   SellingQuantity:number,
      /**  Indicates how Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**  Unique identifier of this material markup. Defaults from its parent table Qmarkup.  */  
   MarkUpID:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Reporting currency value of this field  */  
   Rpt1UnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2UnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3UnitPrice:number,
      /**  Reserved for future use  */  
   InUnitPrice:number,
      /**  Reserved for future use  */  
   DocInUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt1InUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt2InUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt3InUnitPrice:number,
      /**  PriceSource  */  
   PriceSource:string,
      /**  PricePerAdl1000  */  
   PricePerAdl1000:number,
      /**  TotalSellPrice  */  
   TotalSellPrice:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  DocPricePerAdl1000  */  
   DocPricePerAdl1000:number,
      /**  DocTotalSellPrice  */  
   DocTotalSellPrice:number,
      /**  Indicates if the unit price for the qty break has been manually modified  */  
   UserChangedUnitPrice:boolean,
      /**  Worksheet field  */  
   CalcProfit:number,
      /**  CalcProfit Profit calculation  */  
   CalcProfitProfit:number,
      /**  Worksheet field  */  
   CalcUnitCost:number,
      /**  Worksheet field  */  
   CalcUnitPriceMarkup:number,
      /**  Worksheet field  */  
   CalcUnitPriceProfit:number,
      /**  Worksheet field  */  
   CalcUPCommMarkup:number,
      /**  Worksheet field  */  
   CalcUPCommProfit:number,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencySwitch:boolean,
      /**  Currency.CurrSymbol from QuoteHed  */  
   CurrSymbol:string,
      /**  Flag to indicate when to disable/enable material markup field  */  
   DisableMtlMarkup:boolean,
      /**  External field for MaterialMarkup Markup calculations  */  
   MaterialMarkupM:number,
      /**  External field for MaterialMarkup Profit calculations  */  
   MaterialMarkupP:number,
      /**  Indicates if the record has a miscellaneous charge associated with it  */  
   MiscChrg:string,
      /**  Worksheet field  */  
   PriceBurMarkup:number,
      /**  Worksheet field  */  
   PriceBurProfit:number,
      /**  Worksheet field  */  
   PriceLbrMarkup:number,
      /**  Worksheet field  */  
   PriceLbrProfit:number,
      /**  Worksheet field  */  
   PriceMscChrgMarkup:number,
      /**  Worksheet field  */  
   PriceMscChrgProfit:number,
      /**  Worksheet field  */  
   PriceMtlBurMarkup:number,
      /**  Worksheet field  */  
   PriceMtlBurProfit:number,
      /**  Worksheet field  */  
   PriceMtlMarkup:number,
      /**  Worksheet field  */  
   PriceMtlProfit:number,
      /**  Integer value of the PricePerCode field (for calculations)  */  
   PricePerFactor:number,
      /**  Worksheet field  */  
   PriceSubMarkup:number,
      /**  Worksheet field  */  
   PriceSubProfit:number,
      /**  Worksheet field  */  
   PriceTotalCommMarkup:number,
      /**  Worksheet field  */  
   PriceTotalCommProfit:number,
      /**  Worksheet field  */  
   PriceTotalMarkup:number,
      /**  Worksheet field  */  
   PriceTotalProfit:number,
      /**  Worksheet field  */  
   QuotedMarkup:number,
      /**  Worksheet field  */  
   QuotedProfit:number,
      /**  If marked then the totals are not updated and a ?Roll up costs? is needed.  */  
   RollUpCostNeeded:boolean,
      /**  QuoteCst.TotalBurCost - Worksheet temp field  */  
   TotalBurCost:number,
      /**  Worksheet field  */  
   TotalCommission:number,
      /**  Total Commision Profit calculation  */  
   TotalCommProfit:number,
      /**  Worksheet field  */  
   TotalCost:number,
      /**  QuoteCst.TotalLbrCost - Worksheet temp field  */  
   TotalLbrCost:number,
      /**  Worksheet field  */  
   TotalMarkup:number,
      /**  QuoteCst.TotalMtlBurCost - Worksheet temp field  */  
   TotalMtlBurCost:number,
      /**  QuoteCst.TotalMtlCost - Worksheet temp field  */  
   TotalMtlCost:number,
      /**  QuoteCst.TotalProdBurHrs - Worksheet temp field  */  
   TotalProdBurHrs:number,
      /**  QuoteCst.TotalProdLbrHrs - Worksheet temp field  */  
   TotalProdLbrHrs:number,
      /**  Worksheet field  */  
   TotalProfit:number,
      /**  Worksheet field  */  
   TotalQuotedPrice:number,
      /**  QuoteCst.TotalSetupBurHrs - Worksheet temp field  */  
   TotalSetupBurHrs:number,
      /**  QuoteCst.TotalSetupLbrHrs - Worksheet temp field  */  
   TotalSetupLbrHrs:number,
      /**  QuoteCst.TotalSubCost - Worksheet temp field  */  
   TotalSubCost:number,
      /**  Worksheet Quoted Unit Price  */  
   WQUnitPrice:number,
      /**  Currency.CurrSymbol for BASE  */  
   BaseCurrSymbol:string,
      /**  Worksheet field  */  
   CalcMarkup:number,
      /**  CalcMarkup Profit calculation  */  
   CalcMarkupProfit:number,
   BitFlag:number,
   QuoteLineLineDesc:string,
   QuoteNumCurrencyCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_SNFormatRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Site Identifier. This field cannot be blank.  */  
   Plant:string,
      /**  The PartNum field identifies the Part and is used in the primary key.  */  
   PartNum:string,
      /**  Number of digits in the serial number  */  
   NumberOfDigits:number,
      /**  If the SNBaseDataType is Mask this is the Serial Mask ID assigned for format validation/generation.  */  
   SNMask:string,
      /**   Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer, Mask
Code/desc required:
CHARACTER`Alphanumeric
INTEGER`NumericOnly
MASK`Serial Mask
This field should be flagged as Include = true in Object Designer.  */  
   SNBaseDataType:string,
      /**   Current setting for Format of the Base serial number that will be used as new serial numbers are generated. Expressed in progress syntax. Ex: X(30), 99999999 for Character or Integer, or as a Serial Mask defined in SerialMask table.
This field should be flagged as ReadOnly and Include = true in Object Designer.  */  
   SNFormat:string,
      /**  Whether or not to have leading zeroes  */  
   LeadingZeroes:boolean,
      /**   Current setting for the prefix that will be attached to all new Serial Numbers as they are generated for Character and Integer format types.
This field should be flagged as Include = true in Object Designer.  */  
   SNPrefix:string,
      /**  A standard suffix that will be attached to all serial numbers generated for the PartSite currently used only by SNBaseStructure Mask types  */  
   SNMaskSuffix:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types  */  
   SNMaskPrefix:string,
      /**  This is the last used serial sequence. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It can be altered by the user and several PartSites can have the same counter values defined, but  */  
   SNLastUsedSeq:string,
   HasSerialNumbers:boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PartPricePerCode:string,
   PartTrackLots:boolean,
   PartTrackSerialNum:boolean,
   PartTrackDimension:boolean,
   PartSalesUM:string,
   PartIUM:string,
   PartSellingFactor:number,
   PartPartDescription:string,
   SerialMaskMaskType:number,
   SerialMaskMask:string,
   SerialMaskExample:string,
   SerialMaskDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_SOEntryUIParamsRow{
      /**  Value from UserComp.CalcQtysPreference  */  
   CalcQtysPreference:boolean,
      /**  Value from CreditCardProc.AllowDepPay  */  
   CCAllowSales:boolean,
      /**  Value from CreditCardProc.UseAVS  */  
   CCEnableAddress:boolean,
      /**  Value from CreditCardProc.UseCSC.  */  
   CCEnableCSC:boolean,
      /**  True if can find IMOrderHed for this company where the IMOrderHed.IncomingOutgoing = 'i'.  */  
   EnableICPOSugTool:boolean,
      /**  Value from XBSyst.Localization.  */  
   Localization:string,
      /**  Value from XASyst.SOReadyToCalcDflt.  */  
   SOReadyToCalcDflt:boolean,
      /**  Value from PtchFld where tablename = 'PlantConfCtrl', FieldName = 'SuppressSOMakeDirWrn'  */  
   SuppressSOMakeDirWrn:boolean,
      /**   Allow Project/WBS phase to be defined
(Patch field)  */  
   PrjAllowWBSPhase:boolean,
      /**   Filter sales orders and customer access using workflow territory security.
(Patch Field)  */  
   UseTerritorySecurity:boolean,
      /**  Indicates whether the PlantConfCtrl for the current login site has ManifestRateShopping enabled  */  
   EnableManifestRateShopping:boolean,
      /**  URL for Manifest Rate Shopping for the current login Site  */  
   ManifestRateShoppingURL:string,
      /**  CREProcessor is true when Credit Card Configuration is CRE Server.  */  
   CREProcessor:boolean,
      /**  Host Address for the Paygate Hosted Token Service.  */  
   PayGateHostAddress:string,
      /**  NameSpace for the Paygate Hosted Token Service.  */  
   PayGateNameSpace:string,
      /**  Public Key for the Paygate Hosted Token Service EWA component.  */  
   PayGatePublicKey:string,
   HMRCTaxValidationAllow:boolean,
   TaxValidationAllow:boolean,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_SOEntryUIParamsTableset{
   SOEntryUIParams:Erp_Tablesets_SOEntryUIParamsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_SalesOrderTableset{
   OrderHed:Erp_Tablesets_OrderHedRow[],
   OrderHedAttch:Erp_Tablesets_OrderHedAttchRow[],
   OHOrderMsc:Erp_Tablesets_OHOrderMscRow[],
   OrderDtl:Erp_Tablesets_OrderDtlRow[],
   OrderDtlAttch:Erp_Tablesets_OrderDtlAttchRow[],
   OrderMsc:Erp_Tablesets_OrderMscRow[],
   OrderRel:Erp_Tablesets_OrderRelRow[],
   OrderRelTax:Erp_Tablesets_OrderRelTaxRow[],
   OrderHedUPS:Erp_Tablesets_OrderHedUPSRow[],
   OrderRepComm:Erp_Tablesets_OrderRepCommRow[],
   OrderSched:Erp_Tablesets_OrderSchedRow[],
   HedTaxSum:Erp_Tablesets_HedTaxSumRow[],
   OrderHist:Erp_Tablesets_OrderHistRow[],
   PartSubs:Erp_Tablesets_PartSubsRow[],
   SelectedSerialNumbers:Erp_Tablesets_SelectedSerialNumbersRow[],
   SNFormat:Erp_Tablesets_SNFormatRow[],
   TaxConnectStatus:Erp_Tablesets_TaxConnectStatusRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_SaveOTSParamsRow{
   OTSAddress1:string,
   OTSAddress2:string,
   OTSAddress3:string,
   OTSCity:string,
   OTSContact:string,
   OTSCountryNum:number,
   OTSCustSaved:boolean,
   OTSFaxNum:string,
   OTSName:string,
   OTSPhoneNum:string,
   OTSResaleID:string,
   OTSSaveAs:string,
   OTSSaveCustID:string,
   OTSSaved:boolean,
   OTSShipToNum:string,
   OTSState:string,
   OTSTaxRegionCode:string,
   OTSZIP:string,
   OTSOverride:boolean,
   OTSTaxValidationStatus:number,
   OTSTaxValidationDate:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_SaveOTSParamsTableset{
   SaveOTSParams:Erp_Tablesets_SaveOTSParamsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_SelectSerialNumbersParamsRow{
      /**  The part number to which the serial numbers have been assigned.  */  
   partNum:string,
      /**  The quantity of serial numbers that need to be selected.  */  
   quantity:number,
      /**  whereClause for filtering available serial numbers  */  
   whereClause:string,
      /**  transType of this transaction  */  
   transType:string,
      /**  Include when filtering a set of SN's for BL processing is necessary.  It may be null if not needed.  */  
   sourceRowID:string,
      /**  Determines if serial numbers can be created.  */  
   enableCreate:boolean,
      /**  Determines if serial numbers can be selected.  */  
   enableSelect:boolean,
      /**  Determines if serial numbers can be retrieved.  */  
   enableRetrieve:boolean,
      /**  Specifies whether Voided serial numbers can be manually selected.  */  
   allowVoided:boolean,
      /**  The Plant associated with this transaction  */  
   plant:string,
   xrefPartNum:string,
   xrefPartType:string,
   xrefCustNum:number,
      /**  temporary field used to link the packout lines to ship detail lines  */  
   poLinkValues:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   attributeSetID:number,
      /**  The Short Description of the Attribute Set.  */  
   attributeSetShortDescription:string,
      /**  Revision number which is used to uniquely identify the revision of the part.  */  
   revisionNum:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_SelectSerialNumbersParamsTableset{
   SelectSerialNumbersParams:Erp_Tablesets_SelectSerialNumbersParamsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_SelectedSerialNumbersRow{
      /**  Company  */  
   Company:string,
      /**  SerialNumber  */  
   SerialNumber:string,
      /**  Scrapped flag  */  
   Scrapped:boolean,
      /**  Scrapped reason code  */  
   ScrappedReasonCode:string,
      /**  Voided flag  */  
   Voided:boolean,
      /**  Reference field  */  
   Reference:string,
      /**  Reason code type = s  */  
   ReasonCodeType:string,
      /**  Reason code description  */  
   ReasonCodeDesc:string,
      /**  PartNumber  */  
   PartNum:string,
      /**  Serial number prefix  */  
   SNPrefix:string,
      /**  Base number used to create the serial number  */  
   SNBaseNumber:string,
      /**  RowID of the source record for this serial number  */  
   SourceRowID:string,
      /**  TransType of the record that created this serial number  */  
   TransType:string,
      /**  True if this serial numbered part passed inspection  */  
   PassedInspection:boolean,
      /**  Used to flag previously selected serial numbers as deselected  */  
   Deselected:boolean,
   KitWhseList:string,
      /**  This will be the raw serial number as it was scanned or entered into the system. This would only differ from the SerialNumber field if a validate type mask was being used where characters were stripped (using ~ in the mask).  */  
   RawSerialNum:string,
      /**  Action type field used for Kanban receipts to indicate if the new serial number status is Inventory, Scrapped or NonConf.  This requires Code/desc:  1 ` inventory 2 ` Scrapped 3 ` Nonconformance  */  
   KBLbrAction:number,
      /**  Description field for KBLbrAction ? holds the translated description for the KBLbrAction code for UI display and combo box.  */  
   KBLbrActionDesc:string,
      /**  If true, then users can not deselect this serial number.  This is used by applications that allow maintenance to the Selected Serial Numbers after update.  */  
   PreventDeselect:boolean,
      /**  Used only by SN Assignment  */  
   XRefPartNum:string,
      /**  Used only by SN Assignment: C = Customer Part / I = Internal Part XRef  */  
   XRefPartType:string,
   PreDeselected:boolean,
      /**  temporary field used to link the packout lines to ship detail lines  */  
   poLinkValues:string,
      /**  The mask the was used to generate the serial number  */  
   SNMask:string,
      /**  Flag to indicate that the SelectedSerialNumbers entry has not yet been saved to the DB for the related transaction. Used to keep track of which deselected serial numbers need to be passed to the transaction update logic.  */  
   NotSavedToDB:boolean,
   RowSelected:boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_TaxConnectStatusRow{
      /**  Company  */  
   Company:string,
      /**  If true, service is down. If false, service is up.  */  
   ETCOffline:boolean,
      /**  Error message returned from the call to the tax service.  */  
   ErrorMessage:string,
      /**  This is the success/failure status of the call to tax connect. If false, the call failed, if true it was successful  */  
   TCStatus:boolean,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_UpdExtSalesOrderTableset{
   OrderHed:Erp_Tablesets_OrderHedRow[],
   OrderHedAttch:Erp_Tablesets_OrderHedAttchRow[],
   OHOrderMsc:Erp_Tablesets_OHOrderMscRow[],
   OrderDtl:Erp_Tablesets_OrderDtlRow[],
   OrderDtlAttch:Erp_Tablesets_OrderDtlAttchRow[],
   OrderMsc:Erp_Tablesets_OrderMscRow[],
   OrderRel:Erp_Tablesets_OrderRelRow[],
   OrderRelTax:Erp_Tablesets_OrderRelTaxRow[],
   OrderHedUPS:Erp_Tablesets_OrderHedUPSRow[],
   OrderRepComm:Erp_Tablesets_OrderRepCommRow[],
   OrderSched:Erp_Tablesets_OrderSchedRow[],
   HedTaxSum:Erp_Tablesets_HedTaxSumRow[],
   OrderHist:Erp_Tablesets_OrderHistRow[],
   PartSubs:Erp_Tablesets_PartSubsRow[],
   SelectedSerialNumbers:Erp_Tablesets_SelectedSerialNumbersRow[],
   SNFormat:Erp_Tablesets_SNFormatRow[],
   TaxConnectStatus:Erp_Tablesets_TaxConnectStatusRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

   /** Required : 
      @param sourceSysRowID
   */  
export interface GetBasePartAndConfigType_input{
      /**  OrderDtl sysRowID  */  
   sourceSysRowID:string,
}

export interface GetBasePartAndConfigType_output{
parameters : {
      /**  output parameters  */  
   cfgPartNum:string,
   cfgRevisionNum:string,
   configType:string,
   configID:string,
   configURL:string,
}
}

   /** Required : 
      @param sourceSysRowID
   */  
export interface GetBasePartForConfig_input{
      /**  Order Number of the target Assembly  */  
   sourceSysRowID:string,
}

export interface GetBasePartForConfig_output{
parameters : {
      /**  output parameters  */  
   cfgPartNum:string,
   cfgRevisionNum:string,
}
}

   /** Required : 
      @param iOrderNum
   */  
export interface GetByIDLinkedOrder_input{
      /**  The Order Number of the order to get  */  
   iOrderNum:number,
}

export interface GetByIDLinkedOrder_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param orderNum
   */  
export interface GetByID_input{
   orderNum:number,
}

export interface GetByID_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param id
   */  
export interface GetBySysRowID_input{
   id:string,
}

export interface GetBySysRowID_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param ids
   */  
export interface GetBySysRowIDs_input{
   ids:string,
}

export interface GetBySysRowIDs_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

export interface GetCalcQtyPref_output{
parameters : {
      /**  output parameters  */  
   opCalcQtyPref:boolean,
}
}

   /** Required : 
      @param tableName
      @param fieldName
   */  
export interface GetCodeDescList_input{
   tableName:string,
   fieldName:string,
}

export interface GetCodeDescList_output{
   returnObj:string,
}

   /** Required : 
      @param iOrderNum
   */  
export interface GetGlbSugPOChgForOrder_input{
   iOrderNum:number,
}

export interface GetGlbSugPOChgForOrder_output{
   returnObj:Erp_Tablesets_GlbSugPOChgTableset[],
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iOrderRelNum
      @param pageSize
      @param absolutePage
   */  
export interface GetGlbSugPOChg_input{
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The Order Line Number  */  
   iOrderLine:number,
      /**  The Order Release Number  */  
   iOrderRelNum:number,
      /**  The Page Size  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
}

export interface GetGlbSugPOChg_output{
   returnObj:Erp_Tablesets_GlbSugPOChgTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param lOnlyRel
      @param ds
   */  
export interface GetInventoryQuantities_input{
   lOnlyRel:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface GetInventoryQuantities_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param orderNum
      @param orderLine
      @param orderRelNum
   */  
export interface GetJobProdForRelease_input{
      /**  The Order Number  */  
   orderNum:number,
      /**  The Order Line Number  */  
   orderLine:number,
      /**  The Order Line Number  */  
   orderRelNum:number,
}

export interface GetJobProdForRelease_output{
   returnObj:Erp_Tablesets_OrdRelJobProdTableset[],
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param pageSize
      @param absolutePage
   */  
export interface GetJobProd_input{
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The Order Line Number  */  
   iOrderLine:number,
      /**  The Page Size  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
}

export interface GetJobProd_output{
   returnObj:Erp_Tablesets_OrdRelJobProdTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param iPartNum
      @param iRevisionNum
      @param iTargetAsm
      @param orderNum
      @param orderLine
      @param iUseMethodForParts
      @param regenerateKit
      @param errorMsg
      @param ds
   */  
export interface GetKitComponents_input{
      /**  Part Number of the given OrderLine  */  
   iPartNum:string,
      /**  Revision Number selected for the given PartNum  */  
   iRevisionNum:string,
      /**  Target assembly to be exploded (usually asm 0)  */  
   iTargetAsm:number,
      /**  Order number to be exploded  */  
   orderNum:number,
      /**  Order line which will be the Kit Parent  */  
   orderLine:number,
      /**  -  */  
   iUseMethodForParts:boolean,
      /**  If true this will cause the previous loaded components to be deleted  */  
   regenerateKit:boolean,
      /**  Text message returned in case an error/warning was found  */  
   errorMsg:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface GetKitComponents_output{
parameters : {
      /**  output parameters  */  
   errorMsg:string,
   errorType:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
      @param customClause
   */  
export interface GetListCustom_input{
      /**  The search criteria  */  
   whereClause:string,
      /**  Size of a page  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
      /**  Custom WhereClause  */  
   customClause:string,
}

export interface GetListCustom_output{
   returnObj:Erp_Tablesets_OrderHedListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
   */  
export interface GetList_input{
      /**  An expression used to filter the rows. Can be left blank for all rows.  */  
   whereClause:string,
      /**  The maximum number of rows to return. Leave as zero for no maximum.  */  
   pageSize:number,
      /**  Page of rows to return.  */  
   absolutePage:number,
}

export interface GetList_output{
   returnObj:Erp_Tablesets_OrderHedListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param ds
      @param orderNum
      @param orderLine
   */  
export interface GetNewOHOrderMsc_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
   orderLine:number,
}

export interface GetNewOHOrderMsc_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
      @param orderLine
   */  
export interface GetNewOrderDtlAttch_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
   orderLine:number,
}

export interface GetNewOrderDtlAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
   */  
export interface GetNewOrderDtl_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
}

export interface GetNewOrderDtl_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
   */  
export interface GetNewOrderHedAttch_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
}

export interface GetNewOrderHedAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
   */  
export interface GetNewOrderHedUPS_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
}

export interface GetNewOrderHedUPS_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface GetNewOrderHed_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface GetNewOrderHed_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
      @param orderLine
   */  
export interface GetNewOrderMsc_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
   orderLine:number,
}

export interface GetNewOrderMsc_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
      @param orderLine
      @param orderRelNum
      @param taxCode
      @param rateCode
   */  
export interface GetNewOrderRelTax_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
   orderLine:number,
   orderRelNum:number,
   taxCode:string,
   rateCode:string,
}

export interface GetNewOrderRelTax_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
      @param orderLine
   */  
export interface GetNewOrderRel_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
   orderLine:number,
}

export interface GetNewOrderRel_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param orderNum
   */  
export interface GetNewOrderSched_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   orderNum:number,
}

export interface GetNewOrderSched_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param ds
   */  
export interface GetNewSalesKit_input{
      /**  Order number where the Kit Parent resides  */  
   OrderNum:number,
      /**  Order line that has the SalesKit and to which the kit component will be added  */  
   OrderLine:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface GetNewSalesKit_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface GetPayBTFlagDefaults_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface GetPayBTFlagDefaults_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

export interface GetPlantConfCtrlInfo_output{
parameters : {
      /**  output parameters  */  
   opSuppressWarning:boolean,
}
}

   /** Required : 
      @param iQuoteNum
      @param iQuoteLine
      @param pageSize
      @param absolutePage
   */  
export interface GetQuoteQty_input{
      /**  The Quote Number  */  
   iQuoteNum:number,
      /**  The Quote Line Number  */  
   iQuoteLine:number,
      /**  The Page Size  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
}

export interface GetQuoteQty_output{
   returnObj:Erp_Tablesets_OrdDtlQuoteQtyTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
   */  
export interface GetRowsAuthorizedTerritories_input{
      /**  The search criteria  */  
   whereClause:string,
      /**  Size of a page  */  
   pageSize:number,
      /**  The absolute page  */  
   absolutePage:number,
}

export interface GetRowsAuthorizedTerritories_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClauseOrderHed
      @param whereClauseOrderHedAttch
      @param whereClauseOHOrderMsc
      @param whereClauseOrderDtl
      @param whereClauseOrderDtlAttch
      @param whereClauseOrderMsc
      @param whereClauseOrderRel
      @param whereClauseOrderRepComm
      @param whereClauseSelectedSerialNumbers
      @param whereClauseSerialNumberSearch
      @param whereClauseSNFormat
      @param pageSize
      @param absolutePage
   */  
export interface GetRowsCustomerTracker_input{
      /**  Whereclause for OrderHed table.  */  
   whereClauseOrderHed:string,
      /**  Whereclause for OrderHedAttch table.  */  
   whereClauseOrderHedAttch:string,
      /**  Whereclause for OHOrderMsc table.  */  
   whereClauseOHOrderMsc:string,
      /**  Whereclause for OrderDtl table.  */  
   whereClauseOrderDtl:string,
      /**  Whereclause for OrderDtlAttch table.  */  
   whereClauseOrderDtlAttch:string,
      /**  Whereclause for OrderMsc table.  */  
   whereClauseOrderMsc:string,
      /**  Whereclause for OrderRel  table.  */  
   whereClauseOrderRel:string,
      /**  Whereclause for RepComm table.  */  
   whereClauseOrderRepComm:string,
      /**  Whereclause for SelectedSerialNumbers table.  */  
   whereClauseSelectedSerialNumbers:string,
      /**  Whereclause for SerialNumberSearch table.  */  
   whereClauseSerialNumberSearch:string,
      /**  Whereclause for SNFormat table.  */  
   whereClauseSNFormat:string,
      /**  Page size.  */  
   pageSize:number,
      /**  Absolute page.  */  
   absolutePage:number,
}

export interface GetRowsCustomerTracker_output{
   returnObj:Erp_Tablesets_OrderCustTrkTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClauseOrderHed
      @param whereClauseOrderHedAttch
      @param whereClauseOHOrderMsc
      @param whereClauseOrderDtl
      @param whereClauseOrderDtlAttch
      @param whereClauseOrderMsc
      @param whereClauseOrderRel
      @param whereClauseOrderRelTax
      @param whereClauseOrderHedUPS
      @param whereClauseOrderRepComm
      @param whereClauseOrderSched
      @param whereClauseHedTaxSum
      @param whereClauseOrderHist
      @param whereClausePartSubs
      @param whereClauseSelectedSerialNumbers
      @param whereClauseSNFormat
      @param whereClauseTaxConnectStatus
      @param groupID
      @param headNum
      @param pageSize
      @param absolutePage
   */  
export interface GetRowsForCashReceipt_input{
   whereClauseOrderHed:string,
   whereClauseOrderHedAttch:string,
   whereClauseOHOrderMsc:string,
   whereClauseOrderDtl:string,
   whereClauseOrderDtlAttch:string,
   whereClauseOrderMsc:string,
   whereClauseOrderRel:string,
   whereClauseOrderRelTax:string,
   whereClauseOrderHedUPS:string,
   whereClauseOrderRepComm:string,
   whereClauseOrderSched:string,
   whereClauseHedTaxSum:string,
   whereClauseOrderHist:string,
   whereClausePartSubs:string,
   whereClauseSelectedSerialNumbers:string,
   whereClauseSNFormat:string,
   whereClauseTaxConnectStatus:string,
   groupID:string,
   headNum:number,
   pageSize:number,
   absolutePage:number,
}

export interface GetRowsForCashReceipt_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClauseOrderHed
      @param whereClauseOrderHedAttch
      @param whereClauseOHOrderMsc
      @param whereClauseOrderDtl
      @param whereClauseOrderDtlAttch
      @param whereClauseOrderMsc
      @param whereClauseOrderRel
      @param whereClauseOrderRelTax
      @param whereClauseOrderHedUPS
      @param whereClauseOrderRepComm
      @param whereClauseOrderSched
      @param whereClauseHedTaxSum
      @param whereClauseOrderHist
      @param whereClausePartSubs
      @param whereClauseSelectedSerialNumbers
      @param whereClauseSNFormat
      @param whereClauseTaxConnectStatus
      @param invoiceNum
      @param pageSize
      @param absolutePage
   */  
export interface GetRowsForInvoice_input{
   whereClauseOrderHed:string,
   whereClauseOrderHedAttch:string,
   whereClauseOHOrderMsc:string,
   whereClauseOrderDtl:string,
   whereClauseOrderDtlAttch:string,
   whereClauseOrderMsc:string,
   whereClauseOrderRel:string,
   whereClauseOrderRelTax:string,
   whereClauseOrderHedUPS:string,
   whereClauseOrderRepComm:string,
   whereClauseOrderSched:string,
   whereClauseHedTaxSum:string,
   whereClauseOrderHist:string,
   whereClausePartSubs:string,
   whereClauseSelectedSerialNumbers:string,
   whereClauseSNFormat:string,
   whereClauseTaxConnectStatus:string,
   invoiceNum:number,
   pageSize:number,
   absolutePage:number,
}

export interface GetRowsForInvoice_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClauseOrderHed
      @param whereClauseOrderHedAttch
      @param whereClauseOHOrderMsc
      @param whereClauseOrderDtl
      @param whereClauseOrderDtlAttch
      @param whereClauseOrderMsc
      @param whereClauseOrderRel
      @param whereClauseOrderRelTax
      @param whereClauseOrderHedUPS
      @param whereClauseOrderRepComm
      @param whereClauseOrderSched
      @param whereClauseHedTaxSum
      @param whereClauseOrderHist
      @param whereClausePartSubs
      @param whereClauseSelectedSerialNumbers
      @param whereClauseSNFormat
      @param whereClauseTaxConnectStatus
      @param quoteNum
      @param pageSize
      @param absolutePage
   */  
export interface GetRowsForQuote_input{
   whereClauseOrderHed:string,
   whereClauseOrderHedAttch:string,
   whereClauseOHOrderMsc:string,
   whereClauseOrderDtl:string,
   whereClauseOrderDtlAttch:string,
   whereClauseOrderMsc:string,
   whereClauseOrderRel:string,
   whereClauseOrderRelTax:string,
   whereClauseOrderHedUPS:string,
   whereClauseOrderRepComm:string,
   whereClauseOrderSched:string,
   whereClauseHedTaxSum:string,
   whereClauseOrderHist:string,
   whereClausePartSubs:string,
   whereClauseSelectedSerialNumbers:string,
   whereClauseSNFormat:string,
   whereClauseTaxConnectStatus:string,
   quoteNum:number,
   pageSize:number,
   absolutePage:number,
}

export interface GetRowsForQuote_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClauseOrderHed
      @param whereClauseOrderHedAttch
      @param whereClauseOHOrderMsc
      @param whereClauseOrderDtl
      @param whereClauseOrderDtlAttch
      @param whereClauseOrderMsc
      @param whereClauseOrderRel
      @param whereClauseOrderRelTax
      @param whereClauseOrderHedUPS
      @param whereClauseOrderRepComm
      @param whereClauseOrderSched
      @param whereClauseHedTaxSum
      @param whereClauseOrderHist
      @param whereClausePartSubs
      @param whereClauseSelectedSerialNumbers
      @param whereClauseSNFormat
      @param whereClauseTaxConnectStatus
      @param packNum
      @param pageSize
      @param absolutePage
   */  
export interface GetRowsForShipment_input{
   whereClauseOrderHed:string,
   whereClauseOrderHedAttch:string,
   whereClauseOHOrderMsc:string,
   whereClauseOrderDtl:string,
   whereClauseOrderDtlAttch:string,
   whereClauseOrderMsc:string,
   whereClauseOrderRel:string,
   whereClauseOrderRelTax:string,
   whereClauseOrderHedUPS:string,
   whereClauseOrderRepComm:string,
   whereClauseOrderSched:string,
   whereClauseHedTaxSum:string,
   whereClauseOrderHist:string,
   whereClausePartSubs:string,
   whereClauseSelectedSerialNumbers:string,
   whereClauseSNFormat:string,
   whereClauseTaxConnectStatus:string,
   packNum:number,
   pageSize:number,
   absolutePage:number,
}

export interface GetRowsForShipment_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param whereClauseOrderHed
      @param whereClauseOrderHedAttch
      @param whereClauseOHOrderMsc
      @param whereClauseOrderDtl
      @param whereClauseOrderDtlAttch
      @param whereClauseOrderMsc
      @param whereClauseOrderRel
      @param whereClauseOrderRelTax
      @param whereClauseOrderHedUPS
      @param whereClauseOrderRepComm
      @param whereClauseOrderSched
      @param whereClauseHedTaxSum
      @param whereClauseOrderHist
      @param whereClausePartSubs
      @param whereClauseSelectedSerialNumbers
      @param whereClauseSNFormat
      @param whereClauseTaxConnectStatus
      @param pageSize
      @param absolutePage
   */  
export interface GetRows_input{
   whereClauseOrderHed:string,
   whereClauseOrderHedAttch:string,
   whereClauseOHOrderMsc:string,
   whereClauseOrderDtl:string,
   whereClauseOrderDtlAttch:string,
   whereClauseOrderMsc:string,
   whereClauseOrderRel:string,
   whereClauseOrderRelTax:string,
   whereClauseOrderHedUPS:string,
   whereClauseOrderRepComm:string,
   whereClauseOrderSched:string,
   whereClauseHedTaxSum:string,
   whereClauseOrderHist:string,
   whereClausePartSubs:string,
   whereClauseSelectedSerialNumbers:string,
   whereClauseSNFormat:string,
   whereClauseTaxConnectStatus:string,
   pageSize:number,
   absolutePage:number,
}

export interface GetRows_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param orderNum
      @param maxNumOfCards
   */  
export interface GetSalesOrderRelationshipMap_input{
   orderNum:number,
   maxNumOfCards:number,
}

export interface GetSalesOrderRelationshipMap_output{
   returnObj:string,
}

   /** Required : 
      @param ipPartNum
      @param ipAttributeSetID
      @param ipWhseCode
      @param ipBinNum
      @param ipQuantity
      @param ipTranType
      @param ipRowID
   */  
export interface GetSelectSerialNumbersParams_input{
      /**  ipPartNum  */  
   ipPartNum:string,
      /**  ipAttributeSetID  */  
   ipAttributeSetID:number,
      /**  ipWhseCode  */  
   ipWhseCode:string,
      /**  ipBinNum  */  
   ipBinNum:string,
      /**  ipQuantity  */  
   ipQuantity:number,
      /**  ipTranType  */  
   ipTranType:string,
      /**  ipRowID  */  
   ipRowID:string,
}

export interface GetSelectSerialNumbersParams_output{
   returnObj:Erp_Tablesets_SelectSerialNumbersParamsTableset[],
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param PartNum
      @param RevisionNum
   */  
export interface GetSmartString_input{
      /**  Kit component order number  */  
   OrderNum:number,
      /**  Kit component order line  */  
   OrderLine:number,
      /**  The part being configured  */  
   PartNum:string,
      /**  The revision being configured  */  
   RevisionNum:string,
}

export interface GetSmartString_output{
parameters : {
      /**  output parameters  */  
   SmartString:string,
   CreatePart:boolean,
   PromptForPartNum:boolean,
   NotifyOfExistingPart:boolean,
   NewPartNum:string,
   CreateCustPart:boolean,
   PromptForCustPartNum:boolean,
   NewCustPartNum:string,
   PromptForAutoCreatePart:boolean,
}
}

export interface GetUIParams_output{
   returnObj:Erp_Tablesets_SOEntryUIParamsTableset[],
}

   /** Required : 
      @param cRowIdent
   */  
export interface GlbSugPOChgDelete_input{
      /**  The row ident of the record to delete  */  
   cRowIdent:string,
}

export interface GlbSugPOChgDelete_output{
   returnObj:Erp_Tablesets_GlbSugPOChgTableset[],
}

   /** Required : 
      @param ds
   */  
export interface GlbSugPOChgUpdate_input{
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}

export interface GlbSugPOChgUpdate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbSugPOChgTableset[],
}
}

   /** Required : 
      @param iPartNum
   */  
export interface HasMultipleSubs_input{
   iPartNum:string,
}

export interface HasMultipleSubs_output{
   returnObj:boolean,
}

export interface Ice_BOUpdErrorRow{
   TableName:string,
   ErrorLevel:string,
   ErrorType:string,
   ErrorText:string,
   ErrorSysRowID:string,
   SysRowID:string,
   RowMod:string,
}

export interface Ice_BOUpdErrorTableset{
   BOUpdError:Ice_BOUpdErrorRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Ice_Extensions_ExtensionRow{
   ColumnValues:object
   RowMod:string,
   SysRowID:string,
}

export interface Ice_Extensions_ExtensionTableColumn{
   ColumnName:string,
   ColumnType:string,
}

export interface Ice_Extensions_ExtensionTableData{
   Table:Ice_Extensions_ExtensionRow[],
   SystemCode:string,
   TableName:string,
   Columns:Ice_Extensions_ExtensionTableColumn[],
   PrimaryKeyColumns:string,
   PeerTableSystemCode:string,
   PeerTableName:string,
}

   /** Required : 
      @param orderNum
   */  
export interface InvoiceExists_input{
      /**  Order number  */  
   orderNum:number,
}

export interface InvoiceExists_output{
      /**  True if invoice exists, False if not.  */  
   returnObj:boolean,
}

   /** Required : 
      @param iPartNum
   */  
export interface IsRunOutOnHand_input{
   iPartNum:string,
}

export interface IsRunOutOnHand_output{
   returnObj:boolean,
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iOrderRelNum
      @param cJobNum
   */  
export interface JobProdDelete_input{
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The Order Line Number  */  
   iOrderLine:number,
      /**  The Order Release Number  */  
   iOrderRelNum:number,
      /**  Job Number  */  
   cJobNum:string,
}

export interface JobProdDelete_output{
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param PartNum
      @param RevisionNum
      @param SmartString
      @param NewPartNum
      @param NewCustPartNum
      @param ResponseAutoCrtPart
   */  
export interface KitCompPartCreate_input{
      /**  Kit component order number  */  
   OrderNum:number,
      /**  Kit component order line  */  
   OrderLine:number,
      /**  The part being configured  */  
   PartNum:string,
      /**  The revision being configured  */  
   RevisionNum:string,
      /**  The generated smart string of the configuration  */  
   SmartString:string,
      /**  The Part Number to be used for a new part creation.  If blank, a part will not be created.  */  
   NewPartNum:string,
      /**  The Customer Part Number to stored on the order line.  */  
   NewCustPartNum:string,
      /**  Answer to the question presented to user about auto creating a part.  */  
   ResponseAutoCrtPart:boolean,
}

export interface KitCompPartCreate_output{
parameters : {
      /**  output parameters  */  
   NewPartAlreadyExists:boolean,
}
}

   /** Required : 
      @param lCheckForOrderChangedMsg
      @param lcheckForResponse
      @param cTableName
      @param iCustNum
      @param iOrderNum
      @param lweLicensed
      @param ds
   */  
export interface MasterUpdate_input{
      /**  bool to determine whether to run code to check for order changed columns  */  
   lCheckForOrderChangedMsg:boolean,
      /**  bool to determine whether to run code that may require user input  */  
   lcheckForResponse:boolean,
      /**  identifies which table was modified  */  
   cTableName:string,
      /**  The current custNum  */  
   iCustNum:number,
      /**  The current orderNum  */  
   iOrderNum:number,
      /**  whether the WE module is licensed  */  
   lweLicensed:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface MasterUpdate_output{
parameters : {
      /**  output parameters  */  
   lContinue:boolean,
   cResponseMsg:string,
   cCreditShipAction:string,
   cDisplayMsg:string,
   cCompliantMsg:string,
   cResponseMsgOrdRel:string,
   cAgingMessage:string,
   cShipByDateMessage:string,
   cNeedByDateMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param pcPartNum
      @param pcWhseCode
      @param pcBinNum
      @param pcLotNum
      @param pcAttributeSetID
      @param pcPCID
      @param pcDimCode
      @param pdDimConvFactor
      @param ipSellingQuantity
   */  
export interface NegativeInventoryTest_input{
   pcPartNum:string,
   pcWhseCode:string,
   pcBinNum:string,
   pcLotNum:string,
   pcAttributeSetID:number,
   pcPCID:string,
   pcDimCode:string,
   pdDimConvFactor:number,
   ipSellingQuantity:number,
}

export interface NegativeInventoryTest_output{
parameters : {
      /**  output parameters  */  
   pcNeqQtyAction:string,
   pcMessage:string,
}
}

   /** Required : 
      @param ipARLOCID
      @param ds
   */  
export interface OnChangeARLOCID_input{
      /**  The Letter of Credit ID value  */  
   ipARLOCID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeARLOCID_output{
parameters : {
      /**  output parameters  */  
   opOverwriteValue:string,
   opFieldName:string,
   opMsg:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param CardType
      @param ds
   */  
export interface OnChangeCardType_input{
   CardType:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeCardType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipCreditCardOrder
      @param ds
   */  
export interface OnChangeCreditCardOrder_input{
      /**  Proposed CreditCardOrder value  */  
   ipCreditCardOrder:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeCreditCardOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param newHeaderShipToNum
      @param ds
   */  
export interface OnChangeHeaderShipTo_input{
      /**  The proposed  */  
   newHeaderShipToNum:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeHeaderShipTo_output{
parameters : {
      /**  output parameters  */  
   TaxPricingFlag:boolean,
   TaxRecalFlag:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param RateCode
      @param NewFixedAmount
      @param ds
   */  
export interface OnChangeOfFixedAmount_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Release rate code.  */  
   RateCode:string,
      /**  Proposed Fixed AMount.  */  
   NewFixedAmount:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeOfFixedAmount_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param MktgCampaignID
      @param ds
   */  
export interface OnChangeOfMktgCampaign_input{
      /**  The MktgCampaign Id  */  
   MktgCampaignID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeOfMktgCampaign_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param MktgCampaignID
      @param MktgEvntSeq
      @param ds
   */  
export interface OnChangeOfMktgEvnt_input{
      /**  The MktgCampaign Id  */  
   MktgCampaignID:string,
      /**  The MktgCampaign Id  */  
   MktgEvntSeq:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeOfMktgEvnt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param quoteNum
      @param quoteLine
      @param ds
   */  
export interface OnChangeOfQuoteLine_input{
      /**  The QuoteNum  */  
   quoteNum:number,
      /**  The QuoteLine  */  
   quoteLine:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeOfQuoteLine_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param NewTaxAmt
      @param ds
   */  
export interface OnChangeOfTaxAmt_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Proposed Taxable amount.  */  
   NewTaxAmt:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeOfTaxAmt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param NewPercent
      @param ds
   */  
export interface OnChangeOfTaxPercent_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Proposed Percent.  */  
   NewPercent:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeOfTaxPercent_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param proposedRateCode
      @param ds
   */  
export interface OnChangeRateCode_input{
      /**  Release tax rate code.  */  
   proposedRateCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeRateCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param newShipToNum
      @param ds
   */  
export interface OnChangeRelShipToNum_input{
      /**  Proposed Order release Ship to.  */  
   newShipToNum:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeRelShipToNum_output{
parameters : {
      /**  output parameters  */  
   taxPricingFlag:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipOrderNum
      @param ipLineNum
      @param ipRelNum
      @param ipTaxCode
      @param ds
   */  
export interface OnChangeTaxCode_input{
      /**  Order Number.  */  
   ipOrderNum:number,
      /**  Order line number.  */  
   ipLineNum:number,
      /**  Order Rel number.  */  
   ipRelNum:number,
      /**  Release tax code.  */  
   ipTaxCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeTaxCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
      @param TaxCode
      @param RateCode
      @param NewTaxableAmt
      @param ds
   */  
export interface OnChangeTaxableAmt_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order Rel number.  */  
   OrderRel:number,
      /**  Release tax code.  */  
   TaxCode:string,
      /**  Release rate code.  */  
   RateCode:string,
      /**  Proposed Taxable amount.  */  
   NewTaxableAmt:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeTaxableAmt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param orderNum
      @param ds
   */  
export interface OnChangeTranDocTypeID_input{
   orderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeTranDocTypeID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param NewBillToConNum
      @param ds
   */  
export interface OnChangeofBTConNum_input{
      /**  Proposed bill to custid  */  
   NewBillToConNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeofBTConNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param NewBillToCustID
      @param ds
   */  
export interface OnChangeofBTCustID_input{
      /**  Proposed bill to custid  */  
   NewBillToCustID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeofBTCustID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param OrderNum
      @param OrderLine
      @param OrderRel
   */  
export interface OnChangeofLineRelExemptTax_input{
      /**  Order Number.  */  
   OrderNum:number,
      /**  Order line number.  */  
   OrderLine:number,
      /**  Order release number.  */  
   OrderRel:number,
}

export interface OnChangeofLineRelExemptTax_output{
parameters : {
      /**  output parameters  */  
   AskManualQuestion:boolean,
}
}

   /** Required : 
      @param ipPhaseID
      @param ipIsChanging
      @param ds
   */  
export interface OnChangeofPhaseID_input{
      /**  Proposed Phase ID.  */  
   ipPhaseID:string,
      /**  Is called from column_changing.  */  
   ipIsChanging:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeofPhaseID_output{
parameters : {
      /**  output parameters  */  
   opProjMsg:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param iCustID
      @param ds
   */  
export interface OnChangeofSoldToCreditCheck_input{
      /**  The Order Number  */  
   iOrderNum:number,
      /**  The Sold To Customer ID  */  
   iCustID:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeofSoldToCreditCheck_output{
parameters : {
      /**  output parameters  */  
   cCreditLimitMessage:string,
   cAgingMessage:string,
   lContinue:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param taxRegionCode
      @param columnName
      @param ds
   */  
export interface OnChangeofTaxRgnWithColumnName_input{
      /**  Proposed tax region code.  */  
   taxRegionCode:string,
      /**  The name of the column being changed - TaxRegionCode or OTSTaxRegionCode  */  
   columnName:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeofTaxRgnWithColumnName_output{
parameters : {
      /**  output parameters  */  
   taxMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iTaxRegionCode
      @param ds
   */  
export interface OnChangeofTaxRgn_input{
      /**  Proposed tax region code.  */  
   iTaxRegionCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangeofTaxRgn_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param PaySeqEdited
      @param ts
   */  
export interface OnChangingOrderSchedAmount_input{
   PaySeqEdited:number,
   ts:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangingOrderSchedAmount_output{
parameters : {
      /**  output parameters  */  
   ts:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param PaySeqEdited
      @param ts
   */  
export interface OnChangingOrderSchedPercent_input{
   PaySeqEdited:number,
   ts:Erp_Tablesets_SalesOrderTableset[],
}

export interface OnChangingOrderSchedPercent_output{
parameters : {
      /**  output parameters  */  
   ts:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param iOrderNum
   */  
export interface OrderDtlGetNewContracts_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  The order number to add the line to  */  
   iOrderNum:number,
}

export interface OrderDtlGetNewContracts_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param iOrderNum
   */  
export interface OrderDtlGetNewCounterSale_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  The order number to add the line to  */  
   iOrderNum:number,
}

export interface OrderDtlGetNewCounterSale_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param iOrderNum
   */  
export interface OrderDtlGetNewFromQuote_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  The order number to add the line to  */  
   iOrderNum:number,
}

export interface OrderDtlGetNewFromQuote_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param quoteNum
      @param quoteLine
      @param ds
   */  
export interface OrderDtlQuoteLineChanging_input{
      /**  The QuoteNum  */  
   quoteNum:number,
      /**  The QuoteLine  */  
   quoteLine:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface OrderDtlQuoteLineChanging_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
   */  
export interface OverCreditLimitUpdateAllowed_input{
      /**  The Order Number  */  
   iOrderNum:number,
}

export interface OverCreditLimitUpdateAllowed_output{
parameters : {
      /**  output parameters  */  
   lUpdateAllowed:boolean,
}
}

   /** Required : 
      @param phPartNum
      @param OrderNum
      @param OrderLine
      @param errMessage
   */  
export interface PhantomComponents_input{
      /**  The phantom part number  */  
   phPartNum:string,
      /**  Order number where the lines will be saved  */  
   OrderNum:number,
      /**  Order line of the parent line  */  
   OrderLine:number,
      /**  Returns any error messages found during the process  */  
   errMessage:string,
}

export interface PhantomComponents_output{
parameters : {
      /**  output parameters  */  
   errMessage:string,
}
}

   /** Required : 
      @param orderNum
      @param orderLine
   */  
export interface PopulateCallContext_input{
   orderNum:number,
   orderLine:number,
}

export interface PopulateCallContext_output{
parameters : {
      /**  output parameters  */  
   callContext:string,
}
}

   /** Required : 
      @param orderNum
   */  
export interface PreCopyOrder_input{
      /**  The order to copy  */  
   orderNum:number,
}

export interface PreCopyOrder_output{
parameters : {
      /**  output parameters  */  
   holdMessage:string,
}
}

   /** Required : 
      @param ds
      @param continueProcessingOnError
      @param rollbackParentOnChildError
   */  
export interface PreOrder_input{
   ds:Erp_Tablesets_UpdExtSalesOrderTableset[],
   continueProcessingOnError:boolean,
   rollbackParentOnChildError:boolean,
}

export interface PreOrder_output{
   returnObj:Ice_BOUpdErrorTableset[],
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UpdExtSalesOrderTableset[],
   errorsOccurred:boolean,
}
}

   /** Required : 
      @param orderNum
      @param generatePackingSlip
      @param generateInvoice
      @param readyToShip
      @param creditShipAction
      @param ds
   */  
export interface ProcessCounterSaleUsingOrderLinesInDatabase_input{
      /**  The Order Number of the counter sale order to process  */  
   orderNum:number,
      /**  Flag to indicate if the packing slip should be generated  */  
   generatePackingSlip:boolean,
      /**  Flag to indicate if the invoice should be generated  */  
   generateInvoice:boolean,
      /**  Indicates if the packing slip should be marked as ready to ship  */  
   readyToShip:boolean,
      /**  indicates if customer should be placed on credit hold  */  
   creditShipAction:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ProcessCounterSaleUsingOrderLinesInDatabase_output{
parameters : {
      /**  output parameters  */  
   packNumList:string,
   invoiceNum:number,
   counterSaleMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param lGeneratePackingSlip
      @param lGenerateInvoice
      @param lReadyToShip
      @param cCreditShipAction
      @param ds
   */  
export interface ProcessCounterSale_input{
      /**  The Order Number of the counter sale order to process  */  
   iOrderNum:number,
      /**  Flag to indicate if the packing slip should be generated  */  
   lGeneratePackingSlip:boolean,
      /**  Flag to indicate if the invoice should be generated  */  
   lGenerateInvoice:boolean,
      /**  Indicates if the packing slip should be marked as ready to ship  */  
   lReadyToShip:boolean,
      /**  indicates if customer should be placed on credit hold  */  
   cCreditShipAction:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ProcessCounterSale_output{
parameters : {
      /**  output parameters  */  
   cPackNum:string,
   iInvoiceNum:number,
   opMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param creditCardStatus
      @param ds
   */  
export interface ProcessPayGateCreditCardStatus_input{
      /**  Credit card status  */  
   creditCardStatus:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ProcessPayGateCreditCardStatus_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ProcessPayGateMessage_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ProcessPayGateMessage_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param ds
   */  
export interface ProcessQuickEntry_input{
      /**  The Order Number of the order to process  */  
   iOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ProcessQuickEntry_output{
parameters : {
      /**  output parameters  */  
   lProcessComplete:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

export interface REVISIONHISTORY06_output{
}

   /** Required : 
      @param ipCustNum
      @param ipShipToNum
      @param ds
   */  
export interface RebuildShipUPS_input{
      /**  Customer to update  */  
   ipCustNum:number,
      /**  Ship To Num  */  
   ipShipToNum:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface RebuildShipUPS_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
   */  
export interface RecalcKitPriceAfterConfig_input{
      /**  Sales Order Number for configured part  */  
   iOrderNum:number,
      /**  Sales Order Line for configured part  */  
   iOrderLine:number,
}

export interface RecalcKitPriceAfterConfig_output{
}

   /** Required : 
      @param iOrderNum
   */  
export interface RemoveICPOLink_input{
      /**  The Order Number of the Order to remove the link from  */  
   iOrderNum:number,
}

export interface RemoveICPOLink_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
   */  
export interface ReopenOrderLine_input{
      /**  The Order Number of the Order Line to reopen  */  
   iOrderNum:number,
      /**  The Order Line Number to close  */  
   iOrderLine:number,
}

export interface ReopenOrderLine_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param iOrderNum
   */  
export interface ReopenOrder_input{
      /**  The Order Number of the Order to reopen  */  
   iOrderNum:number,
}

export interface ReopenOrder_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param defaultAttributeSetID
      @param iOrderNum
      @param iOrderLine
      @param iOrderRelNum
   */  
export interface ReopenReleaseSetAttributeSetID_input{
   defaultAttributeSetID:number,
      /**  The Order Number of the Order Release to reopen  */  
   iOrderNum:number,
      /**  The Order Line Number of the Release to close  */  
   iOrderLine:number,
      /**  The Release Number of the Release to close  */  
   iOrderRelNum:number,
}

export interface ReopenReleaseSetAttributeSetID_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param iOrderNum
      @param iOrderLine
      @param iOrderRelNum
   */  
export interface ReopenRelease_input{
      /**  The Order Number of the Order Release to reopen  */  
   iOrderNum:number,
      /**  The Order Line Number of the Release to close  */  
   iOrderLine:number,
      /**  The Release Number of the Release to close  */  
   iOrderRelNum:number,
}

export interface ReopenRelease_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

export interface SendLinkedICPOSuggestion_output{
}

   /** Required : 
      @param ipCalcQtyPref
   */  
export interface SetCalcQtysPref_input{
   ipCalcQtyPref:boolean,
}

export interface SetCalcQtysPref_output{
}

   /** Required : 
      @param orderNum
      @param orderLine
      @param kbConfigProdID
   */  
export interface SetKBMaxConfigProdID_input{
      /**  Order Number  */  
   orderNum:number,
      /**  Order Line  */  
   orderLine:number,
      /**  CPQ Quote Product ID  */  
   kbConfigProdID:number,
}

export interface SetKBMaxConfigProdID_output{
}

   /** Required : 
      @param ipOrderNum
      @param ds
   */  
export interface SetReadyToCalc_input{
      /**  The Order Number of the Order to remove the link from  */  
   ipOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface SetReadyToCalc_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param iOrderNum
      @param ds
   */  
export interface SetReprintSOAckFlag_input{
   iOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface SetReprintSOAckFlag_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipQVEnable
      @param ds
   */  
export interface SetUPSQVEnable_input{
      /**  logical indicating if the quantum view is to enabled/disabled  */  
   ipQVEnable:boolean,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface SetUPSQVEnable_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface SubmitNewOrder_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface SubmitNewOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface UpdateExistingOrder_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface UpdateExistingOrder_output{
}

   /** Required : 
      @param ds
      @param continueProcessingOnError
      @param rollbackParentOnChildError
   */  
export interface UpdateExt_input{
   ds:Erp_Tablesets_UpdExtSalesOrderTableset[],
   continueProcessingOnError:boolean,
   rollbackParentOnChildError:boolean,
}

export interface UpdateExt_output{
   returnObj:Ice_BOUpdErrorTableset[],
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UpdExtSalesOrderTableset[],
   errorsOccurred:boolean,
}
}

   /** Required : 
      @param orderNum
      @param orderLine
      @param configuredProductJson
   */  
export interface UpdateKBMaxConfigurator_input{
      /**  Order Number  */  
   orderNum:number,
      /**  Order Line  */  
   orderLine:number,
      /**  KBMax configurator data passed from the embed API  */  
   configuredProductJson:string,
}

export interface UpdateKBMaxConfigurator_output{
}

   /** Required : 
      @param orderNum
      @param orderLines
   */  
export interface UpdateOrderDtlDiscountPercent_input{
   orderNum:number,
   orderLines:string,
}

export interface UpdateOrderDtlDiscountPercent_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param orderNum
      @param action
   */  
export interface UpdatePartAllocQueue_input{
      /**  The sales order number  */  
   orderNum:number,
      /**  The fulfillment queue action to take ("SEND" or "REMOVE")  */  
   action:string,
}

export interface UpdatePartAllocQueue_output{
   returnObj:Erp_Tablesets_SalesOrderTableset[],
}

   /** Required : 
      @param ds
   */  
export interface Update_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface Update_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param proposedDate
      @param originalDate
      @param dateColumnName
      @param plant
   */  
export interface ValidateBAQShippingDate_input{
      /**  New date to be validated  */  
   proposedDate:string,
      /**  The date already set before being changed  */  
   originalDate:string,
      /**  The column the proposed date is from  */  
   dateColumnName:string,
      /**  The site set for the order release  */  
   plant:string,
}

export interface ValidateBAQShippingDate_output{
parameters : {
      /**  output parameters  */  
   invalidDateMessage:string,
}
}

   /** Required : 
      @param orderNum
      @param ds
   */  
export interface ValidateCounterSaleSN_input{
      /**  The Order Number of the counter sale order to validate  */  
   orderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ValidateCounterSaleSN_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param currencyCode
      @param ds
   */  
export interface ValidateCurrencyCode_input{
   currencyCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ValidateCurrencyCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param Cust
      @param Prj
   */  
export interface ValidateCustomer_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  CustID  */  
   Cust:string,
      /**  ProjectID  */  
   Prj:string,
}

export interface ValidateCustomer_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param invCurrCode
      @param ds
   */  
export interface ValidateInvCurrCode_input{
   invCurrCode:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ValidateInvCurrCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipOrderNum
      @param ds
   */  
export interface ValidateInvQty_input{
      /**  The Order Number of the counter sale order to process  */  
   ipOrderNum:number,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ValidateInvQty_output{
parameters : {
      /**  output parameters  */  
   opNegInvMessage:string,
   opNegQtyAction:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param manualValidation
      @param hmrcFraudPrevHeader
   */  
export interface ValidateOTSTaxID_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
   manualValidation:boolean,
   hmrcFraudPrevHeader:string,
}

export interface ValidateOTSTaxID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   opMessage:string,
}
}

   /** Required : 
      @param orderNum
   */  
export interface ValidateOrderLinesTaxCategoryTypes_input{
      /**  The order number to validate  */  
   orderNum:number,
}

export interface ValidateOrderLinesTaxCategoryTypes_output{
}

   /** Required : 
      @param ds
      @param Prj
   */  
export interface ValidateProjectID_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  ProjectID  */  
   Prj:string,
}

export interface ValidateProjectID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ipSerialNum
      @param ipPartNum
      @param ipAttributeSetID
      @param ipOurInvShipQty
      @param ipOrderNum
      @param ipOrderLine
      @param ipOrderRelNum
      @param ipWarehouseCode
      @param ipBinNum
   */  
export interface ValidateSN_input{
      /**  Serial number to validate.  */  
   ipSerialNum:string,
      /**  Part number  */  
   ipPartNum:string,
      /**  Attribute Set  */  
   ipAttributeSetID:number,
      /**  Inventory Ship Quantity  */  
   ipOurInvShipQty:number,
      /**  Order number  */  
   ipOrderNum:number,
      /**  Order Line number  */  
   ipOrderLine:number,
      /**  OrderRelease number  */  
   ipOrderRelNum:number,
      /**  Ship from warehouse  */  
   ipWarehouseCode:string,
      /**  Ship from bin  */  
   ipBinNum:string,
}

export interface ValidateSN_output{
parameters : {
      /**  output parameters  */  
   isVoided:boolean,
}
}

   /** Required : 
      @param ds
   */  
export interface ValidateSNs_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ValidateSNs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param proposedDate
      @param dateColumnName
      @param dateColumnTable
      @param ds
   */  
export interface ValidateShippingDate_input{
      /**  New date to be validated  */  
   proposedDate:string,
      /**  The column the proposed date is from  */  
   dateColumnName:string,
      /**  The table that the validating date belongs to  */  
   dateColumnTable:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}

export interface ValidateShippingDate_output{
parameters : {
      /**  output parameters  */  
   invalidDateMessage:string,
   ds:Erp_Tablesets_SalesOrderTableset[],
}
}

   /** Required : 
      @param ds
      @param iOrderNum
      @param iOrderLine
      @param iOrderRelNum
   */  
export interface VerifyReopenRelease_input{
   ds:Erp_Tablesets_SalesOrderTableset[],
      /**  The Order Number of the Order Release to reopen  */  
   iOrderNum:number,
      /**  The Order Line Number of the Release to close  */  
   iOrderLine:number,
      /**  The Release Number of the Release to close  */  
   iOrderRelNum:number,
}

export interface VerifyReopenRelease_output{
   returnObj:number,
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_SalesOrderTableset[],
   cPromptMessage:string,
}
}

export interface VerifySendICPOSugg_output{
parameters : {
      /**  output parameters  */  
   cVerifySendMsgText:string,
}
}

   /** Required : 
      @param CustNum
      @param OrderNum
      @param ARLocId
      @param NewLineAmt
      @param updCreditHold
   */  
export interface chkCustomerCreditLimitForCopyOrder_input{
      /**  Customer for which we are validating the credit  */  
   CustNum:number,
      /**  Number of the order  */  
   OrderNum:number,
      /**  It indicates if the order has a Letter of Credit associated  */  
   ARLocId:string,
      /**  In this case it's the OrderAmt  */  
   NewLineAmt:number,
      /**  Credit Hold  */  
   updCreditHold:boolean,
}

export interface chkCustomerCreditLimitForCopyOrder_output{
parameters : {
      /**  output parameters  */  
   cCreditOrderAction:string,
   cCreditShipAction:string,
   cCreditLimitMessage:string,
   cCreditStatus:string,
}
}

   /** Required : 
      @param iOrderNum
      @param cARLOCID
      @param dTotalCharges
   */  
export interface chkLtrOfCrdt_input{
      /**  Sales Order number  */  
   iOrderNum:number,
      /**  Letter of Credit ID  */  
   cARLOCID:string,
      /**  OrderHed.TotalCharges  */  
   dTotalCharges:number,
}

export interface chkLtrOfCrdt_output{
parameters : {
      /**  output parameters  */  
   outMsg:string,
}
}

   /** Required : 
      @param pcListCode
      @param pcPartNum
      @param pcLineWarehouse
      @param pcCurrencyCode
      @param pdtOrderDate
   */  
export interface getBreakListCodeDesc_input{
   pcListCode:string,
   pcPartNum:string,
   pcLineWarehouse:string,
   pcCurrencyCode:string,
   pdtOrderDate:string,
}

export interface getBreakListCodeDesc_output{
   returnObj:string,
}

