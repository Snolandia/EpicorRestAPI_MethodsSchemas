import * as configEpicorSchemas from "./configEpicorSchemas"


// Title: Erp.BO.PartSvc
// Description: Part Master file. This file is the Parent to the PartSubs, PartWhse, and PartBin files.
Do not allow delete of Part record if it has existing PartBin records, if it is referenced in the OrderDtl,
JobDtl, or the PartTran file.
// Version: v1



//////////////////////////////////////////////////////////////////////////
// OData methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Get service document
   Description: Get service document for the service
   OperationID: GetServiceDocument
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => application/json
   */  
export function getServiceDocument(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<JSON>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as JSON)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Get metadata document
   Description: Get service ODATA metadata in XML format
   OperationID: GetMetadata
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: Returns metadata document => content
   */  
export function get_metadata(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/$metadata", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get Parts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_Parts
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRow
   */  
export function get_Parts(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_Parts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_Parts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the Part item
   Description: Calls GetByID to retrieve the Part item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_Part
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRow
   */  
export function get_Parts_Company_PartNum(Company:string, PartNum:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update Part for the service
   Description: Calls UpdateExt to update Part. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_Part
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_Parts_Company_PartNum(Company:string, PartNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete Part item
   Description: Call UpdateExt to delete Part item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_Part
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_Parts_Company_PartNum(Company:string, PartNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get EntityGLCs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_EntityGLCs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.EntityGLCRow
   */  
export function get_Parts_Company_PartNum_EntityGLCs(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/EntityGLCs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the EntityGLC item
   Description: Calls GetByID to retrieve the EntityGLC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_EntityGLC1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   */  
export function get_Parts_Company_PartNum_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, PartNum:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get TaxExempts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_TaxExempts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.TaxExemptRow
   */  
export function get_Parts_Company_PartNum_TaxExempts(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/TaxExempts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the TaxExempt item
   Description: Calls GetByID to retrieve the TaxExempt item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_TaxExempt1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   */  
export function get_Parts_Company_PartNum_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, PartNum:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartCOOs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartCOOs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartCOORow
   */  
export function get_Parts_Company_PartNum_PartCOOs(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOORow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartCOOs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOORow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartCOO item
   Description: Calls GetByID to retrieve the PartCOO item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartCOO1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param OrigCountry Desc: OrigCountry   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartCOORow
   */  
export function get_Parts_Company_PartNum_PartCOOs_Company_PartNum_OrigCountry(Company:string, PartNum:string, OrigCountry:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartCOORow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartCOOs(" + Company + "," + PartNum + "," + OrigCountry + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartCOORow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartDims items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartDims1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartDimRow
   */  
export function get_Parts_Company_PartNum_PartDims(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartDimRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartDims", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartDimRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartDim item
   Description: Calls GetByID to retrieve the PartDim item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartDim1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DimCode Desc: DimCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartDimRow
   */  
export function get_Parts_Company_PartNum_PartDims_Company_PartNum_DimCode(Company:string, PartNum:string, DimCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartDimRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartDims(" + Company + "," + PartNum + "," + DimCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartDimRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartLangDescs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartLangDescs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartLangDescRow
   */  
export function get_Parts_Company_PartNum_PartLangDescs(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartLangDescRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartLangDescs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartLangDescRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartLangDesc item
   Description: Calls GetByID to retrieve the PartLangDesc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartLangDesc1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param LangNameID Desc: LangNameID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartLangDescRow
   */  
export function get_Parts_Company_PartNum_PartLangDescs_Company_PartNum_LangNameID(Company:string, PartNum:string, LangNameID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartLangDescRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartLangDescs(" + Company + "," + PartNum + "," + LangNameID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartLangDescRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartPlanningPools items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartPlanningPools1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPlanningPoolRow
   */  
export function get_Parts_Company_PartNum_PartPlanningPools(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlanningPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPlanningPools", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlanningPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPlanningPool item
   Description: Calls GetByID to retrieve the PartPlanningPool item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPlanningPool1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PoolPartNum Desc: PoolPartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPlanningPoolRow
   */  
export function get_Parts_Company_PartNum_PartPlanningPools_Company_PartNum_PoolPartNum(Company:string, PartNum:string, PoolPartNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPlanningPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPlanningPools(" + Company + "," + PartNum + "," + PoolPartNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPlanningPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartPlants items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartPlants1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPlantRow
   */  
export function get_Parts_Company_PartNum_PartPlants(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPlants", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPlant item
   Description: Calls GetByID to retrieve the PartPlant item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPlant1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPlantRow
   */  
export function get_Parts_Company_PartNum_PartPlants_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPlantRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPlants(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPlantRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartPlantPlanningAttributes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartPlantPlanningAttributes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPlantPlanningAttributeRow
   */  
export function get_Parts_Company_PartNum_PartPlantPlanningAttributes(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantPlanningAttributeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPlantPlanningAttributes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantPlanningAttributeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPlantPlanningAttribute item
   Description: Calls GetByID to retrieve the PartPlantPlanningAttribute item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPlantPlanningAttribute1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param AttrClassID Desc: AttrClassID   Required: True   Allow empty value : True
      @param PlanningAttributeSetSeq Desc: PlanningAttributeSetSeq   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPlantPlanningAttributeRow
   */  
export function get_Parts_Company_PartNum_PartPlantPlanningAttributes_Company_PartNum_Plant_AttrClassID_PlanningAttributeSetSeq(Company:string, PartNum:string, Plant:string, AttrClassID:string, PlanningAttributeSetSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPlantPlanningAttributeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPlantPlanningAttributes(" + Company + "," + PartNum + "," + Plant + "," + AttrClassID + "," + PlanningAttributeSetSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPlantPlanningAttributeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRestrictions items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRestrictions1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRestrictionRow
   */  
export function get_Parts_Company_PartNum_PartRestrictions(Company:string, PartNum:string, select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartRestrictions", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRestriction item
   Description: Calls GetByID to retrieve the PartRestriction item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRestriction1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRestrictionRow
   */  
export function get_Parts_Company_PartNum_PartRestrictions_Company_PartNum_RestrictionTypeID(Company:string, PartNum:string, RestrictionTypeID:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartRestrictions(" + Company + "," + PartNum + "," + RestrictionTypeID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRevs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRevs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevRow
   */  
export function get_Parts_Company_PartNum_PartRevs(Company:string, PartNum:string, select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartRevs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRev item
   Description: Calls GetByID to retrieve the PartRev item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRev1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevRow
   */  
export function get_Parts_Company_PartNum_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartSubs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartSubs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartSubsRow
   */  
export function get_Parts_Company_PartNum_PartSubs(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartSubs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartSub item
   Description: Calls GetByID to retrieve the PartSub item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartSub1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   */  
export function get_Parts_Company_PartNum_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartSubsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartSubsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartBinInfoes items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartBinInfoes1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartBinInfoRow
   */  
export function get_Parts_Company_PartNum_PartBinInfoes(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartBinInfoRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartBinInfoes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartBinInfoRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartBinInfo item
   Description: Calls GetByID to retrieve the PartBinInfo item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartBinInfo1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      @param BinNum Desc: BinNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartBinInfoRow
   */  
export function get_Parts_Company_PartNum_PartBinInfoes_Company_PartNum_Plant_WarehouseCode_BinNum(Company:string, PartNum:string, Plant:string, WarehouseCode:string, BinNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartBinInfoRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartBinInfoes(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + "," + BinNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartBinInfoRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartPCs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartPCs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPCRow
   */  
export function get_Parts_Company_PartNum_PartPCs(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPCs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPC item
   Description: Calls GetByID to retrieve the PartPC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPC1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PCType Desc: PCType   Required: True   Allow empty value : True
      @param ProdCode Desc: ProdCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPCRow
   */  
export function get_Parts_Company_PartNum_PartPCs_Company_PartNum_PCType_ProdCode(Company:string, PartNum:string, PCType:string, ProdCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartPCs(" + Company + "," + PartNum + "," + PCType + "," + ProdCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartWhses items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartWhses1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartWhseRow
   */  
export function get_Parts_Company_PartNum_PartWhses(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartWhseRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartWhses", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartWhseRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartWhse item
   Description: Calls GetByID to retrieve the PartWhse item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartWhse1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartWhseRow
   */  
export function get_Parts_Company_PartNum_PartWhses_Company_PartNum_Plant_WarehouseCode(Company:string, PartNum:string, Plant:string, WarehouseCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartWhseRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartWhses(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartWhseRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartUOMs items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartUOMs1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartUOMRow
   */  
export function get_Parts_Company_PartNum_PartUOMs(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartUOMRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartUOMs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartUOMRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartUOM item
   Description: Calls GetByID to retrieve the PartUOM item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartUOM1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param UOMCode Desc: UOMCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartUOMRow
   */  
export function get_Parts_Company_PartNum_PartUOMs_Company_PartNum_UOMCode(Company:string, PartNum:string, UOMCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartUOMRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartUOMs(" + Company + "," + PartNum + "," + UOMCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartUOMRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartAttchRow
   */  
export function get_Parts_Company_PartNum_PartAttches(Company:string, PartNum:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartAttch item
   Description: Calls GetByID to retrieve the PartAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartAttchRow
   */  
export function get_Parts_Company_PartNum_PartAttches_Company_PartNum_DrawingSeq(Company:string, PartNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Parts(" + Company + "," + PartNum + ")/PartAttches(" + Company + "," + PartNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get EntityGLCs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_EntityGLCs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.EntityGLCRow
   */  
export function get_EntityGLCs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EntityGLCs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_EntityGLCs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_EntityGLCs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EntityGLCs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the EntityGLC item
   Description: Calls GetByID to retrieve the EntityGLC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_EntityGLC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   */  
export function get_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_EntityGLCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_EntityGLCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update EntityGLC for the service
   Description: Calls UpdateExt to update EntityGLC. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_EntityGLC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.EntityGLCRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete EntityGLC item
   Description: Call UpdateExt to delete EntityGLC item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_EntityGLC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param Key3 Desc: Key3   Required: True   Allow empty value : True
      @param Key4 Desc: Key4   Required: True   Allow empty value : True
      @param Key5 Desc: Key5   Required: True   Allow empty value : True
      @param Key6 Desc: Key6   Required: True   Allow empty value : True
      @param GLControlType Desc: GLControlType   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_EntityGLCs_Company_RelatedToFile_Key1_Key2_Key3_Key4_Key5_Key6_GLControlType(Company:string, RelatedToFile:string, Key1:string, Key2:string, Key3:string, Key4:string, Key5:string, Key6:string, GLControlType:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EntityGLCs(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + Key3 + "," + Key4 + "," + Key5 + "," + Key6 + "," + GLControlType + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get TaxExempts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_TaxExempts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.TaxExemptRow
   */  
export function get_TaxExempts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/TaxExempts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_TaxExempts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_TaxExempts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/TaxExempts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the TaxExempt item
   Description: Calls GetByID to retrieve the TaxExempt item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_TaxExempt
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   */  
export function get_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_TaxExemptRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_TaxExemptRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update TaxExempt for the service
   Description: Calls UpdateExt to update TaxExempt. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_TaxExempt
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.TaxExemptRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete TaxExempt item
   Description: Call UpdateExt to delete TaxExempt item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_TaxExempt
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param RelatedToFile Desc: RelatedToFile   Required: True   Allow empty value : True
      @param Key1 Desc: Key1   Required: True   Allow empty value : True
      @param Key2 Desc: Key2   Required: True   Allow empty value : True
      @param TaxCode Desc: TaxCode   Required: True   Allow empty value : True
      @param RateCode Desc: RateCode   Required: True   Allow empty value : True
      @param EffectiveFrom Desc: EffectiveFrom   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_TaxExempts_Company_RelatedToFile_Key1_Key2_TaxCode_RateCode_EffectiveFrom(Company:string, RelatedToFile:string, Key1:string, Key2:string, TaxCode:string, RateCode:string, EffectiveFrom:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/TaxExempts(" + Company + "," + RelatedToFile + "," + Key1 + "," + Key2 + "," + TaxCode + "," + RateCode + "," + EffectiveFrom + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartCOOs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartCOOs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartCOORow
   */  
export function get_PartCOOs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOORow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOOs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOORow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartCOOs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartCOORow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartCOORow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartCOOs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOOs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartCOO item
   Description: Calls GetByID to retrieve the PartCOO item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartCOO
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param OrigCountry Desc: OrigCountry   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartCOORow
   */  
export function get_PartCOOs_Company_PartNum_OrigCountry(Company:string, PartNum:string, OrigCountry:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartCOORow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOOs(" + Company + "," + PartNum + "," + OrigCountry + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartCOORow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartCOO for the service
   Description: Calls UpdateExt to update PartCOO. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartCOO
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param OrigCountry Desc: OrigCountry   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartCOORow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartCOOs_Company_PartNum_OrigCountry(Company:string, PartNum:string, OrigCountry:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOOs(" + Company + "," + PartNum + "," + OrigCountry + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartCOO item
   Description: Call UpdateExt to delete PartCOO item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartCOO
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param OrigCountry Desc: OrigCountry   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartCOOs_Company_PartNum_OrigCountry(Company:string, PartNum:string, OrigCountry:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOOs(" + Company + "," + PartNum + "," + OrigCountry + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartDims items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartDims
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartDimRow
   */  
export function get_PartDims(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartDimRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartDims", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartDimRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartDims
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartDimRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartDimRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartDims(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartDims", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartDim item
   Description: Calls GetByID to retrieve the PartDim item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartDim
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DimCode Desc: DimCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartDimRow
   */  
export function get_PartDims_Company_PartNum_DimCode(Company:string, PartNum:string, DimCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartDimRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartDims(" + Company + "," + PartNum + "," + DimCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartDimRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartDim for the service
   Description: Calls UpdateExt to update PartDim. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartDim
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DimCode Desc: DimCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartDimRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartDims_Company_PartNum_DimCode(Company:string, PartNum:string, DimCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartDims(" + Company + "," + PartNum + "," + DimCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartDim item
   Description: Call UpdateExt to delete PartDim item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartDim
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DimCode Desc: DimCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartDims_Company_PartNum_DimCode(Company:string, PartNum:string, DimCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartDims(" + Company + "," + PartNum + "," + DimCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartLangDescs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartLangDescs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartLangDescRow
   */  
export function get_PartLangDescs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartLangDescRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartLangDescs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartLangDescRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartLangDescs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartLangDescRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartLangDescRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartLangDescs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartLangDescs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartLangDesc item
   Description: Calls GetByID to retrieve the PartLangDesc item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartLangDesc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param LangNameID Desc: LangNameID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartLangDescRow
   */  
export function get_PartLangDescs_Company_PartNum_LangNameID(Company:string, PartNum:string, LangNameID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartLangDescRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartLangDescs(" + Company + "," + PartNum + "," + LangNameID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartLangDescRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartLangDesc for the service
   Description: Calls UpdateExt to update PartLangDesc. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartLangDesc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param LangNameID Desc: LangNameID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartLangDescRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartLangDescs_Company_PartNum_LangNameID(Company:string, PartNum:string, LangNameID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartLangDescs(" + Company + "," + PartNum + "," + LangNameID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartLangDesc item
   Description: Call UpdateExt to delete PartLangDesc item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartLangDesc
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param LangNameID Desc: LangNameID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartLangDescs_Company_PartNum_LangNameID(Company:string, PartNum:string, LangNameID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartLangDescs(" + Company + "," + PartNum + "," + LangNameID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartPlanningPools items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartPlanningPools
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPlanningPoolRow
   */  
export function get_PartPlanningPools(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlanningPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlanningPools", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlanningPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartPlanningPools
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartPlanningPoolRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartPlanningPoolRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartPlanningPools(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlanningPools", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPlanningPool item
   Description: Calls GetByID to retrieve the PartPlanningPool item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPlanningPool
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PoolPartNum Desc: PoolPartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPlanningPoolRow
   */  
export function get_PartPlanningPools_Company_PartNum_PoolPartNum(Company:string, PartNum:string, PoolPartNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPlanningPoolRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlanningPools(" + Company + "," + PartNum + "," + PoolPartNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPlanningPoolRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartPlanningPool for the service
   Description: Calls UpdateExt to update PartPlanningPool. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartPlanningPool
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PoolPartNum Desc: PoolPartNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartPlanningPoolRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartPlanningPools_Company_PartNum_PoolPartNum(Company:string, PartNum:string, PoolPartNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlanningPools(" + Company + "," + PartNum + "," + PoolPartNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartPlanningPool item
   Description: Call UpdateExt to delete PartPlanningPool item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartPlanningPool
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PoolPartNum Desc: PoolPartNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartPlanningPools_Company_PartNum_PoolPartNum(Company:string, PartNum:string, PoolPartNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlanningPools(" + Company + "," + PartNum + "," + PoolPartNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartPlants items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartPlants
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPlantRow
   */  
export function get_PartPlants(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlants", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartPlants
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartPlantRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartPlantRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartPlants(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlants", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPlant item
   Description: Calls GetByID to retrieve the PartPlant item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPlant
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPlantRow
   */  
export function get_PartPlants_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPlantRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlants(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPlantRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartPlant for the service
   Description: Calls UpdateExt to update PartPlant. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartPlant
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartPlantRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartPlants_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlants(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartPlant item
   Description: Call UpdateExt to delete PartPlant item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartPlant
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartPlants_Company_PartNum_Plant(Company:string, PartNum:string, Plant:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlants(" + Company + "," + PartNum + "," + Plant + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartPlantPlanningAttributes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartPlantPlanningAttributes
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPlantPlanningAttributeRow
   */  
export function get_PartPlantPlanningAttributes(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantPlanningAttributeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlantPlanningAttributes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantPlanningAttributeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartPlantPlanningAttributes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartPlantPlanningAttributeRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartPlantPlanningAttributeRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartPlantPlanningAttributes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlantPlanningAttributes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPlantPlanningAttribute item
   Description: Calls GetByID to retrieve the PartPlantPlanningAttribute item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPlantPlanningAttribute
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param AttrClassID Desc: AttrClassID   Required: True   Allow empty value : True
      @param PlanningAttributeSetSeq Desc: PlanningAttributeSetSeq   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPlantPlanningAttributeRow
   */  
export function get_PartPlantPlanningAttributes_Company_PartNum_Plant_AttrClassID_PlanningAttributeSetSeq(Company:string, PartNum:string, Plant:string, AttrClassID:string, PlanningAttributeSetSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPlantPlanningAttributeRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlantPlanningAttributes(" + Company + "," + PartNum + "," + Plant + "," + AttrClassID + "," + PlanningAttributeSetSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPlantPlanningAttributeRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartPlantPlanningAttribute for the service
   Description: Calls UpdateExt to update PartPlantPlanningAttribute. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartPlantPlanningAttribute
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param AttrClassID Desc: AttrClassID   Required: True   Allow empty value : True
      @param PlanningAttributeSetSeq Desc: PlanningAttributeSetSeq   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartPlantPlanningAttributeRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartPlantPlanningAttributes_Company_PartNum_Plant_AttrClassID_PlanningAttributeSetSeq(Company:string, PartNum:string, Plant:string, AttrClassID:string, PlanningAttributeSetSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlantPlanningAttributes(" + Company + "," + PartNum + "," + Plant + "," + AttrClassID + "," + PlanningAttributeSetSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartPlantPlanningAttribute item
   Description: Call UpdateExt to delete PartPlantPlanningAttribute item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartPlantPlanningAttribute
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param AttrClassID Desc: AttrClassID   Required: True   Allow empty value : True
      @param PlanningAttributeSetSeq Desc: PlanningAttributeSetSeq   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartPlantPlanningAttributes_Company_PartNum_Plant_AttrClassID_PlanningAttributeSetSeq(Company:string, PartNum:string, Plant:string, AttrClassID:string, PlanningAttributeSetSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPlantPlanningAttributes(" + Company + "," + PartNum + "," + Plant + "," + AttrClassID + "," + PlanningAttributeSetSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRestrictions items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRestrictions
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRestrictionRow
   */  
export function get_PartRestrictions(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRestrictions
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRestrictionRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRestrictionRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRestrictions(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRestriction item
   Description: Calls GetByID to retrieve the PartRestriction item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRestrictionRow
   */  
export function get_PartRestrictions_Company_PartNum_RestrictionTypeID(Company:string, PartNum:string, RestrictionTypeID:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRestrictionRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions(" + Company + "," + PartNum + "," + RestrictionTypeID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRestrictionRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRestriction for the service
   Description: Calls UpdateExt to update PartRestriction. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRestrictionRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRestrictions_Company_PartNum_RestrictionTypeID(Company:string, PartNum:string, RestrictionTypeID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions(" + Company + "," + PartNum + "," + RestrictionTypeID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRestriction item
   Description: Call UpdateExt to delete PartRestriction item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRestriction
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRestrictions_Company_PartNum_RestrictionTypeID(Company:string, PartNum:string, RestrictionTypeID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions(" + Company + "," + PartNum + "," + RestrictionTypeID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRestrictSubsts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRestrictSubsts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRestrictSubstRow
   */  
export function get_PartRestrictions_Company_PartNum_RestrictionTypeID_PartRestrictSubsts(Company:string, PartNum:string, RestrictionTypeID:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictSubstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions(" + Company + "," + PartNum + "," + RestrictionTypeID + ")/PartRestrictSubsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictSubstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRestrictSubst item
   Description: Calls GetByID to retrieve the PartRestrictSubst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRestrictSubst1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param SubstanceID Desc: SubstanceID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRestrictSubstRow
   */  
export function get_PartRestrictions_Company_PartNum_RestrictionTypeID_PartRestrictSubsts_Company_PartNum_RestrictionTypeID_SubstanceID(Company:string, PartNum:string, RestrictionTypeID:string, SubstanceID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRestrictSubstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictions(" + Company + "," + PartNum + "," + RestrictionTypeID + ")/PartRestrictSubsts(" + Company + "," + PartNum + "," + RestrictionTypeID + "," + SubstanceID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRestrictSubstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRestrictSubsts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRestrictSubsts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRestrictSubstRow
   */  
export function get_PartRestrictSubsts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictSubstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictSubsts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictSubstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRestrictSubsts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRestrictSubstRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRestrictSubstRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRestrictSubsts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictSubsts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRestrictSubst item
   Description: Calls GetByID to retrieve the PartRestrictSubst item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRestrictSubst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param SubstanceID Desc: SubstanceID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRestrictSubstRow
   */  
export function get_PartRestrictSubsts_Company_PartNum_RestrictionTypeID_SubstanceID(Company:string, PartNum:string, RestrictionTypeID:string, SubstanceID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRestrictSubstRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictSubsts(" + Company + "," + PartNum + "," + RestrictionTypeID + "," + SubstanceID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRestrictSubstRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRestrictSubst for the service
   Description: Calls UpdateExt to update PartRestrictSubst. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRestrictSubst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param SubstanceID Desc: SubstanceID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRestrictSubstRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRestrictSubsts_Company_PartNum_RestrictionTypeID_SubstanceID(Company:string, PartNum:string, RestrictionTypeID:string, SubstanceID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictSubsts(" + Company + "," + PartNum + "," + RestrictionTypeID + "," + SubstanceID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRestrictSubst item
   Description: Call UpdateExt to delete PartRestrictSubst item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRestrictSubst
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RestrictionTypeID Desc: RestrictionTypeID   Required: True   Allow empty value : True
      @param SubstanceID Desc: SubstanceID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRestrictSubsts_Company_PartNum_RestrictionTypeID_SubstanceID(Company:string, PartNum:string, RestrictionTypeID:string, SubstanceID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRestrictSubsts(" + Company + "," + PartNum + "," + RestrictionTypeID + "," + SubstanceID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRevs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRevs
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevRow
   */  
export function get_PartRevs(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRevs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRevRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRevRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRevs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRev item
   Description: Calls GetByID to retrieve the PartRev item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRev
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRev for the service
   Description: Calls UpdateExt to update PartRev. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRev
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRevRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRev item
   Description: Call UpdateExt to delete PartRev item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRev
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartAudits items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartAudits1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartAuditRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartAudits(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAuditRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartAudits", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAuditRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartAudit item
   Description: Calls GetByID to retrieve the PartAudit item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartAudit1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param ChangeDate Desc: ChangeDate   Required: True   Allow empty value : True
      @param ChangeTime Desc: ChangeTime   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartAuditRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartAudits_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_ChangeDate_ChangeTime(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, ChangeDate:string, ChangeTime:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartAuditRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartAudits(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + ChangeDate + "," + ChangeTime + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartAuditRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartCOParts items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartCOParts1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartCOPartRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartCOParts(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOPartRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartCOParts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOPartRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartCOPart item
   Description: Calls GetByID to retrieve the PartCOPart item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartCOPart1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param CoPartNum Desc: CoPartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartCOPartRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartCOParts_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_CoPartNum(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, CoPartNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartCOPartRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartCOParts(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + CoPartNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartCOPartRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRevInspPlans items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRevInspPlans1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevInspPlanRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartRevInspPlans(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartRevInspPlans", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevInspPlan item
   Description: Calls GetByID to retrieve the PartRevInspPlan item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevInspPlan1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartRevInspPlans_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevInspPlanRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartRevInspPlans(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevInspPlanRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRevInspVends items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRevInspVends1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevInspVendRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartRevInspVends(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspVendRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartRevInspVends", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspVendRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevInspVend item
   Description: Calls GetByID to retrieve the PartRevInspVend item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevInspVend1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param VendorID Desc: VendorID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevInspVendRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartRevInspVends_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_VendorID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, VendorID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevInspVendRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartRevInspVends(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + VendorID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevInspVendRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRevAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRevAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevAttchRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartRevAttches(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartRevAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevAttch item
   Description: Calls GetByID to retrieve the PartRevAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevAttchRow
   */  
export function get_PartRevs_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_PartRevAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevs(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + ")/PartRevAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartAudits items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartAudits
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartAuditRow
   */  
export function get_PartAudits(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAuditRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAudits", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAuditRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartAudits
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartAuditRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartAuditRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartAudits(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAudits", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartAudit item
   Description: Calls GetByID to retrieve the PartAudit item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartAudit
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param ChangeDate Desc: ChangeDate   Required: True   Allow empty value : True
      @param ChangeTime Desc: ChangeTime   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartAuditRow
   */  
export function get_PartAudits_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_ChangeDate_ChangeTime(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, ChangeDate:string, ChangeTime:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartAuditRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAudits(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + ChangeDate + "," + ChangeTime + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartAuditRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartAudit for the service
   Description: Calls UpdateExt to update PartAudit. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartAudit
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param ChangeDate Desc: ChangeDate   Required: True   Allow empty value : True
      @param ChangeTime Desc: ChangeTime   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartAuditRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartAudits_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_ChangeDate_ChangeTime(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, ChangeDate:string, ChangeTime:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAudits(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + ChangeDate + "," + ChangeTime + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartAudit item
   Description: Call UpdateExt to delete PartAudit item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartAudit
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param ChangeDate Desc: ChangeDate   Required: True   Allow empty value : True
      @param ChangeTime Desc: ChangeTime   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartAudits_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_ChangeDate_ChangeTime(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, ChangeDate:string, ChangeTime:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAudits(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + ChangeDate + "," + ChangeTime + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartCOParts items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartCOParts
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartCOPartRow
   */  
export function get_PartCOParts(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOPartRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOParts", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOPartRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartCOParts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartCOPartRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartCOPartRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartCOParts(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOParts", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartCOPart item
   Description: Calls GetByID to retrieve the PartCOPart item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartCOPart
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param CoPartNum Desc: CoPartNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartCOPartRow
   */  
export function get_PartCOParts_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_CoPartNum(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, CoPartNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartCOPartRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOParts(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + CoPartNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartCOPartRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartCOPart for the service
   Description: Calls UpdateExt to update PartCOPart. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartCOPart
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param CoPartNum Desc: CoPartNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartCOPartRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartCOParts_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_CoPartNum(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, CoPartNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOParts(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + CoPartNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartCOPart item
   Description: Call UpdateExt to delete PartCOPart item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartCOPart
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param CoPartNum Desc: CoPartNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartCOParts_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_CoPartNum(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, CoPartNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartCOParts(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + CoPartNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRevInspPlans items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRevInspPlans
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevInspPlanRow
   */  
export function get_PartRevInspPlans(select?:string, expand?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRevInspPlans
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRevInspPlans(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevInspPlan item
   Description: Calls GetByID to retrieve the PartRevInspPlan item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevInspPlan
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param expand Desc: Odata expand to child
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanRow
   */  
export function get_PartRevInspPlans_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, select?:string, expand?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevInspPlanRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevInspPlanRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRevInspPlan for the service
   Description: Calls UpdateExt to update PartRevInspPlan. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRevInspPlan
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRevInspPlans_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRevInspPlan item
   Description: Call UpdateExt to delete PartRevInspPlan item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRevInspPlan
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRevInspPlans_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID for the service
   Description: Get PartRevInspPlanAttches items from the server using GetByID standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetByID_PartRevInspPlanAttches1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevInspPlanAttchRow
   */  
export function get_PartRevInspPlans_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan_PartRevInspPlanAttches(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + ")/PartRevInspPlanAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevInspPlanAttch item
   Description: Calls GetByID to retrieve the PartRevInspPlanAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevInspPlanAttch1
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanAttchRow
   */  
export function get_PartRevInspPlans_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan_PartRevInspPlanAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevInspPlanAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlans(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + ")/PartRevInspPlanAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevInspPlanAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRevInspPlanAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRevInspPlanAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevInspPlanAttchRow
   */  
export function get_PartRevInspPlanAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlanAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRevInspPlanAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRevInspPlanAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlanAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevInspPlanAttch item
   Description: Calls GetByID to retrieve the PartRevInspPlanAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevInspPlanAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanAttchRow
   */  
export function get_PartRevInspPlanAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevInspPlanAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlanAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevInspPlanAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRevInspPlanAttch for the service
   Description: Calls UpdateExt to update PartRevInspPlanAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRevInspPlanAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRevInspPlanAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRevInspPlanAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlanAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRevInspPlanAttch item
   Description: Call UpdateExt to delete PartRevInspPlanAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRevInspPlanAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param SeqPlan Desc: SeqPlan   Required: True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRevInspPlanAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_SeqPlan_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, SeqPlan:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspPlanAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + SeqPlan + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRevInspVends items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRevInspVends
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevInspVendRow
   */  
export function get_PartRevInspVends(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspVendRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspVends", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspVendRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRevInspVends
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRevInspVendRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRevInspVendRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRevInspVends(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspVends", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevInspVend item
   Description: Calls GetByID to retrieve the PartRevInspVend item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevInspVend
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param VendorID Desc: VendorID   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevInspVendRow
   */  
export function get_PartRevInspVends_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_VendorID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, VendorID:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevInspVendRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspVends(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + VendorID + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevInspVendRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRevInspVend for the service
   Description: Calls UpdateExt to update PartRevInspVend. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRevInspVend
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param VendorID Desc: VendorID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRevInspVendRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRevInspVends_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_VendorID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, VendorID:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspVends(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + VendorID + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRevInspVend item
   Description: Call UpdateExt to delete PartRevInspVend item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRevInspVend
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param VendorID Desc: VendorID   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRevInspVends_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_VendorID(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, VendorID:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevInspVends(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + VendorID + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartRevAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartRevAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartRevAttchRow
   */  
export function get_PartRevAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartRevAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartRevAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartRevAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartRevAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartRevAttch item
   Description: Calls GetByID to retrieve the PartRevAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartRevAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartRevAttchRow
   */  
export function get_PartRevAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartRevAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartRevAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartRevAttch for the service
   Description: Calls UpdateExt to update PartRevAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartRevAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartRevAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartRevAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartRevAttch item
   Description: Call UpdateExt to delete PartRevAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartRevAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param RevisionNum Desc: RevisionNum   Required: True   Allow empty value : True
      @param AltMethod Desc: AltMethod   Required: True   Allow empty value : True
      @param ProcessMfgID Desc: ProcessMfgID   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartRevAttches_Company_PartNum_RevisionNum_AltMethod_ProcessMfgID_DrawingSeq(Company:string, PartNum:string, RevisionNum:string, AltMethod:string, ProcessMfgID:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartRevAttches(" + Company + "," + PartNum + "," + RevisionNum + "," + AltMethod + "," + ProcessMfgID + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartSubs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartSubs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartSubsRow
   */  
export function get_PartSubs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartSubs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartSubs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartSubsRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartSubs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartSub item
   Description: Calls GetByID to retrieve the PartSub item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartSub
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   */  
export function get_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartSubsRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartSubsRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartSub for the service
   Description: Calls UpdateExt to update PartSub. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartSub
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartSubsRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartSub item
   Description: Call UpdateExt to delete PartSub item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartSub
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param SubPart Desc: SubPart   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartSubs_Company_PartNum_SubPart(Company:string, PartNum:string, SubPart:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartSubs(" + Company + "," + PartNum + "," + SubPart + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartBinInfoes items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartBinInfoes
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartBinInfoRow
   */  
export function get_PartBinInfoes(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartBinInfoRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartBinInfoes", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartBinInfoRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartBinInfoes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartBinInfoRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartBinInfoRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartBinInfoes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartBinInfoes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartBinInfo item
   Description: Calls GetByID to retrieve the PartBinInfo item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartBinInfo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      @param BinNum Desc: BinNum   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartBinInfoRow
   */  
export function get_PartBinInfoes_Company_PartNum_Plant_WarehouseCode_BinNum(Company:string, PartNum:string, Plant:string, WarehouseCode:string, BinNum:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartBinInfoRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartBinInfoes(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + "," + BinNum + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartBinInfoRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartBinInfo for the service
   Description: Calls UpdateExt to update PartBinInfo. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartBinInfo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      @param BinNum Desc: BinNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartBinInfoRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartBinInfoes_Company_PartNum_Plant_WarehouseCode_BinNum(Company:string, PartNum:string, Plant:string, WarehouseCode:string, BinNum:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartBinInfoes(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + "," + BinNum + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartBinInfo item
   Description: Call UpdateExt to delete PartBinInfo item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartBinInfo
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      @param BinNum Desc: BinNum   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartBinInfoes_Company_PartNum_Plant_WarehouseCode_BinNum(Company:string, PartNum:string, Plant:string, WarehouseCode:string, BinNum:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartBinInfoes(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + "," + BinNum + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartPCs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartPCs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartPCRow
   */  
export function get_PartPCs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPCs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartPCs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartPCRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartPCRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartPCs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPCs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartPC item
   Description: Calls GetByID to retrieve the PartPC item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartPC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PCType Desc: PCType   Required: True   Allow empty value : True
      @param ProdCode Desc: ProdCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartPCRow
   */  
export function get_PartPCs_Company_PartNum_PCType_ProdCode(Company:string, PartNum:string, PCType:string, ProdCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartPCRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPCs(" + Company + "," + PartNum + "," + PCType + "," + ProdCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartPCRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartPC for the service
   Description: Calls UpdateExt to update PartPC. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartPC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PCType Desc: PCType   Required: True   Allow empty value : True
      @param ProdCode Desc: ProdCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartPCRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartPCs_Company_PartNum_PCType_ProdCode(Company:string, PartNum:string, PCType:string, ProdCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPCs(" + Company + "," + PartNum + "," + PCType + "," + ProdCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartPC item
   Description: Call UpdateExt to delete PartPC item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartPC
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param PCType Desc: PCType   Required: True   Allow empty value : True
      @param ProdCode Desc: ProdCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartPCs_Company_PartNum_PCType_ProdCode(Company:string, PartNum:string, PCType:string, ProdCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartPCs(" + Company + "," + PartNum + "," + PCType + "," + ProdCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartWhses items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartWhses
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartWhseRow
   */  
export function get_PartWhses(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartWhseRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartWhses", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartWhseRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartWhses
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartWhseRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartWhseRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartWhses(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartWhses", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartWhse item
   Description: Calls GetByID to retrieve the PartWhse item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartWhse
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartWhseRow
   */  
export function get_PartWhses_Company_PartNum_Plant_WarehouseCode(Company:string, PartNum:string, Plant:string, WarehouseCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartWhseRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartWhses(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartWhseRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartWhse for the service
   Description: Calls UpdateExt to update PartWhse. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartWhse
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartWhseRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartWhses_Company_PartNum_Plant_WarehouseCode(Company:string, PartNum:string, Plant:string, WarehouseCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartWhses(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartWhse item
   Description: Call UpdateExt to delete PartWhse item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartWhse
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param Plant Desc: Plant   Required: True   Allow empty value : True
      @param WarehouseCode Desc: WarehouseCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartWhses_Company_PartNum_Plant_WarehouseCode(Company:string, PartNum:string, Plant:string, WarehouseCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartWhses(" + Company + "," + PartNum + "," + Plant + "," + WarehouseCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartUOMs items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartUOMs
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartUOMRow
   */  
export function get_PartUOMs(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartUOMRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMs", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartUOMRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartUOMs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartUOMRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartUOMRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartUOMs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartUOM item
   Description: Calls GetByID to retrieve the PartUOM item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartUOM
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param UOMCode Desc: UOMCode   Required: True   Allow empty value : True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartUOMRow
   */  
export function get_PartUOMs_Company_PartNum_UOMCode(Company:string, PartNum:string, UOMCode:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartUOMRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMs(" + Company + "," + PartNum + "," + UOMCode + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartUOMRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartUOM for the service
   Description: Calls UpdateExt to update PartUOM. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartUOM
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param UOMCode Desc: UOMCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartUOMRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartUOMs_Company_PartNum_UOMCode(Company:string, PartNum:string, UOMCode:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMs(" + Company + "," + PartNum + "," + UOMCode + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartUOM item
   Description: Call UpdateExt to delete PartUOM item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartUOM
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param UOMCode Desc: UOMCode   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartUOMs_Company_PartNum_UOMCode(Company:string, PartNum:string, UOMCode:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMs(" + Company + "," + PartNum + "," + UOMCode + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetRows for the service
   Description: Get PartAttches items from the server using GetRows standard method. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetRows_PartAttches
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartAttchRow
   */  
export function get_PartAttches(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAttches", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to create new item for the service
   Description: Calls UpdateExt to create new item for the service. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: NewUpdateExt_PartAttches
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Erp.Tablesets.PartAttchRow
   Returns: 
      201 Desc: Resource is created. Operation is successful.  => reference#/components/schemas/Erp.Tablesets.PartAttchRow
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartAttches(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAttches", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetByID to retrieve the PartAttch item
   Description: Calls GetByID to retrieve the PartAttch item by specified keys. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: GetById_PartAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Erp.Tablesets.PartAttchRow
   */  
export function get_PartAttches_Company_PartNum_DrawingSeq(Company:string, PartNum:string, DrawingSeq:string, select?:string, filter?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Erp_Tablesets_PartAttchRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAttches(" + Company + "," + PartNum + "," + DrawingSeq + ")", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Erp_Tablesets_PartAttchRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls UpdateExt to update PartAttch for the service
   Description: Calls UpdateExt to update PartAttch. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: UpdateExt_PartAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
      :param requestBody: Desc: input params  => reference#/components/schemas/Erp.Tablesets.PartAttchRow
   Returns: 
      204 Desc: No Content. Operation is successful.
      400 Desc: Unable to deserialize entity. Input data is not in correct format.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function patch_PartAttches_Company_PartNum_DrawingSeq(Company:string, PartNum:string, DrawingSeq:string, requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAttches(" + Company + "," + PartNum + "," + DrawingSeq + ")", {
          method: 'patch',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Call UpdateExt to delete PartAttch item
   Description: Call UpdateExt to delete PartAttch item. <div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li><li>String parameters should be specified in single quotes</li></ul></div>
   OperationID: DeleteUpdateExt_PartAttch
      @param Company Desc: Company   Required: True   Allow empty value : True
      @param PartNum Desc: PartNum   Required: True   Allow empty value : True
      @param DrawingSeq Desc: DrawingSeq   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      204 Desc: No Content. Operation is successful.
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function delete_PartAttches_Company_PartNum_DrawingSeq(Company:string, PartNum:string, DrawingSeq:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartAttches(" + Company + "," + PartNum + "," + DrawingSeq + ")", {
          method: 'delete',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Calls GetList for the service
   Description: Get list of items<div>OData-specific rules:<ul><li>OData $-parameters data are case-sensitive</li></ul></div>
   OperationID: GetList
      @param select Desc: Odata select comma delimited list of fields
      @param filter Desc: Odata filter results
      @param orderby Desc: Odata sort results
      @param top Desc: Odata top results
      @param skip Desc: Odata skip results
      @param inlinecount Desc: Odata.count value
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => reference#/components/schemas/Epicor.RESTApi.Help.ODataSetResponse_System.Collections.Generic.List_Erp.Tablesets.PartListRow
   */  
export function get_List(select?:string, filter?:string, orderby?:string, top?:string, skip?:string, inlinecount?:string, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartListRow>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/List", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartListRow)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
// Custom methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Invoke method GetList
   Description: Returns a list of rows that satisfy the where clause.
   OperationID: Get_GetList
      @param whereClause Desc: An expression used to filter the rows. Can be left blank for all rows.   Required: True   Allow empty value : True
      @param pageSize Desc: The maximum number of rows to return. Leave as zero for no maximum.   Required: True
      @param absolutePage Desc: Page of rows to return.   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetList(whereClause:string, pageSize:string, absolutePage:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof whereClause!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClause=" + whereClause
   }
   if(typeof pageSize!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "pageSize=" + pageSize
   }
   if(typeof absolutePage!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "absolutePage=" + absolutePage
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetList" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method WhereUsedTrackUp
   Description: Adds new part to Used List
   OperationID: WhereUsedTrackUp
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/WhereUsedTrackUp_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/WhereUsedTrackUp_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_WhereUsedTrackUp(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/WhereUsedTrackUp", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method WhereUsedTrackDown
   Description: Removes part From Used List
   OperationID: WhereUsedTrackDown
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/WhereUsedTrackDown_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/WhereUsedTrackDown_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_WhereUsedTrackDown(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/WhereUsedTrackDown", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method WhereUsedRtnStart
   Description: Clear Used List
   OperationID: WhereUsedRtnStart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/WhereUsedRtnStart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/WhereUsedRtnStart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_WhereUsedRtnStart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/WhereUsedRtnStart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetWhereUsedECORevClause
   Description: Calculates ECORevClause where clause
   OperationID: GetWhereUsedECORevClause
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetWhereUsedECORevClause_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetWhereUsedECORevClause_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetWhereUsedECORevClause(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetWhereUsedECORevClause", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetConfTypeDescList
   Description: Method to call to get a Code Description list.
   OperationID: GetConfTypeDescList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetConfTypeDescList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetConfTypeDescList(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetConfTypeDescList", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateNewPartRevAttch
   Description: Limit addition of attachments to approved Part Revisions
   OperationID: ValidateNewPartRevAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateNewPartRevAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateNewPartRevAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateNewPartRevAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ValidateNewPartRevAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateAfterGlbPartLink
   Description: The call to Update after linking to a global part.  Need the ErpCallContext to check during update to skip some checks in ValidateTrackInventoryAttributes
   OperationID: UpdateAfterGlbPartLink
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateAfterGlbPartLink_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateAfterGlbPartLink_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateAfterGlbPartLink(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/UpdateAfterGlbPartLink", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartUOMPlasticTax
   OperationID: GetNewPartUOMPlasticTax
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartUOMPlasticTax_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartUOMPlasticTax_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartUOMPlasticTax(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartUOMPlasticTax", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPartUOMPlasticTax
   OperationID: GetPartUOMPlasticTax
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPartUOMPlasticTax_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPartUOMPlasticTax_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPartUOMPlasticTax(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPartUOMPlasticTax", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PartUOMPlasticTaxUpdate
   OperationID: PartUOMPlasticTaxUpdate
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PartUOMPlasticTaxUpdate_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PartUOMPlasticTaxUpdate_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartUOMPlasticTaxUpdate(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMPlasticTaxUpdate", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PartUOMPlasticTaxDelete
   OperationID: PartUOMPlasticTaxDelete
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PartUOMPlasticTaxDelete_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PartUOMPlasticTaxDelete_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartUOMPlasticTaxDelete(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartUOMPlasticTaxDelete", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSerialNumberFormatLeadingZeros
   Description: Calculates Serial Number Format for Kinetic
   OperationID: GetSerialNumberFormatLeadingZeros
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetSerialNumberFormatLeadingZeros_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSerialNumberFormatLeadingZeros_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSerialNumberFormatLeadingZeros(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetSerialNumberFormatLeadingZeros", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartSNBaseDataTypePrep
   OperationID: ChangePartSNBaseDataTypePrep
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartSNBaseDataTypePrep_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartSNBaseDataTypePrep_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartSNBaseDataTypePrep(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartSNBaseDataTypePrep", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePlantSNBaseDataTypePrep
   OperationID: ChangePlantSNBaseDataTypePrep
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePlantSNBaseDataTypePrep_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePlantSNBaseDataTypePrep_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePlantSNBaseDataTypePrep(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePlantSNBaseDataTypePrep", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantSourceTypePrep
   Description: Used when the SourceType field of PartPlant or the TypeCode of Part is being changed
to a new value and the user selected to update the PartPlant records with the change.
It will check to see if a configuration exists for the part.  If a configuration
exists it will return a warning message in ruleMessage that should be displayed to the user as a warning.
If the configuration is not marked as single-level configuration then a message will be returned in
singleLevelConfMsg which should be displayed to the user asking if they want to continue.  If they answer Yes
to continue then the method DeleteMultiLevelRules should be called.
   OperationID: ChangePartPlantSourceTypePrep
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantSourceTypePrep_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantSourceTypePrep_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantSourceTypePrep(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantSourceTypePrep", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartSNMaskPrefixSuffixPrep
   OperationID: ChangePartSNMaskPrefixSuffixPrep
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartSNMaskPrefixSuffixPrep_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartSNMaskPrefixSuffixPrep_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartSNMaskPrefixSuffixPrep(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartSNMaskPrefixSuffixPrep", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePlantSNMaskPrefixSuffixPrep
   OperationID: ChangePlantSNMaskPrefixSuffixPrep
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePlantSNMaskPrefixSuffixPrep_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePlantSNMaskPrefixSuffixPrep_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePlantSNMaskPrefixSuffixPrep(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePlantSNMaskPrefixSuffixPrep", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckColumnValue
   OperationID: CheckColumnValue
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckColumnValue_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckColumnValue_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckColumnValue(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckColumnValue", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRestrictedMethodsInfo
   OperationID: GetRestrictedMethodsInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRestrictedMethodsInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRestrictedMethodsInfo(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetRestrictedMethodsInfo", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetValidatePartWarehouseBin
   Description: Finds bin related with a Warehouse, and return binNum only if part has such warehouse configured.
   OperationID: GetValidatePartWarehouseBin
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetValidatePartWarehouseBin_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetValidatePartWarehouseBin_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetValidatePartWarehouseBin(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetValidatePartWarehouseBin", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPart
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartCOO
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartCOO
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartCOO_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartCOO_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartCOO(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartCOO", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartDim
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartDim
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartDim_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartDim_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartDim(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartDim", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartLangDesc
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartLangDesc
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartLangDesc_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartLangDesc_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartLangDesc(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartLangDesc", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartPlanningPool
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartPlanningPool
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartPlanningPool_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartPlanningPool_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartPlanningPool(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartPlanningPool", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartPlant
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartPlant
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartPlant_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartPlant_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartPlant(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartPlant", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartPlantPlanningAttribute
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartPlantPlanningAttribute
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartPlantPlanningAttribute_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartPlantPlanningAttribute_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartPlantPlanningAttribute(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartPlantPlanningAttribute", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRestriction
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRestriction
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRestriction_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRestriction_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRestriction(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRestriction", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRestrictSubst
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRestrictSubst
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRestrictSubst_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRestrictSubst_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRestrictSubst(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRestrictSubst", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRev
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRev
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRev_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRev_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRev(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRev", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRevAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRevAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRevAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRevAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRevAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRevAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartAudit
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartAudit
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartAudit_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartAudit_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartAudit(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartAudit", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartCOPart
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartCOPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartCOPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartCOPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartCOPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartCOPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRevInspPlan
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRevInspPlan
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRevInspPlan_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRevInspPlan_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRevInspPlan(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRevInspPlan", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRevInspPlanAttch
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRevInspPlanAttch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRevInspPlanAttch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRevInspPlanAttch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRevInspPlanAttch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRevInspPlanAttch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartRevInspVend
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartRevInspVend
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartRevInspVend_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartRevInspVend_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartRevInspVend(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartRevInspVend", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartSubs
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartSubs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartSubs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartSubs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartSubs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartPC
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartPC
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartPC_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartPC_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartPC(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartPC", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartWhse
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartWhse
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartWhse_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartWhse_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartWhse(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartWhse", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartBinInfo
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartBinInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartBinInfo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartBinInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartBinInfo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartBinInfo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewPartUOM
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewPartUOM
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewPartUOM_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewPartUOM_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewPartUOM(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewPartUOM", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewEntityGLC
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewEntityGLC
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewEntityGLC_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewEntityGLC_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewEntityGLC(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewEntityGLC", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetNewTaxExempt
   Description: Inserts a new row in the DataSet with defaults populated.
   OperationID: GetNewTaxExempt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetNewTaxExempt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetNewTaxExempt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetNewTaxExempt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetNewTaxExempt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeleteByID
   Description: Deletes a row given its ID.
   OperationID: DeleteByID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DeleteByID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeleteByID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeleteByID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/DeleteByID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetByID
   Description: Returns a DataSet given the primary key.
   OperationID: Get_GetByID
   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetByID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetByID(partNum:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof partNum!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "partNum=" + partNum
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetByID" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRows
   Description: Returns a dataset containing all rows that satisfy the where clauses.
   OperationID: Get_GetRows
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True   Allow empty value : True
   Required: True
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRows_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetRows(whereClausePart:string, whereClausePartAttch:string, whereClausePartCOO:string, whereClausePartDim:string, whereClausePartLangDesc:string, whereClausePartPlanningPool:string, whereClausePartPlant:string, whereClausePartPlantPlanningAttribute:string, whereClausePartRestriction:string, whereClausePartRestrictSubst:string, whereClausePartRev:string, whereClausePartRevAttch:string, whereClausePartAudit:string, whereClausePartCOPart:string, whereClausePartRevInspPlan:string, whereClausePartRevInspPlanAttch:string, whereClausePartRevInspVend:string, whereClausePartSubs:string, whereClausePartPC:string, whereClausePartWhse:string, whereClausePartBinInfo:string, whereClausePartUOM:string, whereClauseEntityGLC:string, whereClauseTaxExempt:string, pageSize:string, absolutePage:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof whereClausePart!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePart=" + whereClausePart
   }
   if(typeof whereClausePartAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartAttch=" + whereClausePartAttch
   }
   if(typeof whereClausePartCOO!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartCOO=" + whereClausePartCOO
   }
   if(typeof whereClausePartDim!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartDim=" + whereClausePartDim
   }
   if(typeof whereClausePartLangDesc!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartLangDesc=" + whereClausePartLangDesc
   }
   if(typeof whereClausePartPlanningPool!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartPlanningPool=" + whereClausePartPlanningPool
   }
   if(typeof whereClausePartPlant!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartPlant=" + whereClausePartPlant
   }
   if(typeof whereClausePartPlantPlanningAttribute!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartPlantPlanningAttribute=" + whereClausePartPlantPlanningAttribute
   }
   if(typeof whereClausePartRestriction!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRestriction=" + whereClausePartRestriction
   }
   if(typeof whereClausePartRestrictSubst!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRestrictSubst=" + whereClausePartRestrictSubst
   }
   if(typeof whereClausePartRev!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRev=" + whereClausePartRev
   }
   if(typeof whereClausePartRevAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRevAttch=" + whereClausePartRevAttch
   }
   if(typeof whereClausePartAudit!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartAudit=" + whereClausePartAudit
   }
   if(typeof whereClausePartCOPart!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartCOPart=" + whereClausePartCOPart
   }
   if(typeof whereClausePartRevInspPlan!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRevInspPlan=" + whereClausePartRevInspPlan
   }
   if(typeof whereClausePartRevInspPlanAttch!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRevInspPlanAttch=" + whereClausePartRevInspPlanAttch
   }
   if(typeof whereClausePartRevInspVend!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartRevInspVend=" + whereClausePartRevInspVend
   }
   if(typeof whereClausePartSubs!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartSubs=" + whereClausePartSubs
   }
   if(typeof whereClausePartPC!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartPC=" + whereClausePartPC
   }
   if(typeof whereClausePartWhse!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartWhse=" + whereClausePartWhse
   }
   if(typeof whereClausePartBinInfo!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartBinInfo=" + whereClausePartBinInfo
   }
   if(typeof whereClausePartUOM!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClausePartUOM=" + whereClausePartUOM
   }
   if(typeof whereClauseEntityGLC!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseEntityGLC=" + whereClauseEntityGLC
   }
   if(typeof whereClauseTaxExempt!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "whereClauseTaxExempt=" + whereClauseTaxExempt
   }
   if(typeof pageSize!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "pageSize=" + pageSize
   }
   if(typeof absolutePage!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "absolutePage=" + absolutePage
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetRows" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBySysRowID
   OperationID: Get_GetBySysRowID
   Required: True   Allow empty value : True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBySysRowID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetBySysRowID(id:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof id!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "id=" + id
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetBySysRowID" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetBySysRowIDs
   OperationID: Get_GetBySysRowIDs
   Required: True
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetBySysRowIDs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function get_GetBySysRowIDs(ids:string, epicorHeaders?:Headers){
   var firstParam = true
   var params = ""
   if(typeof ids!== 'undefined'){
      if(firstParam){
         params += "?"
         firstParam = false
      }else{
         params += "&"
      }
      params += "ids=" + ids
   }

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetBySysRowIDs" + params, {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method Update
   Description: Commits the DataSet changes to the data store.
   OperationID: Update
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/Update_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/Update_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_Update(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/Update", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UpdateExt
   Description: Apply input data to service by calling GetByID/GetNew/Update methods.
   OperationID: UpdateExt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UpdateExt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UpdateExt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UpdateExt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/UpdateExt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPartGlobalFields
   Description: Gets Part global fields
   OperationID: GetPartGlobalFields
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPartGlobalFields_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPartGlobalFields_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPartGlobalFields(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPartGlobalFields", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method BuildPartPlantPlanningAttributeTable
   Description: Add records in PartPlantPlanningAttribute table against the current part and PartPlant
   OperationID: BuildPartPlantPlanningAttributeTable
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/BuildPartPlantPlanningAttributeTable_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/BuildPartPlantPlanningAttributeTable_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_BuildPartPlantPlanningAttributeTable(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/BuildPartPlantPlanningAttributeTable", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AllowDimensionMaintenance
   Description: This method exists soley for the purpose of allowing security for
dimension maintenance to be defined
   OperationID: AllowDimensionMaintenance
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/AllowDimensionMaintenance_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AllowDimensionMaintenance(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/AllowDimensionMaintenance", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AllowInventoryInfo
   Description: This method exists soley for the purpose of allowing security for
inventory information to be defined
   OperationID: AllowInventoryInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/AllowInventoryInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AllowInventoryInfo(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/AllowInventoryInfo", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AllowLotMaintenance
   Description: This method exists soley for the purpose of allowing security for
lot maintenance to be defined
   OperationID: AllowLotMaintenance
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/AllowLotMaintenance_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AllowLotMaintenance(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/AllowLotMaintenance", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AllowPurchasingInfo
   Description: This method exists soley for the purpose of allowing security for
purchasing information to be defined
   OperationID: AllowPurchasingInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/AllowPurchasingInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AllowPurchasingInfo(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/AllowPurchasingInfo", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AllowViewLotCosts
   Description: This method exists soley for the purpose of allowing security for
viewing part lot costs to be defined
   OperationID: AllowViewLotCosts
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/AllowViewLotCosts_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AllowViewLotCosts(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/AllowViewLotCosts", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMRPWarning
   Description: When the ProcessMRP flag for a Part/Plant is changed from Yes to No all related unfirm jobs will be deleted
when the record is committed to the database.
You can use this method to provide a warning to the user of this fact and provide a confirmation dialog. This is
intended to be called upon value change of the ProcessMRP field.
If there are existing unfirm Jobs for the given Part/PlantThis warningMsg will contain a translated text message
which can be used to display in your message dialog.  Otherwise it returns blanks and there is no need to provide a
dialog.
   OperationID: ChangeMRPWarning
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMRPWarning_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMRPWarning_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMRPWarning(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeMRPWarning", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetTrackInventoryByRevision
   Description: Returns TrackInventoryByRevision value for the given PartNum
   OperationID: GetTrackInventoryByRevision
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetTrackInventoryByRevision_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetTrackInventoryByRevision_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetTrackInventoryByRevision(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetTrackInventoryByRevision", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartBinInfoKBCode
   Description: Used when the KBCode field of PartBinInfo is being changed to a new value.
It will validate the new KBCode field.
If it is valid the dataset will be updated with the new KBCode and related KBActionCode.
   OperationID: ChangePartBinInfoKBCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartBinInfoKBCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartBinInfoKBCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartBinInfoKBCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartBinInfoKBCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartBuyToOrder
   Description: Used when the Buy To Order field of Part is being changed to a new value.
   OperationID: ChangePartBuyToOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartBuyToOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartBuyToOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartBuyToOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartBuyToOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartInspectionRequired
   Description: Used when the Inspection Required of Part is being changed to a new value.
   OperationID: ChangePartInspectionRequired
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartInspectionRequired_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartInspectionRequired_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartInspectionRequired(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartInspectionRequired", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartCommodityCode
   Description: Used when the Part.CommodityCode field is being changed to a new value.
It will validate the new value, passed in with newCommodityCode
If it is valid the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartCommodityCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartCommodityCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartCommodityCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartCommodityCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartCommodityCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartIsServices
   Description: Used when the Part.IsServices field is being changed to a new value.
the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartIsServices
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartIsServices_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartIsServices_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartIsServices(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartIsServices", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartSyncToExternalCRM
   Description: Used when the Part.SyncToExternalCRM field is being changed to a new value.
the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartSyncToExternalCRM
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartSyncToExternalCRM_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartSyncToExternalCRM_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartSyncToExternalCRM(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartSyncToExternalCRM", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartExternalMESSyncRequired
   Description: Used when the Part.ExternalMESSyncRequired field is being changed to a new value.
the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartExternalMESSyncRequired
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartExternalMESSyncRequired_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartExternalMESSyncRequired_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartExternalMESSyncRequired(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartExternalMESSyncRequired", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartNonStock
   Description: Used when the Part.NonStock field is being changed to a new value.
It will verify a configurator ID isn't assigned to any part revisions
If it is valid the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartNonStock
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartNonStock_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartNonStock_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartNonStock(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartNonStock", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartGlobalPart
   Description: Method to call when changing the global part flag on a part.
Assigns the GlbFlag base on the new value.
   OperationID: ChangePartGlobalPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartGlobalPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartGlobalPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartGlobalPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartGlobalPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartNum
   Description: Method to call when changing the Part Number.
Validates this is a "Add", PartNumber does not already exist, sets defaults for UOMClass, UOM
   OperationID: ChangePartNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantBuyToOrder
   Description: Used when the Buy To Order field of PartPlant is being changed to a new value.
   OperationID: ChangePartPlantBuyToOrder
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantBuyToOrder_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantBuyToOrder_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantBuyToOrder(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantBuyToOrder", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantSourceType
   Description: Used when the SourceType field of PartPlant or the TypeCode of Part is being changed
to a new value and the user selected to update the PartPlant records with the change.
It will check to see if a configuration exists for the part.  If a configuration
exists it will return a warning message in ruleMessage that should be displayed to the user as a warning.
If the configuration is not marked as single-level configuration then a message will be returned in
singleLevelConfMsg which should be displayed to the user asking if they want to continue.  If they answer Yes
to continue then the method DeleteMultiLevelRules should be called.
   OperationID: ChangePartPlantSourceType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantSourceType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantSourceType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantSourceType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantSourceType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantUrgentVendorID
   Description: Used when the VendorID field of PartPlant is being changed to a new value.
It will validate the new VendorID field.
If it is valid the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartPlantUrgentVendorID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantUrgentVendorID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantUrgentVendorID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantUrgentVendorID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantUrgentVendorID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantPlanningAttributeUrgentVendorID
   Description: Used when the VendorID field of PartPlantPlanningAttribute is being changed to a new value.
It will validate the new VendorID field.
If it is valid the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartPlantPlanningAttributeUrgentVendorID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantPlanningAttributeUrgentVendorID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantPlanningAttributeUrgentVendorID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantPlanningAttributeUrgentVendorID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantPlanningAttributeUrgentVendorID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantVendorID
   Description: Used when the VendorID field of PartPlant is being changed to a new value.
It will validate the new VendorID field.
If it is valid the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartPlantVendorID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantVendorID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantVendorID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantVendorID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantVendorID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantPlanningAttributeVendorID
   Description: Used when the VendorID field of PartPlantPlanningAttribute is being changed to a new value.
It will validate the new VendorID field.
If it is valid the dataset will be updated with the new value and related values will be refreshed.
   OperationID: ChangePartPlantPlanningAttributeVendorID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantPlanningAttributeVendorID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantPlanningAttributeVendorID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantPlanningAttributeVendorID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantPlanningAttributeVendorID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantPlanningAttributeNofP
   Description: Used when any of the 12 Number of Pieces columns of ttPartPlantPlanningAttribute are being changed.
The dataset will be updated with the new values and returned.
   OperationID: ChangePartPlantPlanningAttributeNofP
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantPlanningAttributeNofP_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantPlanningAttributeNofP_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantPlanningAttributeNofP(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantPlanningAttributeNofP", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantPlanningAttributeQty
   Description: Used when any of the 12 Quantity columns of ttPartPlantPlanningAttribute are being changed.
The dataset will be updated with the new values and returned.
   OperationID: ChangePartPlantPlanningAttributeQty
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantPlanningAttributeQty_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantPlanningAttributeQty_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantPlanningAttributeQty(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantPlanningAttributeQty", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartPlantPlanningAttributeQtyDisplayOption
   Description: Used when the QtyDisplayOption field of ttPartPlantPlanningAttribute is being changed.
When false - all quantity columns will already contain the value in IUM, so no recalculation is required
When true - all Number of Pieces columns will need to be recalculated based on the current quantity values
The dataset will be updated with the new values and returned.
   OperationID: ChangePartPlantPlanningAttributeQtyDisplayOption
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartPlantPlanningAttributeQtyDisplayOption_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartPlantPlanningAttributeQtyDisplayOption_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartPlantPlanningAttributeQtyDisplayOption(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartPlantPlanningAttributeQtyDisplayOption", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartProdCode
   Description: Method to call when changing the product group code on a part.
Validates the code and defaults the part tax category code based
on the product group.
   OperationID: ChangePartProdCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartProdCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartProdCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartProdCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartProdCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartRestrictionManual
   Description: Used when Manual field of PartRestriction is being changed to a new value.
   OperationID: ChangePartRestrictionManual
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartRestrictionManual_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartRestrictionManual_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartRestrictionManual(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartRestrictionManual", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartRestrictionType
   Description: This methods assigns associated fields when PartRestriction.RestrictionTypeID changes.
   OperationID: ChangePartRestrictionType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartRestrictionType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartRestrictionType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartRestrictionType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartRestrictionType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartRestrictSubstance
   Description: This methods assigns associated fields when PartRestrictSubst.SubstanceID changes.
   OperationID: ChangePartRestrictSubstance
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartRestrictSubstance_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartRestrictSubstance_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartRestrictSubstance(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartRestrictSubstance", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartRevApproved
   Description: This method checks that a valid password was provided when required before
changing the PartRev.Approved flag
   OperationID: ChangePartRevApproved
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartRevApproved_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartRevApproved_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartRevApproved(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartRevApproved", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartSNBaseDataType
   OperationID: ChangePartSNBaseDataType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartSNBaseDataType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartSNBaseDataType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartSNBaseDataType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartSNBaseDataType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartSNMaskPrefixSuffix
   OperationID: ChangePartSNMaskPrefixSuffix
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartSNMaskPrefixSuffix_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartSNMaskPrefixSuffix_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartSNMaskPrefixSuffix(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartSNMaskPrefixSuffix", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartSubsPartNum
   Description: Method to call when changing the Part Number for an Alternate Part
   OperationID: ChangePartSubsPartNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartSubsPartNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartSubsPartNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartSubsPartNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartSubsPartNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartTrackDimension
   Description: Used when the Track Dimension field of Part is being changed to a new value.
It cannot be turned On if Part.TypeCode is Sales Kit (K).
   OperationID: ChangePartTrackDimension
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartTrackDimension_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartTrackDimension_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartTrackDimension(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartTrackDimension", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartTrackLots
   Description: Used when the Track Lots field of Part is being changed to a new value.
It cannot be turned On if Part.TypeCode is Sales Kit (K).
   OperationID: ChangePartTrackLots
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartTrackLots_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartTrackLots_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartTrackLots(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartTrackLots", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartUnitPrice
   Description: Used when the UnitPrice is set.
It should be validated.
   OperationID: ChangePartUnitPrice
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartUnitPrice_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartUnitPrice_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartUnitPrice(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartUnitPrice", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartInternalUnitPrice
   Description: Used when the InternalUnitPrice is set.
It should be validated.
   OperationID: ChangePartInternalUnitPrice
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartInternalUnitPrice_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartInternalUnitPrice_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartInternalUnitPrice(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartInternalUnitPrice", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartTrackSerialNum
   Description: Used when the Track Serial Numbers field of Part is being changed to a new value.
It cannot be turned On if Part.TypeCode is Sales Kit (K).
   OperationID: ChangePartTrackSerialNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartTrackSerialNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartTrackSerialNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartTrackSerialNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartTrackSerialNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartLocationIDNumReq
   Description: Used when the LocationIDNumReq field of Part is being changed to a new value.
It cannot be turned On if Part.TypeCode is Sales Kit (K).
   OperationID: ChangePartLocationIDNumReq
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartLocationIDNumReq_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartLocationIDNumReq_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartLocationIDNumReq(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartLocationIDNumReq", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangedAttrClassID
   Description: Used when Attr Class ID changed.
   OperationID: ChangedAttrClassID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangedAttrClassID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangedAttrClassID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangedAttrClassID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangedAttrClassID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangedAttrClassIDFromPartUOMConversion
   Description: Used when Attr Class ID changed in the Part UOM Conversion}
THis will update the database Part record when the Attribute Clas is changed - will result and clear
   OperationID: ChangedAttrClassIDFromPartUOMConversion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangedAttrClassIDFromPartUOMConversion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangedAttrClassIDFromPartUOMConversion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangedAttrClassIDFromPartUOMConversion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangedAttrClassIDFromPartUOMConversion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeTrackInventoryAttributes
   Description: Obsoleted.  Performs specific action when changing the Track Inventory Attributes.  Modifies columns specifically related to TrackInventoryAttributes.
   OperationID: ChangeTrackInventoryAttributes
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeTrackInventoryAttributes_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeTrackInventoryAttributes_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeTrackInventoryAttributes(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeTrackInventoryAttributes", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartTypeCode
   Description: Used when the Type field of Part is being changed to a new value.
It can be turned to Sales Kit if any of Track Lots, Dimension or Serial Numbers are ON.
   OperationID: ChangePartTypeCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartTypeCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartTypeCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartTypeCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartTypeCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartUOMConvOverride
   OperationID: ChangePartUOMConvOverride
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartUOMConvOverride_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartUOMConvOverride_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartUOMConvOverride(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartUOMConvOverride", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartUOMConvFactor
   Description: Updates ConvToUOM according to ConvFactor
   OperationID: ChangePartUOMConvFactor
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartUOMConvFactor_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartUOMConvFactor_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartUOMConvFactor(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartUOMConvFactor", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePartWhseKBCode
   Description: Used when the KBCode field of PartWhse is being changed to a new value.
It will validate the new KBCode field.
If it is valid the dataset will be updated with the new KBCode and related KBActionCode.
   OperationID: ChangePartWhseKBCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePartWhseKBCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePartWhseKBCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePartWhseKBCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePartWhseKBCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePlantSNBaseDataType
   OperationID: ChangePlantSNBaseDataType
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePlantSNBaseDataType_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePlantSNBaseDataType_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePlantSNBaseDataType(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePlantSNBaseDataType", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangePlantSNMaskPrefixSuffix
   OperationID: ChangePlantSNMaskPrefixSuffix
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangePlantSNMaskPrefixSuffix_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangePlantSNMaskPrefixSuffix_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangePlantSNMaskPrefixSuffix(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangePlantSNMaskPrefixSuffix", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeQtyBearing
   OperationID: ChangeQtyBearing
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeQtyBearing_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeQtyBearing_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeQtyBearing(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeQtyBearing", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeLinkToContract
   OperationID: ChangeLinkToContract
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeLinkToContract_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeLinkToContract_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeLinkToContract(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeLinkToContract", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeCostMethod
   Description: Method that is executed when the costing method is changing
Costing method cannot be changed if there is any qty on hand, either for Part or for PartPlant
   OperationID: ChangeCostMethod
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeCostMethod_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeCostMethod_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeCostMethod(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeCostMethod", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeSNMask
   OperationID: ChangeSNMask
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeSNMask_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeSNMask_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeSNMask(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeSNMask", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeDualUOMClassID
   Description: Used when the Dual UOM Class ID is modified
   OperationID: ChangeDualUOMClassID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeDualUOMClassID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeDualUOMClassID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeDualUOMClassID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeDualUOMClassID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeUOMClassID
   Description: Used when the UOM Class ID is modified
   OperationID: ChangeUOMClassID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeUOMClassID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeUOMClassID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeUOMClassID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeUOMClassID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeUOMCode
   Description: Used when the UOM code is modified
   OperationID: ChangeUOMCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeUOMCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeUOMCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeUOMCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeUOMCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChanginPartRestrictSubs
   Description: This methods to validate duplicated substances on the part.
   OperationID: ChanginPartRestrictSubs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChanginPartRestrictSubs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChanginPartRestrictSubs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChanginPartRestrictSubs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChanginPartRestrictSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckAltMethodForDelete
   Description: This method should be called before allowing delete a revision.  This method
will determine if the revision being deleted has alternate methods.  If it
does, the user will be prompted with a message indicating this revision
has alternate methods and if they want to delete those records as well.  If
the user answers yes, the delete can procede.  If they answer no, the delete
should be canceled.  This method will return a string that contains the text
of the message to ask the  user.
   OperationID: CheckAltMethodForDelete
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckAltMethodForDelete_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckAltMethodForDelete_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckAltMethodForDelete(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckAltMethodForDelete", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCOOPercents
   Description: CheckCOOPercents
   OperationID: CheckCOOPercents
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCOOPercents_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCOOPercents_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCOOPercents(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckCOOPercents", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckCOOPercentsExt
   Description: CheckCOOPercents
   OperationID: CheckCOOPercentsExt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckCOOPercentsExt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckCOOPercentsExt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckCOOPercentsExt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckCOOPercentsExt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckDuplicateCOO
   Description: Check Duplicate COO - called only when the coo is changed or a partcoo is being added
   OperationID: CheckDuplicateCOO
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckDuplicateCOO_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckDuplicateCOO_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckDuplicateCOO(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckDuplicateCOO", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckPartChanges
   Description: Checks to see if certain fields changed on the part record.  If they did,
a question is presented to the user asking if these changes should carry over
to the PartPlant records. Changes to Part serial format fields builds a separate message.
This method returns the text of the message
to ask.  When adding a part it is not necessary to call this method because the
default (current) PartPlant record already uses the Part fields to default from.
The user can answer yes or no, but processing doesn't stop based on the answer.
The answers should be stored in the dataset in field Part.UpdatePartPlant and Part.UpdateSNPartPlant.
   OperationID: CheckPartChanges
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckPartChanges_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckPartChanges_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckPartChanges(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckPartChanges", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeleteMRPJobs
   Description: Deletes MRP Jobs.
   OperationID: DeleteMRPJobs
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DeleteMRPJobs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeleteMRPJobs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeleteMRPJobs(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/DeleteMRPJobs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeleteMultiLevelRules
   Description: Used when the SourceType field of PartPlant is being changed to SalesKit and
a multi-level configuration exists for the part.  This method is called after
displaying the message returned from ChangePartPlantSourceType.  This method
will unapprove the revision and configuration, set the single-level configuration
flag to true on the configuration, and then delete any existing lower level rules
that may have been created for the configuration.
   OperationID: DeleteMultiLevelRules
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DeleteMultiLevelRules_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeleteMultiLevelRules_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeleteMultiLevelRules(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/DeleteMultiLevelRules", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DuplicatePart
   Description: To create a new part by duplicating from another.
   OperationID: DuplicatePart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/DuplicatePart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DuplicatePart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DuplicatePart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/DuplicatePart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method EnterpriseGetList
   Description: Will invoke GetList or perform the Enterprise Search when enterpriseSearchText / enterpriseBAQID is provided
   OperationID: EnterpriseGetList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/EnterpriseGetList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/EnterpriseGetList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_EnterpriseGetList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EnterpriseGetList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetGlbPartList
   Description: This method returns the GlbPart dataset based on a delimited list of
GlbPartNum values passed in.
If GlbPart.PartNum = chr(9) that means the record has been skipped and should be shown
at the bottom of the browser. (GlbPart only)
   OperationID: GetGlbPartList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetGlbPartList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetGlbPartList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetGlbPartList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetGlbPartList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListByConfigID
   Description: Retreive all Parts related with the PartRev.ConfigID received from the UI
Used PartRevWhereClause in case a new Clause is added
instead of just receive the configID
   OperationID: GetListByConfigID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListByConfigID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListByConfigID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListByConfigID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetListByConfigID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListByWarehouseBin
   Description: Gets a part list depending on the warehouse/bin conditions.
   OperationID: GetListByWarehouseBin
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListByWarehouseBin_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListByWarehouseBin_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListByWarehouseBin(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetListByWarehouseBin", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListFilterPlants
   Description: Filter parts by plant.  Call normal GetList method.
   OperationID: GetListFilterPlants
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListFilterPlants_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListFilterPlants_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListFilterPlants(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetListFilterPlants", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListFilterCustXPrt
   Description: Filter parts by Customer Part Cross Reference.  Call normal GetList method.
   OperationID: GetListFilterCustXPrt
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListFilterCustXPrt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListFilterCustXPrt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListFilterCustXPrt(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetListFilterCustXPrt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetListFromSelectedKeys
   Description: This methods will return all of the Part recordsthat meet the selection criteria.
This method will try to mirror the functionality of the base GetList method but
since we are populating a temp table we need our own public method.
   OperationID: GetListFromSelectedKeys
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetListFromSelectedKeys_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetListFromSelectedKeys_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetListFromSelectedKeys(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetListFromSelectedKeys", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPartForLink
   Description: This returns the Part dataset for linking.
   OperationID: GetPartForLink
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPartForLink_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPartForLink_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPartForLink(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPartForLink", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPartWhereUsed
   Description: To return a PartWhereUsed dataset for a given part number
   OperationID: GetPartWhereUsed
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPartWhereUsed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPartWhereUsed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPartWhereUsed(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPartWhereUsed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPartXRefInfo
   Description: This method defaults PartAdvisor fields when the PartNum field changes
   OperationID: GetPartXRefInfo
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPartXRefInfo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPartXRefInfo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPartXRefInfo(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPartXRefInfo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method InitializeTracker
   Description: Method for kinetic part tracker
   OperationID: InitializeTracker
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/InitializeTracker_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_InitializeTracker(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/InitializeTracker", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CalcWipWClause
   Description: CalcWipWClause static filter calculation
   OperationID: CalcWipWClause
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CalcWipWClause_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CalcWipWClause_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CalcWipWClause(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CalcWipWClause", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSerialNumberFormat
   Description: Calculates Serial Number Format for Kinetic
   OperationID: GetSerialNumberFormat
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetSerialNumberFormat_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSerialNumberFormat_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSerialNumberFormat(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetSerialNumberFormat", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDMRListSearch
   Description: Part
   OperationID: GetDMRListSearch
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetDMRListSearch_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDMRListSearch_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDMRListSearch(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetDMRListSearch", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GlbPartsExist
   Description: This method checks if GlbPart records exist or not.  Can be used
to determine if the option to link/unlink parts is available.
   OperationID: GlbPartsExist
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GlbPartsExist_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GlbPartsExist(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GlbPartsExist", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method HasIntrastat
   Description: To determine if the Current company is using Intrastat
The following fields on the part table are controlled by this method
part.CommodityCode
part.ISOrigCountry
part.ISSuppUnitsFactor
   OperationID: HasIntrastat
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/HasIntrastat_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_HasIntrastat(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/HasIntrastat", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method IsRunOutOnHand
   Description: This method receives a part and returns a flag if the part is a run out part with on hand quantity.
   OperationID: IsRunOutOnHand
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/IsRunOutOnHand_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/IsRunOutOnHand_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_IsRunOutOnHand(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/IsRunOutOnHand", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method LinkGlbPart
   Description: This method performs the actual logic behind linking a Part.  It is run after
the PreLinkGlbPart method which determines the Part Number to link to.
If the Part Number is for a Part that already exists, the GlbPart information is
translated and then copied to the PartDataSet as an update.
If the Part Number is for a new Part, the GlbPart information is translated and then
copied to the PartDataSet as an Add.  Until the update method is run on Part record
the Link process is not completed.
   OperationID: LinkGlbPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/LinkGlbPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/LinkGlbPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_LinkGlbPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/LinkGlbPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangePkgCode
   Description: This method should be called when PartUOM DispPkgCode changes.
   OperationID: OnChangePkgCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangePkgCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangePkgCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangePkgCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/OnChangePkgCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangePESUNAT
   Description: This method should be called after SUNAT fieds has been changed.
   OperationID: OnChangePESUNAT
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangePESUNAT_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangePESUNAT_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangePESUNAT(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/OnChangePESUNAT", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangingDefaultAttributeSet
   Description: Call this method when the default attribute set changes
   OperationID: OnChangingDefaultAttributeSet
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangingDefaultAttributeSet_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangingDefaultAttributeSet_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangingDefaultAttributeSet(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/OnChangingDefaultAttributeSet", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangePlant
   Description: Run after Plant changing.
   OperationID: OnChangePlant
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangePlant_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangePlant_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangePlant(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/OnChangePlant", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CalcACWDays
   Description: Calculate the Auto Consume Window Days
   OperationID: CalcACWDays
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CalcACWDays_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CalcACWDays_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CalcACWDays(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CalcACWDays", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PreLinkGlbPart
   Description: Linking a GlbPart record ties a global record to a new or existing Vendor record so
that any changes made to the GlbPart record in another company are automatically copied
to any linked Parts.
This method performs the pre link logic to check of okay to link or get the new partnum
to create/link to.  Will be run before LinkGlbPart which actually creates/updates a
Part record and will send the modified record back for update.  When the Link "button" is
originally selected, the LinkPartNum will be defaulted to the GlbPartNum field.  It will then
check to see if this part number is available for Use.  If available for use the system will return a
question asking the user if they want to use this number.  If the answer is no, then the user
either needs to select an existing Part Number to link to or enter a brand new number.  You will
run this method until the user answer is yes.  Then the LinkGlbPart method is called.
   OperationID: PreLinkGlbPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PreLinkGlbPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PreLinkGlbPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PreLinkGlbPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PreLinkGlbPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PromptForPassword
   Description: This method checks the BMSyst record to see if a password should prompted for and then
validated by the ValidatePassword method in UserFile BO.  Run this before ApproveAll,
CheckECORevApproved, CheckIn, CheckInAll, and CheckOut.
   OperationID: PromptForPassword
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/PromptForPassword_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PromptForPassword(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PromptForPassword", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetMRPRecalcFlag
   Description: This method is used to enable the MRPRecalcFlag on PartPlant.  This
field determines whether the part is picked up in MRP Net Change mode or not.
   OperationID: SetMRPRecalcFlag
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetMRPRecalcFlag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetMRPRecalcFlag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetMRPRecalcFlag(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/SetMRPRecalcFlag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SetNextGeneratedLotNum
   Description: Set the Next Generated Lot Number.
   OperationID: SetNextGeneratedLotNum
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SetNextGeneratedLotNum_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SetNextGeneratedLotNum_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SetNextGeneratedLotNum(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/SetNextGeneratedLotNum", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SkipGlbPart
   Description: This method performs the logic behind the skip/UnSkip option for GlbPart
This works as a toggle.  If the flag is currently true it will change it to false
and if the flag is currently false, it will change it to true.
If the PartNum field is not blank will error out
   OperationID: SkipGlbPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/SkipGlbPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SkipGlbPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SkipGlbPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/SkipGlbPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UnlinkGlbPart
   Description: This method performs the logic behind the unlink option for GlbPart
Unlink - clears the PartNum field in GlbPart.  Returns the Part DataSet
   OperationID: UnlinkGlbPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/UnlinkGlbPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UnlinkGlbPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UnlinkGlbPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/UnlinkGlbPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateInspection
   Description: Method to validate the Inspection control fields. (EQM)
   OperationID: ValidateInspection
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateInspection_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateInspection_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateInspection(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ValidateInspection", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateInspVendor
   Description: Method to validate the Inspection control fields. (EQM)
   OperationID: ValidateInspVendor
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateInspVendor_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateInspVendor_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateInspVendor(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ValidateInspVendor", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateUOMconvChange
   Description: Method to validate the changing of UOM Class when performing UOM conversion
   OperationID: ValidateUOMconvChange
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateUOMconvChange_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateUOMconvChange_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateUOMconvChange(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ValidateUOMconvChange", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ValidateUOMConvTrans
   Description: Method to validate there are no open transactions when changing UOM Class, and performs the conversion
   OperationID: ValidateUOMConvTrans
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ValidateUOMConvTrans_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ValidateUOMConvTrans_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ValidateUOMConvTrans(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ValidateUOMConvTrans", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method EnableTrackInventoryAttributeConversion
   Description: Determines what should be enabled based on current selections.
   OperationID: EnableTrackInventoryAttributeConversion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/EnableTrackInventoryAttributeConversion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/EnableTrackInventoryAttributeConversion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_EnableTrackInventoryAttributeConversion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/EnableTrackInventoryAttributeConversion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CreateRevisionListValForPart
   Description: Creates DynAttrClassDtlListVal records for all Revision of a Part.
Typically used when enabling Part.TrackInventoryByRevision
   OperationID: CreateRevisionListValForPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CreateRevisionListValForPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CreateRevisionListValForPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CreateRevisionListValForPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CreateRevisionListValForPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckTrackInventoryAttributeConversion
   Description: Performs validation on changing of: Attribute Class, Track Inventory Attributes, Track Inventory By Revision , Planning By Revision
   OperationID: CheckTrackInventoryAttributeConversion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckTrackInventoryAttributeConversion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckTrackInventoryAttributeConversion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckTrackInventoryAttributeConversion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckTrackInventoryAttributeConversion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PerformTrackInventoryAttributeConversion
   Description: Performs the conversion when changing: Attribute Class, Track Inventory Attributes, Track Inventory By Revision , Planning By Revision
   OperationID: PerformTrackInventoryAttributeConversion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PerformTrackInventoryAttributeConversion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PerformTrackInventoryAttributeConversion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PerformTrackInventoryAttributeConversion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PerformTrackInventoryAttributeConversion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PerformTrackByRevisionConversion
   Description: Procedure to update the Track Inventory by Revision.
If passes all validation change will be committed.
   OperationID: PerformTrackByRevisionConversion
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PerformTrackByRevisionConversion_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PerformTrackByRevisionConversion_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PerformTrackByRevisionConversion(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PerformTrackByRevisionConversion", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSNFormat
   Description: Gets serial number format
   OperationID: GetSNFormat
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSNFormat_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSNFormat(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetSNFormat", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PartExists
   Description: Verifies if a part already exists
   OperationID: PartExists
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PartExists_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PartExists_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartExists(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartExists", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPcStatusIsKinetic
   Description: Returns true if the given Configurator has Design in App Studio.
   OperationID: GetPcStatusIsKinetic
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPcStatusIsKinetic_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPcStatusIsKinetic_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPcStatusIsKinetic(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPcStatusIsKinetic", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PartIsActive
   Description: Verifies if a part is active
   OperationID: PartIsActive
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PartIsActive_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PartIsActive_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartIsActive(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartIsActive", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method PartIsSalesKit
   Description: Returns true if the given PartNumber is defined as a Sales Kit
on the current plant (PartPlant.SourceType = "K")
   OperationID: PartIsSalesKit
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/PartIsSalesKit_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/PartIsSalesKit_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_PartIsSalesKit(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/PartIsSalesKit", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCodeDescList
   Description: Returns a list of code descriptions
   OperationID: GetCodeDescList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetCodeDescList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCodeDescList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCodeDescList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetCodeDescList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method FindPart
   Description: Finds an existing part
   OperationID: FindPart
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/FindPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/FindPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_FindPart(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/FindPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPartFromRowID
   Description: Gets a Part from RowID
   OperationID: GetPartFromRowID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetPartFromRowID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPartFromRowID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPartFromRowID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetPartFromRowID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangeSNLastUsedSeq
   Description: On Change SN Last Used Seq
   OperationID: OnChangeSNLastUsedSeq
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangeSNLastUsedSeq_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangeSNLastUsedSeq_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangeSNLastUsedSeq(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/OnChangeSNLastUsedSeq", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDupPartConfigID
   Description: Returns ConfigID and Description
   OperationID: GetDupPartConfigID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetDupPartConfigID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDupPartConfigID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDupPartConfigID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetDupPartConfigID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ConfigIDChanging
   Description: Returns correct ConfigID
   OperationID: ConfigIDChanging
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ConfigIDChanging_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ConfigIDChanging_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ConfigIDChanging(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ConfigIDChanging", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method OnChangedConfigID
   Description: Delete pcrules when
   OperationID: OnChangedConfigID
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/OnChangedConfigID_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/OnChangedConfigID_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_OnChangedConfigID(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/OnChangedConfigID", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CheckConfigForDelete
   Description: This method should be called before allowing delete a part or revision.  This method
will determine if the part/revision being deleted has an existing configuration.  If it
does, the user will be prompted with a message indicating this part/revision
has an existing configuration and if they want to delete those records as well.  If
the user answers yes, the delete can procede.  If they answer no, the delete
should be canceled.  This method will return a string that contains the text
of the message to ask the  user.
   OperationID: CheckConfigForDelete
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/CheckConfigForDelete_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CheckConfigForDelete_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CheckConfigForDelete(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/CheckConfigForDelete", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetIfCurrentSiteHasExternalMES
   Description: Returns If Current Site has External (MES)
   OperationID: GetIfCurrentSiteHasExternalMES
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetIfCurrentSiteHasExternalMES_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetIfCurrentSiteHasExternalMES_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetIfCurrentSiteHasExternalMES(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetIfCurrentSiteHasExternalMES", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetIfCurrentRevIsSiteExternalMES
   Description: Returns If Current Revision Is SiteExternal (MES)
   OperationID: GetIfCurrentRevIsSiteExternalMES
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetIfCurrentRevIsSiteExternalMES_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetIfCurrentRevIsSiteExternalMES_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetIfCurrentRevIsSiteExternalMES(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetIfCurrentRevIsSiteExternalMES", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSendToFSAChange
   Description: Returns If SendToFSA has change from false to true.
   OperationID: GetSendToFSAChange
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetSendToFSAChange_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSendToFSAChange_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSendToFSAChange(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetSendToFSAChange", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method RequestNoRevWithExternalMESForSiteValidation
   Description: Request No Rev With External MES For Site Validation
   OperationID: RequestNoRevWithExternalMESForSiteValidation
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/RequestNoRevWithExternalMESForSiteValidation_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/RequestNoRevWithExternalMESForSiteValidation_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_RequestNoRevWithExternalMESForSiteValidation(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/RequestNoRevWithExternalMESForSiteValidation", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetExternalCRMIntegrationIsEnabled
   OperationID: GetExternalCRMIntegrationIsEnabled
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetExternalCRMIntegrationIsEnabled_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetExternalCRMIntegrationIsEnabled(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetExternalCRMIntegrationIsEnabled", {
          method: 'post',
          headers: headers,
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ChangeMXProdServCode
   Description: Performs required logic when Part.MXProdServCode is modified.
   OperationID: ChangeMXProdServCode
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/ChangeMXProdServCode_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ChangeMXProdServCode_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ChangeMXProdServCode(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/ChangeMXProdServCode", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDualUomClassList
   Description: Get a list of compatible dual UOM class IDs for the specified UOM class ID
   OperationID: GetDualUomClassList
      :param epicorHeaders: A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      :param requestBody: Desc: Input parameters  => reference#/components/schemas/GetDualUomClassList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDualUomClassList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDualUomClassList(requestBody:any, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.PartSvc/GetDualUomClassList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => res.json())
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
// OData Schemas:
//////////////////////////////////////////////////////////////////////////
export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_EntityGLCRow{
   "odatametadata":string,
   "value":Erp_Tablesets_EntityGLCRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartAuditRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartAuditRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartBinInfoRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartBinInfoRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOORow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartCOORow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartCOPartRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartCOPartRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartDimRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartDimRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartLangDescRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartLangDescRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartListRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartListRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPCRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartPCRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlanningPoolRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartPlanningPoolRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantPlanningAttributeRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartPlantPlanningAttributeRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartPlantRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartPlantRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictSubstRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRestrictSubstRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRestrictionRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRestrictionRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRevAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanAttchRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRevInspPlanAttchRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspPlanRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRevInspPlanRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevInspVendRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRevInspVendRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRevRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRevRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartSubsRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartSubsRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartUOMRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartUOMRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_PartWhseRow{
   "odatametadata":string,
   "value":Erp_Tablesets_PartWhseRow[],
}

export interface Epicor_RESTApi_Help_ODataSetResponse_System_Collections_Generic_List_Erp_Tablesets_TaxExemptRow{
   "odatametadata":string,
   "value":Erp_Tablesets_TaxExemptRow[],
}

export interface Erp_Tablesets_EntityGLCRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   "RelatedToFile":string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   "Key1":string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   "Key2":string,
      /**   3rd component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key3":string,
      /**   4th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key4":string,
      /**   5th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key5":string,
      /**   6th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   "Key6":string,
      /**  Identifier of the GL Control Type.  */  
   "GLControlType":string,
      /**  GL Control Identifier.  */  
   "GLControlCode":string,
      /**  Identifies the entity.  Reference only.  Used for integrity validation when deleting a GLCTEntity record.  */  
   "BusinessEntity":string,
      /**  Global Company identifier.  Used in Multi-Company Journal.  */  
   "ExtCompanyID":string,
      /**  Flag to indicate the account in this record is for an external company.  */  
   "IsExternalCompany":boolean,
      /**  Marks this EntityGLC as global, available to be sent out to other companies.  */  
   "GlobalEntityGLC":boolean,
      /**  Disables this record from receiving global updates.  */  
   "GlobalLock":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  BankAcctID of the related BankAcct record.  */  
   "BankAcctID":string,
   "BankFeeID":string,
      /**  CallCode of the related FSCallCd record.  */  
   "CallCode":string,
   "ChargeCode":string,
      /**  ClassCode of the related FAClass record.  */  
   "ClassCode":string,
      /**  ClassID.  This can be ClassID of PartClass, PRClsDed, or PRClsTax  */  
   "ClassID":string,
      /**  ContractCode of the related FSContCd record.  */  
   "ContractCode":string,
      /**  CurrencyCode of the related Currency record.  */  
   "CurrencyCode":string,
      /**  CustNum of the related Customer record  */  
   "CustNum":number,
      /**  DeductionID of PRClsDed or PRDeduct.  */  
   "DeductionID":string,
      /**  EmpID of the related PREmpMas record.  */  
   "EmpID":string,
      /**  ExpenseCode of PayTLbr, LabExpCd  */  
   "ExpenseCode":string,
      /**  ExtSystemID of ExtCompany table  */  
   "ExtSystemID":string,
      /**  FromPlant value of the related PlntTranDef record.  */  
   "FromPlant":string,
      /**  GroupCode of the related FAGroup record.  */  
   "GroupCode":string,
   "GroupID":string,
   "HeadNum":number,
   "InvoiceNum":string,
      /**  JCDept of the related JCDept record.  */  
   "JCDept":string,
      /**  MiscCode of the related MiscChrg or PurMisc record.  */  
   "MiscCode":string,
      /**  PartNum of the related Part record.  */  
   "PartNum":string,
      /**  PayTypeID of PayType  */  
   "PayTypeID":string,
   "PerConName":string,
      /**  PI Status  */  
   "PIStatus":string,
      /**  Plant of the related PlantConfCtrl record.  */  
   "Plant":string,
      /**  ProdCode of the related ProdGrup record.  */  
   "ProdCode":string,
      /**  ProjectID of the related Project record.  */  
   "ProjectID":string,
      /**  PurchCode of the related GLPurch record.  */  
   "PurchCode":string,
      /**  RateCode of the related GLRate record.  */  
   "RateCode":string,
      /**  ReasonCode of the related Reason record.  */  
   "ReasonCode":string,
      /**  ReasonType of the related Reason record.  */  
   "ReasonType":string,
      /**  SalesCatID of the related SalesCat record.  */  
   "SalesCatID":string,
      /**  Shift value of the related JCShift record.  */  
   "Shift":number,
      /**  TaxCode of the related SalesTax record.  */  
   "TaxCode":string,
      /**  TaxTblID of PRTaxMas or PRClsTax.  */  
   "TaxTblID":string,
      /**  ToPlant value of the related PlntTranDef record.  */  
   "ToPlant":string,
      /**  TransferMethod of ExtCompany table  */  
   "TransferMethod":string,
      /**  Type ID  */  
   "TypeID":string,
      /**  VendorNum of the related Vendor record.  */  
   "VendorNum":number,
      /**  WarehouseCode of the related Warehse record.  */  
   "WarehouseCode":string,
   "ExpenseTypeCode":string,
   "IsFiltered":boolean,
   "OprTypeCode":string,
   "CashDeskID":string,
   "TIN":string,
   "ReclassCodeID":string,
   "BitFlag":number,
   "GLCntrlDescription":string,
   "GLCntrlTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartAttchRow{
   "Company":string,
   "PartNum":string,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartAuditRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The PartNum of the Part master to which this record is related.  */  
   "PartNum":string,
      /**  Revision number which is used to uniquely identify the revision of the part.  */  
   "RevisionNum":string,
      /**  System Date when this change was made.  */  
   "ChangeDate":string,
      /**  System Time (seconds since midnight) of when the changes were made.  */  
   "ChangeTime":number,
      /**  UserID who made the changes.  Not maintainable by the user.  */  
   "ChangedBy":string,
      /**  Used to enter a description of the changes that were made.  */  
   "ChangeDescription":string,
      /**  Alternate Routing method to be used for this revision.  */  
   "AltMethod":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  The identifier of related Process Manufacturing.  */  
   "ProcessMfgID":string,
      /**  Display ChangeTime in HH:MM AM format  */  
   "DspChangeTime":string,
   "BitFlag":number,
   "PartNumTrackDimension":boolean,
   "PartNumTrackLots":boolean,
   "PartNumPartDescription":string,
   "PartNumPricePerCode":string,
   "PartNumTrackSerialNum":boolean,
   "PartNumIUM":string,
   "PartNumSalesUM":string,
   "PartNumSellingFactor":number,
   "RevisionNumRevShortDesc":string,
   "RevisionNumRevDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartBinInfoRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Identifies the Part Number. It must be valid in the Part table.  */  
   "PartNum":string,
      /**  Contains the Warehouse code of where this part exists. This must be valid in the WareHouse table.  */  
   "WarehouseCode":string,
      /**  Identifies the Bin location that contains an Onhand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   "BinNum":string,
      /**  Indicates the desired minimum on-hand quantity.  */  
   "MinimumQty":number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand.  */  
   "MaximumQty":number,
      /**  Safety quantity is a "purchasing cushion" limit.  */  
   "SafetyQty":number,
      /**  Uniquely indentifies the record.  */  
   "KBCode":string,
      /**  Purchase order number  that the detail line item is linked to.  */  
   "KBPONUM":number,
      /**  The line number of the detail record on the purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   "KBPOLine":number,
      /**  Kanban Warehouse  */  
   "KBWarehouseCode":string,
      /**  Identifies the Bin location that contains an Onhand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   "KBBinNum":string,
      /**  Site Identifier. This field cannot be blank.  */  
   "KBPlant":string,
      /**  Holds the Quantity onhand for this Part in the warehouse in the specific bin location.  Whenever this quantity becomes zero the record should be deleted. This quantity needs to added to or subtracted from Manufactured receipts, Purchased receipts, Physical inventories, Inventory issues, Warehouse Transfers, Shipping and Adjustments.  */  
   "OnhandQty":number,
      /**  Indicates the desired minimum on-hand Kanban quantity.  */  
   "KBQty":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   "AttributeSetID":number,
   "KBActionCode":string,
   "KBActionDesc":string,
      /**  Maximum Quantity UOM  */  
   "MaxQtyUOM":string,
      /**  Minimum Quantity UOM  */  
   "MinQtyUOM":string,
      /**  Filled in by BO, not phiscally in database.  */  
   "Plant":string,
   "PlantOwner":string,
      /**  Safety Quantity UOM  */  
   "SafetyQtyUOM":string,
   "BitFlag":number,
   "BinNumDescription":string,
   "BinNumNonNettable":boolean,
   "KBBinNumDescription":string,
   "KBCodeKBDescription":string,
   "KBCodeKBActionCode":string,
   "KBPlantName":string,
   "KBWarehouseCodeDescription":string,
   "WarehouseCodeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartCOORow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  CountryNum for Country of Origin  */  
   "OrigCountry":number,
      /**  Qty percent of this part which is from this country of origin.  */  
   "QtyPerc":number,
      /**  Value percent of this part from this country of origin.  */  
   "ValuePerc":number,
      /**  Is this the primary country of origin for this part  */  
   "Primary":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "CountryDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartCOPartRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The PartNum field identifies the Part and is used as part of the primary key.  */  
   "PartNum":string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   "RevisionNum":string,
      /**  Companion PartNum identifies the Part that is manufactured along with the main part (ex: Right and Left parts)  */  
   "CoPartNum":string,
      /**  Revision number which is used to uniquely identify the revision of the companion part, and is used as part of the primary key  */  
   "CoRevisionNum":string,
      /**   Part Per Operation. Active only for Concurrent process
Jobs. Otherwise set to 1.  */  
   "PartsPerOp":number,
      /**   Defines an integer value which is used to calculate a
ratio for prorating the labor costs to the end part. For example a job produces parts A and B, and you want part B to have cost 2 times that of the cost of Part A.  Part A CostBase would be 1 and B would be 2.  */  
   "LbrCostBase":number,
      /**   Defines an integer value which is used to calculate a
ratio for prorating the material costs to the end part. For example a job produces parts A and B, and you want part B to have cost 2 times that of the cost of Part A.  Part A CostBase would be 1 and B would be 2.  */  
   "MtlCostBase":number,
      /**  Describes the Part.  */  
   "PartDescription":string,
      /**  Defines the Unit of Measure used when part is issued, this is also how it is stocked.  Use the value from XaSyst.UM as a default when creating new part records.  */  
   "IUM":string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   "AltMethod":string,
      /**  If true, MRP will not generate change suggestions for the co-part  */  
   "PreventSugg":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Indicates if the parent Part should be used as the primary costing method for the co-part  */  
   "PrimaryCost":boolean,
      /**  The identifier of related Process Manufacturing.  */  
   "ProcessMfgID":string,
   "EnablePreventSugg":boolean,
   "PartMasterPart":boolean,
   "ProcessMode":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartDimRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The PartNum field identifies the Part.  */  
   "PartNum":string,
      /**  Unique dimension code for the part.  */  
   "DimCode":string,
      /**  Description for the dimension code.  */  
   "DimCodeDescription":string,
      /**  Dimension unit of measure. Cannot be blank. Defaults to part's unit of measure.  */  
   "DUM":string,
      /**   Dimension conversion factor.  This conversion factor is used to convert the qty to the base part unit of measure.
Example: A half sheet to full sheet conversion factor would be 2 and a double sheet to full sheet conversion factor would be 0.5.  */  
   "DimConvFactor":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Default Dimenision for this part.  */  
   "DefaultDim":boolean,
   "BitFlag":number,
   "PartNumTrackLots":boolean,
   "PartNumIUM":string,
   "PartNumSalesUM":string,
   "PartNumSellingFactor":number,
   "PartNumPartDescription":string,
   "PartNumTrackDimension":boolean,
   "PartNumTrackSerialNum":boolean,
   "PartNumPricePerCode":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartLangDescRow{
      /**  Language ID  */  
   "LangNameID":string,
      /**  The PartNum field identifies the Part and is used as the primary key.  */  
   "PartNum":string,
      /**  Description  */  
   "Description":string,
      /**  Company Identifier.  */  
   "Company":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "LangNameIDDescription":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartListRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  An abbreviated part description field by which the user can search the Part file. In Part maintenance the Search Word is to only be updated upon initial creation of the Part with the first 8 bytes of the Part.Description.  */  
   "SearchWord":string,
      /**  Describes the Part.  */  
   "PartDescription":string,
      /**   The Inventory class that this Part belongs to. The Class field can be blank or must be valid in the PartClass master file.
Classes could be set up for different type of raw materials. It will primarily be used as a report selection parameter.  */  
   "ClassID":string,
      /**  Primary Inventory Unit of Measure. The unit costs, are based on this uom. Used as a default for issue transactions for the part.  Part onhand and allocation quantities are tracked by this uom.  The quantities can also be tracked by other uoms (see PartUOM table) but tracking at this uom is mandatory.   Use UOMClass.DefUOMCode of the system default UOMClass  when creating new part records (see XASyst.DefUOMClassID).  */  
   "IUM":string,
      /**  The Purchasing Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Purchase Order entry as the default on line item details.  */  
   "PUM":string,
      /**   Classifies Parts into the following...
M = Manufactured Part.
P = Purchased Part.
K = Sales Kit Part.B = Planning BOM.
This type code does limit referencing any part in any way. For example a type "P" can be entered on a sales order, or a type "M" can be referenced in a Purchase Order.
This field will also be used as a selection parameter in certain reports, such as Time Phase Requirements.  */  
   "TypeCode":string,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   "NonStock":boolean,
      /**  Product Group ID for the Part. This can be blank or must be valid in the ProdGrup file.  This will be used for report sorting and selection. Also as a default in order entry, invoice entry and job entry.  */  
   "ProdCode":string,
      /**   Flag which indicates if the Part Master is considered as "Inactive".
This flag will be used to exclude parts from certain searches and reports.  */  
   "InActive":boolean,
      /**  An internal flag which indicates that this part contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   "Method":boolean,
      /**  Indicates if Lot numbers are prompted for in transactions for this part.  Backflushing and AutoReceiving functions are ignored when TrackLots = Yes.  */  
   "TrackLots":boolean,
      /**   Onhand quantity is always tracked in the Parts primary inventory uom (Part.IUM). Checking this box indicates that you want to allow tracking of onhand quantity by additional uoms.
The actual UOMs to be tracked for the part are indicated by PartUOM.TrackOnHand. In order to set the PartUOM.TrackOhHand = True the Part.TrackDimension must = true.
This replaces the old 8.3 Track Dimension feature  */  
   "TrackDimension":boolean,
      /**  Indicates if this part is serial number tracked  */  
   "TrackSerialNum":boolean,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   "PhantomBOM":boolean,
      /**  Indicates that the part is on hold.  This feature can be used to indicate that a new part is not yet approved, that it is being phased out, has a quality issue, etc.  Further demands/supplies of this part should not be made. Similar to an "Inactive" part. However at the moment it still may have an onhand balance, supply and demands and will be reflected in stock status reporting.  */  
   "OnHold":boolean,
      /**  Indicates a Quantity Bearing part. Works in conjunction with the Non-Stock field to enable the part master parts to be setup for expense items.  Quantity Bearing will be set to Yes by default and only enable to be set to No if the Non-Stock flag is Yes.  */  
   "QtyBearing":boolean,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotBatch":boolean,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotMfgBatch":boolean,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotMfgLot":boolean,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotHeat":boolean,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotFirmware":boolean,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotBeforeDt":boolean,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotMfgDt":boolean,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotCureDt":boolean,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotExpDt":boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttBatch":string,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttMfgBatch":string,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttMfgLot":string,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttHeat":string,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttFirmware":string,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttBeforeDt":string,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttMfgDt":string,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttCureDt":string,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttExpDt":string,
      /**  ID of related Attribute Class.  */  
   "AttrClassID":string,
      /**  Indicates if inventory for this part is tracked at the attribute level. This feature requires the Advanced Unit of Measure license.  */  
   "TrackInventoryAttributes":boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   "DefaultAttributeSetID":number,
      /**  If this Part is TrackInventoryAttributes = true, and the AttrClassID it is associated to has one or more attributes whose DynAttrClassDtl.UsedInPlanning= true.  */  
   "HasMRPPlanningAttribute":boolean,
      /**  Indicates if inventory for this part is tracked by revision number.  */  
   "TrackInventoryByRevision":boolean,
      /**  Optional field that contains the customers revision. Default from the PartRev.RevisionNum field.  */  
   "RevisionNum":string,
   "DynAttrValueSetDescription":string,
   "DynAttrValueSetShortDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartPCRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**   Identifies the type of product code. This value can be used to find a Product code for a specific PartNum/ Type/UOM combination.
Currentlt the following types are valid;
"UPC-12,EAN-13,EAN-14,EAN-8,GTIN-14" 
This is for reference only and performs not other function.  */  
   "PCType":string,
      /**  Product Group code  */  
   "ProdCode":string,
      /**  Unit of Measure code that will be defaulted in when this Product Code is used. Must be a Unit of measure that is valid within the Parts UOMClass.  */  
   "UOMCode":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartPlanningPoolRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Part Number.  */  
   "PartNum":string,
      /**  Pool Part Number.  */  
   "PoolPartNum":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "BitFlag":number,
   "PartNumTrackLots":boolean,
   "PartNumTrackSerialNum":boolean,
   "PartNumTrackDimension":boolean,
   "PartNumSalesUM":string,
   "PartNumPartDescription":string,
   "PartNumIUM":string,
   "PartNumTrackInventoryAttributes":boolean,
   "PartNumPricePerCode":string,
   "PartNumSellingFactor":number,
   "PartNumAttrClassID":string,
   "PoolPartNumPartDescription":string,
   "PoolPartNumAttrClassID":string,
   "PoolPartNumTrackDimension":boolean,
   "PoolPartNumTrackLots":boolean,
   "PoolPartNumTrackSerialNum":boolean,
   "PoolPartNumTrackInventoryAttributes":boolean,
   "PoolPartNumSalesUM":string,
   "PoolPartNumIUM":string,
   "PoolPartNumPricePerCode":string,
   "PoolPartNumSellingFactor":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartPlantPlanningAttributeRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The PartNum field identifies the Part and is used in the primary key.  */  
   "PartNum":string,
      /**  Site Identifier. This field cannot be blank  */  
   "Plant":string,
      /**  ID of related Attribute Class.  */  
   "AttrClassID":string,
      /**  The unique identifier of the Dynamic Attribute Planning Set.  */  
   "PlanningAttributeSetSeq":number,
      /**  Hash key of the Company, AttrClassID, Planning Attributes and Planning Attribute Values.  */  
   "PlanningAttributeSetHash":string,
      /**  Indicates the desired minimum on-hand quantity. This is used by the time phase requirements report when user requests to show any parts that will or have fallen below this level. It is also used as a selection parameter for the inventory reorder report. This is an optional field.  */  
   "MinimumQty":number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand. This field is used as a selection option by the inventory reorder report to show all parts that are over this limit. This field is optional.  */  
   "MaximumQty":number,
      /**  Safety quantity is a "purchasing cushion" limit. It's the amount you would need to have to cover your requirements until a shipment arrives from the vendor. If your on-hand quantity falls below this limit it means that there is a good chance that you will run out of material before the next shipment arrives. This value is used by the inventory reorder report and the time phase report. It is an optional field.  */  
   "SafetyQty":number,
      /**  Used to establish a suggested Order Qty when purchasing this Part for this Site. This value will be shown on the time phase report.  */  
   "MinOrderQty":number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "LeadTime":number,
      /**  Number of Vendor master that this part is normally purchased from. The Purchase Order Management module uses it.  used in suggested vendor analysis.  */  
   "VendorNum":number,
      /**  Default Vendor purchase point ID.  */  
   "PurPoint":string,
      /**  This is the minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   "MinMfgLotSize":number,
      /**  This is the maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   "MaxMfgLotSize":number,
      /**  This is the manufacturing lot size multiple.  MRP will create jobs in multiples of this field.  Any excess amount will be sent to stock.  Zero is no lot multiple (lot-for-lot).  Example:  Required Quantity = 500, Lot Multiple = 150, Lot Maximum = 450, 2 jobs will be created with production quantities of 450, and 150.  */  
   "MfgLotMultiple":number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "DaysOfSupply":number,
      /**  This is the flag indicating the inventory level we need to bring up to when it falls below re-order point(safety + minimum). Valid values are MAX and MIN.  */  
   "ReOrderLevel":boolean,
      /**  Number of days forward to capture SugPODtl records for transfer as Forecast records.  Only for Intercompany trading partners.  */  
   "ForecastTime":number,
      /**  Default Site that part is transfered from when it is obtained via Site transfer.  */  
   "TransferPlant":string,
      /**  Used to record the normal order lead time for a Part from the transfer Site to this Site. This value is represented in days. It is optional.  */  
   "TransferLeadTime":number,
      /**  Number of days out that the ShortHorizonMinMfgLotSize and ShortHorizonMaxMfgLotSize will be used instead of MinLotSize and MaxLotSize.  */  
   "ShortHorizonDays":number,
      /**  This is the Short Horizon minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   "ShortHorizonMinMfgLotSize":number,
      /**  This is the Short Horizon maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   "ShortHorizonMaxMfgLotSize":number,
      /**  Used to record the short horizon order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "ShortHorizonDaysSupp":number,
      /**  Auto consume available stock when MRP runs and creates a job.  */  
   "AutoConsumeStock":boolean,
      /**  Start the minimum lot quantity for a job when there is enough quantity to do so.  If enough quantity is available for the minimum lot quantity, the job will be split - one job for the quantity that can be started, another job for the remaining quantity.  Used when MRP creates jobs.  */  
   "StartMinLotQty":boolean,
      /**  The lead time to consider for constrained materials when determining if a quantity can be started on a job.  Applicable when StartMinLotQty is true.  */  
   "MinLotLeadTime":number,
      /**  Indicates the minumum quantity that can be started when splitting a job.  Used when the StartMinLotQty option is selected.  */  
   "MinStartQty":number,
      /**  This is the lead time used when generating a new suggestion within the lead time window.  If this field is 0 and the Supplier is determined from the Supplier Price List, the suggestion will use the lead time from the price list.  */  
   "UrgentLeadTime":number,
      /**  This is the minimum qty required when generating a new suggestion within the lead time window.  */  
   "UrgentMinOrdQty":number,
      /**  This is used to calculate the suggestion qty to the nearest multiple when generating a new suggestion within the lead time window.  */  
   "UrgentMultQty":number,
      /**  See UrgentVendorNum  */  
   "UrgentPurPoint":string,
      /**  If this field is not populated then the system will use the standard Supplier from PartPlant, or the last Supplier the part was purchased from, or the Supplier from the first Price list found for the part.  */  
   "UrgentVendorNum":number,
      /**  Indicates the normal source for this part in the Site.  Values are: M = Manufactured, P = Purchased, T = Transferred.  Initial default is base on Part.TypeCode.  */  
   "SourceType":string,
      /**  SysRevID  */  
   "SysRevID":number,
      /**  SysRowID  */  
   "SysRowID":string,
      /**  Number of days before the forecast date in which any sales orders that exist should reduce the forecast quantity.  Ex: Forecast date of 3/31/98, Days before of 10, then any orders that have a date of 3/21/98 to 3/31/98 would reduce forecast.  */  
   "ForecastDaysBefore":number,
      /**  Number of days after the forecast date in which any sales orders that exist should reduce the forecast quantity.  Ex: Forecast date of 3/31/98, Days after of 10, then any orders that have a date of 4/01/98 to 4/10/98 would reduce the forecast.  */  
   "ForecastDaysAfter":number,
      /**  Description of the Planning Attribute Set  */  
   "PlanningAttributeSet":string,
      /**  Base UOM Code from Part Master  */  
   "BaseUOMCode":string,
      /**  Name of Urgent Supplier  */  
   "UrgentVendorName":string,
      /**  ID of Supplier.  */  
   "UrgentVendorVendorID":string,
      /**  Indicates no planning attribute parameters have been entered and will default from PartPlant.  */  
   "UseSite":boolean,
      /**  Number of Pieces for MaximumQty  */  
   "MaximumQtyNofP":number,
      /**  Number of Pieces for MinimumQty  */  
   "MinimumQtyNofP":number,
   "QtyDisplayOption":string,
      /**  Number of Pieces for MaxMfgLotSize  */  
   "MaxMfgLotSizeNofP":number,
      /**  Number of Pieces for MfgLotMultiple  */  
   "MfgLotMultipleNofP":number,
      /**  Number of Pieces for MinMfgLotSize  */  
   "MinMfgLotSizeNofP":number,
      /**  Number of Pieces for MinOrderQty  */  
   "MinOrderQtyNofP":number,
      /**  Number of Pieces for MinStartQty  */  
   "MinStartQtyNofP":number,
      /**  Number of Pieces for SafetyQty  */  
   "SafetyQtyNofP":number,
      /**  Number of Pieces for ShortHorizonMaxMfgLotSize  */  
   "ShortHorizonMaxMfgLotSizeNofP":number,
      /**  Number of Pieces for ShortHorizonMinMfgLotSize  */  
   "ShortHorizonMinMfgLotSizeNofP":number,
      /**  Number of Pieces for UrgentMinOrdQty  */  
   "UrgentMinOrdQtyNofP":number,
      /**  Number of Pieces for UrgentMultQty  */  
   "UrgentMultQtyNofP":number,
      /**  If true, then the planning set is not valid for the part.  */  
   "InvalidPlanningSet":boolean,
      /**  The reason why the planning set is invalid.  */  
   "InvalidPlanningSetReason":string,
   "BitFlag":number,
   "AttrClassIDDescription":string,
   "PartAttrClassID":string,
   "PartPartDescription":string,
   "PartTrackSerialNum":boolean,
   "PartIUM":string,
   "PartTrackLots":boolean,
   "PartPricePerCode":string,
   "PartTrackDimension":boolean,
   "PartSellingFactor":number,
   "PartSalesUM":string,
   "PartTrackInventoryAttributes":boolean,
   "PlanningAttributeSetSeqActive":boolean,
   "PlantName":string,
   "TransferPlantName":string,
   "VendorNumName":string,
   "VendorNumVendorID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartPlantRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Site Identifier. This field cannot be blank.  */  
   "Plant":string,
      /**  The PartNum field identifies the Part and is used in the primary key.  */  
   "PartNum":string,
      /**  Defines which warehouse is to be used as the Primary Warehouse for this part in this Site. A primary warehouse is the one that this part is most commonly found in.  This warehouse is used as the default in many programs, such as entry of sales order line  */  
   "PrimWhse":string,
      /**  Indicates the desired minimum on-hand quantity. This is used by the time phase requirements report when user requests to show any parts that will or have fallen below this level. It is also used as a selection parameter for the inventory reorder report. This is an optional field.  */  
   "MinimumQty":number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand. This field is used as a selection option by the inventory reorder report to show all parts that are over this limit. This field is optional.  */  
   "MaximumQty":number,
      /**   Safety quantity is a "purchasing cushion" limit. It's the amount you would need to have to cover your requirements until a shipment arrives from the vendor. If your on-hand quantity falls below this limit it means that there is a good chance that you will run out of material before the next shipment arrives. This value is used by the inventory reorder report and the time phase report. It is an optional field.
Note: Safety + Minimum = Reorder Point...  using this formula the  reorder point is the amount at which to reorder to maintain at least the prescribed minimum quantity.  */  
   "SafetyQty":number,
      /**  Used to establish a suggested Order Qty when purchasing this Part for this Site. This value will be shown on the time phase report.  */  
   "MinOrderQty":number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "LeadTime":number,
      /**  Number of Vendor master that this part is normally purchased from. The Purchase Order Management module uses it.  used in suggested vendor analysis.  */  
   "VendorNum":number,
      /**  Default Vendor purchase point ID.  */  
   "PurPoint":string,
      /**  Indicates if this part should be backflushed for this Site. Backflushing is the process of automatically issuing the material to jobs based on the operation quantity completed.  When completed and scrap quantities are reported to a job operation (via labo  */  
   "BackFlush":boolean,
      /**  This is the lot size that is used when performing a BOM cost rollup to distribute setup costs.  */  
   "MfgLotSize":number,
      /**  This is the minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   "MinMfgLotSize":number,
      /**  This is the maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   "MaxMfgLotSize":number,
      /**  This is the manufacturing lot size multiple.  MRP will create jobs in multiples of this field.  Any excess amount will be sent to stock.  Zero is no lot multiple (lot-for-lot).  Example:  Required Quantity = 500, Lot Multiple = 150, Lot Maximum = 450, 2 jobs will be created with production quantities of 450, and 150.  */  
   "MfgLotMultiple":number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "DaysOfSupply":number,
      /**  This is the flag indicating the inventory level we need to bring up to when it falls below re-order point(safety + minimum). Valid values are MAX and MIN.  */  
   "ReOrderLevel":boolean,
      /**  System maintained field.  Indicates that MRP needs to be recalculated for this part/Site.  */  
   "MRPRecalcNeeded":boolean,
      /**  Flag indicating if MRP should process this part.  */  
   "ProcessMRP":boolean,
      /**  Flag indicating if PO suggestion should be generated for this part.  */  
   "GenerateSugg":boolean,
      /**  This flag controls if a supply is always created in this Site for a part. If it is no then the default Site that provides a supply is from a part's product group unless the Site from product group is blank, in that case the default Site should be from the  */  
   "GetFromLocalWhse":boolean,
      /**  Number of days forward to capture SugPODtl records for transfer as Forecast records.  Only for Intercompany trading partners  */  
   "ForecastTime":number,
      /**  Default Site that part is transfered from when it is obtained via Site transfer.  */  
   "TransferPlant":string,
      /**   Indicates the normal source for this part in the Site.
Values are; K = Sales Kit,M = Manufactured,P = Purchased,T = Transferred.B = Planning BOM. 
Initial default is base on Part.TypeCode.  */  
   "SourceType":string,
      /**  Used to record the normal order lead time for a Part from the transfer Site to this Site. This value is represented in days. It is optional.  */  
   "TransferLeadTime":number,
      /**  Used to determine the start date  */  
   "PrepTime":number,
      /**  Days needed to move part to stock or next job.  Deducted from Due Date.  */  
   "ReceiveTime":number,
      /**  Days out from the current date when dates on jobs, PO, TO cannot be changed  */  
   "PlanTimeFence":number,
      /**  MRP parameter not to reschedule if number of days change below  */  
   "ReschedOutDelta":number,
      /**  Same as ReschedOutDelta but for messages  */  
   "ReschedInDelta":number,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   "NonStock":boolean,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   "PhantomBOM":boolean,
      /**  Identifies the Buyer for the part class. Used as the default in the Automated Purchasing process.  */  
   "BuyerID":string,
      /**   Identifies the Person to be used as the default Production Planner. This person is responsible for handling  the manufacturing suggestions of parts in this Product Group.
Used as the default for "new" manufacturing suggestions and on Job Header. Manufacturing suggestions can be filtered by Planner.
Relates to the Person table.  */  
   "PersonID":string,
      /**  Defines the Costing method to be associated with this Part. Use the XaSyst.CostMethod as a default.  When a unit cost is retrieved from the Part file the programs will use this field to determine which one of the Four sets of cost fields should be used.  A = Use Average L= Use Last S = Use Standard T = Use Avg by lot(not found in XaSyst).  */  
   "CostMethod":string,
      /**  Alternate Routing method to be used for this Part/Site  */  
   "AltMethod":string,
      /**  For Manufactured Parts to determine the Due date of the material  */  
   "KitTime":number,
      /**  Indicates if kit component lines can be added, deleted and modified during Sales Order and Quote entry.  */  
   "KitAllowUpdate":boolean,
      /**  Indicates if the parent kit part must be shipped complete or if kit components can be shipped in varying degrees of completeness.  If this field is set to "No", then KitPricing must be set to "P" .  */  
   "KitShipComplete":boolean,
      /**  Indicates if changes the kit parameters is allowed during Sales Order and Quote entry.  */  
   "KitAllowChangeParms":boolean,
      /**  Indicates if all components are to be backflushed when a kit parent item is shipped.  */  
   "KitBackFlush":boolean,
      /**  Indicates how kits will be priced.  Values are: P = Kit Parent Pricing (The price is obtained from the sales price for the kit parent item), C = Component Pricing (The price is obtained from a rollup of kit component items).  */  
   "KitPricing":string,
      /**  Indicates if kit components are to be printed on packing slips.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  */  
   "KitPrintCompsPS":boolean,
      /**  Indicates if kit components are to be printed on invoices.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  */  
   "KitPrintCompsInv":boolean,
      /**  Number of days out that the ShortHorizonMinMfgLotSize and ShortHorizonMaxMfgLotSize will be used instead of MinLotSize and MaxLotSize.  */  
   "ShortHorizonDays":number,
      /**  This is the Short Horizon minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   "ShortHorizonMinMfgLotSize":number,
      /**  This is the Short Horizon maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   "ShortHorizonMaxMfgLotSize":number,
      /**  If set = true and the production yield is being recalculated for an assembly or any of its subassemblies, then the recalculation and quantity adjustments will stop at the assembly level and reduce the overrun quantity and if necessary adjust the PullQty rather than rolling up to its parent  */  
   "LimitProdYldRecalc":boolean,
      /**  Sets the default for Part.QtyBearing. The Part.QtyBearing fields works in conjunction with the Part.Non-Stock field to enable the part master parts to be setup for expense items.  */  
   "QtyBearing":boolean,
      /**  System date on which the last MRP processing was run.  */  
   "MRPLastRunDate":string,
      /**  System Time (hr-min-sec) when the last MRP process was run.  */  
   "MRPLastRunTime":number,
      /**  Scheduled Date used in last MRP run  */  
   "MRPLastScheduledDate":string,
      /**  Cut Off Date used in last MRP run  */  
   "MRPLastCutOffDate":string,
      /**  Used to record the short horizon order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "ShortHorizonDaysSupp":number,
      /**  If the SNBaseDataType is Mask this is the Serial Mask ID assigned for format validation/generation.  */  
   "SNMask":string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   "SNMaskExample":string,
      /**   Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer, Mask
Code/desc required:
CHARACTER`Alphanumeric
INTEGER`NumericOnly
MASK`Serial Mask
This field should be flagged as Include = true in Object Designer.  */  
   "SNBaseDataType":string,
      /**   Current setting for Format of the Base serial number that will be used as new serial numbers are generated. Expressed in progress syntax. Ex: X(30), 99999999 for Character or Integer, or as a Serial Mask defined in SerialMask table.
This field should be flagged as ReadOnly and Include = true in Object Designer.  */  
   "SNFormat":string,
      /**   Current setting for the prefix that will be attached to all new Serial Numbers as they are generated for Character and Integer format types.
This field should be flagged as Include = true in Object Designer.  */  
   "SNPrefix":string,
      /**  A standard suffix that will be attached to all serial numbers generated for the PartSite currently used only by SNBaseStructure Mask types  */  
   "SNMaskSuffix":string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types  */  
   "SNMaskPrefix":string,
      /**  This is the last used serial sequence. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It can be altered by the user and several PartSites can have the same counter values defined, but  */  
   "SNLastUsedSeq":string,
      /**  Indicates to use the value in SerialMask.SNLastUsedSeq when generating the next serial number for a Generate Mask type.  */  
   "UseMaskSeq":boolean,
      /**  This flag identifies those parts that will suggest a PO each time than a sales order is created. This flag will be used as a default in the sales order.  */  
   "BuyToOrder":boolean,
      /**  This flag identifies those parts that are commonly drop shipped. This flag will be used as a default in the sales order.  */  
   "DropShip":boolean,
      /**  Percent Tolerance. Entered as a positive number, Used to define the default percent tolerance for parts for which no percent tolerance is set up in PartWhse. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a percentage difference between the count quantity and the frozen quantity by more than the percent tolerance figure is considered out of tolerance. Calculated as ?adjustment qty / frozen qty? expressed as a percent.  */  
   "PcntTolerance":number,
      /**  False = there is no percent tolerance consideration and any percent variance is considered within tolerance. True = percent tolerance is active for this part/Site and the value in PcntTolerance will be used to determine if the count variance is within tol  */  
   "CalcPcnt":boolean,
      /**  False = there is no quantity tolerance consideration and any quantity variance is considered within tolerance. True = quantity tolerance is active for this part/Site and the value in QtyTolerance will be used to determine if the count variance is within t  */  
   "CalcQty":boolean,
      /**  False = there is no value tolerance consideration and any value variance is considered within tolerance. True = value tolerance is active for this part/Site and the value in ValueTolerance will be used to determine if the count variance is within toleranc  */  
   "CalcValue":boolean,
      /**  Used to provide a means to control whether a count quantity discrepancy should be posted as an adjustment to inventory. This value is used for parts for which no qty adj tolerance is set up in PartWhse. Zero indicates all quantity adjustments will be posted. This parameter is used to control the count discrepancy of parts that are counted by weight on a scale. Counts often vary based upon humidity. If the count of the part is within this tolerance but different from the frozen quantity then no inventory adjustment will be posted.  */  
   "QtyAdjTolerance":number,
      /**  Quantity tolerance. Entered as a positive whole number, Used to define the default quantity tolerance for parts for which no quantity tolerance is set up in PartWhse. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a count quantity that varies from the frozen quantity by more than the quantity tolerance figure is considered out of tolerance.  */  
   "QtyTolerance":number,
      /**  Value tolerance. Entered as a positive number. Used to define the default value tolerance for parts for which no value tolerance is set up in PartWhse, PartSite, WarehseABC or SiteConfABC  An entry of zero will indicate that any value variance will be con  */  
   "ValueTolerance":number,
      /**  This is a summary of the total outstanding manufacturing allocation requirements for this Part in this Site.  It is updated from Order Release records that are being manufactured. The outstanding  Sales Order Requirements is calculated from Open ORderRel  */  
   "DemandQty":number,
      /**  This is a summary of the total outstanding manufacturing requirements for this Part in this Site.  It is updated from Order Release records that are being manufactured. The outstanding  Sales Order Requirements is calculated from Open ORderRel records as  */  
   "ReservedQty":number,
      /**  This is a summary of the total outstanding job allocation requirements for this Part in this Site.  */  
   "AllocatedQty":number,
      /**  Cross Reference Part Number  */  
   "XRefPartNum":string,
      /**  Cross Reference Part Type  */  
   "XRefPartType":string,
      /**  System flag future use  */  
   "NeverReuseMRPJob":boolean,
      /**  Flag indicates the need to delete unfirm Jobs even if MRP is run with the recycle job option  */  
   "DeleteMRPJobs":boolean,
      /**  System calculated manufacturing lead time.  This is the total lead time needed to generate the part, which includes the time on lower level parts, lead times, etc.  Not editable by the user.  */  
   "TotMfgLeadTimeSys":number,
      /**  Manually entered manufacturing lead time.  This is the total lead time needed to generate the part.  Directly maintained by the user.  */  
   "TotMfgLeadTimeMnl":number,
      /**  Displays the manufacturing lead time calculated by the system. This is the lead time required to manufacture the part at the level of this part, it includes the time to manufacture the subassemblies in the same job (Pull as Assembly materials). The user cannot edit this value.  */  
   "LvlMfgLeadTimeSys":number,
      /**  Displays the manufacturing lead time calculated by the system. This is the lead time required to manufacture the part at the level of this part, it includes the time to manufacture the subassemblies in the same job (Pull as Assembly materials). Directly maintained by the user.  */  
   "LvlMfgLeadTimeMnl":number,
      /**  The date the system manufacturing lead times (TotMfglLeadTimeSys and LvlMfgLeadTimeSys) were calculated.  */  
   "MfgLeadTimeCalcDate":string,
      /**  The date the manual manufacturing lead times (TotMfgLeadTimeSys and LvlMfgLeadTimeSys) were entered by the user.  */  
   "MfgLeadTimeMnlDate":string,
      /**  Auto consume available stock when MRP runs and creates a job.  */  
   "AutoConsumeStock":boolean,
      /**  Start the minimum lot quantity for a job when there is enough quantity to do so.  If enough quantity is available for the minimum lot quantity, the job will be split - one job for the quantity that can be started, another job for the remaining quantity.  Used when MRP creates jobs.  */  
   "StartMinLotQty":boolean,
      /**  The lead time to consider for constrained materials when determining if a quantity can be started on a job.  Applicable when StartMinLotQty is true.  */  
   "MinLotLeadTime":number,
      /**  Indicates manufacturing lead times are entered manually by the user.  */  
   "MfgLeadTimeMnl":boolean,
      /**  Userid of user who entered manual manufacturing lead times.  */  
   "MfgLeadTimeEnteredBy":string,
      /**  Indicates the minumum quantity that can be started when splitting a job.  Used when the StartMinLotQty option is selected.  */  
   "MinStartQty":number,
      /**  Raw Material  */  
   "RawMaterial":boolean,
      /**  Available for stock manufactured parts.  Indicates if capable to promise considers sub-assemblies when determining the capable to promise date.  When false, capable to promise only looks at ATP for the capable to promise part - subassemblies are not considered.  */  
   "MultiLevelCTP":boolean,
      /**  Indicates if  Inspection is required for items received from this vendor.  Inspection will also be enforced if the related PartClass, Vendor, Podetail, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   "RcvInspectionReq":boolean,
      /**  Indicates if MRP should allow consumption of safety stock within the purchase lead time  */  
   "ConsumeSafety":boolean,
      /**  Number of Alternate Vendor master that this part can be purchased from with short lead times. The Purchase Order will be generated for this supplier when suggestions fall within the purchasing lead time and the projected supply drops below safely.  */  
   "SLTVendorNum":number,
      /**  Default Vendor purchase point ID.  */  
   "SLTPurPoint":string,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "ShortLeadTime":number,
      /**  Indicates the record is used with Machine MES  */  
   "ExternalMES":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  This is the lead time used when generating a new suggestion within the lead time window.  If this field is 0 and the Supplier is determined from the Supplier Price List, the suggestion will use the lead time from the price list.  */  
   "UrgentLeadTime":number,
      /**  This is the minimum qty required when generating a new suggestion within the lead time window.  */  
   "UrgentMinOrdQty":number,
      /**  This is used to calculate the suggestion qty to the nearest multiple when generating a new suggestion within the lead time window.  */  
   "UrgentMultQty":number,
      /**  See UrgentVendorNum  */  
   "UrgentPurPoint":string,
      /**  If this field is not populated then the system will use the standard Supplier from PartPlant, or the last Supplier the part was purchased from, or the Supplier from the first Price list found for the part.  */  
   "UrgentVendorNum":number,
      /**  PartRunMRP  */  
   "PartRunMRP":boolean,
      /**  LinkToContract  */  
   "LinkToContract":boolean,
      /**  Indicates if this part will be excluded in the Inventory Min/Max/Safety calculation.  */  
   "MMSExclude":boolean,
      /**  Indicates if sales history for this part will be included in the Inventory Min/Max/Safety calculation.  */  
   "MMSSales":boolean,
      /**  Indicates if job materials history for this part will be included in the Inventory Min/Max/Safety calculation.  */  
   "MMSIssue":boolean,
      /**  User defined number in days, of how far back to look in usage history.  */  
   "MMSHistory":number,
      /**  User defined, percentage of MIN to be set as Safety stock value.  */  
   "MMSSafetyFactor":number,
      /**  User defined, used in calculation to defined MAX stock value.  */  
   "MMSMaxFactor":number,
      /**  WIll hold the proposed Min when the Min/Max/Safety process is ran  */  
   "SavedMinimumQty":number,
      /**  WIll hold the proposed Max when the Min/Max/Safety process is ran  */  
   "SavedMaximumQty":number,
      /**  WIll hold the proposed Safety when the Min/Max/Safety process is ran  */  
   "SavedSafetyQty":number,
      /**  It will hold the last TotalUsage used for the Saved Min/Max/Safety  */  
   "SavedCalculatedUsageQty":number,
      /**  Last Date when the Saved Min/Max/Safety were updated  */  
   "SavedOnDateTime":string,
      /**  Auto consume window percentage, this is a percentage to calculate the auto consume window days  that scheduling engine will take in consideration to look for available quantity to consume.  */  
   "ACWPercentage":number,
      /**  Auto consume window days, this is the number of days that scheduling engine will take in consideration to look for available quantity to consume.  */  
   "ACWDays":number,
      /**  GenNewPCIDDelaySeconds  */  
   "GenNewPCIDDelaySeconds":number,
      /**  GenNewPCIDLimitDays  */  
   "GenNewPCIDLimitDays":number,
      /**  System calculated manufacturing lead time.  This is the lead time needed to generate the part at the level of this part only.  Does not include the time on lower level parts.  Not editable by the user.  */  
   "TopLvlMfgLeadTimeSys":number,
      /**  Manually entered manufacturing lead time.  This is the lead time needed to generate the part at the level of this part only. Does not include the time on lower level parts. Directly maintained by the user.  */  
   "TopLvlMfgLeadTimeMnl":number,
      /**  Actual Costing Category ID  */  
   "ActualCostingCategoryID":string,
      /**  Included Into Allocation Base  */  
   "IncludedIntoAllocationBase":boolean,
      /**  Number of days before the forecast date in which any sales orders that exist should reduce the forecast quantity. Ex: Forecast date of 3/31/98, Days before of 10, then any orders that have a date of 3/21/98 to 3/31/98 would reduce forecast.  */  
   "ForecastDaysBefore":number,
      /**  Number of days after the forecast date in which any sales orders that exist should reduce the forecast quantity. Ex: Forecast date of 3/31/98, Days after of 10, then any orders that have a date of 4/01/98 to 4/10/98 would reduce the forecast.  */  
   "ForecastDaysAfter":number,
      /**  RcvInspectionReqPart  */  
   "RcvInspectionReqPart":string,
      /**  Base UOM Code from Part Master  */  
   "BaseUOMCode":string,
      /**  Used to calculate the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   "CalculatedLeadTime":number,
   "ExtLeadTime":number,
      /**  Used to designate the number of digits for an Integer or Mask type serial number format.  */  
   "SNNumODigits":number,
   "UrgentVendorName":string,
   "UrgentVendorVendorID":string,
   "DisableQtyBrng":boolean,
      /**  Used to indicate if the Serial Number format button should be enabled.  */  
   "EnableSerialNum":boolean,
   "ICTrader":boolean,
   "InActive":boolean,
      /**  A summary of PartBin.OnHandQty for the warehouses where the bin is a nettable bin (WhseBin.NonNettable = NO).  */  
   "OnHandQty":number,
   "PlantConfCtrlSerialTracking":number,
      /**  Used to designate the number of leading zeros for an Integer or Mask type serial number format.  */  
   "SNLeadingZeros":boolean,
      /**  Indicates if there is any quantity on hand for this part  */  
   "HasOnHandQty":boolean,
   "IsActCostingAllocEnabled":boolean,
      /**  Number of Pieces for MaximumQty  */  
   "MaximumQtyNofP":number,
      /**  Number of Pieces for MaxMfgLotSize  */  
   "MaxMfgLotSizeNofP":number,
      /**  Number of Pieces for MfgLotMultiple  */  
   "MfgLotMultipleNofP":number,
      /**  Number of Pieces for MinimumQty  */  
   "MinimumQtyNofP":number,
      /**  Number of Pieces for MinMfgLotSize  */  
   "MinMfgLotSizeNofP":number,
      /**  Number of Pieces for MinOrderQty  */  
   "MinOrderQtyNofP":number,
      /**  Number of Pieces for MinStartQty  */  
   "MinStartQtyNofP":number,
   "QtyDisplayOption":string,
      /**  Number of Pieces for SafetyQty  */  
   "SafetyQtyNofP":number,
      /**  Number of Pieces for ShortHorizonMaxMfgLotSize  */  
   "ShortHorizonMaxMfgLotSizeNofP":number,
      /**  Number of Pieces for ShortHorizonMinMfgLotSize  */  
   "ShortHorizonMinMfgLotSizeNofP":number,
      /**  Number of Pieces for UrgentMinOrdQty  */  
   "UrgentMinOrdQtyNofP":number,
      /**  Number of Pieces for UrgentMultQty  */  
   "UrgentMultQtyNofP":number,
   "BitFlag":number,
   "BuyerIDName":string,
   "PartTrackInventoryAttributes":boolean,
   "PartAttrClassID":string,
   "PartSellingFactor":number,
   "PartTrackLots":boolean,
   "PartTrackSerialNum":boolean,
   "PartTrackDimension":boolean,
   "PartIUM":string,
   "PartPricePerCode":string,
   "PartPartDescription":string,
   "PartSalesUM":string,
   "PersonName":string,
   "PlantName":string,
   "PrimWhseDescription":string,
   "SerialMaskMaskType":number,
   "SerialMaskDescription":string,
   "TransferPlantName":string,
   "VendorNumAddress1":string,
   "VendorNumState":string,
   "VendorNumCountry":string,
   "VendorNumCity":string,
   "VendorNumCurrencyCode":string,
   "VendorNumDefaultFOB":string,
   "VendorNumAddress2":string,
   "VendorNumZIP":string,
   "VendorNumTermsCode":string,
   "VendorNumAddress3":string,
   "VendorNumName":string,
   "VendorNumVendorID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRestrictSubstRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  Restriction Type identification.  */  
   "RestrictionTypeID":string,
      /**  Substance identification.  */  
   "SubstanceID":string,
      /**  Default weight of the substance per primary part of UOM  */  
   "Weight":number,
      /**  By default the primary UOM of the part.  */  
   "WeightUOM":string,
      /**  When true then weight is disregarded in compliance roll-up.  */  
   "Manual":boolean,
      /**  The date when exempt status for this substance expires.  */  
   "ExemptDate":string,
      /**  Optional. Exemption certificate.  */  
   "ExemptCertificate":string,
      /**  Indicates if the Part Restriction Substance is inactive and the Roll-Up process will not take it in count and it won?t be copied when the part is selected.  */  
   "Inactive":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "Exempt":boolean,
   "BitFlag":number,
   "PartNumIUM":string,
   "PartNumPricePerCode":string,
   "PartNumSellingFactor":number,
   "PartNumPartDescription":string,
   "PartNumSalesUM":string,
   "PartNumTrackLots":boolean,
   "PartNumTrackSerialNum":boolean,
   "PartNumTrackDimension":boolean,
   "RestrictionTypeDescription":string,
   "SubstanceDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRestrictionRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  Restriction Type identification.  */  
   "RestrictionTypeID":string,
      /**  When true then no roll-up will be calculated for this Restriction type. Compliance date is set when this flag is set. D/I Roll-Up radio Button will be disabled.  */  
   "Manual":boolean,
      /**  Enabled when manual flag is unchecked and company configuration flag for allow direct roll-up is enabled. Default to Indirect Roll-Up.  */  
   "RollupType":string,
      /**  Displays one of the compliance statuses: 1. Not applicable (Yellow) (when no substances are selected) 2. Non compliant (Red) (one or more substances are selected but roll-up has not been executed or roll-up has failed) 3. Compliant (Green) (one or more substances are selected and roll-up was successful) 4. Exempt (Yellow) (when all substances are exempt ? verify exempt date)  */  
   "Compliance":string,
      /**  Set when Manual flag is checked or after compliance roll-up is successful. Cleared Manual flag is unchecked or after compliance roll-up is unsuccessful.  */  
   "ComplianceDate":string,
      /**  Set after compliance roll-up  */  
   "LastRollUp":string,
      /**  Indicates if the Part Restriction Type is inactive and the Roll-Up process will not take it in count and it won?t be copied when the part is selected.  */  
   "Inactive":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "Weight":boolean,
      /**  To enable RollUpType when manual flag is unchecked and company configuration flag for allow direct rolling-up is enabled.  */  
   "EnableRollUpType":boolean,
   "BitFlag":number,
   "PartNumTrackLots":boolean,
   "PartNumTrackSerialNum":boolean,
   "PartNumIUM":string,
   "PartNumTrackDimension":boolean,
   "PartNumSellingFactor":number,
   "PartNumPartDescription":string,
   "PartNumPricePerCode":string,
   "PartNumSalesUM":string,
   "RestrictionTypeDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRevAttchRow{
   "Company":string,
   "PartNum":string,
   "RevisionNum":string,
   "AltMethod":string,
   "ProcessMfgID":string,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRevInspPlanAttchRow{
   "Company":string,
   "PartNum":string,
   "RevisionNum":string,
   "AltMethod":string,
   "ProcessMfgID":string,
   "SeqPlan":number,
   "DrawingSeq":number,
   "XFileRefNum":number,
   "SysRevID":number,
   "SysRowID":string,
   "ForeignSysRowID":string,
   "DrawDesc":string,
   "FileName":string,
   "PDMDocID":string,
   "DocTypeID":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRevInspPlanRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   "RevisionNum":string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   "AltMethod":string,
      /**  Part Inspection Plan Sequence  */  
   "SeqPlan":number,
      /**  The inspection plan part number (configurator part number).  */  
   "InspPlanPartNum":string,
      /**  The specification ID.  Must be a valid value defined in the SpecDtl master table.  */  
   "SpecID":string,
      /**  Unique identifier of this Site assigned by the user.  */  
   "Plant":string,
      /**  The default quantity to be inspected.  */  
   "SampleSize":number,
      /**  Percentage of quantity to be inspected  */  
   "SampleSizePct":number,
      /**  This is used to establish the default plan to be used.  Only one record of the same company, Site, part number, and revision combination can have this flag set to true.  */  
   "IsDefault":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  The identifier of related Process Manufacturing.  */  
   "ProcessMfgID":string,
   "SpecHedDescription":string,
   "BitFlag":number,
   "InspPlanDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRevInspVendRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   "RevisionNum":string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   "AltMethod":string,
      /**  Contains the vendor ID for Skip Lot processing  */  
   "VendorID":string,
      /**  Unique identifier of this Site assigned by the user.  */  
   "Plant":string,
      /**  If true, this supplier / purchase point / part combination is to be included in the skip lot process.  */  
   "SkipLotCtl":boolean,
      /**  Skip Lot Control Code.  Must be a valid code defined in the SkipLotCtl master file.  */  
   "SkipLotCtlCode":string,
      /**  Counter of the receipts of this part / supplier combination. It can be maintained here in case the QA personnel want to force further inspections.  */  
   "InspCnt":number,
      /**  Counter of the number of lots that have been skipped within this cycle.  */  
   "SkipCnt":number,
      /**  Counter of the number of cycles that this has been through.  */  
   "RptCycles":number,
      /**  Counter of the number of lots that have been rejected.  */  
   "RejectCnt":number,
      /**   Valid options are S (Skip Lot) or Q (Quantity).
This field will control the value of what is added to the RejectCnt field. If set to S then the RejectCnt will be increased by 1 if the lot being inspected has a rejected quantity.  If set to Q then the field will be increased by the total failed quantity.  */  
   "RejectCntBy":string,
      /**  Default minimum sample size to be inspected.  */  
   "SampleSize":number,
      /**  Percentage of the receipt quantity to be inspected  */  
   "SampleSizePct":number,
      /**  Setting to true will force all receipts to be inspected.  */  
   "ForceInsp":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  The identifier of related Process Manufacturing.  */  
   "ProcessMfgID":string,
   "BitFlag":number,
   "VendorName":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRevRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The PartNum field identifies the Part and is used as part of the primary key.  */  
   "PartNum":string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   "RevisionNum":string,
      /**  Short description of the revision. This is NOT the Part description.  */  
   "RevShortDesc":string,
      /**  Used to enter a full description of the revision.  */  
   "RevDescription":string,
      /**  Indicates if the methods of manufacturing have been approved for this revision.  Only approved methods can be pulled into jobs/quotes.  */  
   "Approved":boolean,
      /**  Date which this revision was approved for use by manufacturing/quoting.  This is set to the system date when the user marks the revision Approved. It is not maintainable by the user.  */  
   "ApprovedDate":string,
      /**  UserID who approved the revision.  Not maintainable by the user.  */  
   "ApprovedBy":string,
      /**  Date at which this revision is considered effective.  This date is used to control the pulling of subassembly revisions.  */  
   "EffectiveDate":string,
      /**  This Level Unit Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   "TLRLaborCost":number,
      /**   This Level Unit Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   "TLRBurdenCost":number,
      /**  This Level Unit Material Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   "TLRMaterialCost":number,
      /**  This Level Unit Subcontract Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   "TLRSubcontractCost":number,
      /**  This Level Unit Material Burden Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   "TLRMtlBurCost":number,
      /**  This Level Setup Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   "TLRSetupLaborCost":number,
      /**   This Level Setup Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   "TLRSetupBurdenCost":number,
      /**  This Level Unit Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   "LLRLaborCost":number,
      /**   This Level Unit Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   "LLRBurdenCost":number,
      /**  This Level Unit Material Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   "LLRMaterialCost":number,
      /**  This Level Unit Subcontract Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   "LLRSubcontractCost":number,
      /**  This Level Unit Material Burden Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   "LLRMtlBurCost":number,
      /**  This Level Setup Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   "LLRSetupLaborCost":number,
      /**   This Level Setup Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   "LLRSetupBurdenCost":number,
      /**  Date that this part cost was last rolled up.  Updated by the BOM Cost Roll up routine.  */  
   "RollupDate":string,
      /**  Engineering Drawing Number. An optional field.  */  
   "DrawNum":string,
      /**  Engineering Change Order Number. An optional field for reference.  */  
   "ECO":string,
      /**  An internal flag which indicates that this part revision contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   "Method":boolean,
      /**   The operation number PartOpr.OprSeq) that is marked to do the Automatic Receipt to inventory.  Note: Zero = no operation is set to perform the auto receive into inventory function.
This field is not directly maintainable. Instead it is set during operation maintenance by having the user mark a check box indicating "Auto Receive" which then updates this field with the operations sequence number.  */  
   "AutoRecOpr":number,
      /**   The sequence of the operation that is to be considered as the operation which indicates the quantity complete for the Job/Assembly.  In other words this operations completed quantity = Job/Assembly completed.   Note: Zero = no operation is set and that the system should use the last operation to determine quantity complete.
This field is not directly maintainable. Instead it is set during operation maintenance by having the user mark a check box indicating "Final Operation" which then updates this field with the operations sequence number.  */  
   "FinalOpr":number,
      /**  Holds the internal object id of pdm parts.  */  
   "PDMObjID":string,
      /**  If true then the revision has a configuration defined for it.  This will be set when a configuration is approved.  */  
   "Configured":boolean,
      /**  If set to TRUE then the revision can be configured in StoreFront.  */  
   "WebConfigured":boolean,
      /**  If TRUE then the input prices will be shown in the Customer Connect Configuration Review.  */  
   "ShowInputPrice":boolean,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   "AltMethod":string,
      /**  The description of the alternate method.  */  
   "AltMethodDesc":string,
      /**  Site Identifier. This field cannot be blank.  */  
   "Plant":string,
      /**  The alternate method of the parent this method inherits from.  */  
   "ParentAltMethod":string,
      /**  Indicates if this revision is to use stage number or operations on materials.  If false, operation sequences are to be used.  If true, staging numbers are to be used.  */  
   "UseStaging":boolean,
      /**  UseAltRevForParts: Flag to indicate if the Use Alternate method for parts option is selected, this flag affects directly the creation and loading of data inside EngWorkbench, because it will control the Alternate Method used.  */  
   "UseAltRevForParts":boolean,
      /**  This field can be used with external system integrations to identify which system currently has ownership of the record.  This field can hold either the name of the external system (example: PDM), ERP (Epicor) or null.  */  
   "OwnershipStatus":string,
      /**  External Configurator  */  
   "ExtConfig":boolean,
      /**  Validate Reference Designators.  */  
   "ValRefDes":boolean,
      /**  Is the part for this revision a global part  */  
   "PcGlobalPart":boolean,
      /**  If a configuration is created for this revision, is it marked as enterprise configurator  */  
   "PcEntprsConf":boolean,
      /**  Marks the Part Revision as a global Revision, available to be sent out to other companies  */  
   "GlobalRev":boolean,
      /**  Rough Cut Code.  Rough cut parameters to use when rough cut scheduling for the revision.  */  
   "RoughCutCode":string,
      /**  The inspection plan part number (configurator part number) to use for RMA processing for this part.  */  
   "RMAInspPlan":string,
      /**  The specification ID to use for RMA processing for this part.  */  
   "RMASpecID":string,
      /**  The default sample size to use for RMA processing for this part  */  
   "RMASampleSize":number,
      /**  Percentage of quantity to be inspected for RMA processing of this part  */  
   "RMASampleSizePct":number,
      /**  The part number used to identify the configured part number that this part revision was created from  */  
   "BasePartNum":string,
      /**  The revision number used to identify the configured part revision this part number was generated from.  */  
   "BaseRevisionNum":string,
      /**  ConfigID  */  
   "ConfigID":string,
      /**  RegenConfig  */  
   "RegenConfig":boolean,
      /**  SIValuesGroupSeq  */  
   "SIValuesGroupSeq":number,
      /**  SIValuesHeadNum  */  
   "SIValuesHeadNum":number,
      /**  Indicates the record is used with Machine MES  */  
   "ExternalMES":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Indicates the way in which parts are made for Co-Part jobs.  There are two value S  Sequential and C  Concurrent.  Sequential is the default. This field is similar to the JobHead.ProcessMode field.  */  
   "ProcessMode":string,
      /**  DefaultConfigPart  */  
   "DefaultConfigPart":boolean,
      /**  Number of COPart required in the Revision  */  
   "CoPartsReqQty":number,
      /**  Material Cost Factor  */  
   "MtlCostPct":number,
      /**  Labor Cost Factor  */  
   "LaborCostPct":number,
      /**  Number of COParts per Operation  */  
   "CoPartsPerOp":number,
      /**  CreatedBy  */  
   "CreatedBy":string,
      /**  CreatedOn  */  
   "CreatedOn":string,
      /**  ChangedBy  */  
   "ChangedBy":string,
      /**  ChangedOn  */  
   "ChangedOn":string,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   "ExternalMESSyncRequired":boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   "ExternalMESLastSync":string,
      /**  Customs BOM  */  
   "CNCustomsBOM":boolean,
      /**  The identifier of related Process Manufacturing.  */  
   "ProcessMfgID":string,
      /**  Type of Process Manufacturing this revision is for: General, Site, Master.  */  
   "ProcessMfgType":string,
      /**  Description of Process Manufacturing revision.  */  
   "ProcessMfgDescription":string,
      /**  Indicates if this revision is to use Advanced Staging.  */  
   "UseAdvancedStaging":boolean,
      /**  The last Group to modify this Revision for Recipe Authoring.  */  
   "ProcessMfgLastGroupID":string,
      /**  Only Part Revisions marked as Connected Process Control (CPC) enable will be send to CPC.  */  
   "ECPCEnabled":boolean,
   "DisableApproved":boolean,
      /**  Name of ECO Group that this part is checked out to  */  
   "ECOGroup":string,
      /**  This field will be set to true if two or more ECOCoParts records exist for the revision.  */  
   "HasCoParts":boolean,
   "ParentAltMethodDesc":string,
      /**  Part Number of the Parent Part  */  
   "ParentPartNum":string,
      /**  Revision number  of Parent Part.  */  
   "ParentRevisionNum":string,
   "ProdCode":string,
      /**   Revision Status used to determina in the Revision of all the Materials are Effective As Of Date
Used to indicate the MAX MtlRevisionStatus of all its Materials/SubAssemblies.
If <= 2 the all its materials/subAssemblies's Revisions are Effective As Of Date  */  
   "RevStatusAsOfDate":number,
   "SpecHedDescription":string,
      /**  Last date that this Revison is effective.  (Next Rev Effective date - 1)  */  
   "vDate":string,
   "vQty":number,
   "Class":string,
   "NonStock":boolean,
      /**  Indicates that the PartRev is the root node in the tree  */  
   "IsRootNode":boolean,
      /**  Holds the ECORev Approved flag for the last ProcessMfgID specified against the PartRev  */  
   "EngineeringApproved":boolean,
   "BitFlag":number,
   "InspPlanDescription":string,
   "PartDescriptionTrackDimension":boolean,
   "PartDescriptionSellingFactor":number,
   "PartDescriptionPartDescription":string,
   "PartDescriptionIUM":string,
   "PartDescriptionTrackLots":boolean,
   "PartDescriptionPricePerCode":string,
   "PartDescriptionSalesUM":string,
   "PartDescriptionTrackSerialNum":boolean,
   "PartDescriptionTypeCode":string,
   "PcStatusConfigType":string,
   "PlantName":string,
   "RoughCutParamDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  An abbreviated part description field by which the user can search the Part file. In Part maintenance the Search Word is to only be updated upon initial creation of the Part with the first 8 bytes of the Part.Description.  */  
   "SearchWord":string,
      /**  Describes the Part.  */  
   "PartDescription":string,
      /**   The Inventory class that this Part belongs to. The Class field can be blank or must be valid in the PartClass master file.
Classes could be set up for different type of raw materials. It will primarily be used as a report selection parameter.  */  
   "ClassID":string,
      /**  Primary Inventory Unit of Measure. The unit costs, are based on this uom. Used as a default for issue transactions for the part.  Part onhand and allocation quantities are tracked by this uom.  The quantities can also be tracked by other uoms (see PartUOM table) but tracking at this uom is mandatory.   Use UOMClass.DefUOMCode of the system default UOMClass  when creating new part records (see XASyst.DefUOMClassID).  */  
   "IUM":string,
      /**  The Purchasing Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Purchase Order entry as the default on line item details.  */  
   "PUM":string,
      /**   Classifies Parts into the following...
M = Manufactured Part.
P = Purchased Part.
K = Sales Kit Part.B = Planning BOM.
This type code does limit referencing any part in any way. For example a type "P" can be entered on a sales order, or a type "M" can be referenced in a Purchase Order.
This field will also be used as a selection parameter in certain reports, such as Time Phase Requirements.  */  
   "TypeCode":string,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   "NonStock":boolean,
      /**   This value is used to convert quantity when there is a difference in the vendors unit of measure and how it is stocked in inventory. Example is purchased in pounds, stocked in sheets.


Formula: Issue Qty * Conversion Factor = Purchased Qty.  */  
   "PurchasingFactor":number,
      /**  Base Unit Selling Price for the Item. Maintainable only via Part Master Maintenance program. It is used as a default unit price on Sales Order line detail and on Invoice line details that are not referencing a sales order line.  */  
   "UnitPrice":number,
      /**  Indicates the pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Maintainable only via Part Maintenance. The initial default is "E". Used as default PricePerCode in order entry and invoice entry.  */  
   "PricePerCode":string,
      /**  Base Internal Unit Selling Price for the Item.  Maintainable only via Part Master Maintenance program.  If zero, then the external unit price (Part.UnitPrice) is used.  */  
   "InternalUnitPrice":number,
      /**  Indicates the internal pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand.  Maintainable only via Part Maintenance.  The initial default is "E".  */  
   "InternalPricePerCode":string,
      /**  Product Group ID for the Part. This can be blank or must be valid in the ProdGrup file.  This will be used for report sorting and selection. Also as a default in order entry, invoice entry and job entry.  */  
   "ProdCode":string,
      /**  Used to enter comments for manufacturing when this part is referenced on a job. These are copied to JobHead.Comment, JobAsmbl.Comment,JobMtl.MfgComment depending on the point of reference. Commens are printed on the routing report.  */  
   "MfgComment":string,
      /**   Part Comments that will be used as a default for purchasing. These will be copied into the JobMtl.PurComment which then will be used to pass along to the PO when that JobMtl is referenced. It will also be copied into the PODetail.Comment field when the PO is buying the part for stock and not referencing a Job. View as an EDITOR widget.
To be view-as EDITOR widget.  */  
   "PurComment":string,
      /**  Defines the Costing method to be associated with this Part. Use the XaSyst.CostMethod as a default.  When a unit cost is retrieved from the Part file the programs will use this field to determine which one of the Four sets of cost fields should be used.  A = Use Average L= Use Last S = Use Standard T = Use Avg by lot(not found in XaSyst).  */  
   "CostMethod":string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar1Label
is non blank.  */  
   "UserChar1":string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar2Label
is non blank.  */  
   "UserChar2":string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar3Label
is non blank.  */  
   "UserChar3":string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar4Label
is non blank.  */  
   "UserChar4":string,
      /**   User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate1Label
is non blank.  */  
   "UserDate1":string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate2Label is non blank.  */  
   "UserDate2":string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate3 Label is non blank.  */  
   "UserDate3":string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate4 Label is non blank.  */  
   "UserDate4":string,
      /**   User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec1Label
is non blank.  */  
   "UserDecimal1":number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec2Label is non blank.  */  
   "UserDecimal2":number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec3Label is non blank.  */  
   "UserDecimal3":number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec4Label is non blank.  */  
   "UserDecimal4":number,
      /**  User Defined Integer field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserInt1Label is non blank.  */  
   "UserInteger1":number,
      /**  User Defined Integer field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserInt2Label is non blank.  */  
   "UserInteger2":number,
      /**  Indicates the Tax Category for this Part. Used as a default to Order line items or Invoice line items. Can be left blank which indicates item is taxable. If entered must be valid in the TaxCat master file.  */  
   "TaxCatID":string,
      /**   Flag which indicates if the Part Master is considered as "Inactive".
This flag will be used to exclude parts from certain searches and reports.  */  
   "InActive":boolean,
      /**  Internally assigned integer which indicates the deepest level of assembly indention that this part is used at.  This is used by the Cost Rollup routines to control the order in which parts get costed. Part at the bottom (highest levelcode) Product structure are calculated first and continues up the chain, with the final assembly parts being processed last.  This insures that when retrieving the cost of an assemblies components the components will already have had their cost rolled up.  */  
   "LowLevelCode":number,
      /**  An internal flag which indicates that this part contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   "Method":boolean,
      /**  Indicates if Lot numbers are prompted for in transactions for this part.  Backflushing and AutoReceiving functions are ignored when TrackLots = Yes.  */  
   "TrackLots":boolean,
      /**   Onhand quantity is always tracked in the Parts primary inventory uom (Part.IUM). Checking this box indicates that you want to allow tracking of onhand quantity by additional uoms.
The actual UOMs to be tracked for the part are indicated by PartUOM.TrackOnHand. In order to set the PartUOM.TrackOhHand = True the Part.TrackDimension must = true.
This replaces the old 8.3 Track Dimension feature  */  
   "TrackDimension":boolean,
      /**  Default dimension code for the part.  Set by selecting a PartDim record as default.  */  
   "DefaultDim":string,
      /**  Indicates if this part is serial number tracked  */  
   "TrackSerialNum":boolean,
      /**  Intrastat goods classification code following the Intrastat Classification Nomenclature (ICN). The Commodity Code field can be blank to indicate the value from the part class or must be valid in the ICommCode (formerly called IStatGrp) master file.  */  
   "CommodityCode":string,
      /**  Unique code for the Warranty for this part  */  
   "WarrantyCode":string,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   "PhantomBOM":boolean,
      /**  The Selling Unit of measure for the Part. The UOM which the unit prices are based on. Defaults as the Part.IUM.  */  
   "SalesUM":string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   "SellingFactor":number,
      /**  The material burden rate for this part.  */  
   "MtlBurRate":number,
      /**  The Part's Unit Net Weight.  */  
   "NetWeight":number,
      /**  if Yes then the part effective revision is used. If No then the revision of the demand source is used (OrderDtl, JobMtl...)  */  
   "UsePartRev":boolean,
      /**  Default for label printing.  Zero indicates that only one label should be produced for the entire quantity.  */  
   "PartsPerContainer":number,
      /**  Part's length.  */  
   "PartLength":number,
      /**  Part's width.  */  
   "PartWidth":number,
      /**  Part's Height.  */  
   "PartHeight":number,
      /**  Shelf life of a lot in days.  Zero indicates unlimited shelf life.  */  
   "LotShelfLife":number,
      /**  This is a Web saleable part  */  
   "WebPart":boolean,
      /**  Indicates that the onhand quantity is to be consumed and no further replenishments should be made.  Similar to Obsolete, however only warning messages will be issued to the user if they attempt new references.  */  
   "RunOut":boolean,
      /**  Indicates the default Substitute part number.  This is optional. Must be one of the related PartSub records.  This field is set indirectly when the user checks the default toggle box in Part Substitution dialog.  */  
   "SubPart":string,
      /**  Part's diameter.  */  
   "Diameter":number,
      /**  Part's gravity.  */  
   "Gravity":number,
      /**  Indicates that the part is on hold.  This feature can be used to indicate that a new part is not yet approved, that it is being phased out, has a quality issue, etc.  Further demands/supplies of this part should not be made. Similar to an "Inactive" part. However at the moment it still may have an onhand balance, supply and demands and will be reflected in stock status reporting.  */  
   "OnHold":boolean,
      /**  Date that part becomes obsolete.  This can be set to a future date when the part should become obsolete.  */  
   "OnHoldDate":string,
      /**  The Reason.Code associate with the reason why the part has been placed on hold. Valid only when Part.OnHold = Yes.  */  
   "OnHoldReasonCode":string,
      /**  Default analysis code to be used when this part appears as an assembly  on a quote or a job.  */  
   "AnalysisCode":string,
      /**  Marks the Part as a global Part, available to be sent out to other companies  */  
   "GlobalPart":boolean,
      /**  MtlAnalysisCode  */  
   "MtlAnalysisCode":string,
      /**  Disables this record from receiving global updates  */  
   "GlobalLock":boolean,
      /**  This value is used to calculate the Supplementary Units for the Intrastat.  */  
   "ISSuppUnitsFactor":number,
      /**  Holds the internal object id of pdm parts.  */  
   "PDMObjID":string,
      /**  Path & filename (relative to images/prod_img directory on Web Server) of .jpg product image file.  */  
   "ImageFileName":string,
      /**  This field contains the Intrastat Country of Origin Code from the Country table.  */  
   "ISOrigCountry":string,
      /**  Current setting for the prefix that will be attached to all new Serial Numbers as they are generated.  */  
   "SNPrefix":string,
      /**  Current setting for Format of the Base serial number that will be used as new serial numbers are generated. Expressed in progress syntax. Ex: X(30), 99999999  */  
   "SNFormat":string,
      /**  Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer  */  
   "SNBaseDataType":string,
      /**  Used by the scheduling process when a part is stocked.  When TRUE,  the availability of this Part must be calculated via the TimePhase process prior to scheduling a Job.  */  
   "Constrained":boolean,
      /**  UPS / UCC Code required by some industries.  */  
   "UPCCode1":string,
      /**  UPS / UCC Code required by some industries.  */  
   "UPCCode2":string,
      /**  UPS / UCC Code required by some industries.  */  
   "UPCCode3":string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   "EDICode":string,
      /**  For Customer Connect Only.  This field is used in Store Front to indicate if the part is available in stock.  */  
   "WebInStock":boolean,
      /**  Should this Part be included in Consolidated Purchasing?  */  
   "ConsolidatedPurchasing":boolean,
      /**  Indicates how Purchasing Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   "PurchasingFactorDirection":string,
      /**  Indicates how Selling Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   "SellingFactorDirection":string,
      /**   Receiving Documents Required.
Indicates receiving documents are required when receiving this part.  This pertains only to lot tracked parts that are received to inventory. If checked, then at the time of receiving the system will require that one or more attachments with a reference to a DocType having Receipt = yes be entered.Requires DocManagement license.  */  
   "RecDocReq":boolean,
      /**  Maximum daily production value.  Used in demand shipping schedule.  */  
   "MDPV":number,
      /**   Shipping Documents Required.
Indicates if shipping documents are required when shipping this part. Pertains to Inventory shipments of lot tracked parts or shipments directly from the job only. If checked, then at the time of shipping the system will require that the PartLot.Ship DocsAvail, or JobPart.ShipDocsAvail flag is true before allowing the shipment.Requires DocManagement license.  */  
   "ShipDocReq":boolean,
      /**  The returnable container for this part when the part needs to be returned.  The value is provided by the trading partner.  */  
   "ReturnableContainer":string,
      /**  The Part's Net Volume.  */  
   "NetVolume":number,
      /**  Indicates a Quantity Bearing part. Works in conjunction with the Non-Stock field to enable the part master parts to be setup for expense items.  Quantity Bearing will be set to Yes by default and only enable to be set to No if the Non-Stock flag is Yes.  */  
   "QtyBearing":boolean,
      /**  This field contains the Country of Origin Code from the Country table.  For International shipping.  */  
   "NAFTAOrigCountry":string,
      /**  NAFTA Producer Code - For international shipping  */  
   "NAFTAProd":string,
      /**  NAFTA Preference Code  */  
   "NAFTAPref":string,
      /**  Export License Type  */  
   "ExpLicType":string,
      /**  Export License Number  */  
   "ExpLicNumber":string,
      /**  ECCN Number  */  
   "ECCNNumber":string,
      /**  AES Export code  */  
   "AESExp":string,
      /**  Harmonized Tariff Schedule Code  */  
   "HTS":string,
      /**  Use HTS description flag - for shippers shippers export declaration  */  
   "UseHTSDesc":boolean,
      /**  Schedule B Code  */  
   "SchedBcode":string,
      /**  Hazardous Item  */  
   "HazItem":boolean,
      /**  Hazardous Technical Name  */  
   "HazTechName":string,
      /**  Hazardous Class Number  */  
   "HazClass":string,
      /**  Hazardous Subrisk Class  */  
   "HazSub":string,
      /**  Hazardous Government Assigned ID  */  
   "HazGvrnmtID":string,
      /**  Hazardous Packing instructions  */  
   "HazPackInstr":string,
      /**   Indicates what VAT Reverse Charge method needs to be applied for this Part.  The possible values are:
   "RCT"  -  "Reverse Charge with Threshold";
   "RCN"  -  "Reverse Charge with No Threshold"
Leave this field blank if no Reverse Charge should be applied in the invoice line for this Part.  */  
   "RevChargeMethod":string,
      /**  Reverse Charge Under Threshold value. If the absolute value of an invoice line is less than the under threshold then the reverse charge tax code will be applied.  */  
   "RCUnderThreshold":number,
      /**  Reverse Charge Over Threshold value. If the absolute value of an invoice line is more than the over threshold then the reverse charge tax code will be applied.  */  
   "RCOverThreshold":number,
      /**  This field can be used with external system integrations to identify which system currently has ownership of the record.  This field can hold either the name of the external system (example: PDM), ERP (Epicor) or null.  */  
   "OwnershipStatus":string,
      /**   The UOM Class that will be used for the Part. The UOM Class establishes the list of unit of measures that can be used in reference to this part.
Must be valid in the UOMClass table.  */  
   "UOMClassID":string,
      /**  This is the ID by which the user will reference a particular serial number format mask.  */  
   "SNMask":string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   "SNMaskExample":string,
      /**  A standard suffix that will be attached to all serial numbers currently used only by SNBaseStructure Mask types.  */  
   "SNMaskSuffix":string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types.  */  
   "SNMaskPrefix":string,
      /**  This is the last used serial sequence default. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It will be used when defaulting the SNLastUsedSeq field for new PartSite records.  */  
   "SNLastUsedSeq":string,
      /**  Indicates to use the value in SerialMask.SNLastUsedSeq when generating the next serial number for a Generate Mask type.  */  
   "UseMaskSeq":boolean,
      /**   Qualifies the unit of measure of the NetWeight field.
Must be a UOMConv of the UOMClass with ClassType of "weight".   Use UOMClass.DefUOMCode of the "weight" UOMClass as a default  when creating new part records.
Having a NetWeightUOM will provides the ability to calculate total  weight.  */  
   "NetWeightUOM":string,
      /**   Qualifies the unit of measure of the NewVolume field.
Must be a UOMConv of the UOMClass with ClassType of "volume".   Use UOMClass.DefUOMCode of the "volume" UOMClass as a default  when creating new part records.
Having a Net Volume UOM will provides the ability to calculate total volume  */  
   "NetVolumeUOM":string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotBatch":boolean,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotMfgBatch":boolean,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotMfgLot":boolean,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotHeat":boolean,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotFirmware":boolean,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotBeforeDt":boolean,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotMfgDt":boolean,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotCureDt":boolean,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   "LotExpDt":boolean,
      /**  Defines a prefix to be used when a lot number is generated for the specific part.  */  
   "LotPrefix":string,
      /**  When generating the numeric portion of a lot number it can be either based on a next available number for the part (see Part.LotNextNum) or next available number from a Global Sequence (see LotSeq table and Part.LotSeqID)  */  
   "LotUseGlobalSeq":boolean,
      /**  The LotSeqID of the LotSeq record to use to retreive next available number when the part is using a Global Sequence  (Part.LotUseGlobalSeq = True). Must be valid in the LotSeq table if Part.LotUseGlobalSeq = True)  */  
   "LotSeqID":string,
      /**  The next available number to use to generate new lot numbers a part when the  is configured to use "Part Specific" number sequence. (Part.LotUseGlobalSeq = false).  */  
   "LotNxtNum":number,
      /**  Number of digits of the Next Avail Lot Number controls that will be used by system Generate lot number logic.  */  
   "LotDigits":number,
      /**  If leading zeros should be included in the numeric portion of the system generated lot number.  */  
   "LotLeadingZeros":boolean,
      /**   Option to append a trailing date string to the system generated lot number. The Date is the current system date.
Valid options are: None (Default), DD, MM, YYYY, MMYYYY, MM_YYYY, DDMMYYY, DD-MM-YYY, MMDDYYYY, MM-DD-YYYY,  YYYYMMDD, YYYY-MM-DD  */  
   "LotAppendDate":string,
      /**  This flag identifies those parts that will suggest a PO each time than a sales order is created. This flag will be used as a default in the sales order.  */  
   "BuyToOrder":boolean,
      /**  This flag identifies those parts that are commonly drop shipped. This flag will be used as a default in the sales order.  */  
   "DropShip":boolean,
      /**  Configured Part  */  
   "IsConfigured":boolean,
      /**  External Configurator  */  
   "ExtConfig":boolean,
      /**  The reference category that this Part belongs to.  */  
   "RefCategory":string,
      /**   Malaysia Localization
The flag to indicate that the part is under CJ5 jurisdiction  */  
   "CSFCJ5":boolean,
      /**   Malaysa Localization
The flag to indicate that the part is under LMW jurisdiction  */  
   "CSFLMW":boolean,
      /**  The Part's Unit Gross Weight.  */  
   "GrossWeight":number,
      /**   Qualifies the unit of measure of the GrossWeight field.
Must be a UOMConv of the UOMClass with ClassType of "weight".   Use UOMClass.DefUOMCode of the "weight" UOMClass as a defaul
t  when creating new part records.  */  
   "GrossWeightUOM":string,
      /**  The part number used to identify the configured part number this part number was generated from.  */  
   "BasePartNum":string,
      /**  Class Code Entry Field  */  
   "FSAssetClassCode":string,
      /**  Field Service Sales Unit Price  */  
   "FSSalesUnitPrice":number,
      /**  Indicates the field service sales pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. The initial default is "E".  */  
   "FSPricePerCode":string,
      /**  Indicates if  Inspection is required upon receipt.  Inspection will also be enforced if the related Part Class, Vendor, PO Detail, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   "RcvInspectionReq":boolean,
      /**  EstimateID  */  
   "EstimateID":string,
      /**  EstimateOrPlan  */  
   "EstimateOrPlan":string,
      /**  DiffPrc2PrchUOM  */  
   "DiffPrc2PrchUOM":boolean,
      /**  DupOnJobCrt  */  
   "DupOnJobCrt":boolean,
      /**  PricingFactor  */  
   "PricingFactor":number,
      /**  PricingUOM  */  
   "PricingUOM":string,
      /**  MobilePart  */  
   "MobilePart":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  AGUseGoodMark  */  
   "AGUseGoodMark":boolean,
      /**  AGProductMark  */  
   "AGProductMark":boolean,
      /**  ISRegion  */  
   "ISRegion":string,
      /**  INChapterID  */  
   "INChapterID":string,
      /**  CSF Peru -  SUNAT Type  */  
   "PESUNATType":string,
      /**  PESUNATUOM  */  
   "PESUNATUOM":string,
      /**  DEIsServices  */  
   "DEIsServices":boolean,
      /**  DEIsSecurityFinancialDerivative  */  
   "DEIsSecurityFinancialDerivative":boolean,
      /**  DEInternationalSecuritiesID  */  
   "DEInternationalSecuritiesID":string,
      /**  LinkToContract  */  
   "LinkToContract":boolean,
      /**  DEIsInvestment  */  
   "DEIsInvestment":boolean,
      /**  DEPayStatCode  */  
   "DEPayStatCode":string,
      /**  DEDenomination  */  
   "DEDenomination":string,
      /**  PartLengthWidthHeightUM  */  
   "PartLengthWidthHeightUM":string,
      /**  DiameterUM  */  
   "DiameterUM":string,
      /**  DiameterInside  */  
   "DiameterInside":number,
      /**  DiameterOutside  */  
   "DiameterOutside":number,
      /**  ThicknessUM  */  
   "ThicknessUM":string,
      /**  Thickness  */  
   "Thickness":number,
      /**  ThicknessMax  */  
   "ThicknessMax":number,
      /**  Durometer  */  
   "Durometer":string,
      /**  Specification  */  
   "Specification":string,
      /**  EngineeringAlert  */  
   "EngineeringAlert":string,
      /**  Condition  */  
   "Condition":string,
      /**  IsCompliant  */  
   "IsCompliant":boolean,
      /**  IsRestricted  */  
   "IsRestricted":boolean,
      /**  IsSafetyItem  */  
   "IsSafetyItem":boolean,
      /**  CommercialBrand  */  
   "CommercialBrand":string,
      /**  CommercialSubBrand  */  
   "CommercialSubBrand":string,
      /**  CommercialCategory  */  
   "CommercialCategory":string,
      /**  CommercialSubCategory  */  
   "CommercialSubCategory":string,
      /**  CommercialStyle  */  
   "CommercialStyle":string,
      /**  CommercialSize1  */  
   "CommercialSize1":string,
      /**  CommercialSize2  */  
   "CommercialSize2":string,
      /**  CommercialColor  */  
   "CommercialColor":string,
      /**  IsGiftCard  */  
   "IsGiftCard":boolean,
      /**  PhotoFile  */  
   "PhotoFile":string,
      /**  PartPhotoExists  */  
   "PartPhotoExists":boolean,
      /**  CommentText  */  
   "CommentText":string,
      /**  Indicates if the packaging information is part specific or specified at the UOM class level.  */  
   "PartSpecificPackingUOM":boolean,
      /**  ImageID  */  
   "ImageID":string,
      /**  Specification Code for China GTI purposes  */  
   "CNSpecification":string,
      /**  This field defines if the part  is synchronized to an External CRM.  */  
   "SyncToExternalCRM":boolean,
      /**  This field holds the id of this part in the External CRM  */  
   "ExternalCRMPartID":string,
      /**  This field defines the last time that the  part  has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   "ExternalCRMLastSync":string,
      /**  This fields determines if the part needs to be synchronized to the External CRM. If there are changes in the part master file , Epicor ERP automatically turns on this field.  */  
   "ExternalCRMSyncRequired":boolean,
      /**  PESUNATTypeCode  */  
   "PESUNATTypeCode":string,
      /**  PESUNATUOMCode  */  
   "PESUNATUOMCode":string,
      /**  Code Version for China GTI purposes  */  
   "CNCodeVersion":string,
      /**  Tax Category Code for China GTI purposes  */  
   "CNTaxCategoryCode":string,
      /**  Has Preferential Treatment value for China GTI purposes  */  
   "CNHasPreferentialTreatment":boolean,
      /**  Preferential Treatment Content for China GTI purposes  */  
   "CNPreferentialTreatmentContent":string,
      /**  Zero Tax Rate Mark for China GTI purposes  */  
   "CNZeroTaxRateMark":string,
      /**  SubLevelCode  */  
   "SubLevelCode":number,
      /**  Date the Part was created  */  
   "CreatedBy":string,
      /**  User the Part was created by  */  
   "CreatedOn":string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttBatch":string,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttMfgBatch":string,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttMfgLot":string,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttHeat":string,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttFirmware":string,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttBeforeDt":string,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttMfgDt":string,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttCureDt":string,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttExpDt":string,
      /**  DeferManualEntry  */  
   "DeferManualEntry":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Container Receipt, Receipt Entry.  */  
   "DeferPurchaseReceipt":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Job Receipt to Job, Job Receipt to Salvage, Job Receipt to Inventory, Kanban Receipts.  */  
   "DeferJobReceipt":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Inspection Processing.  */  
   "DeferInspection":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Quantity Adjustment.  */  
   "DeferQtyAdjustment":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Inventory Transfer.  */  
   "DeferInventoryMove":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Customer Shipment Entry, Subcontractor Shipment Entry, Drop Shipment Entry, Order Entry.  */  
   "DeferShipments":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Count Tag Entry.  */  
   "DeferInventoryCounts":boolean,
      /**  DeferAssetDisposal  */  
   "DeferAssetDisposal":boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: RMA Processing.  */  
   "DeferReturnMaterials":boolean,
      /**  MXProdServCode  */  
   "MXProdServCode":string,
      /**  Date/Time when the Part record was updated  */  
   "ChangedOn":string,
      /**  MXCustomsDuty  */  
   "MXCustomsDuty":string,
      /**  Determines if the Part has to be synchronized with Epicor FSA application.  */  
   "SendToFSA":boolean,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   "ExternalMESSyncRequired":boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   "ExternalMESLastSync":string,
      /**  When the part is marked as Item, it will create an Item Resource in Epicor FSA.  */  
   "FSAItem":boolean,
      /**  When the part is marked as Equipment, it will create an Equipment Resource Template in Epicor FSA.  */  
   "FSAEquipment":boolean,
      /**  Bill of Lading Class. Additional data for the part required for LTL and International shipments.  */  
   "BOLClass":string,
      /**  Fair Market Value. Additional data for the part required for LTL and International shipments.  */  
   "FairMarketValue":number,
      /**  SAFTProdCategory  */  
   "SAFTProdCategory":string,
      /**  ID of related Attribute Class.  */  
   "AttrClassID":string,
      /**  Indicates if this part requires Identification Numbers shipment time.  This is disable if Track Location inventory is false.  */  
   "LocationIDNumReq":boolean,
      /**  Indicates if this part tracks Location Inventory.  */  
   "LocationTrackInv":boolean,
      /**  Set the default value of Location View for materials added in Engineering Workbench.  */  
   "LocationMtlView":boolean,
      /**  LCNRVReporting  */  
   "LCNRVReporting":boolean,
      /**  LCNRVEstimatedUnitPrice  */  
   "LCNRVEstimatedUnitPrice":number,
      /**  MXCustomsUMFrom  */  
   "MXCustomsUMFrom":string,
      /**  Default format ID used when assigning ID Numbers.  */  
   "LocationFormatID":string,
      /**  IsServices  */  
   "IsServices":boolean,
      /**  PEDetrGoodServiceCode  */  
   "PEDetrGoodServiceCode":string,
      /**  PEProductServiceCode  */  
   "PEProductServiceCode":string,
      /**  Dual UOM Class ID  */  
   "DualUOMClassID":string,
      /**  Product Name  */  
   "CNProductName":string,
      /**  Weight  */  
   "CNWeight":number,
      /**  Unit of Weight  */  
   "CNWeightUOM":string,
      /**  Bonded  */  
   "CNBonded":boolean,
      /**  Indicates if inventory for this part is tracked at the attribute level. This feature requires the Advanced Unit of Measure license.  */  
   "TrackInventoryAttributes":boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   "DefaultAttributeSetID":number,
      /**  Indicates if entry of a County of Origin is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   "AttISOrigCountry":string,
      /**  ISO / IEC 6523  */  
   "ExternalSchemeID":string,
      /**  Part ID  */  
   "ExternalID":string,
      /**  UNTDID 7143  */  
   "CommoditySchemeID":string,
      /**  Part Commodity Scheme Version  */  
   "CommoditySchemeVersion":string,
      /**  Indicates if inventory for this part is tracked by revision number.  */  
   "TrackInventoryByRevision":boolean,
      /**  Indicates if this part performs MRP by Revision.  Requires Planning by Revision license.  */  
   "PlanningByRevision":boolean,
      /**  RcvInspectionReqPart  */  
   "RcvInspectionReqPart":string,
      /**  FSMSendTo  */  
   "FSMSendTo":boolean,
      /**  FSMPartType  */  
   "FSMPartType":number,
   "CountryNumDescription":string,
      /**  Should the Express Part Check Out option be enabled?  */  
   "EnableExpressCheckOut":boolean,
   "EnableGlobalLock":boolean,
   "EnableGlobalPart":boolean,
      /**  Indicates if the InActive flag should be available for input,  */  
   "EnableInActive":boolean,
      /**  Flag to tell UI whether the Part.IUM field should be enabled or not.  */  
   "EnableIUM":boolean,
      /**  Indicates if Override Reverse Charge check box should be enabled.  */  
   "EnableRevCharge":boolean,
      /**  Indicates if the Serial Number button should be enabled.  */  
   "EnableSerialNum":boolean,
      /**  This field is used only as a flag to determine in UI, if the Part.TrackSerialNum can be change.  */  
   "EnableTrackSerialNum":boolean,
      /**  Flag to tell UI whether the UOMClassID field should be enabled or not.  */  
   "EnableUOMClass":boolean,
   "ExtCoExist":boolean,
      /**  Default installation price of an equipment that requires installation in Epicor FSA.  */  
   "FSAInstallationCost":number,
      /**  Indicates if the equipment requires an installation prior being marked as Installed on a Location in Epicor FSA. If true, at shipment it will create a service order for the installation service in FSA.  */  
   "FSAInstallationRequired":boolean,
      /**  Indicates the service order template ID that Epicor FSA will use to create the installation service order.  */  
   "FSAInstallationType":string,
   "FSAInstTypeDesc":string,
      /**  Indicates if the Part is Global (master or linked)  */  
   "GlbFlag":boolean,
      /**  Delimited list of GlbCompany and GlbPartNum that is linking to this part  */  
   "GlbLink":string,
      /**  check if TrackDimension is in GlbTable and should be disabled in Part Entry  */  
   "GlbTableAllowUpdTrackDim":boolean,
      /**  check if TrackLots is in GlbTable and should be disabled in Part Entry  */  
   "GlbTableAllowUpdTrackLots":boolean,
      /**  check if TrackSerialNum is in GlbTable and should be disabled in Part Entry  */  
   "GlbTableAllowUpdTrackSerial":boolean,
      /**  Indicates if there is any quantity on hand for this part  */  
   "HasOnHandQty":boolean,
      /**  Indicates if part is a component (has a where used list available)  */  
   "IsComponent":boolean,
      /**   This field indicates if the part is being used as a co-part anywhere.  This field will be used to prevent a Part from being marked as serial tracked or configured after being added as a co-part.

CoParts Project.  */  
   "IsCoPart":boolean,
      /**  This is the numeric value of ISOrigCountry.  */  
   "ISOrigCountryNum":number,
      /**  Shows what the next generated lot number for this part would look like  */  
   "NextGeneratedLotNum":string,
   "PEDetrGoodServiceCodeDesc":string,
   "PEProductServiceCodeDesc":string,
   "PLM":boolean,
      /**  Indicates if the PLM toggle box is enabled.  */  
   "PLMEnabled":boolean,
      /**  Revision  */  
   "Revision":boolean,
   "SalesUMDisp":string,
   "SNLeadingZeros":boolean,
   "SNMaskPrefixLength":number,
   "SNMaskSuffixLength":number,
   "SNNumODigits":number,
      /**  Yes means to copy the NonStock and CostMethod from Part to all the PartPlant records.  */  
   "UpdatePartPlant":boolean,
      /**  Indicates whether to update the Part serial number format changes to part plant  */  
   "UpdateSNPartPlant":boolean,
      /**  List of fields which are referenced by COA segments.  */  
   "COASegReferences":string,
      /**  If this Part is TrackInventoryAttributes = true, and the AttrClassID it is associated to has one or more attributes whose DynAttrClassDtl.UsedInPlanning= true.  */  
   "HasMRPPlanningAttribute":boolean,
   "UpdatePartPlantOverride":boolean,
      /**  DEPayStatCode Description  */  
   "DEPayStatCodeDescr":string,
      /**  DEDenomination Description  */  
   "DEDenominationDescr":string,
   "DefaultBuyerName":string,
   "DefaultPlannerName":string,
      /**  This field is used only as a flag to determine in UI, if the Part.TrackInventoryByRevision can be changed.  */  
   "EnableTrackByRevision":boolean,
      /**  indicated if this part has been linked to a global part  */  
   "LinkedToGlbPart":boolean,
      /**  Value is from MXProdCls User Code  */  
   "MXProductClass":string,
      /**  Active Ingredient Name  */  
   "MXActiveIngredientName":string,
      /**  Chemical Name  */  
   "MXChemicalName":string,
      /**  Generic Product Name  */  
   "MXGenericProductName":string,
      /**  Trademark  */  
   "MXTrademark":string,
      /**  Manufacturer Company  */  
   "MXManufacturerCompany":string,
      /**  Expiration Date  */  
   "MXExpirationDate":string,
      /**  Medication Lot  */  
   "MXMedicationLot":string,
      /**  Value is from MXProdForm User Code  */  
   "MXPharmaceuticalForm":string,
      /**  Value is from MXProdKCnd User Code  */  
   "MXKeepCondition":string,
      /**  Sanitary Registration Number  */  
   "MXSanitaryRegistration":string,
      /**  CAS Number  */  
   "MXCASNum":string,
      /**  Import Sanitary Registration Number  */  
   "MXImportSanitaryRegistration":string,
      /**  Manufacturer Data Description  */  
   "MXManufacturerData":string,
      /**  Formulator Data Description  */  
   "MXFormulatorData":string,
      /**  Person Data Description  */  
   "MXPersonData":string,
      /**  Authorized Use Description  */  
   "MXAuthorizedUse":string,
      /**  Value is from MXProdMTyp User Code  */  
   "MXMaterialType":string,
      /**  Description of the Other material Type  */  
   "MXMaterialTypeDescription":string,
   "BitFlag":number,
   "AnalysisCdDescription":string,
   "ClassDescription":string,
   "CommodityCodeSuppUnitsUOM":string,
   "CommodityCodeDescription":string,
   "CompanySendToFSA":boolean,
   "DualUOMClassIDDescription":string,
   "DynAttrValueSetShortDescription":string,
   "DynAttrValueSetDescription":string,
   "FSAssetClassCodeFSAssetClassDesc":string,
   "Mtl_AnalysisCdDescription":string,
   "MXProdServCodeDesc":string,
   "OnHoldReasonCodeDescription":string,
   "ProdCodeDescription":string,
   "RefCategoryDescription":string,
   "SerialMaskMaskType":number,
   "SerialMaskDescription":string,
   "TaxCatIDDescription":string,
   "UOMClassIDDescription":string,
   "WarrantyCodeWarrDescription":string,
   "XbSystELIEinvoice":boolean,
      /**  RowMod  */  
   "RowMod":string,
   "UD_SysRevID":string,
   "SalesCatID_c":string,
   "CustomBuyout_c":boolean,
   "NonSellable_c":boolean,
   "WebSearchable_c":boolean,
}

export interface Erp_Tablesets_PartSubsRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  The Part number that this substitute Part is for.  */  
   "PartNum":string,
      /**  Substitute Part  */  
   "SubPart":string,
      /**  Indicates the record type. "S" = Substitute, "C" = Compliment  */  
   "RecType":string,
      /**  Pertains only to Substitute Parts (RecType = "S"). Values are "C" - Comparable, "D" - Downgrade, "U" - Upgrade  */  
   "SubType":string,
      /**   The quantity of the alternate part per 1 of the parent part in the parents base inventory uom. Cannot be zero.
To convert an existing OrderDtl.SellingQty to a PartSubs. It is converted to the Parents Part Base Inventory UOM  then multiply PartSubs.QtyPer, then converted to  PartSub.SalesUM.  */  
   "QtyPer":number,
      /**  Selling Unit of measure used when this part is used as a substitute/compliment with the parent part (partsubs.partnum).  Defaults as Part.SUM of the PartSub.SubPart.  */  
   "SalesUM":string,
      /**  Optional Comment  */  
   "Comment":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
   "DefaultSub":boolean,
      /**  Price for the Suggested Quantity  */  
   "Price":number,
      /**  Suggested Quantity  */  
   "SuggestedQty":number,
      /**  Selected Row  */  
   "Selected":boolean,
      /**  Suggested Quantity for Order Qty in Quote Detail  */  
   "SugOrderQty":number,
   "BitFlag":number,
   "PartNumPricePerCode":string,
   "PartNumTrackLots":boolean,
   "PartNumPartDescription":string,
   "PartNumSalesUM":string,
   "PartNumIUM":string,
   "PartNumSellingFactor":number,
   "PartNumTrackSerialNum":boolean,
   "PartNumTrackDimension":boolean,
   "SubPartSellingFactor":number,
   "SubPartTrackSerialNum":boolean,
   "SubPartTrackDimension":boolean,
   "SubPartPartDescription":string,
   "SubPartIUM":string,
   "SubPartSalesUM":string,
   "SubPartTrackLots":boolean,
   "SubPartPricePerCode":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartUOMRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  A unique part number that identifies this part.  */  
   "PartNum":string,
      /**  User defined code which uniquely identifies the UOM within the UOMClass.  */  
   "UOMCode":string,
      /**   Value used to convert to/from base uom for the specific part. Cannot change if it's base uom of UOMClass (always 1.0) Sometimes a unit of measure conversion is relative to a specific part. These are non-standard conversions.
For example; 1 box(bx) of  Part A is 12ea. 1(bx) of Part B is 24ea. Non-standard conversions are defined in the PartUOM table. When ConvOperator = * then ConvFactor is 1 UOM expressed in Base UOM else it is 1 Base UOM expressed in UOM  */  
   "ConvFactor":number,
      /**  Indicates if the PartUOM is Active. This field is ready only and is used for internal logic purposes only.  */  
   "Active":boolean,
      /**  If true then Onhand Quantity will be tracked per this UOM for this part.  */  
   "TrackOnHand":boolean,
      /**  The Part's Net Volume.  */  
   "NetVolume":number,
      /**   Qualifies the unit of measure of the NewVolume field.
Must be a UOMConv of the UOMClass with ClassType of "volume".   Use UOMClass.DefUOMCode of the "volume" UOMClass as a default  when creating new part records.
Having a Net Volume UOM will provides the ability to calculate total volume  */  
   "NetVolumeUOM":string,
      /**  This indicates that this Part UOM has been used somewhere.  Therefore we do not want to allow the associated part specific conversion to change.  */  
   "HasBeenUsed":boolean,
      /**   Indicates the mathmatical operator that is used for performing the UOM Conversion. Options are "*" (Multiply) or "\" (Divide).
For example for Feet to Inch where Inch is the base uom. 
You could have 1ft / 12 = 1In  */  
   "ConvOperator":string,
      /**  WebUOM  */  
   "WebUOM":boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Qualifies that 1 of this uom = ConvFactor in ConvToUOM. Example: 12in = 1ft or 1ft = 12in  */  
   "ConvFromUOM":string,
      /**  External field used to enable/disable the conversion factor to able to change it.  */  
   "ConvOverrride":boolean,
      /**  Qualifies UOM of the ConvFactor. This either the UOMClass.BaseUOM or the UOMConv.UOMCode depending on the value of ConvOperator.  */  
   "ConvToUOM":string,
      /**  EAN13 product code from PartPC  */  
   "EAN13":string,
      /**  EAN14 product code from PartPC  */  
   "EAN14":string,
      /**  EAN8 product code from PartPC  */  
   "EAN8":string,
      /**  Internal use. To indicate if the ConvFactor should be enabled. This field is set to true if the related UOMClass is non-standard and the UOMCode is not the BaseUOM  */  
   "EnableConvFactor":boolean,
      /**  Indicates if the TrackOnHand is enabled. True when Part.TrackMultiUOM = true and UOMCode <> Part.IUM  */  
   "EnableTrackOnHand":boolean,
      /**  GTIN14 product code from PartPC  */  
   "GTIN14":string,
      /**  HIBC UPN product code from PartPC  */  
   "HIBC":string,
      /**  Value of UOMConv.PartSpecific for informational purposes  */  
   "PartSpecific":boolean,
   "UOMDesc":string,
      /**  UPC12 product code from PartPC  */  
   "UPC12":string,
      /**  BaseUOMCode from UOMClass file  */  
   "BaseUOMCode":string,
      /**  Used to input/display the package code related to the part/UOM. The user will only be able to update this data if Part.UsePartSpecificPckCode = true  */  
   "DispPkgCode":string,
      /**  Description of the PkgCode  */  
   "DispPkgCodeDesc":string,
      /**  Indicates the display sequence of the packaging in relation to the other packaging for the part.  */  
   "DispPkgDisplaySeq":number,
      /**  Indicates if the PkgCode is the default.  */  
   "DispPkgIsDefault":boolean,
      /**  Indicates if the pkg code information seen in PartUOM is part specific (the data came from PackingUOM where PartNum is not blank.) If true the package code data can be updated in Part Maint, if false the PartUOM pkgcode columns will be disabled.  */  
   "PartSpecificPkgCode":boolean,
      /**  Indicates if the package code will be displayed in the application. If false, the package codes that are not valid for the MGF process on the shop floor are hidden.  */  
   "DispPkgDisplayHidden":boolean,
   "StandardUpdate":boolean,
   "BitFlag":number,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_PartWhseRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**  Part Number  */  
   "PartNum":string,
      /**  Warehouse  */  
   "WarehouseCode":string,
      /**   A summary of the outstanding quantities for order open sales releases that are being filled from stock and of the open job material requirements that are to be issued from stock (JobMtl.Buyit = No) for this Part within a specific warehouse.
The system calculates Available as OnhandQty - AllocatedQty.  */  
   "DemandQty":number,
      /**  A summary of the reserved quantities for order open sales releases for this Part within a specific warehouse. NOTE: This value is the TOTAL of reservations in PartAlloc.  */  
   "ReservedQty":number,
      /**  A summary of the allocated quantities for order open sales releases for this Part within a specific warehouse. NOTE: This value is the TOTAL of allocation in PartAlloc.  */  
   "AllocatedQty":number,
      /**  Quantity that is in the picking process for orders. A summary of PartAlloc.PickingQty for all demand.  */  
   "PickingQty":number,
      /**  Stock Quantity picked for orders.  A summary of PartAlloc.PickedQty for all demand.  */  
   "PickedQty":number,
      /**  Date last counted.  Updated during the Inventory Posting Process.  Not directly maintainable by user.  */  
   "CountedDate":string,
      /**  A summary of PartBin.OnHandQty for the warehouse where the bin is a nettable bin (WhseBin.NonNettable = NO). Maintained via the PartBin write trigger.  */  
   "OnHandQty":number,
      /**  A summary of PartBin.OnHandQty for the warehouse where the bin is a non nettable bin (WhseBin.NonNettable = YES). Maintained via the PartBin write trigger.  */  
   "NonNettableQty":number,
      /**  A summary of Demand that is Buy To Order and thus should not take away from Available inventory.  */  
   "BuyToOrderQty":number,
      /**   A summary of the outstanding quantities for order open sales releases that are being filled from stock for this Part within a specific warehouse.
The system calculates Available as OnhandQty - AllocatedQty.  */  
   "SalesDemandQty":number,
      /**  A total of inventory quantities that has been reserved  for sales orders.   A summary of PartAlloc.ReservedQty for sales order allocations against stock  (PartAlloc.OrderNum > 0 & SupplyJobNum = blank).  */  
   "SalesReservedQty":number,
      /**  New in 9.00.  A summary of outstanding quantities for order open sales releases that are being filled from stock and have not been reserved, selected for picking or picked. Calculated as OurStockQty - ReservedQty + PickingQty + PickedQty).  Note: ReservedQty, PickingQty, PickedQty are summaries of PartAlloc records with a blank job,  related to an OrderRel.  The system tracks allocation summaries in the following sequence; AllocQty--> ReservedQty--> PickingQty--> PickedQty.  */  
   "SalesAllocatedQty":number,
      /**   Quantity that is in the picking process for sales orders. A summary of PartAlloc.PickingQty where PartAlloc.OrderNum > 0
A summary of PartAlloc.PickingQty for sales order that are being picked from stock (PartAlloc.OrderNum > 0 & SupplyJobNum = blank).  */  
   "SalesPickingQty":number,
      /**  Stock Quantity picked for sales orders.  A summary of PartAlloc.PickedQty for sales order picked from stock  (PartAlloc.OrderNum > 0 & SupplyJobNum = blank).  */  
   "SalesPickedQty":number,
      /**  A summary of the outstanding quantities for job material requirements that are being filled from stock for this Part within a specific warehouse.  */  
   "JobDemandQty":number,
      /**  Summary of mfg demands on released jobs. That is, a summary of outstanding JobMtl and JobAsmbl.PullQty where JobHead.JobFirm = Yes and JobReleased = Yes  */  
   "JobReservedQty":number,
      /**  New in 9.00.  Summary of stock allocated for jobs.  */  
   "JobAllocatedQty":number,
      /**  Quantity that is in the picking process for jobs. A summary of PartAlloc.PickingQty where PartAlloc.JobNum <> ''.  */  
   "JobPickingQty":number,
      /**  Stock Quantity picked for jobs.  */  
   "JobPickedQty":number,
      /**  New in 9.00.  Summary of mfg demand requirements on unfirm jobs. That is, a summary of outstanding JobMtl.RequiredQty and JobAsmbl.PullQty where JobHead.JobFirm = No.  */  
   "UnfirmJobDemandQty":number,
      /**   A summary of the outstanding quantities for transfer order requirements that are being filled from stock for this Part within a specific warehouse.
The system calculates Available as OnhandQty - AllocatedQty.  */  
   "TFOrdDemandQty":number,
      /**  Summary of Transfer Order Reserved Qty for this Part in this Warehouse.  */  
   "TFOrdReservedQty":number,
      /**  Summary of Transfer Order Allocated Qty for this Part in this Warehouse.  */  
   "TFOrdAllocatedQty":number,
      /**  Quantity that is in the picking process for transfer orders.  A summary of PartAlloc.PickingQty where PartAlloc.TFOrdNum > 0.  */  
   "TFOrdPickingQty":number,
      /**  Stock Quantity picked for transfer orders.  */  
   "TFOrdPickedQty":number,
      /**  Uniquely indentifies the record.  */  
   "KBCode":string,
      /**  Indicates the desired minimum on-hand quantity. This is used by the time phase requirements report when user requests to show any parts that will or have fallen below this level. It is also used as a selection parameter for the inventory reorder report. This is an optional field.  */  
   "MinimumQty":number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand. This field is used as a selection option by the inventory reorder report to show all parts that are over this limit. This field is optional.  */  
   "MaximumQty":number,
      /**   Safety quantity is a "purchasing cushion" limit. It's the amount you would need to have to cover your requirements until a shipment arrives from the vendor. If your on-hand quantity falls below this limit it means that there is a good chance that you will run out of material before the next shipment arrives. This value is used by the inventory reorder report and the time phase report. It is an optional field.
Note: Safety + Minimum = Reorder Point...  using this formula the  reorder point is the amount at which to reorder to maintain at least the prescribed minimum quantity.  */  
   "SafetyQty":number,
      /**  Purchase order number  that the detail line item is linked to.  */  
   "KBPONUM":number,
      /**  The line number of the detail record on the purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   "KBPOLine":number,
      /**  Kanban Warehouse  */  
   "KBWarehouseCode":string,
      /**  Identifies the Bin location that contains an Onhand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   "KBBinNum":string,
      /**  Site Identifier. This field cannot be blank.  */  
   "KBPlant":string,
      /**  Indicates the desired minimum on-hand Kanban quantity.  */  
   "KBQty":number,
      /**  Percent Tolerance. Entered as a positive number, Used to define the default percent tolerance. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a percentage difference between the count quantity and the frozen quantity by more than the percent tolerance figure is considered out of tolerance. Calculated as ?adjustment qty / frozen qty? expressed as a percent.  */  
   "PcntTolerance":number,
      /**  False = there is no percent tolerance consideration and any percent variance is considered within tolerance. True = percent tolerance is active for this part/whs and the value in PcntTolerance will be used to determine if the count variance is within tolerance.  */  
   "CalcPcnt":boolean,
      /**  False = there is no quantity tolerance consideration and any quantity variance is considered within tolerance. True = quantity tolerance is active for this part/whse and the value in QtyTolerance will be used to determine if the count variance is within tolerance.  */  
   "CalcQty":boolean,
      /**  False = there is no value tolerance consideration and any value variance is considered within tolerance. True = value tolerance is active for this part/whse and the value in ValueTolerance will be used to determine if the count variance is within tolerance.  */  
   "CalcValue":boolean,
      /**  Used to provide a means to control whether a count quantity discrepancy should be posted as an adjustment to inventory. Zero indicates all quantity adjustments will be posted. This parameter is used to control the count discrepancy of parts that are counted by weight on a scale. Counts often vary based upon humidity. If the count of the part is within this tolerance but different from the frozen quantity then no inventory adjustment will be posted.  */  
   "QtyAdjTolerance":number,
      /**  False = there is no qty adj tolerance setting at the PartWhse level (so the setting in PartSite will be used). True = qty adj tolerance is active for this part/whs and the value in QtyAdjTolerance will be used to determine if the count variance should be  */  
   "CalcQtyAdj":boolean,
      /**  Moved from PartSite. When the system sets the ABC class, it will not allow the class to be lower than this class.  */  
   "MinAbc":string,
      /**  Moved from PartSite. ABC Classification calculated by the system based on Stock Valuation Percent. This is maintainable by the user if ManualABC = true.  */  
   "SystemAbc":string,
      /**  This will lock the SystemABC code preventing the automatic determination by the Calculate ABC Codes process, which will not reset the ABC code on parts that have the flag set.  */  
   "ManualABC":boolean,
      /**  The last date this part was cycle counted. This date is used to insure that a part will be selected for cycle counting at the appropriate time. This is different than the CountedDate field, which will be updated for either a cycle count or physical inventory.  */  
   "LastCCDate":string,
      /**  This flag indicates whether the CountFreq defined in this record should over ride the count frequency in the AbcCode, SiteConfABC or WarehseABC tables.  */  
   "OvrrideCountFreq":boolean,
      /**  If greater than zero this setting overrides values in AbcCode,  SiteConfABC and Warehse.  */  
   "CountFreq":number,
      /**  Quantity tolerance. Entered as a positive whole number, Used to define the default quantity tolerance. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a count quantity that varies from the frozen quantity by more than the quantity tolerance figure is considered out of tolerance.  */  
   "QtyTolerance":number,
      /**  Value tolerance. Entered as a positive number. Used to define the default value tolerance.  An entry of zero will indicate that any value variance will be considered out of tolerance for this part. Value variance is calculated as the difference in cost between the counted quantity and the frozen quantity.  */  
   "ValueTolerance":number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  Filled in by BO, not phiscally in database.  */  
   "Plant":string,
   "DefaultWhse":boolean,
   "PrimBinNum":string,
   "TotalDemand":number,
   "PrimBinNumDescription":string,
   "KBActionCode":string,
   "KBActionDesc":string,
   "PlantOwner":string,
   "MaxQtyUOM":string,
   "MinQtyUOM":string,
   "SafetyQtyUOM":string,
      /**  Part Warehouse columns Unit Of Measure.  */  
   "IUM":string,
   "BitFlag":number,
   "KBBinNumDescription":string,
   "KBCodeKBActionCode":string,
   "KBCodeKBDescription":string,
   "KBPlantName":string,
   "KBWarehouseCodeDescription":string,
   "PartNumIUM":string,
   "PartNumPricePerCode":string,
   "PartNumTrackSerialNum":boolean,
   "PartNumSalesUM":string,
   "PartNumSellingFactor":number,
   "PartNumTrackLots":boolean,
   "PartNumPartDescription":string,
   "PartNumTrackDimension":boolean,
   "WarehouseDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}

export interface Erp_Tablesets_TaxExemptRow{
      /**  Company Identifier.  */  
   "Company":string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   "RelatedToFile":string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   "Key1":string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   "Key2":string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   "TaxCode":string,
      /**  Tax Rate Code  */  
   "RateCode":string,
      /**  Exemption Effective Start Date  */  
   "EffectiveFrom":string,
      /**  Exemption Effective End Date  */  
   "EffectiveTo":string,
      /**  Exemption Type  */  
   "ExemptType":number,
      /**  Exemption Percent  */  
   "ExemptPercent":number,
      /**  Tax Legal Text Code  */  
   "TextCode":string,
      /**  Tax Resolution Number  */  
   "ResolutionNum":string,
      /**  Tax Resolution Date  */  
   "ResolutionDate":string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   "SysRevID":number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   "SysRowID":string,
      /**  A unique Customer identifier.  */  
   "CustNum":number,
      /**  The PartNum field identifies the Part.  */  
   "PartNum":string,
      /**  A unique Vendor identifier.  */  
   "VendorNum":number,
   "BitFlag":number,
   "SalesTaxDescription":string,
   "SalesTRCDescription":string,
   "TaxTextDescription":string,
      /**  RowMod  */  
   "RowMod":string,
}




//////////////////////////////////////////////////////////////////////////
// Custom Schemas:
//////////////////////////////////////////////////////////////////////////
export interface AllowDimensionMaintenance_output{
}

export interface AllowInventoryInfo_output{
}

export interface AllowLotMaintenance_output{
}

export interface AllowPurchasingInfo_output{
}

export interface AllowViewLotCosts_output{
}

   /** Required : 
      @param tblPPPAttribute
      @param ttPartPlantRow
      @param attrClassID
      @param ium
   */  
export interface BuildPartPlantPlanningAttributeTable_input{
      /**  Input-output PartPlantPlanningAttribute table  */  
   tblPPPAttribute:Erp_Tablesets_PartPlantPlanningAttributeRow[],
   ttPartPlantRow:Erp_Tablesets_PartPlantRow[],
      /**  Attribute ClassID  */  
   attrClassID:string,
      /**  Inventory part UOM  */  
   ium:string,
}

export interface BuildPartPlantPlanningAttributeTable_output{
parameters : {
      /**  output parameters  */  
   tblPPPAttribute:any[],
}
}

   /** Required : 
      @param ipMfgLeadTimeMnl
      @param ipLvlMfgLeadTimeMnl
      @param ipACWPercentage
      @param ds
   */  
export interface CalcACWDays_input{
      /**  Indicates manufacturing lead times are entered manually by the user.  */  
   ipMfgLeadTimeMnl:boolean,
      /**  Manually entered manufacturing lead time value  */  
   ipLvlMfgLeadTimeMnl:number,
      /**  Auto Consume Window Percentage  */  
   ipACWPercentage:number,
   ds:Erp_Tablesets_PartTableset[],
}

export interface CalcACWDays_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param partNum
      @param wipCompletedOnly
      @param wipExcludeProdLoc
      @param wipPlant
      @param authorizedPlants
   */  
export interface CalcWipWClause_input{
   partNum:string,
   wipCompletedOnly:boolean,
   wipExcludeProdLoc:boolean,
   wipPlant:string,
   authorizedPlants:string,
}

export interface CalcWipWClause_output{
   returnObj:string,
}

   /** Required : 
      @param ds
      @param newCostMethod
   */  
export interface ChangeCostMethod_input{
   ds:Erp_Tablesets_PartTableset[],
   newCostMethod:string,
}

export interface ChangeCostMethod_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param uomClassID
      @param ds
   */  
export interface ChangeDualUOMClassID_input{
      /**  proposed DualUOMClassID.  */  
   uomClassID:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeDualUOMClassID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newLinkToContract
      @param ds
   */  
export interface ChangeLinkToContract_input{
      /**  The new LinkToContract value.  */  
   newLinkToContract:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeLinkToContract_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param partNum
      @param plant
      @param processMRP
   */  
export interface ChangeMRPWarning_input{
      /**  Part number of the PartPlant record that is being updated.  */  
   partNum:string,
      /**  Plant ID of the PartPlant record that is being updated .  */  
   plant:string,
      /**  New value of the PartPlant.ProcessMRP field.  */  
   processMRP:boolean,
}

export interface ChangeMRPWarning_output{
parameters : {
      /**  output parameters  */  
   warningMsg:string,
}
}

   /** Required : 
      @param ipMXProdServCode
      @param ds
   */  
export interface ChangeMXProdServCode_input{
      /**  Proposed input value of Product or Service Code  */  
   ipMXProdServCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeMXProdServCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewKBCode
      @param ds
   */  
export interface ChangePartBinInfoKBCode_input{
      /**  The new Kan Ban Type code field value.  */  
   NewKBCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartBinInfoKBCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipBuyToOrder
      @param ds
   */  
export interface ChangePartBuyToOrder_input{
      /**  The new part Buy To Order value.  */  
   ipBuyToOrder:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartBuyToOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newCommodityCode
      @param ds
   */  
export interface ChangePartCommodityCode_input{
      /**  The new commodity code.  */  
   newCommodityCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartCommodityCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newExternalMESSyncRequired
      @param ds
   */  
export interface ChangePartExternalMESSyncRequired_input{
      /**  The new ExternalMESSyncRequired value.  */  
   newExternalMESSyncRequired:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartExternalMESSyncRequired_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ProposedGlobalPart
      @param ds
   */  
export interface ChangePartGlobalPart_input{
      /**  The proposed global part value  */  
   ProposedGlobalPart:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartGlobalPart_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param inspectionReq
      @param ds
   */  
export interface ChangePartInspectionRequired_input{
      /**  The new Inspection Required part value.  */  
   inspectionReq:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartInspectionRequired_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param internalUnitPrice
      @param ds
   */  
export interface ChangePartInternalUnitPrice_input{
      /**  The new Unit Price value.  */  
   internalUnitPrice:number,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartInternalUnitPrice_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newIsServices
      @param ds
   */  
export interface ChangePartIsServices_input{
      /**  The new non-stock value.  */  
   newIsServices:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartIsServices_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param LocationIDNumReq
      @param ds
   */  
export interface ChangePartLocationIDNumReq_input{
      /**  The new part LocationIDNumReq value.  */  
   LocationIDNumReq:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartLocationIDNumReq_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newNonStock
      @param ds
   */  
export interface ChangePartNonStock_input{
      /**  The new non-stock value.  */  
   newNonStock:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartNonStock_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ProposedPartNum
      @param ds
   */  
export interface ChangePartNum_input{
      /**  The proposed product code value  */  
   ProposedPartNum:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipBuyToOrder
      @param ds
   */  
export interface ChangePartPlantBuyToOrder_input{
      /**  The new part Buy To Order value.  */  
   ipBuyToOrder:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantBuyToOrder_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NofPColumnName
      @param NewQty
      @param ds
   */  
export interface ChangePartPlantPlanningAttributeNofP_input{
      /**  The Number of Pieces column being modified.  */  
   NofPColumnName:string,
      /**  The value entered in the Number of Pieces column being modified.  */  
   NewQty:number,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantPlanningAttributeNofP_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewQtyDisplayOption
      @param ds
   */  
export interface ChangePartPlantPlanningAttributeQtyDisplayOption_input{
      /**  The QtyDisplayOption value.  */  
   NewQtyDisplayOption:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantPlanningAttributeQtyDisplayOption_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param QtyColumnName
      @param NewQty
      @param ds
   */  
export interface ChangePartPlantPlanningAttributeQty_input{
      /**  The Quantity column being modified.  */  
   QtyColumnName:string,
      /**  The value entered in the Quantity column being modified.  */  
   NewQty:number,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantPlanningAttributeQty_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewVendorId
      @param ds
   */  
export interface ChangePartPlantPlanningAttributeUrgentVendorID_input{
      /**  The new Vendor ID value.  */  
   NewVendorId:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantPlanningAttributeUrgentVendorID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewVendorId
      @param ds
   */  
export interface ChangePartPlantPlanningAttributeVendorID_input{
      /**  The new Vendor ID value.  */  
   NewVendorId:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantPlanningAttributeVendorID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param PartNum
      @param NewSourceType
   */  
export interface ChangePartPlantSourceTypePrep_input{
      /**  PartNum  */  
   PartNum:string,
      /**  The new SourceType value.  */  
   NewSourceType:string,
}

export interface ChangePartPlantSourceTypePrep_output{
parameters : {
      /**  output parameters  */  
   ruleMessage:string,
   singleLevelConfMsg:string,
}
}

   /** Required : 
      @param NewSourceType
      @param ds
   */  
export interface ChangePartPlantSourceType_input{
      /**  The new SourceType value.  */  
   NewSourceType:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantSourceType_output{
parameters : {
      /**  output parameters  */  
   ruleMessage:string,
   singleLevelConfMsg:string,
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewVendorId
      @param ds
   */  
export interface ChangePartPlantUrgentVendorID_input{
      /**  The new Vendor ID value.  */  
   NewVendorId:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantUrgentVendorID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewVendorId
      @param ds
   */  
export interface ChangePartPlantVendorID_input{
      /**  The new Vendor ID value.  */  
   NewVendorId:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartPlantVendorID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ProposedProdCode
      @param ds
   */  
export interface ChangePartProdCode_input{
      /**  The proposed product code value  */  
   ProposedProdCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartProdCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangePartRestrictSubstance_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartRestrictSubstance_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param checkManual
      @param ds
   */  
export interface ChangePartRestrictionManual_input{
      /**  Manual value  */  
   checkManual:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartRestrictionManual_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangePartRestrictionType_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartRestrictionType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipApproved
      @param ipValidPassword
      @param ds
   */  
export interface ChangePartRevApproved_input{
      /**  The proposed PartRev.Approved value  */  
   ipApproved:boolean,
      /**  Did the user supply a valid password to run this functionality?
             The value for this parameter should come from running the ValidatePassword method
             in the UserFile BO.  */  
   ipValidPassword:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartRevApproved_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNBaseDataType
      @param ds
      @param ipInitNumODigits
      @param ipCutPrefix
   */  
export interface ChangePartSNBaseDataTypePrep_input{
      /**  Part.SNBaseDataType  */  
   ipSNBaseDataType:string,
   ds:Erp_Tablesets_PartTableset[],
      /**  Cut prefix  */  
   ipInitNumODigits:boolean,
      /**  Cut prefix  */  
   ipCutPrefix:boolean,
}

export interface ChangePartSNBaseDataTypePrep_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNBaseDataType
      @param ds
   */  
export interface ChangePartSNBaseDataType_input{
      /**  Part.SNBaseDataType  */  
   ipSNBaseDataType:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartSNBaseDataType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNMaskValue
      @param ipPreSuffix
      @param ds
   */  
export interface ChangePartSNMaskPrefixSuffixPrep_input{
      /**  Part.SNMaskPrefix  */  
   ipSNMaskValue:string,
      /**  Part.SNMaskPrefix  */  
   ipPreSuffix:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartSNMaskPrefixSuffixPrep_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNMaskPrefix
      @param ipSNMaskSuffix
      @param ds
   */  
export interface ChangePartSNMaskPrefixSuffix_input{
      /**  Part.SNMaskPrefix  */  
   ipSNMaskPrefix:string,
      /**  Part.SNMaskSuffix  */  
   ipSNMaskSuffix:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartSNMaskPrefixSuffix_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param proposedPartNum
      @param ds
   */  
export interface ChangePartSubsPartNum_input{
      /**  The proposed PartNum  */  
   proposedPartNum:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartSubsPartNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newSyncToExternalCRM
      @param ds
   */  
export interface ChangePartSyncToExternalCRM_input{
      /**  The new SyncToExternalCRM value.  */  
   newSyncToExternalCRM:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartSyncToExternalCRM_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param TrackDimension
      @param ds
   */  
export interface ChangePartTrackDimension_input{
      /**  The new part Track Dimension value.  */  
   TrackDimension:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartTrackDimension_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param TrackLots
      @param ds
   */  
export interface ChangePartTrackLots_input{
      /**  The new part Track Lots value.  */  
   TrackLots:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartTrackLots_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param TrackSerialNum
      @param ds
   */  
export interface ChangePartTrackSerialNum_input{
      /**  The new part Track Serial Numbers value.  */  
   TrackSerialNum:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartTrackSerialNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param TypeCode
      @param ds
   */  
export interface ChangePartTypeCode_input{
      /**  The new part Type Code field value.  */  
   TypeCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartTypeCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangePartUOMConvFactor_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartUOMConvFactor_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipConvOverrride
      @param ds
   */  
export interface ChangePartUOMConvOverride_input{
      /**  The new ConvOverrride field value.  */  
   ipConvOverrride:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartUOMConvOverride_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param unitPrice
      @param ds
   */  
export interface ChangePartUnitPrice_input{
      /**  The new Unit Price value.  */  
   unitPrice:number,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartUnitPrice_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewKBCode
      @param ds
   */  
export interface ChangePartWhseKBCode_input{
      /**  The new Kan Ban Type code field value.  */  
   NewKBCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePartWhseKBCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNBaseDataType
      @param ds
      @param ipInitNumODigits
      @param ipCutPrefix
   */  
export interface ChangePlantSNBaseDataTypePrep_input{
      /**  Part.SNBaseDataType  */  
   ipSNBaseDataType:string,
   ds:Erp_Tablesets_PartTableset[],
      /**  Cut prefix  */  
   ipInitNumODigits:boolean,
      /**  Cut prefix  */  
   ipCutPrefix:boolean,
}

export interface ChangePlantSNBaseDataTypePrep_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNBaseDataType
      @param ds
   */  
export interface ChangePlantSNBaseDataType_input{
      /**  Part.SNBaseDataType  */  
   ipSNBaseDataType:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePlantSNBaseDataType_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNMaskValue
      @param ipPreSuffix
      @param ds
   */  
export interface ChangePlantSNMaskPrefixSuffixPrep_input{
      /**  PartPlant.SNMaskPrefix  */  
   ipSNMaskValue:string,
      /**  PartPlant.SNMaskPrefix  */  
   ipPreSuffix:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePlantSNMaskPrefixSuffixPrep_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNMaskPrefix
      @param ipSNMaskSuffix
      @param ds
   */  
export interface ChangePlantSNMaskPrefixSuffix_input{
      /**  Prefix  */  
   ipSNMaskPrefix:string,
      /**  Suffix  */  
   ipSNMaskSuffix:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangePlantSNMaskPrefixSuffix_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param newQtyBearing
      @param ds
   */  
export interface ChangeQtyBearing_input{
      /**  The new QtyBearing value.  */  
   newQtyBearing:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeQtyBearing_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipSNMask
      @param ds
   */  
export interface ChangeSNMask_input{
      /**  Part.SNMask  */  
   ipSNMask:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeSNMask_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param trackInventoryAttributes
      @param ds
   */  
export interface ChangeTrackInventoryAttributes_input{
   trackInventoryAttributes:boolean,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeTrackInventoryAttributes_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param uomClassID
      @param ds
   */  
export interface ChangeUOMClassID_input{
      /**  proposed UOMClassId.  */  
   uomClassID:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeUOMClassID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param uomCode
      @param ds
   */  
export interface ChangeUOMCode_input{
      /**  proposed uomCode.  */  
   uomCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangeUOMCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface ChangedAttrClassIDFromPartUOMConversion_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangedAttrClassIDFromPartUOMConversion_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
   msg:string,
}
}

   /** Required : 
      @param ds
   */  
export interface ChangedAttrClassID_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChangedAttrClassID_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
   msg:string,
}
}

   /** Required : 
      @param pSubstanceID
      @param ds
   */  
export interface ChanginPartRestrictSubs_input{
      /**  Substance ID  */  
   pSubstanceID:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ChanginPartRestrictSubs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipPartNum
      @param ipRevisionNum
      @param ipAltMethod
      @param ipProcessMfgID
   */  
export interface CheckAltMethodForDelete_input{
      /**  The current Part Number  */  
   ipPartNum:string,
      /**  The current Revision Number  */  
   ipRevisionNum:string,
      /**  The current Alt Method  */  
   ipAltMethod:string,
      /**  The current Recipe  */  
   ipProcessMfgID:string,
}

export interface CheckAltMethodForDelete_output{
parameters : {
      /**  output parameters  */  
   opMessage:string,
}
}

   /** Required : 
      @param ds
   */  
export interface CheckCOOPercentsExt_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface CheckCOOPercentsExt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param cPartNum
   */  
export interface CheckCOOPercents_input{
      /**  The Part Number  */  
   cPartNum:string,
}

export interface CheckCOOPercents_output{
}

   /** Required : 
      @param ipValue
      @param ipColumnName
      @param ipCOASegReferences
      @param ipIllegalSymbsForCOASegVals
   */  
export interface CheckColumnValue_input{
      /**  Value  */  
   ipValue:string,
      /**  Column Name  */  
   ipColumnName:string,
      /**  COA References  */  
   ipCOASegReferences:string,
      /**  Illegal Symbols  */  
   ipIllegalSymbsForCOASegVals:string,
}

export interface CheckColumnValue_output{
parameters : {
      /**  output parameters  */  
   opIllegal:boolean,
}
}

   /** Required : 
      @param ipPartNum
      @param ipRevisionNum
      @param ipAltMethod
      @param ipForRevision
   */  
export interface CheckConfigForDelete_input{
      /**  The current Part Number  */  
   ipPartNum:string,
      /**  The current Revision Number  */  
   ipRevisionNum:string,
      /**  The current Alternate Method  */  
   ipAltMethod:string,
      /**  True if deleting revision record  */  
   ipForRevision:boolean,
}

export interface CheckConfigForDelete_output{
parameters : {
      /**  output parameters  */  
   opMessage:string,
}
}

   /** Required : 
      @param ipPart
      @param ipOrigCountry
   */  
export interface CheckDuplicateCOO_input{
      /**  The Part Number  */  
   ipPart:string,
      /**  proposed origin country  */  
   ipOrigCountry:number,
}

export interface CheckDuplicateCOO_output{
}

   /** Required : 
      @param ds
   */  
export interface CheckPartChanges_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface CheckPartChanges_output{
parameters : {
      /**  output parameters  */  
   cPartChangedMsgText:string,
   cPartSNChangedMsgText:string,
}
}

   /** Required : 
      @param performInventoryTransfer
      @param defaultRevisionNum
      @param ds
   */  
export interface CheckTrackInventoryAttributeConversion_input{
   performInventoryTransfer:boolean,
   defaultRevisionNum:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface CheckTrackInventoryAttributeConversion_output{
parameters : {
      /**  output parameters  */  
   validationMessage:string,
   noConversionsToConvert:boolean,
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param configID
      @param partNum
      @param revisionNum
   */  
export interface ConfigIDChanging_input{
      /**  proposed ConfigID  */  
   configID:string,
      /**  Part  */  
   partNum:string,
      /**  Revision Num  */  
   revisionNum:string,
}

export interface ConfigIDChanging_output{
parameters : {
      /**  output parameters  */  
   configID:string,
   outMessage:string,
}
}

   /** Required : 
      @param partNum
      @param attrClassID
      @param trackInventoryAttributes
      @param trackInventoryByRevision
   */  
export interface CreateRevisionListValForPart_input{
   partNum:string,
   attrClassID:string,
   trackInventoryAttributes:boolean,
   trackInventoryByRevision:boolean,
}

export interface CreateRevisionListValForPart_output{
}

   /** Required : 
      @param partNum
   */  
export interface DeleteByID_input{
   partNum:string,
}

export interface DeleteByID_output{
}

   /** Required : 
      @param ds
   */  
export interface DeleteMRPJobs_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface DeleteMRPJobs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param NewSourceType
      @param ds
   */  
export interface DeleteMultiLevelRules_input{
      /**  The new SourceType value.  */  
   NewSourceType:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface DeleteMultiLevelRules_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param sourcePartNum
      @param targetPartNum
      @param targetPartDescription
      @param configuratorMode
      @param configID
      @param configDescription
      @param configType
   */  
export interface DuplicatePart_input{
      /**  Existing part number that will be duplicated.  */  
   sourcePartNum:string,
      /**  New part number that will be created.  */  
   targetPartNum:string,
      /**  Description that will be used for the new part.  */  
   targetPartDescription:string,
      /**  Indicates how the configurator will be handled.  */  
   configuratorMode:string,
      /**  Configurator ID  */  
   configID:string,
      /**  Configurator description.  */  
   configDescription:string,
      /**  Configurator type.  */  
   configType:string,
}

export interface DuplicatePart_output{
   returnObj:Erp_Tablesets_PartTableset[],
}

   /** Required : 
      @param ds
   */  
export interface EnableTrackInventoryAttributeConversion_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface EnableTrackInventoryAttributeConversion_output{
parameters : {
      /**  output parameters  */  
   enableInventoryTransfer:boolean,
   enableConvertButton:boolean,
   serialsExist:boolean,
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
      @param enterpriseBAQID
      @param enterpriseSearchText
   */  
export interface EnterpriseGetList_input{
      /**  whereClause  */  
   whereClause:string,
      /**  pageSize  */  
   pageSize:number,
      /**  absolutePage  */  
   absolutePage:number,
      /**  Enterprise BAQ ID  */  
   enterpriseBAQID:string,
      /**  Enterprise Search  */  
   enterpriseSearchText:string,
}

export interface EnterpriseGetList_output{
   returnObj:Erp_Tablesets_PartListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

export interface Erp_Tablesets_EntityGLCRow{
      /**  Company Identifier.  */  
   Company:string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   RelatedToFile:string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   Key1:string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   Key2:string,
      /**   3rd component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key3:string,
      /**   4th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key4:string,
      /**   5th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key5:string,
      /**   6th component of the foreign key to the related master record.
The usage of this field is dependent record type.  */  
   Key6:string,
      /**  Identifier of the GL Control Type.  */  
   GLControlType:string,
      /**  GL Control Identifier.  */  
   GLControlCode:string,
      /**  Identifies the entity.  Reference only.  Used for integrity validation when deleting a GLCTEntity record.  */  
   BusinessEntity:string,
      /**  Global Company identifier.  Used in Multi-Company Journal.  */  
   ExtCompanyID:string,
      /**  Flag to indicate the account in this record is for an external company.  */  
   IsExternalCompany:boolean,
      /**  Marks this EntityGLC as global, available to be sent out to other companies.  */  
   GlobalEntityGLC:boolean,
      /**  Disables this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  BankAcctID of the related BankAcct record.  */  
   BankAcctID:string,
   BankFeeID:string,
      /**  CallCode of the related FSCallCd record.  */  
   CallCode:string,
   ChargeCode:string,
      /**  ClassCode of the related FAClass record.  */  
   ClassCode:string,
      /**  ClassID.  This can be ClassID of PartClass, PRClsDed, or PRClsTax  */  
   ClassID:string,
      /**  ContractCode of the related FSContCd record.  */  
   ContractCode:string,
      /**  CurrencyCode of the related Currency record.  */  
   CurrencyCode:string,
      /**  CustNum of the related Customer record  */  
   CustNum:number,
      /**  DeductionID of PRClsDed or PRDeduct.  */  
   DeductionID:string,
      /**  EmpID of the related PREmpMas record.  */  
   EmpID:string,
      /**  ExpenseCode of PayTLbr, LabExpCd  */  
   ExpenseCode:string,
      /**  ExtSystemID of ExtCompany table  */  
   ExtSystemID:string,
      /**  FromPlant value of the related PlntTranDef record.  */  
   FromPlant:string,
      /**  GroupCode of the related FAGroup record.  */  
   GroupCode:string,
   GroupID:string,
   HeadNum:number,
   InvoiceNum:string,
      /**  JCDept of the related JCDept record.  */  
   JCDept:string,
      /**  MiscCode of the related MiscChrg or PurMisc record.  */  
   MiscCode:string,
      /**  PartNum of the related Part record.  */  
   PartNum:string,
      /**  PayTypeID of PayType  */  
   PayTypeID:string,
   PerConName:string,
      /**  PI Status  */  
   PIStatus:string,
      /**  Plant of the related PlantConfCtrl record.  */  
   Plant:string,
      /**  ProdCode of the related ProdGrup record.  */  
   ProdCode:string,
      /**  ProjectID of the related Project record.  */  
   ProjectID:string,
      /**  PurchCode of the related GLPurch record.  */  
   PurchCode:string,
      /**  RateCode of the related GLRate record.  */  
   RateCode:string,
      /**  ReasonCode of the related Reason record.  */  
   ReasonCode:string,
      /**  ReasonType of the related Reason record.  */  
   ReasonType:string,
      /**  SalesCatID of the related SalesCat record.  */  
   SalesCatID:string,
      /**  Shift value of the related JCShift record.  */  
   Shift:number,
      /**  TaxCode of the related SalesTax record.  */  
   TaxCode:string,
      /**  TaxTblID of PRTaxMas or PRClsTax.  */  
   TaxTblID:string,
      /**  ToPlant value of the related PlntTranDef record.  */  
   ToPlant:string,
      /**  TransferMethod of ExtCompany table  */  
   TransferMethod:string,
      /**  Type ID  */  
   TypeID:string,
      /**  VendorNum of the related Vendor record.  */  
   VendorNum:number,
      /**  WarehouseCode of the related Warehse record.  */  
   WarehouseCode:string,
   ExpenseTypeCode:string,
   IsFiltered:boolean,
   OprTypeCode:string,
   CashDeskID:string,
   TIN:string,
   ReclassCodeID:string,
   BitFlag:number,
   GLCntrlDescription:string,
   GLCntrlTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbPartRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The PartNum field identifies the Part and is used as the primary key.  */  
   PartNum:string,
      /**  An abbreviated part description field by which the user can search the Part file. During Part maintenance a change to the Part.Description field causes this field to be updated with the first 8 bytes of the Part.Description.  */  
   SearchWord:string,
      /**  Describes the Part.  This field can not be blank.  */  
   PartDescription:string,
   ClassID:string,
      /**  Defines the Unit of Measure used when part is issued, this is also how it is stocked.  Use the value from XaSyst.UM as a default when creating new part records.  */  
   IUM:string,
      /**  The Purchasing Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Purchase Order entry as the default on line item details.  */  
   PUM:string,
      /**   Classifies Parts into the following...
M = Manufactured Part.
P = Purchased Part
This type code does limit referencing any part in any way. For example a type "P" can be entered on a sales order, or a type "M" can be referenced in a Purchase Order.
This field will also be used as a selection parameter in certain reports, such as Time Phase Requirements.  */  
   TypeCode:string,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   NonStock:boolean,
      /**  This value is used to convert quantity when there is a difference in the vendors unit of measure and how it is stocked in inventory. Example is purchased in pounds, stocked in sheets.
Formula: Issue Qty * Conversion Factor = Purchased Qty.  */  
   PurchasingFactor:number,
      /**  Base Unit Selling Price for the Item. Maintainable only via Part Master Maintenance program. It is used as a default unit price on Sales Order line detail and on Invoice line details that are not referencing a sales order line.  */  
   UnitPrice:number,
      /**  Indicates the pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Maintainable only via Part Maintenance. The initial default is "E". Used as default PricePerCode in order entry and invoice entry.  */  
   PricePerCode:string,
      /**  Base Internal Unit Selling Price for the Item.  Maintainable only via Part Master Maintenance program.  If zero, then the external unit price (Part.UnitPrice) is used.  */  
   InternalUnitPrice:number,
      /**  Indicates the internal pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand.  Maintainable only via Part Maintenance.  The initial default is "E".  */  
   InternalPricePerCode:string,
      /**  Product Group ID for the Part. This can be blank or must be valid in the ProdGrup file.  This will be used for report sorting and selection. Also as a default in order entry, invoice entry and job entry.  */  
   ProdCode:string,
      /**  Used to enter comments for manufacturing when this part is referenced on a job. These are copied to JobHead.Comment, JobAsmbl.Comment,JobMtl.MfgComment depending on the point of reference. Commens are printed on the routing report.  */  
   MfgComment:string,
      /**  Part Comments that will be used as a default for purchasing. These will be copied into the JobMtl.PurComment which then will be used to pass along to the PO when that JobMtl is referenced. It will also be copied into the PODetail.Comment field when the PO is buying the part for stock and not referencing a Job. View as an EDITOR widget. To be view-as EDITOR widget.  */  
   PurComment:string,
      /**  Defines the Costing method to be associated with this Part. Use the XaSyst.CostMethod as a default.  When a unit cost is retrieved from the Part file the programs will use this field to determine which one of the Four sets of cost fields should be used.  A = Use Average L= Use Last S = Use Standard T = Use Avg by lot(not found in XaSyst).  */  
   CostMethod:string,
      /**  Indicates the Tax Category for this Part. Used as a default to Order line items or Invoice line items. Can be left blank which indicates item is taxable. If entered must be valid in the TaxCat master file.  */  
   TaxCatID:string,
      /**   Flag which indicates if the Part Master is considered as "Inactive".
This flag will be used to exclude parts from certain searches and reports.  */  
   InActive:boolean,
      /**  Internally assigned integer which indicates the deepest level of assembly indention that this part is used at.  This is used by the Cost Rollup routines to control the order in which parts get costed. Part at the bottom (highest levelcode) Product structure are calculated first and continues up the chain, with the final assembly parts being processed last.  This insures that when retrieving the cost of an assemblies components the components will already have had their cost rolled up.  */  
   LowLevelCode:number,
      /**  An internal flag which indicates that this part contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   Method:boolean,
      /**  Indicates if Lot numbers are prompted for in transactions for this part.  Backflushing and AutoReceiving functions are ignored when TrackLots = Yes.  */  
   TrackLots:boolean,
      /**  Indicates if this part is dimension tracked  */  
   TrackDimension:boolean,
      /**  Default dimension code for the part.  Set by selecting a PartDim record as default.  */  
   DefaultDim:string,
      /**  Indicates if this part is serial number tracked  */  
   TrackSerialNum:boolean,
      /**  Intrastat goods classification code following the Intrastat Classification Nomenclature (ICN). The Commodity Code field can be blank to indicate the value from the part class or must be valid in the ICommCode (formerly called IStatGrp) master file.  */  
   CommodityCode:string,
      /**  Unique code for the Warranty for this part  */  
   WarrantyCode:string,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   PhantomBOM:boolean,
      /**  The Selling Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Sales Order entry as the default on line item details.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  The material burden rate for this part.  */  
   MtlBurRate:number,
      /**  The Part's Unit Net Weight.  */  
   NetWeight:number,
      /**   NOTE: NOT IMPLEMENTED ON INITIAL 5.0.300 RELEASE.
if Yes then the part effective revision is used. If No then the revision of the demand source is used (OrderDtl, JobMtl...)  */  
   UsePartRev:boolean,
      /**  Default for label printing.  Zero indicates that only one label should be produced for the entire quantity.  */  
   PartsPerContainer:number,
      /**  Part's length.  */  
   PartLength:number,
      /**  Part's width.  */  
   PartWidth:number,
      /**  Part's Height.  */  
   PartHeight:number,
      /**  Shelf life of a lot in days.  Zero indicates unlimited shelf life.  */  
   LotShelfLife:number,
      /**  This is a Web saleable part  */  
   WebPart:boolean,
      /**  Indicates that the onhand quantity is to be consumed and no further replenishments should be made.  Similar to Obsolete, however only warning messages will be issued to the user if they attempt new references.  */  
   RunOut:boolean,
      /**  Indicates the default Substitute part number.  This is optional. Must be one of the related PartSub records.  This field is set indirectly when the user checks the default toggle box in Part Substitution dialog.  */  
   SubPart:string,
      /**  Part's diameter.  */  
   Diameter:number,
      /**  Part's gravity.  */  
   Gravity:number,
      /**  Indicates that the part is on hold.  This feature can be used to indicate that a new part is not yet approved, that it is being phased out, has a quality issue, etc.  Further demands/supplies of this part should not be made. Similar to an "Inactive" part. However at the moment it still may have an onhand balance, supply and demands and will be reflected in stock status reporting.  */  
   OnHold:boolean,
      /**  Date that part becomes obsolete.  This can be set to a future date when the part should become obsolete.  */  
   OnHoldDate:string,
      /**   The reason code that links to a Reason master record, which indicates why the part has been placed on hold.
Valid only when Part.OnHold = Yes.  */  
   OnHoldReasonCode:string,
   AnalysisCode:string,
      /**  Owner Company Identifier.  */  
   GlbCompany:string,
      /**  The Owner's PartNum field identifies the Part and is used as the primary key.  */  
   GlbPartNum:string,
      /**  MtlAnalysisCode  */  
   MtlAnalysisCode:string,
      /**  Marks the Part as a global Part, available to be sent out to other companies  */  
   GlobalPart:boolean,
      /**  Disable this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  This value is used to calculate the Supplementary Units for the Intrastat.  */  
   ISSuppUnitsFactor:number,
      /**  Original Owner Company Identifier. - NOT CURRENTLY IN USE  */  
   OldCompany:string,
      /**  The Original Owner's PartNum field identifies the Part and is used as the primary key.   NOT CURRENTLY IN USE  */  
   OldPartNum:string,
      /**  Holds the internal object id of pdm parts.  */  
   PDMObjID:string,
   SNPrefix:string,
      /**  Path & filename (relative to images/prod_img directory on Web Server) of .jpg product image file.  */  
   ImageFileName:string,
   SNFormat:string,
   SNBaseDataType:string,
      /**  This field contains the Intrastat Country of Origin Code from the Country table.  */  
   ISOrigCountry:string,
   Constrained:boolean,
   UPCCode1:string,
   UPCCode2:string,
   UPCCode3:string,
   EDICode:string,
      /**  Indicates if the user chose to skip this record when linking global parts.  The user can come back at a later time and choose to link a skipped part if they need to.  */  
   Skipped:boolean,
   ConsolidatedPurchasing:boolean,
   WebInStock:boolean,
      /**  Indicates how Purchasing Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   PurchasingFactorDirection:string,
      /**  Indicates how Selling Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
   MDPV:number,
   ReturnableContainer:string,
   NetVolume:number,
   RecDocReq:boolean,
   ShipDocReq:boolean,
   QtyBearing:boolean,
   AESExp:string,
   ECCNNumber:string,
   ExpLicNumber:string,
   ExpLicType:string,
   HazClass:string,
   HazGvrnmtID:string,
   HazItem:boolean,
   HazPackInstr:string,
   HazSub:string,
   HazTechName:string,
   HTS:string,
   NAFTAOrigCountry:string,
   NAFTAPref:string,
   NAFTAProd:string,
   SchedBcode:string,
   UseHTSDesc:boolean,
   OwnershipStatus:string,
   RCOverThreshold:number,
   RCUnderThreshold:number,
   RevChargeMethod:string,
   UOMClassID:string,
      /**  This is the ID by which the user will reference a particular serial number format mask.  */  
   SNMask:string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   SNMaskExample:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types.  */  
   SNMaskPrefix:string,
      /**  A standard suffix that will be attached to all serial numbers currently used only by SNBaseStructure Mask types.  */  
   SNMaskSuffix:string,
   LotAppendDate:string,
   LotBatch:boolean,
   LotBeforeDt:boolean,
   LotCureDt:boolean,
   LotDigits:number,
   LotExpDt:boolean,
   LotFirmware:boolean,
   LotHeat:boolean,
   LotLeadingZeros:boolean,
   LotMfgBatch:boolean,
   LotMfgDt:boolean,
   LotMfgLot:boolean,
   LotNxtNum:number,
   LotPrefix:string,
   LotSeqID:string,
   LotUseGlobalSeq:boolean,
   NetVolumeUOM:string,
   NetWeightUOM:string,
   SNLastUsedSeq:string,
   UseMaskSeq:boolean,
   BuyToOrder:boolean,
   DropShip:boolean,
   ExtConfig:boolean,
   IsConfigured:boolean,
   RefCategory:string,
   CSFCJ5:boolean,
   CSFLMW:boolean,
   GrossWeight:number,
   GrossWeightUOM:string,
   BasePartNum:string,
   FSAssetClassCode:string,
   FSPricePerCode:string,
   FSSalesUnitPrice:number,
   RcvInspectionReq:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  ISRegion  */  
   ISRegion:string,
      /**  INChapterID  */  
   INChapterID:string,
      /**  EstimateID  */  
   EstimateID:string,
      /**  EstimateOrPlan  */  
   EstimateOrPlan:string,
      /**  DiffPrc2PrchUOM  */  
   DiffPrc2PrchUOM:boolean,
      /**  DupOnJobCrt  */  
   DupOnJobCrt:boolean,
      /**  PricingFactor  */  
   PricingFactor:number,
      /**  PricingUOM  */  
   PricingUOM:string,
      /**  MobilePart  */  
   MobilePart:boolean,
      /**  AGUseGoodMark  */  
   AGUseGoodMark:boolean,
      /**  AGProductMark  */  
   AGProductMark:boolean,
      /**  CSF Peru -  SUNAT Type  */  
   PESUNATType:string,
      /**  PESUNATUOM  */  
   PESUNATUOM:string,
      /**  DEIsServices  */  
   DEIsServices:boolean,
      /**  DEIsSecurityFinancialDerivative  */  
   DEIsSecurityFinancialDerivative:boolean,
      /**  DEInternationalSecuritiesID  */  
   DEInternationalSecuritiesID:string,
      /**  LinkToContract  */  
   LinkToContract:boolean,
      /**  DEIsInvestment  */  
   DEIsInvestment:boolean,
      /**  DEPayStatCode  */  
   DEPayStatCode:string,
      /**  DEDenomination  */  
   DEDenomination:string,
      /**  PartLengthWidthHeightUM  */  
   PartLengthWidthHeightUM:string,
      /**  DiameterUM  */  
   DiameterUM:string,
      /**  DiameterInside  */  
   DiameterInside:number,
      /**  DiameterOutside  */  
   DiameterOutside:number,
      /**  ThicknessUM  */  
   ThicknessUM:string,
      /**  Thickness  */  
   Thickness:number,
      /**  ThicknessMax  */  
   ThicknessMax:number,
      /**  Durometer  */  
   Durometer:string,
      /**  Specification  */  
   Specification:string,
      /**  EngineeringAlert  */  
   EngineeringAlert:string,
      /**  Condition  */  
   Condition:string,
      /**  IsCompliant  */  
   IsCompliant:boolean,
      /**  IsRestricted  */  
   IsRestricted:boolean,
      /**  IsSafetyItem  */  
   IsSafetyItem:boolean,
      /**  CommercialBrand  */  
   CommercialBrand:string,
      /**  CommercialSubBrand  */  
   CommercialSubBrand:string,
      /**  CommercialCategory  */  
   CommercialCategory:string,
      /**  CommercialSubCategory  */  
   CommercialSubCategory:string,
      /**  CommercialStyle  */  
   CommercialStyle:string,
      /**  CommercialSize1  */  
   CommercialSize1:string,
      /**  CommercialSize2  */  
   CommercialSize2:string,
      /**  CommercialColor  */  
   CommercialColor:string,
      /**  IsGiftCard  */  
   IsGiftCard:boolean,
      /**  PhotoFile  */  
   PhotoFile:string,
      /**  PartPhotoExists  */  
   PartPhotoExists:boolean,
      /**  CommentText  */  
   CommentText:string,
      /**  PartSpecificPackingUOM  */  
   PartSpecificPackingUOM:boolean,
      /**  ImageID  */  
   ImageID:string,
      /**  CNSpecification  */  
   CNSpecification:string,
      /**  SyncToExternalCRM  */  
   SyncToExternalCRM:boolean,
      /**  ExternalCRMPartID  */  
   ExternalCRMPartID:string,
      /**  ExternalCRMLastSync  */  
   ExternalCRMLastSync:string,
      /**  ExternalCRMSyncRequired  */  
   ExternalCRMSyncRequired:boolean,
      /**  PESUNATTypeCode  */  
   PESUNATTypeCode:string,
      /**  PESUNATUOMCode  */  
   PESUNATUOMCode:string,
      /**  CNCodeVersion  */  
   CNCodeVersion:string,
      /**  CNTaxCategoryCode  */  
   CNTaxCategoryCode:string,
      /**  CNHasPreferentialTreatment  */  
   CNHasPreferentialTreatment:boolean,
      /**  CNPreferentialTreatmentContent  */  
   CNPreferentialTreatmentContent:string,
      /**  CNZeroTaxRateMark  */  
   CNZeroTaxRateMark:string,
      /**  SubLevelCode  */  
   SubLevelCode:number,
      /**  User the part was created by  */  
   CreatedBy:string,
      /**  Date the part was created on  */  
   CreatedOn:string,
      /**  AttBatch  */  
   AttBatch:string,
      /**  AttMfgBatch  */  
   AttMfgBatch:string,
      /**  AttMfgLot  */  
   AttMfgLot:string,
      /**  AttHeat  */  
   AttHeat:string,
      /**  AttFirmware  */  
   AttFirmware:string,
      /**  AttBeforeDt  */  
   AttBeforeDt:string,
      /**  AttMfgDt  */  
   AttMfgDt:string,
      /**  AttCureDt  */  
   AttCureDt:string,
      /**  AttExpDt  */  
   AttExpDt:string,
      /**  DeferManualEntry  */  
   DeferManualEntry:boolean,
      /**  DeferPurchaseReceipt  */  
   DeferPurchaseReceipt:boolean,
      /**  DeferJobReceipt  */  
   DeferJobReceipt:boolean,
      /**  DeferInspection  */  
   DeferInspection:boolean,
      /**  DeferQtyAdjustment  */  
   DeferQtyAdjustment:boolean,
      /**  DeferInventoryMove  */  
   DeferInventoryMove:boolean,
      /**  DeferShipments  */  
   DeferShipments:boolean,
      /**  DeferInventoryCounts  */  
   DeferInventoryCounts:boolean,
      /**  DeferAssetDisposal  */  
   DeferAssetDisposal:boolean,
      /**  DeferReturnMaterials  */  
   DeferReturnMaterials:boolean,
      /**  MXProdServCode  */  
   MXProdServCode:string,
      /**  Date/Time when the Part record was last updated.  */  
   ChangedOn:string,
      /**  MXCustomsDuty  */  
   MXCustomsDuty:string,
      /**  SendToFSA  */  
   SendToFSA:boolean,
      /**  ExternalMESSyncRequired  */  
   ExternalMESSyncRequired:boolean,
      /**  ExternalMESLastSync  */  
   ExternalMESLastSync:string,
      /**  FSAItem  */  
   FSAItem:boolean,
      /**  FSAEquipment  */  
   FSAEquipment:boolean,
      /**  BOLClass  */  
   BOLClass:string,
      /**  FairMarketValue  */  
   FairMarketValue:number,
      /**  SAFTProdCategory  */  
   SAFTProdCategory:string,
      /**  AttrClassID  */  
   AttrClassID:string,
      /**  LocationIDNumReq  */  
   LocationIDNumReq:boolean,
      /**  LocationTrackInv  */  
   LocationTrackInv:boolean,
      /**  LocationMtlView  */  
   LocationMtlView:boolean,
      /**  LCNRVReporting  */  
   LCNRVReporting:boolean,
      /**  LCNRVEstimatedUnitPrice  */  
   LCNRVEstimatedUnitPrice:number,
      /**  MXCustomsUMFrom  */  
   MXCustomsUMFrom:string,
      /**  LocationFormatID  */  
   LocationFormatID:string,
      /**  IsServices  */  
   IsServices:boolean,
      /**  PEDetrGoodServiceCode  */  
   PEDetrGoodServiceCode:string,
      /**  PEProductServiceCode  */  
   PEProductServiceCode:string,
      /**  DualUOMClassID  */  
   DualUOMClassID:string,
      /**  CNProductName  */  
   CNProductName:string,
      /**  CNWeight  */  
   CNWeight:number,
      /**  CNWeightUOM  */  
   CNWeightUOM:string,
      /**  CNBonded  */  
   CNBonded:boolean,
      /**  Indicates if inventory for this part is tracked at the attribute level. This feature requires the Advanced Unit of Measure license.  */  
   TrackInventoryAttributes:boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   DefaultAttributeSetID:number,
      /**  Indicates if entry of a County of Origin is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttISOrigCountry:string,
      /**  ExternalSchemeID  */  
   ExternalSchemeID:string,
      /**  ExternalID  */  
   ExternalID:string,
      /**  CommoditySchemeID  */  
   CommoditySchemeID:string,
      /**  CommoditySchemeVersion  */  
   CommoditySchemeVersion:string,
      /**  TrackInventoryByRevision  */  
   TrackInventoryByRevision:boolean,
      /**  PlanningByRevision  */  
   PlanningByRevision:boolean,
      /**  RcvInspectionReqPart  */  
   RcvInspectionReqPart:string,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMPartType  */  
   FSMPartType:number,
      /**  UserChar1  */  
   UserChar1:string,
      /**  UserChar2  */  
   UserChar2:string,
      /**  UserChar3  */  
   UserChar3:string,
      /**  UserChar4  */  
   UserChar4:string,
      /**  UserDate1  */  
   UserDate1:string,
      /**  UserDate2  */  
   UserDate2:string,
      /**  UserDate3  */  
   UserDate3:string,
      /**  UserDate4  */  
   UserDate4:string,
      /**  UserDecimal1  */  
   UserDecimal1:number,
      /**  UserDecimal2  */  
   UserDecimal2:number,
   LinkPartNum:string,
      /**  UserDecimal3  */  
   UserDecimal3:number,
   ProdCodeDescription:string,
      /**  UserDecimal4  */  
   UserDecimal4:number,
   StockPart:boolean,
   TypeCodeDescription:string,
      /**  UserInteger1  */  
   UserInteger1:number,
      /**  UserInteger2  */  
   UserInteger2:number,
   DispPartNum:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_GlbPartTableset{
   GlbPart:Erp_Tablesets_GlbPartRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_PartAttchRow{
   Company:string,
   PartNum:string,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartAuditRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The PartNum of the Part master to which this record is related.  */  
   PartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part.  */  
   RevisionNum:string,
      /**  System Date when this change was made.  */  
   ChangeDate:string,
      /**  System Time (seconds since midnight) of when the changes were made.  */  
   ChangeTime:number,
      /**  UserID who made the changes.  Not maintainable by the user.  */  
   ChangedBy:string,
      /**  Used to enter a description of the changes that were made.  */  
   ChangeDescription:string,
      /**  Alternate Routing method to be used for this revision.  */  
   AltMethod:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
      /**  Display ChangeTime in HH:MM AM format  */  
   DspChangeTime:string,
   BitFlag:number,
   PartNumTrackDimension:boolean,
   PartNumTrackLots:boolean,
   PartNumPartDescription:string,
   PartNumPricePerCode:string,
   PartNumTrackSerialNum:boolean,
   PartNumIUM:string,
   PartNumSalesUM:string,
   PartNumSellingFactor:number,
   RevisionNumRevShortDesc:string,
   RevisionNumRevDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartBinInfoRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Identifies the Part Number. It must be valid in the Part table.  */  
   PartNum:string,
      /**  Contains the Warehouse code of where this part exists. This must be valid in the WareHouse table.  */  
   WarehouseCode:string,
      /**  Identifies the Bin location that contains an Onhand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   BinNum:string,
      /**  Indicates the desired minimum on-hand quantity.  */  
   MinimumQty:number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand.  */  
   MaximumQty:number,
      /**  Safety quantity is a "purchasing cushion" limit.  */  
   SafetyQty:number,
      /**  Uniquely indentifies the record.  */  
   KBCode:string,
      /**  Purchase order number  that the detail line item is linked to.  */  
   KBPONUM:number,
      /**  The line number of the detail record on the purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   KBPOLine:number,
      /**  Kanban Warehouse  */  
   KBWarehouseCode:string,
      /**  Identifies the Bin location that contains an Onhand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   KBBinNum:string,
      /**  Site Identifier. This field cannot be blank.  */  
   KBPlant:string,
      /**  Holds the Quantity onhand for this Part in the warehouse in the specific bin location.  Whenever this quantity becomes zero the record should be deleted. This quantity needs to added to or subtracted from Manufactured receipts, Purchased receipts, Physical inventories, Inventory issues, Warehouse Transfers, Shipping and Adjustments.  */  
   OnhandQty:number,
      /**  Indicates the desired minimum on-hand Kanban quantity.  */  
   KBQty:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
   KBActionCode:string,
   KBActionDesc:string,
      /**  Maximum Quantity UOM  */  
   MaxQtyUOM:string,
      /**  Minimum Quantity UOM  */  
   MinQtyUOM:string,
      /**  Filled in by BO, not phiscally in database.  */  
   Plant:string,
   PlantOwner:string,
      /**  Safety Quantity UOM  */  
   SafetyQtyUOM:string,
   BitFlag:number,
   BinNumDescription:string,
   BinNumNonNettable:boolean,
   KBBinNumDescription:string,
   KBCodeKBDescription:string,
   KBCodeKBActionCode:string,
   KBPlantName:string,
   KBWarehouseCodeDescription:string,
   WarehouseCodeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartCOORow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  CountryNum for Country of Origin  */  
   OrigCountry:number,
      /**  Qty percent of this part which is from this country of origin.  */  
   QtyPerc:number,
      /**  Value percent of this part from this country of origin.  */  
   ValuePerc:number,
      /**  Is this the primary country of origin for this part  */  
   Primary:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   CountryDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartCOPartRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The PartNum field identifies the Part and is used as part of the primary key.  */  
   PartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   RevisionNum:string,
      /**  Companion PartNum identifies the Part that is manufactured along with the main part (ex: Right and Left parts)  */  
   CoPartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the companion part, and is used as part of the primary key  */  
   CoRevisionNum:string,
      /**   Part Per Operation. Active only for Concurrent process
Jobs. Otherwise set to 1.  */  
   PartsPerOp:number,
      /**   Defines an integer value which is used to calculate a
ratio for prorating the labor costs to the end part. For example a job produces parts A and B, and you want part B to have cost 2 times that of the cost of Part A.  Part A CostBase would be 1 and B would be 2.  */  
   LbrCostBase:number,
      /**   Defines an integer value which is used to calculate a
ratio for prorating the material costs to the end part. For example a job produces parts A and B, and you want part B to have cost 2 times that of the cost of Part A.  Part A CostBase would be 1 and B would be 2.  */  
   MtlCostBase:number,
      /**  Describes the Part.  */  
   PartDescription:string,
      /**  Defines the Unit of Measure used when part is issued, this is also how it is stocked.  Use the value from XaSyst.UM as a default when creating new part records.  */  
   IUM:string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   AltMethod:string,
      /**  If true, MRP will not generate change suggestions for the co-part  */  
   PreventSugg:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Indicates if the parent Part should be used as the primary costing method for the co-part  */  
   PrimaryCost:boolean,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
   EnablePreventSugg:boolean,
   PartMasterPart:boolean,
   ProcessMode:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartDimRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The PartNum field identifies the Part.  */  
   PartNum:string,
      /**  Unique dimension code for the part.  */  
   DimCode:string,
      /**  Description for the dimension code.  */  
   DimCodeDescription:string,
      /**  Dimension unit of measure. Cannot be blank. Defaults to part's unit of measure.  */  
   DUM:string,
      /**   Dimension conversion factor.  This conversion factor is used to convert the qty to the base part unit of measure.
Example: A half sheet to full sheet conversion factor would be 2 and a double sheet to full sheet conversion factor would be 0.5.  */  
   DimConvFactor:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Default Dimenision for this part.  */  
   DefaultDim:boolean,
   BitFlag:number,
   PartNumTrackLots:boolean,
   PartNumIUM:string,
   PartNumSalesUM:string,
   PartNumSellingFactor:number,
   PartNumPartDescription:string,
   PartNumTrackDimension:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumPricePerCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartGetDMRListRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  DMR Number to identify the DMR record.  Auto assign/increment starting at 1000.  Cannot be blank.  */  
   DMRNum:number,
      /**  DMR Open or Close flag.  Default value is TRUE.  User cannot close a DMR with quantity remaining on it.  */  
   OpenDMR:boolean,
      /**  Vendor Purchase Point.  Maintainable only if NOT attached to a receipt.  */  
   PurPoint:string,
      /**  The total amount of discrepant material moved into the DMR in base inventory unit of measure(IUM).  */  
   TotDiscrepantQty:number,
      /**  The total amount of rejected material from this DMR in base inventory unit of measure(IUM).  */  
   TotRejectedQty:number,
      /**  The total amount of accepted material that was accepted from this DMR in base inventory unit of measure(IUM).  */  
   TotAcceptedQty:number,
      /**  Average Material Unit Cost.  */  
   AvgMtlUnitCost:number,
      /**  Average Labor Unit cost.  */  
   AvgLbrUnitCost:number,
      /**  Average Burden unit cost.  */  
   AvgBurUnitCost:number,
      /**  Average Subcontract unit cost  */  
   AvgSubUnitCost:number,
      /**  Average Mtl Burden unit cost  */  
   AvgMtlBurUnitCost:number,
      /**  Parrt Number  */  
   PartNum:string,
      /**  Describes the Part.  System maintained, not user modifiable.  */  
   PartDescription:string,
      /**  Unique dimension code for the part.  Set from the receipt or must match a referenced receipt's dimension.  NOT user modifiable.  */  
   DimCode:string,
      /**  Lot Number for this DMR to be received into.  Set from the receipt or must match a referenced receipt's lot number.  NOT user modifiable.  */  
   LotNum:string,
      /**  Base Inventory Unit of Measure.  System maintained, not user modifiable.  */  
   IUM:string,
      /**  Job Number.  Associates the assembly record back its parent JobHead record.  Not directly maintainable.  */  
   JobNum:string,
      /**  A sequence number that uniquely identifies the JobAsmbl record within the JobNum.  This can be user assigned or assigned by the system.  The system assigns the next available number during add mode if its left blank.  */  
   AssemblySeq:number,
      /**  A sequence number that uniquely defines the Material (JobMtl) record within a specific Job/Assembly.  This is system assigned.  The next available number is determined by reading last JobMtl record on the Job/Assembly and then adding ten to it.  */  
   MtlSeq:number,
      /**  A sequence number which uniquely identifies the operation record within the Job/lot/level. The sequence can be system generated or assigned by user. System generated numbers are determined by reading last JobOper for the job/lot/level and then figures out what the next number that is divisible by 10. If this number is within 3 of the last Number on file it will be bumped up another 10. This keeps a minimum of 2 available sequences between records. For example if last = 18 Next would be 30, If last = 17  next = 20.  */  
   OprSeq:number,
      /**  The ID of the Resource that was used to do the work. This field will be used to run reports using LaborDtl records to show how much work has been done on a specific Resource. This ID is directly entered in labor entry and Labor collection. It is only prompted for if the JcSyst.MachinePrompt = Yes/  */  
   ResourceID:string,
      /**  Contains the Warehouse code of where this part exists. This must be valid in the WareHouse table.  */  
   WarehouseCode:string,
      /**  Identifies the Bin location that contains an On hand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   BinNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part.  */  
   RevisionNum:string,
      /**  Total Mtl Mtl unit cost to date.  */  
   MaterialMtlCost:number,
      /**  Total Mtl Lab unit cost to date  */  
   MaterialLabCost:number,
      /**  Total Mtl Sub unit cost to date  */  
   MaterialSubCost:number,
      /**  Total Material  Bur unit component cost to date  */  
   MaterialBurCost:number,
      /**  Indicates this requires a Vendor RMA number  */  
   ReqDMR:boolean,
      /**  Vendors RMA number.  Defaults to DMR Number.  */  
   VendRMANum:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Plant  */  
   Plant:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  PCID  */  
   PCID:string,
      /**  Warehouse Description  */  
   WarehouseCodeDescription:string,
   PlantName:string,
   QtyRemaining:number,
   SupplierName:string,
   DynAttrValueSetDescription:string,
   DynAttrValueSetShortDescription:string,
   PartNumIUM:string,
   PartNumTrackDimension:boolean,
   PartNumSellingFactor:number,
   PartNumPartDescription:string,
   PartNumTrackSerialNum:boolean,
   PartNumTrackInventoryAttributes:boolean,
   PartNumTrackLots:boolean,
   PartNumAttrClassID:string,
   PartNumPricePerCode:string,
   PartNumSalesUM:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartGetDMRListTableset{
   PartGetDMRList:Erp_Tablesets_PartGetDMRListRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_PartLangDescRow{
      /**  Language ID  */  
   LangNameID:string,
      /**  The PartNum field identifies the Part and is used as the primary key.  */  
   PartNum:string,
      /**  Description  */  
   Description:string,
      /**  Company Identifier.  */  
   Company:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   LangNameIDDescription:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartListRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  An abbreviated part description field by which the user can search the Part file. In Part maintenance the Search Word is to only be updated upon initial creation of the Part with the first 8 bytes of the Part.Description.  */  
   SearchWord:string,
      /**  Describes the Part.  */  
   PartDescription:string,
      /**   The Inventory class that this Part belongs to. The Class field can be blank or must be valid in the PartClass master file.
Classes could be set up for different type of raw materials. It will primarily be used as a report selection parameter.  */  
   ClassID:string,
      /**  Primary Inventory Unit of Measure. The unit costs, are based on this uom. Used as a default for issue transactions for the part.  Part onhand and allocation quantities are tracked by this uom.  The quantities can also be tracked by other uoms (see PartUOM table) but tracking at this uom is mandatory.   Use UOMClass.DefUOMCode of the system default UOMClass  when creating new part records (see XASyst.DefUOMClassID).  */  
   IUM:string,
      /**  The Purchasing Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Purchase Order entry as the default on line item details.  */  
   PUM:string,
      /**   Classifies Parts into the following...
M = Manufactured Part.
P = Purchased Part.
K = Sales Kit Part.B = Planning BOM.
This type code does limit referencing any part in any way. For example a type "P" can be entered on a sales order, or a type "M" can be referenced in a Purchase Order.
This field will also be used as a selection parameter in certain reports, such as Time Phase Requirements.  */  
   TypeCode:string,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   NonStock:boolean,
      /**  Product Group ID for the Part. This can be blank or must be valid in the ProdGrup file.  This will be used for report sorting and selection. Also as a default in order entry, invoice entry and job entry.  */  
   ProdCode:string,
      /**   Flag which indicates if the Part Master is considered as "Inactive".
This flag will be used to exclude parts from certain searches and reports.  */  
   InActive:boolean,
      /**  An internal flag which indicates that this part contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   Method:boolean,
      /**  Indicates if Lot numbers are prompted for in transactions for this part.  Backflushing and AutoReceiving functions are ignored when TrackLots = Yes.  */  
   TrackLots:boolean,
      /**   Onhand quantity is always tracked in the Parts primary inventory uom (Part.IUM). Checking this box indicates that you want to allow tracking of onhand quantity by additional uoms.
The actual UOMs to be tracked for the part are indicated by PartUOM.TrackOnHand. In order to set the PartUOM.TrackOhHand = True the Part.TrackDimension must = true.
This replaces the old 8.3 Track Dimension feature  */  
   TrackDimension:boolean,
      /**  Indicates if this part is serial number tracked  */  
   TrackSerialNum:boolean,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   PhantomBOM:boolean,
      /**  Indicates that the part is on hold.  This feature can be used to indicate that a new part is not yet approved, that it is being phased out, has a quality issue, etc.  Further demands/supplies of this part should not be made. Similar to an "Inactive" part. However at the moment it still may have an onhand balance, supply and demands and will be reflected in stock status reporting.  */  
   OnHold:boolean,
      /**  Indicates a Quantity Bearing part. Works in conjunction with the Non-Stock field to enable the part master parts to be setup for expense items.  Quantity Bearing will be set to Yes by default and only enable to be set to No if the Non-Stock flag is Yes.  */  
   QtyBearing:boolean,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotBatch:boolean,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgBatch:boolean,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgLot:boolean,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotHeat:boolean,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotFirmware:boolean,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotBeforeDt:boolean,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgDt:boolean,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotCureDt:boolean,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotExpDt:boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttBatch:string,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgBatch:string,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgLot:string,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttHeat:string,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttFirmware:string,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttBeforeDt:string,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgDt:string,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttCureDt:string,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttExpDt:string,
      /**  ID of related Attribute Class.  */  
   AttrClassID:string,
      /**  Indicates if inventory for this part is tracked at the attribute level. This feature requires the Advanced Unit of Measure license.  */  
   TrackInventoryAttributes:boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   DefaultAttributeSetID:number,
      /**  If this Part is TrackInventoryAttributes = true, and the AttrClassID it is associated to has one or more attributes whose DynAttrClassDtl.UsedInPlanning= true.  */  
   HasMRPPlanningAttribute:boolean,
      /**  Indicates if inventory for this part is tracked by revision number.  */  
   TrackInventoryByRevision:boolean,
      /**  Optional field that contains the customers revision. Default from the PartRev.RevisionNum field.  */  
   RevisionNum:string,
   DynAttrValueSetDescription:string,
   DynAttrValueSetShortDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartListTableset{
   PartList:Erp_Tablesets_PartListRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_PartPCRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**   Identifies the type of product code. This value can be used to find a Product code for a specific PartNum/ Type/UOM combination.
Currentlt the following types are valid;
"UPC-12,EAN-13,EAN-14,EAN-8,GTIN-14" 
This is for reference only and performs not other function.  */  
   PCType:string,
      /**  Product Group code  */  
   ProdCode:string,
      /**  Unit of Measure code that will be defaulted in when this Product Code is used. Must be a Unit of measure that is valid within the Parts UOMClass.  */  
   UOMCode:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartPlanningPoolRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Part Number.  */  
   PartNum:string,
      /**  Pool Part Number.  */  
   PoolPartNum:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
   PartNumTrackLots:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   PartNumSalesUM:string,
   PartNumPartDescription:string,
   PartNumIUM:string,
   PartNumTrackInventoryAttributes:boolean,
   PartNumPricePerCode:string,
   PartNumSellingFactor:number,
   PartNumAttrClassID:string,
   PoolPartNumPartDescription:string,
   PoolPartNumAttrClassID:string,
   PoolPartNumTrackDimension:boolean,
   PoolPartNumTrackLots:boolean,
   PoolPartNumTrackSerialNum:boolean,
   PoolPartNumTrackInventoryAttributes:boolean,
   PoolPartNumSalesUM:string,
   PoolPartNumIUM:string,
   PoolPartNumPricePerCode:string,
   PoolPartNumSellingFactor:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartPlantPlanningAttributeRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The PartNum field identifies the Part and is used in the primary key.  */  
   PartNum:string,
      /**  Site Identifier. This field cannot be blank  */  
   Plant:string,
      /**  ID of related Attribute Class.  */  
   AttrClassID:string,
      /**  The unique identifier of the Dynamic Attribute Planning Set.  */  
   PlanningAttributeSetSeq:number,
      /**  Hash key of the Company, AttrClassID, Planning Attributes and Planning Attribute Values.  */  
   PlanningAttributeSetHash:string,
      /**  Indicates the desired minimum on-hand quantity. This is used by the time phase requirements report when user requests to show any parts that will or have fallen below this level. It is also used as a selection parameter for the inventory reorder report. This is an optional field.  */  
   MinimumQty:number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand. This field is used as a selection option by the inventory reorder report to show all parts that are over this limit. This field is optional.  */  
   MaximumQty:number,
      /**  Safety quantity is a "purchasing cushion" limit. It's the amount you would need to have to cover your requirements until a shipment arrives from the vendor. If your on-hand quantity falls below this limit it means that there is a good chance that you will run out of material before the next shipment arrives. This value is used by the inventory reorder report and the time phase report. It is an optional field.  */  
   SafetyQty:number,
      /**  Used to establish a suggested Order Qty when purchasing this Part for this Site. This value will be shown on the time phase report.  */  
   MinOrderQty:number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   LeadTime:number,
      /**  Number of Vendor master that this part is normally purchased from. The Purchase Order Management module uses it.  used in suggested vendor analysis.  */  
   VendorNum:number,
      /**  Default Vendor purchase point ID.  */  
   PurPoint:string,
      /**  This is the minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   MinMfgLotSize:number,
      /**  This is the maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   MaxMfgLotSize:number,
      /**  This is the manufacturing lot size multiple.  MRP will create jobs in multiples of this field.  Any excess amount will be sent to stock.  Zero is no lot multiple (lot-for-lot).  Example:  Required Quantity = 500, Lot Multiple = 150, Lot Maximum = 450, 2 jobs will be created with production quantities of 450, and 150.  */  
   MfgLotMultiple:number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   DaysOfSupply:number,
      /**  This is the flag indicating the inventory level we need to bring up to when it falls below re-order point(safety + minimum). Valid values are MAX and MIN.  */  
   ReOrderLevel:boolean,
      /**  Number of days forward to capture SugPODtl records for transfer as Forecast records.  Only for Intercompany trading partners.  */  
   ForecastTime:number,
      /**  Default Site that part is transfered from when it is obtained via Site transfer.  */  
   TransferPlant:string,
      /**  Used to record the normal order lead time for a Part from the transfer Site to this Site. This value is represented in days. It is optional.  */  
   TransferLeadTime:number,
      /**  Number of days out that the ShortHorizonMinMfgLotSize and ShortHorizonMaxMfgLotSize will be used instead of MinLotSize and MaxLotSize.  */  
   ShortHorizonDays:number,
      /**  This is the Short Horizon minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   ShortHorizonMinMfgLotSize:number,
      /**  This is the Short Horizon maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   ShortHorizonMaxMfgLotSize:number,
      /**  Used to record the short horizon order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   ShortHorizonDaysSupp:number,
      /**  Auto consume available stock when MRP runs and creates a job.  */  
   AutoConsumeStock:boolean,
      /**  Start the minimum lot quantity for a job when there is enough quantity to do so.  If enough quantity is available for the minimum lot quantity, the job will be split - one job for the quantity that can be started, another job for the remaining quantity.  Used when MRP creates jobs.  */  
   StartMinLotQty:boolean,
      /**  The lead time to consider for constrained materials when determining if a quantity can be started on a job.  Applicable when StartMinLotQty is true.  */  
   MinLotLeadTime:number,
      /**  Indicates the minumum quantity that can be started when splitting a job.  Used when the StartMinLotQty option is selected.  */  
   MinStartQty:number,
      /**  This is the lead time used when generating a new suggestion within the lead time window.  If this field is 0 and the Supplier is determined from the Supplier Price List, the suggestion will use the lead time from the price list.  */  
   UrgentLeadTime:number,
      /**  This is the minimum qty required when generating a new suggestion within the lead time window.  */  
   UrgentMinOrdQty:number,
      /**  This is used to calculate the suggestion qty to the nearest multiple when generating a new suggestion within the lead time window.  */  
   UrgentMultQty:number,
      /**  See UrgentVendorNum  */  
   UrgentPurPoint:string,
      /**  If this field is not populated then the system will use the standard Supplier from PartPlant, or the last Supplier the part was purchased from, or the Supplier from the first Price list found for the part.  */  
   UrgentVendorNum:number,
      /**  Indicates the normal source for this part in the Site.  Values are: M = Manufactured, P = Purchased, T = Transferred.  Initial default is base on Part.TypeCode.  */  
   SourceType:string,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
      /**  Number of days before the forecast date in which any sales orders that exist should reduce the forecast quantity.  Ex: Forecast date of 3/31/98, Days before of 10, then any orders that have a date of 3/21/98 to 3/31/98 would reduce forecast.  */  
   ForecastDaysBefore:number,
      /**  Number of days after the forecast date in which any sales orders that exist should reduce the forecast quantity.  Ex: Forecast date of 3/31/98, Days after of 10, then any orders that have a date of 4/01/98 to 4/10/98 would reduce the forecast.  */  
   ForecastDaysAfter:number,
      /**  Description of the Planning Attribute Set  */  
   PlanningAttributeSet:string,
      /**  Base UOM Code from Part Master  */  
   BaseUOMCode:string,
      /**  Name of Urgent Supplier  */  
   UrgentVendorName:string,
      /**  ID of Supplier.  */  
   UrgentVendorVendorID:string,
      /**  Indicates no planning attribute parameters have been entered and will default from PartPlant.  */  
   UseSite:boolean,
      /**  Number of Pieces for MaximumQty  */  
   MaximumQtyNofP:number,
      /**  Number of Pieces for MinimumQty  */  
   MinimumQtyNofP:number,
   QtyDisplayOption:string,
      /**  Number of Pieces for MaxMfgLotSize  */  
   MaxMfgLotSizeNofP:number,
      /**  Number of Pieces for MfgLotMultiple  */  
   MfgLotMultipleNofP:number,
      /**  Number of Pieces for MinMfgLotSize  */  
   MinMfgLotSizeNofP:number,
      /**  Number of Pieces for MinOrderQty  */  
   MinOrderQtyNofP:number,
      /**  Number of Pieces for MinStartQty  */  
   MinStartQtyNofP:number,
      /**  Number of Pieces for SafetyQty  */  
   SafetyQtyNofP:number,
      /**  Number of Pieces for ShortHorizonMaxMfgLotSize  */  
   ShortHorizonMaxMfgLotSizeNofP:number,
      /**  Number of Pieces for ShortHorizonMinMfgLotSize  */  
   ShortHorizonMinMfgLotSizeNofP:number,
      /**  Number of Pieces for UrgentMinOrdQty  */  
   UrgentMinOrdQtyNofP:number,
      /**  Number of Pieces for UrgentMultQty  */  
   UrgentMultQtyNofP:number,
      /**  If true, then the planning set is not valid for the part.  */  
   InvalidPlanningSet:boolean,
      /**  The reason why the planning set is invalid.  */  
   InvalidPlanningSetReason:string,
   BitFlag:number,
   AttrClassIDDescription:string,
   PartAttrClassID:string,
   PartPartDescription:string,
   PartTrackSerialNum:boolean,
   PartIUM:string,
   PartTrackLots:boolean,
   PartPricePerCode:string,
   PartTrackDimension:boolean,
   PartSellingFactor:number,
   PartSalesUM:string,
   PartTrackInventoryAttributes:boolean,
   PlanningAttributeSetSeqActive:boolean,
   PlantName:string,
   TransferPlantName:string,
   VendorNumName:string,
   VendorNumVendorID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartPlantRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Site Identifier. This field cannot be blank.  */  
   Plant:string,
      /**  The PartNum field identifies the Part and is used in the primary key.  */  
   PartNum:string,
      /**  Defines which warehouse is to be used as the Primary Warehouse for this part in this Site. A primary warehouse is the one that this part is most commonly found in.  This warehouse is used as the default in many programs, such as entry of sales order line  */  
   PrimWhse:string,
      /**  Indicates the desired minimum on-hand quantity. This is used by the time phase requirements report when user requests to show any parts that will or have fallen below this level. It is also used as a selection parameter for the inventory reorder report. This is an optional field.  */  
   MinimumQty:number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand. This field is used as a selection option by the inventory reorder report to show all parts that are over this limit. This field is optional.  */  
   MaximumQty:number,
      /**   Safety quantity is a "purchasing cushion" limit. It's the amount you would need to have to cover your requirements until a shipment arrives from the vendor. If your on-hand quantity falls below this limit it means that there is a good chance that you will run out of material before the next shipment arrives. This value is used by the inventory reorder report and the time phase report. It is an optional field.
Note: Safety + Minimum = Reorder Point...  using this formula the  reorder point is the amount at which to reorder to maintain at least the prescribed minimum quantity.  */  
   SafetyQty:number,
      /**  Used to establish a suggested Order Qty when purchasing this Part for this Site. This value will be shown on the time phase report.  */  
   MinOrderQty:number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   LeadTime:number,
      /**  Number of Vendor master that this part is normally purchased from. The Purchase Order Management module uses it.  used in suggested vendor analysis.  */  
   VendorNum:number,
      /**  Default Vendor purchase point ID.  */  
   PurPoint:string,
      /**  Indicates if this part should be backflushed for this Site. Backflushing is the process of automatically issuing the material to jobs based on the operation quantity completed.  When completed and scrap quantities are reported to a job operation (via labo  */  
   BackFlush:boolean,
      /**  This is the lot size that is used when performing a BOM cost rollup to distribute setup costs.  */  
   MfgLotSize:number,
      /**  This is the minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   MinMfgLotSize:number,
      /**  This is the maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   MaxMfgLotSize:number,
      /**  This is the manufacturing lot size multiple.  MRP will create jobs in multiples of this field.  Any excess amount will be sent to stock.  Zero is no lot multiple (lot-for-lot).  Example:  Required Quantity = 500, Lot Multiple = 150, Lot Maximum = 450, 2 jobs will be created with production quantities of 450, and 150.  */  
   MfgLotMultiple:number,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   DaysOfSupply:number,
      /**  This is the flag indicating the inventory level we need to bring up to when it falls below re-order point(safety + minimum). Valid values are MAX and MIN.  */  
   ReOrderLevel:boolean,
      /**  System maintained field.  Indicates that MRP needs to be recalculated for this part/Site.  */  
   MRPRecalcNeeded:boolean,
      /**  Flag indicating if MRP should process this part.  */  
   ProcessMRP:boolean,
      /**  Flag indicating if PO suggestion should be generated for this part.  */  
   GenerateSugg:boolean,
      /**  This flag controls if a supply is always created in this Site for a part. If it is no then the default Site that provides a supply is from a part's product group unless the Site from product group is blank, in that case the default Site should be from the  */  
   GetFromLocalWhse:boolean,
      /**  Number of days forward to capture SugPODtl records for transfer as Forecast records.  Only for Intercompany trading partners  */  
   ForecastTime:number,
      /**  Default Site that part is transfered from when it is obtained via Site transfer.  */  
   TransferPlant:string,
      /**   Indicates the normal source for this part in the Site.
Values are; K = Sales Kit,M = Manufactured,P = Purchased,T = Transferred.B = Planning BOM. 
Initial default is base on Part.TypeCode.  */  
   SourceType:string,
      /**  Used to record the normal order lead time for a Part from the transfer Site to this Site. This value is represented in days. It is optional.  */  
   TransferLeadTime:number,
      /**  Used to determine the start date  */  
   PrepTime:number,
      /**  Days needed to move part to stock or next job.  Deducted from Due Date.  */  
   ReceiveTime:number,
      /**  Days out from the current date when dates on jobs, PO, TO cannot be changed  */  
   PlanTimeFence:number,
      /**  MRP parameter not to reschedule if number of days change below  */  
   ReschedOutDelta:number,
      /**  Same as ReschedOutDelta but for messages  */  
   ReschedInDelta:number,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   NonStock:boolean,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   PhantomBOM:boolean,
      /**  Identifies the Buyer for the part class. Used as the default in the Automated Purchasing process.  */  
   BuyerID:string,
      /**   Identifies the Person to be used as the default Production Planner. This person is responsible for handling  the manufacturing suggestions of parts in this Product Group.
Used as the default for "new" manufacturing suggestions and on Job Header. Manufacturing suggestions can be filtered by Planner.
Relates to the Person table.  */  
   PersonID:string,
      /**  Defines the Costing method to be associated with this Part. Use the XaSyst.CostMethod as a default.  When a unit cost is retrieved from the Part file the programs will use this field to determine which one of the Four sets of cost fields should be used.  A = Use Average L= Use Last S = Use Standard T = Use Avg by lot(not found in XaSyst).  */  
   CostMethod:string,
      /**  Alternate Routing method to be used for this Part/Site  */  
   AltMethod:string,
      /**  For Manufactured Parts to determine the Due date of the material  */  
   KitTime:number,
      /**  Indicates if kit component lines can be added, deleted and modified during Sales Order and Quote entry.  */  
   KitAllowUpdate:boolean,
      /**  Indicates if the parent kit part must be shipped complete or if kit components can be shipped in varying degrees of completeness.  If this field is set to "No", then KitPricing must be set to "P" .  */  
   KitShipComplete:boolean,
      /**  Indicates if changes the kit parameters is allowed during Sales Order and Quote entry.  */  
   KitAllowChangeParms:boolean,
      /**  Indicates if all components are to be backflushed when a kit parent item is shipped.  */  
   KitBackFlush:boolean,
      /**  Indicates how kits will be priced.  Values are: P = Kit Parent Pricing (The price is obtained from the sales price for the kit parent item), C = Component Pricing (The price is obtained from a rollup of kit component items).  */  
   KitPricing:string,
      /**  Indicates if kit components are to be printed on packing slips.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  */  
   KitPrintCompsPS:boolean,
      /**  Indicates if kit components are to be printed on invoices.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  */  
   KitPrintCompsInv:boolean,
      /**  Number of days out that the ShortHorizonMinMfgLotSize and ShortHorizonMaxMfgLotSize will be used instead of MinLotSize and MaxLotSize.  */  
   ShortHorizonDays:number,
      /**  This is the Short Horizon minimum manufacturing lot size.  If the required quantity is less than this amount then MRP will create a job with this production quantity.  The excess amount will be sent to stock.  Zero is no minimum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  */  
   ShortHorizonMinMfgLotSize:number,
      /**  This is the Short Horizon maximum manufacturing lot size.  If the required quantity is greater than this amount then MRP will create additional job(s) to satisfy the required production quantity.  Zero is no maximum.  If nonzero, this field must be an even multiple of the MfgLotMultiple field.  Example:  Required Quantity = 500, Maximum Lot Size = 150, 4 jobs will be created with production quantities of 150, 150, 150, and 50.  */  
   ShortHorizonMaxMfgLotSize:number,
      /**  If set = true and the production yield is being recalculated for an assembly or any of its subassemblies, then the recalculation and quantity adjustments will stop at the assembly level and reduce the overrun quantity and if necessary adjust the PullQty rather than rolling up to its parent  */  
   LimitProdYldRecalc:boolean,
      /**  Sets the default for Part.QtyBearing. The Part.QtyBearing fields works in conjunction with the Part.Non-Stock field to enable the part master parts to be setup for expense items.  */  
   QtyBearing:boolean,
      /**  System date on which the last MRP processing was run.  */  
   MRPLastRunDate:string,
      /**  System Time (hr-min-sec) when the last MRP process was run.  */  
   MRPLastRunTime:number,
      /**  Scheduled Date used in last MRP run  */  
   MRPLastScheduledDate:string,
      /**  Cut Off Date used in last MRP run  */  
   MRPLastCutOffDate:string,
      /**  Used to record the short horizon order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   ShortHorizonDaysSupp:number,
      /**  If the SNBaseDataType is Mask this is the Serial Mask ID assigned for format validation/generation.  */  
   SNMask:string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   SNMaskExample:string,
      /**   Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer, Mask
Code/desc required:
CHARACTER`Alphanumeric
INTEGER`NumericOnly
MASK`Serial Mask
This field should be flagged as Include = true in Object Designer.  */  
   SNBaseDataType:string,
      /**   Current setting for Format of the Base serial number that will be used as new serial numbers are generated. Expressed in progress syntax. Ex: X(30), 99999999 for Character or Integer, or as a Serial Mask defined in SerialMask table.
This field should be flagged as ReadOnly and Include = true in Object Designer.  */  
   SNFormat:string,
      /**   Current setting for the prefix that will be attached to all new Serial Numbers as they are generated for Character and Integer format types.
This field should be flagged as Include = true in Object Designer.  */  
   SNPrefix:string,
      /**  A standard suffix that will be attached to all serial numbers generated for the PartSite currently used only by SNBaseStructure Mask types  */  
   SNMaskSuffix:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types  */  
   SNMaskPrefix:string,
      /**  This is the last used serial sequence. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It can be altered by the user and several PartSites can have the same counter values defined, but  */  
   SNLastUsedSeq:string,
      /**  Indicates to use the value in SerialMask.SNLastUsedSeq when generating the next serial number for a Generate Mask type.  */  
   UseMaskSeq:boolean,
      /**  This flag identifies those parts that will suggest a PO each time than a sales order is created. This flag will be used as a default in the sales order.  */  
   BuyToOrder:boolean,
      /**  This flag identifies those parts that are commonly drop shipped. This flag will be used as a default in the sales order.  */  
   DropShip:boolean,
      /**  Percent Tolerance. Entered as a positive number, Used to define the default percent tolerance for parts for which no percent tolerance is set up in PartWhse. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a percentage difference between the count quantity and the frozen quantity by more than the percent tolerance figure is considered out of tolerance. Calculated as ?adjustment qty / frozen qty? expressed as a percent.  */  
   PcntTolerance:number,
      /**  False = there is no percent tolerance consideration and any percent variance is considered within tolerance. True = percent tolerance is active for this part/Site and the value in PcntTolerance will be used to determine if the count variance is within tol  */  
   CalcPcnt:boolean,
      /**  False = there is no quantity tolerance consideration and any quantity variance is considered within tolerance. True = quantity tolerance is active for this part/Site and the value in QtyTolerance will be used to determine if the count variance is within t  */  
   CalcQty:boolean,
      /**  False = there is no value tolerance consideration and any value variance is considered within tolerance. True = value tolerance is active for this part/Site and the value in ValueTolerance will be used to determine if the count variance is within toleranc  */  
   CalcValue:boolean,
      /**  Used to provide a means to control whether a count quantity discrepancy should be posted as an adjustment to inventory. This value is used for parts for which no qty adj tolerance is set up in PartWhse. Zero indicates all quantity adjustments will be posted. This parameter is used to control the count discrepancy of parts that are counted by weight on a scale. Counts often vary based upon humidity. If the count of the part is within this tolerance but different from the frozen quantity then no inventory adjustment will be posted.  */  
   QtyAdjTolerance:number,
      /**  Quantity tolerance. Entered as a positive whole number, Used to define the default quantity tolerance for parts for which no quantity tolerance is set up in PartWhse. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a count quantity that varies from the frozen quantity by more than the quantity tolerance figure is considered out of tolerance.  */  
   QtyTolerance:number,
      /**  Value tolerance. Entered as a positive number. Used to define the default value tolerance for parts for which no value tolerance is set up in PartWhse, PartSite, WarehseABC or SiteConfABC  An entry of zero will indicate that any value variance will be con  */  
   ValueTolerance:number,
      /**  This is a summary of the total outstanding manufacturing allocation requirements for this Part in this Site.  It is updated from Order Release records that are being manufactured. The outstanding  Sales Order Requirements is calculated from Open ORderRel  */  
   DemandQty:number,
      /**  This is a summary of the total outstanding manufacturing requirements for this Part in this Site.  It is updated from Order Release records that are being manufactured. The outstanding  Sales Order Requirements is calculated from Open ORderRel records as  */  
   ReservedQty:number,
      /**  This is a summary of the total outstanding job allocation requirements for this Part in this Site.  */  
   AllocatedQty:number,
      /**  Cross Reference Part Number  */  
   XRefPartNum:string,
      /**  Cross Reference Part Type  */  
   XRefPartType:string,
      /**  System flag future use  */  
   NeverReuseMRPJob:boolean,
      /**  Flag indicates the need to delete unfirm Jobs even if MRP is run with the recycle job option  */  
   DeleteMRPJobs:boolean,
      /**  System calculated manufacturing lead time.  This is the total lead time needed to generate the part, which includes the time on lower level parts, lead times, etc.  Not editable by the user.  */  
   TotMfgLeadTimeSys:number,
      /**  Manually entered manufacturing lead time.  This is the total lead time needed to generate the part.  Directly maintained by the user.  */  
   TotMfgLeadTimeMnl:number,
      /**  Displays the manufacturing lead time calculated by the system. This is the lead time required to manufacture the part at the level of this part, it includes the time to manufacture the subassemblies in the same job (Pull as Assembly materials). The user cannot edit this value.  */  
   LvlMfgLeadTimeSys:number,
      /**  Displays the manufacturing lead time calculated by the system. This is the lead time required to manufacture the part at the level of this part, it includes the time to manufacture the subassemblies in the same job (Pull as Assembly materials). Directly maintained by the user.  */  
   LvlMfgLeadTimeMnl:number,
      /**  The date the system manufacturing lead times (TotMfglLeadTimeSys and LvlMfgLeadTimeSys) were calculated.  */  
   MfgLeadTimeCalcDate:string,
      /**  The date the manual manufacturing lead times (TotMfgLeadTimeSys and LvlMfgLeadTimeSys) were entered by the user.  */  
   MfgLeadTimeMnlDate:string,
      /**  Auto consume available stock when MRP runs and creates a job.  */  
   AutoConsumeStock:boolean,
      /**  Start the minimum lot quantity for a job when there is enough quantity to do so.  If enough quantity is available for the minimum lot quantity, the job will be split - one job for the quantity that can be started, another job for the remaining quantity.  Used when MRP creates jobs.  */  
   StartMinLotQty:boolean,
      /**  The lead time to consider for constrained materials when determining if a quantity can be started on a job.  Applicable when StartMinLotQty is true.  */  
   MinLotLeadTime:number,
      /**  Indicates manufacturing lead times are entered manually by the user.  */  
   MfgLeadTimeMnl:boolean,
      /**  Userid of user who entered manual manufacturing lead times.  */  
   MfgLeadTimeEnteredBy:string,
      /**  Indicates the minumum quantity that can be started when splitting a job.  Used when the StartMinLotQty option is selected.  */  
   MinStartQty:number,
      /**  Raw Material  */  
   RawMaterial:boolean,
      /**  Available for stock manufactured parts.  Indicates if capable to promise considers sub-assemblies when determining the capable to promise date.  When false, capable to promise only looks at ATP for the capable to promise part - subassemblies are not considered.  */  
   MultiLevelCTP:boolean,
      /**  Indicates if  Inspection is required for items received from this vendor.  Inspection will also be enforced if the related PartClass, Vendor, Podetail, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   RcvInspectionReq:boolean,
      /**  Indicates if MRP should allow consumption of safety stock within the purchase lead time  */  
   ConsumeSafety:boolean,
      /**  Number of Alternate Vendor master that this part can be purchased from with short lead times. The Purchase Order will be generated for this supplier when suggestions fall within the purchasing lead time and the projected supply drops below safely.  */  
   SLTVendorNum:number,
      /**  Default Vendor purchase point ID.  */  
   SLTPurPoint:string,
      /**  Used to record the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   ShortLeadTime:number,
      /**  Indicates the record is used with Machine MES  */  
   ExternalMES:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  This is the lead time used when generating a new suggestion within the lead time window.  If this field is 0 and the Supplier is determined from the Supplier Price List, the suggestion will use the lead time from the price list.  */  
   UrgentLeadTime:number,
      /**  This is the minimum qty required when generating a new suggestion within the lead time window.  */  
   UrgentMinOrdQty:number,
      /**  This is used to calculate the suggestion qty to the nearest multiple when generating a new suggestion within the lead time window.  */  
   UrgentMultQty:number,
      /**  See UrgentVendorNum  */  
   UrgentPurPoint:string,
      /**  If this field is not populated then the system will use the standard Supplier from PartPlant, or the last Supplier the part was purchased from, or the Supplier from the first Price list found for the part.  */  
   UrgentVendorNum:number,
      /**  PartRunMRP  */  
   PartRunMRP:boolean,
      /**  LinkToContract  */  
   LinkToContract:boolean,
      /**  Indicates if this part will be excluded in the Inventory Min/Max/Safety calculation.  */  
   MMSExclude:boolean,
      /**  Indicates if sales history for this part will be included in the Inventory Min/Max/Safety calculation.  */  
   MMSSales:boolean,
      /**  Indicates if job materials history for this part will be included in the Inventory Min/Max/Safety calculation.  */  
   MMSIssue:boolean,
      /**  User defined number in days, of how far back to look in usage history.  */  
   MMSHistory:number,
      /**  User defined, percentage of MIN to be set as Safety stock value.  */  
   MMSSafetyFactor:number,
      /**  User defined, used in calculation to defined MAX stock value.  */  
   MMSMaxFactor:number,
      /**  WIll hold the proposed Min when the Min/Max/Safety process is ran  */  
   SavedMinimumQty:number,
      /**  WIll hold the proposed Max when the Min/Max/Safety process is ran  */  
   SavedMaximumQty:number,
      /**  WIll hold the proposed Safety when the Min/Max/Safety process is ran  */  
   SavedSafetyQty:number,
      /**  It will hold the last TotalUsage used for the Saved Min/Max/Safety  */  
   SavedCalculatedUsageQty:number,
      /**  Last Date when the Saved Min/Max/Safety were updated  */  
   SavedOnDateTime:string,
      /**  Auto consume window percentage, this is a percentage to calculate the auto consume window days  that scheduling engine will take in consideration to look for available quantity to consume.  */  
   ACWPercentage:number,
      /**  Auto consume window days, this is the number of days that scheduling engine will take in consideration to look for available quantity to consume.  */  
   ACWDays:number,
      /**  GenNewPCIDDelaySeconds  */  
   GenNewPCIDDelaySeconds:number,
      /**  GenNewPCIDLimitDays  */  
   GenNewPCIDLimitDays:number,
      /**  System calculated manufacturing lead time.  This is the lead time needed to generate the part at the level of this part only.  Does not include the time on lower level parts.  Not editable by the user.  */  
   TopLvlMfgLeadTimeSys:number,
      /**  Manually entered manufacturing lead time.  This is the lead time needed to generate the part at the level of this part only. Does not include the time on lower level parts. Directly maintained by the user.  */  
   TopLvlMfgLeadTimeMnl:number,
      /**  Actual Costing Category ID  */  
   ActualCostingCategoryID:string,
      /**  Included Into Allocation Base  */  
   IncludedIntoAllocationBase:boolean,
      /**  Number of days before the forecast date in which any sales orders that exist should reduce the forecast quantity. Ex: Forecast date of 3/31/98, Days before of 10, then any orders that have a date of 3/21/98 to 3/31/98 would reduce forecast.  */  
   ForecastDaysBefore:number,
      /**  Number of days after the forecast date in which any sales orders that exist should reduce the forecast quantity. Ex: Forecast date of 3/31/98, Days after of 10, then any orders that have a date of 4/01/98 to 4/10/98 would reduce the forecast.  */  
   ForecastDaysAfter:number,
      /**  RcvInspectionReqPart  */  
   RcvInspectionReqPart:string,
      /**  Base UOM Code from Part Master  */  
   BaseUOMCode:string,
      /**  Used to calculate the normal order lead time for a Part for this Site. This value is represented in days. It is optional. Used in calculation of suggested order dates, as a default value in job material detail records.  */  
   CalculatedLeadTime:number,
   ExtLeadTime:number,
      /**  Used to designate the number of digits for an Integer or Mask type serial number format.  */  
   SNNumODigits:number,
   UrgentVendorName:string,
   UrgentVendorVendorID:string,
   DisableQtyBrng:boolean,
      /**  Used to indicate if the Serial Number format button should be enabled.  */  
   EnableSerialNum:boolean,
   ICTrader:boolean,
   InActive:boolean,
      /**  A summary of PartBin.OnHandQty for the warehouses where the bin is a nettable bin (WhseBin.NonNettable = NO).  */  
   OnHandQty:number,
   PlantConfCtrlSerialTracking:number,
      /**  Used to designate the number of leading zeros for an Integer or Mask type serial number format.  */  
   SNLeadingZeros:boolean,
      /**  Indicates if there is any quantity on hand for this part  */  
   HasOnHandQty:boolean,
   IsActCostingAllocEnabled:boolean,
      /**  Number of Pieces for MaximumQty  */  
   MaximumQtyNofP:number,
      /**  Number of Pieces for MaxMfgLotSize  */  
   MaxMfgLotSizeNofP:number,
      /**  Number of Pieces for MfgLotMultiple  */  
   MfgLotMultipleNofP:number,
      /**  Number of Pieces for MinimumQty  */  
   MinimumQtyNofP:number,
      /**  Number of Pieces for MinMfgLotSize  */  
   MinMfgLotSizeNofP:number,
      /**  Number of Pieces for MinOrderQty  */  
   MinOrderQtyNofP:number,
      /**  Number of Pieces for MinStartQty  */  
   MinStartQtyNofP:number,
   QtyDisplayOption:string,
      /**  Number of Pieces for SafetyQty  */  
   SafetyQtyNofP:number,
      /**  Number of Pieces for ShortHorizonMaxMfgLotSize  */  
   ShortHorizonMaxMfgLotSizeNofP:number,
      /**  Number of Pieces for ShortHorizonMinMfgLotSize  */  
   ShortHorizonMinMfgLotSizeNofP:number,
      /**  Number of Pieces for UrgentMinOrdQty  */  
   UrgentMinOrdQtyNofP:number,
      /**  Number of Pieces for UrgentMultQty  */  
   UrgentMultQtyNofP:number,
   BitFlag:number,
   BuyerIDName:string,
   PartTrackInventoryAttributes:boolean,
   PartAttrClassID:string,
   PartSellingFactor:number,
   PartTrackLots:boolean,
   PartTrackSerialNum:boolean,
   PartTrackDimension:boolean,
   PartIUM:string,
   PartPricePerCode:string,
   PartPartDescription:string,
   PartSalesUM:string,
   PersonName:string,
   PlantName:string,
   PrimWhseDescription:string,
   SerialMaskMaskType:number,
   SerialMaskDescription:string,
   TransferPlantName:string,
   VendorNumAddress1:string,
   VendorNumState:string,
   VendorNumCountry:string,
   VendorNumCity:string,
   VendorNumCurrencyCode:string,
   VendorNumDefaultFOB:string,
   VendorNumAddress2:string,
   VendorNumZIP:string,
   VendorNumTermsCode:string,
   VendorNumAddress3:string,
   VendorNumName:string,
   VendorNumVendorID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRefDesWhereUsedRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   RevisionNum:string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   AltMethod:string,
      /**  A sequence number that uniquely defines the Material (JobMtl) record within a specific Job/Assembly.  This is system assigned.  The next available number is determined by reading last JobMtl record on the Job/Assembly and then adding ten to it.  */  
   MtlSeq:number,
      /**  Identifier of Reference Designator  */  
   RefDes:string,
      /**  Unique identifies the reference designator with the material sequence.  */  
   RefDesSeq:number,
      /**  The Part Number of the component material record for the related Parent Part.  */  
   MtlPartNum:string,
      /**  Free form side location. (Top, Bottom, Both, Level, etc)  */  
   Side:string,
      /**  X Coordinate of the reference designator  */  
   XLocation:number,
      /**  Y Coordinate of the reference designator  */  
   YLocation:number,
      /**  Z Coordinate of the reference designator  */  
   ZLocation:number,
      /**  Rotation of the reference designator. Max value = 360.000  */  
   Rotation:number,
      /**  Designator Description  */  
   Description:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRestrictSubstRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  Restriction Type identification.  */  
   RestrictionTypeID:string,
      /**  Substance identification.  */  
   SubstanceID:string,
      /**  Default weight of the substance per primary part of UOM  */  
   Weight:number,
      /**  By default the primary UOM of the part.  */  
   WeightUOM:string,
      /**  When true then weight is disregarded in compliance roll-up.  */  
   Manual:boolean,
      /**  The date when exempt status for this substance expires.  */  
   ExemptDate:string,
      /**  Optional. Exemption certificate.  */  
   ExemptCertificate:string,
      /**  Indicates if the Part Restriction Substance is inactive and the Roll-Up process will not take it in count and it won?t be copied when the part is selected.  */  
   Inactive:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   Exempt:boolean,
   BitFlag:number,
   PartNumIUM:string,
   PartNumPricePerCode:string,
   PartNumSellingFactor:number,
   PartNumPartDescription:string,
   PartNumSalesUM:string,
   PartNumTrackLots:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   RestrictionTypeDescription:string,
   SubstanceDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRestrictionRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  Restriction Type identification.  */  
   RestrictionTypeID:string,
      /**  When true then no roll-up will be calculated for this Restriction type. Compliance date is set when this flag is set. D/I Roll-Up radio Button will be disabled.  */  
   Manual:boolean,
      /**  Enabled when manual flag is unchecked and company configuration flag for allow direct roll-up is enabled. Default to Indirect Roll-Up.  */  
   RollupType:string,
      /**  Displays one of the compliance statuses: 1. Not applicable (Yellow) (when no substances are selected) 2. Non compliant (Red) (one or more substances are selected but roll-up has not been executed or roll-up has failed) 3. Compliant (Green) (one or more substances are selected and roll-up was successful) 4. Exempt (Yellow) (when all substances are exempt ? verify exempt date)  */  
   Compliance:string,
      /**  Set when Manual flag is checked or after compliance roll-up is successful. Cleared Manual flag is unchecked or after compliance roll-up is unsuccessful.  */  
   ComplianceDate:string,
      /**  Set after compliance roll-up  */  
   LastRollUp:string,
      /**  Indicates if the Part Restriction Type is inactive and the Roll-Up process will not take it in count and it won?t be copied when the part is selected.  */  
   Inactive:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   Weight:boolean,
      /**  To enable RollUpType when manual flag is unchecked and company configuration flag for allow direct rolling-up is enabled.  */  
   EnableRollUpType:boolean,
   BitFlag:number,
   PartNumTrackLots:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumIUM:string,
   PartNumTrackDimension:boolean,
   PartNumSellingFactor:number,
   PartNumPartDescription:string,
   PartNumPricePerCode:string,
   PartNumSalesUM:string,
   RestrictionTypeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRevAttchRow{
   Company:string,
   PartNum:string,
   RevisionNum:string,
   AltMethod:string,
   ProcessMfgID:string,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRevInspPlanAttchRow{
   Company:string,
   PartNum:string,
   RevisionNum:string,
   AltMethod:string,
   ProcessMfgID:string,
   SeqPlan:number,
   DrawingSeq:number,
   XFileRefNum:number,
   SysRevID:number,
   SysRowID:string,
   ForeignSysRowID:string,
   DrawDesc:string,
   FileName:string,
   PDMDocID:string,
   DocTypeID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRevInspPlanRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   RevisionNum:string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   AltMethod:string,
      /**  Part Inspection Plan Sequence  */  
   SeqPlan:number,
      /**  The inspection plan part number (configurator part number).  */  
   InspPlanPartNum:string,
      /**  The specification ID.  Must be a valid value defined in the SpecDtl master table.  */  
   SpecID:string,
      /**  Unique identifier of this Site assigned by the user.  */  
   Plant:string,
      /**  The default quantity to be inspected.  */  
   SampleSize:number,
      /**  Percentage of quantity to be inspected  */  
   SampleSizePct:number,
      /**  This is used to establish the default plan to be used.  Only one record of the same company, Site, part number, and revision combination can have this flag set to true.  */  
   IsDefault:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
   SpecHedDescription:string,
   BitFlag:number,
   InspPlanDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRevInspVendRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   RevisionNum:string,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   AltMethod:string,
      /**  Contains the vendor ID for Skip Lot processing  */  
   VendorID:string,
      /**  Unique identifier of this Site assigned by the user.  */  
   Plant:string,
      /**  If true, this supplier / purchase point / part combination is to be included in the skip lot process.  */  
   SkipLotCtl:boolean,
      /**  Skip Lot Control Code.  Must be a valid code defined in the SkipLotCtl master file.  */  
   SkipLotCtlCode:string,
      /**  Counter of the receipts of this part / supplier combination. It can be maintained here in case the QA personnel want to force further inspections.  */  
   InspCnt:number,
      /**  Counter of the number of lots that have been skipped within this cycle.  */  
   SkipCnt:number,
      /**  Counter of the number of cycles that this has been through.  */  
   RptCycles:number,
      /**  Counter of the number of lots that have been rejected.  */  
   RejectCnt:number,
      /**   Valid options are S (Skip Lot) or Q (Quantity).
This field will control the value of what is added to the RejectCnt field. If set to S then the RejectCnt will be increased by 1 if the lot being inspected has a rejected quantity.  If set to Q then the field will be increased by the total failed quantity.  */  
   RejectCntBy:string,
      /**  Default minimum sample size to be inspected.  */  
   SampleSize:number,
      /**  Percentage of the receipt quantity to be inspected  */  
   SampleSizePct:number,
      /**  Setting to true will force all receipts to be inspected.  */  
   ForceInsp:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
   BitFlag:number,
   VendorName:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRevRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The PartNum field identifies the Part and is used as part of the primary key.  */  
   PartNum:string,
      /**  Revision number which is used to uniquely identify the revision of the part, and is used as part of the primary key  */  
   RevisionNum:string,
      /**  Short description of the revision. This is NOT the Part description.  */  
   RevShortDesc:string,
      /**  Used to enter a full description of the revision.  */  
   RevDescription:string,
      /**  Indicates if the methods of manufacturing have been approved for this revision.  Only approved methods can be pulled into jobs/quotes.  */  
   Approved:boolean,
      /**  Date which this revision was approved for use by manufacturing/quoting.  This is set to the system date when the user marks the revision Approved. It is not maintainable by the user.  */  
   ApprovedDate:string,
      /**  UserID who approved the revision.  Not maintainable by the user.  */  
   ApprovedBy:string,
      /**  Date at which this revision is considered effective.  This date is used to control the pulling of subassembly revisions.  */  
   EffectiveDate:string,
      /**  This Level Unit Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   TLRLaborCost:number,
      /**   This Level Unit Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   TLRBurdenCost:number,
      /**  This Level Unit Material Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   TLRMaterialCost:number,
      /**  This Level Unit Subcontract Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   TLRSubcontractCost:number,
      /**  This Level Unit Material Burden Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   TLRMtlBurCost:number,
      /**  This Level Setup Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   TLRSetupLaborCost:number,
      /**   This Level Setup Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   TLRSetupBurdenCost:number,
      /**  This Level Unit Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   LLRLaborCost:number,
      /**   This Level Unit Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   LLRBurdenCost:number,
      /**  This Level Unit Material Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   LLRMaterialCost:number,
      /**  This Level Unit Subcontract Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   LLRSubcontractCost:number,
      /**  This Level Unit Material Burden Cost calculated by the BOM Cost rollup routine. "This level" cost excludes costs from sub assemblies.  */  
   LLRMtlBurCost:number,
      /**  This Level Setup Labor Cost calculated by the BOM Cost rollup routine. This level cost excludes costs from sub assemblies.  */  
   LLRSetupLaborCost:number,
      /**   This Level Setup Burden Cost calculated by the BOM Cost rollup routine. "This level cost" excludes costs from sub assemblies.
Rolled up Burden cost. Calculated by the BOM cost rollup routine  */  
   LLRSetupBurdenCost:number,
      /**  Date that this part cost was last rolled up.  Updated by the BOM Cost Roll up routine.  */  
   RollupDate:string,
      /**  Engineering Drawing Number. An optional field.  */  
   DrawNum:string,
      /**  Engineering Change Order Number. An optional field for reference.  */  
   ECO:string,
      /**  An internal flag which indicates that this part revision contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   Method:boolean,
      /**   The operation number PartOpr.OprSeq) that is marked to do the Automatic Receipt to inventory.  Note: Zero = no operation is set to perform the auto receive into inventory function.
This field is not directly maintainable. Instead it is set during operation maintenance by having the user mark a check box indicating "Auto Receive" which then updates this field with the operations sequence number.  */  
   AutoRecOpr:number,
      /**   The sequence of the operation that is to be considered as the operation which indicates the quantity complete for the Job/Assembly.  In other words this operations completed quantity = Job/Assembly completed.   Note: Zero = no operation is set and that the system should use the last operation to determine quantity complete.
This field is not directly maintainable. Instead it is set during operation maintenance by having the user mark a check box indicating "Final Operation" which then updates this field with the operations sequence number.  */  
   FinalOpr:number,
      /**  Holds the internal object id of pdm parts.  */  
   PDMObjID:string,
      /**  If true then the revision has a configuration defined for it.  This will be set when a configuration is approved.  */  
   Configured:boolean,
      /**  If set to TRUE then the revision can be configured in StoreFront.  */  
   WebConfigured:boolean,
      /**  If TRUE then the input prices will be shown in the Customer Connect Configuration Review.  */  
   ShowInputPrice:boolean,
      /**  Alternate Routing method to be used for this revision, and is used as part of the primary key  */  
   AltMethod:string,
      /**  The description of the alternate method.  */  
   AltMethodDesc:string,
      /**  Site Identifier. This field cannot be blank.  */  
   Plant:string,
      /**  The alternate method of the parent this method inherits from.  */  
   ParentAltMethod:string,
      /**  Indicates if this revision is to use stage number or operations on materials.  If false, operation sequences are to be used.  If true, staging numbers are to be used.  */  
   UseStaging:boolean,
      /**  UseAltRevForParts: Flag to indicate if the Use Alternate method for parts option is selected, this flag affects directly the creation and loading of data inside EngWorkbench, because it will control the Alternate Method used.  */  
   UseAltRevForParts:boolean,
      /**  This field can be used with external system integrations to identify which system currently has ownership of the record.  This field can hold either the name of the external system (example: PDM), ERP (Epicor) or null.  */  
   OwnershipStatus:string,
      /**  External Configurator  */  
   ExtConfig:boolean,
      /**  Validate Reference Designators.  */  
   ValRefDes:boolean,
      /**  Is the part for this revision a global part  */  
   PcGlobalPart:boolean,
      /**  If a configuration is created for this revision, is it marked as enterprise configurator  */  
   PcEntprsConf:boolean,
      /**  Marks the Part Revision as a global Revision, available to be sent out to other companies  */  
   GlobalRev:boolean,
      /**  Rough Cut Code.  Rough cut parameters to use when rough cut scheduling for the revision.  */  
   RoughCutCode:string,
      /**  The inspection plan part number (configurator part number) to use for RMA processing for this part.  */  
   RMAInspPlan:string,
      /**  The specification ID to use for RMA processing for this part.  */  
   RMASpecID:string,
      /**  The default sample size to use for RMA processing for this part  */  
   RMASampleSize:number,
      /**  Percentage of quantity to be inspected for RMA processing of this part  */  
   RMASampleSizePct:number,
      /**  The part number used to identify the configured part number that this part revision was created from  */  
   BasePartNum:string,
      /**  The revision number used to identify the configured part revision this part number was generated from.  */  
   BaseRevisionNum:string,
      /**  ConfigID  */  
   ConfigID:string,
      /**  RegenConfig  */  
   RegenConfig:boolean,
      /**  SIValuesGroupSeq  */  
   SIValuesGroupSeq:number,
      /**  SIValuesHeadNum  */  
   SIValuesHeadNum:number,
      /**  Indicates the record is used with Machine MES  */  
   ExternalMES:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Indicates the way in which parts are made for Co-Part jobs.  There are two value S  Sequential and C  Concurrent.  Sequential is the default. This field is similar to the JobHead.ProcessMode field.  */  
   ProcessMode:string,
      /**  DefaultConfigPart  */  
   DefaultConfigPart:boolean,
      /**  Number of COPart required in the Revision  */  
   CoPartsReqQty:number,
      /**  Material Cost Factor  */  
   MtlCostPct:number,
      /**  Labor Cost Factor  */  
   LaborCostPct:number,
      /**  Number of COParts per Operation  */  
   CoPartsPerOp:number,
      /**  CreatedBy  */  
   CreatedBy:string,
      /**  CreatedOn  */  
   CreatedOn:string,
      /**  ChangedBy  */  
   ChangedBy:string,
      /**  ChangedOn  */  
   ChangedOn:string,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   ExternalMESSyncRequired:boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   ExternalMESLastSync:string,
      /**  Customs BOM  */  
   CNCustomsBOM:boolean,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
      /**  Type of Process Manufacturing this revision is for: General, Site, Master.  */  
   ProcessMfgType:string,
      /**  Description of Process Manufacturing revision.  */  
   ProcessMfgDescription:string,
      /**  Indicates if this revision is to use Advanced Staging.  */  
   UseAdvancedStaging:boolean,
      /**  The last Group to modify this Revision for Recipe Authoring.  */  
   ProcessMfgLastGroupID:string,
      /**  Only Part Revisions marked as Connected Process Control (CPC) enable will be send to CPC.  */  
   ECPCEnabled:boolean,
   DisableApproved:boolean,
      /**  Name of ECO Group that this part is checked out to  */  
   ECOGroup:string,
      /**  This field will be set to true if two or more ECOCoParts records exist for the revision.  */  
   HasCoParts:boolean,
   ParentAltMethodDesc:string,
      /**  Part Number of the Parent Part  */  
   ParentPartNum:string,
      /**  Revision number  of Parent Part.  */  
   ParentRevisionNum:string,
   ProdCode:string,
      /**   Revision Status used to determina in the Revision of all the Materials are Effective As Of Date
Used to indicate the MAX MtlRevisionStatus of all its Materials/SubAssemblies.
If <= 2 the all its materials/subAssemblies's Revisions are Effective As Of Date  */  
   RevStatusAsOfDate:number,
   SpecHedDescription:string,
      /**  Last date that this Revison is effective.  (Next Rev Effective date - 1)  */  
   vDate:string,
   vQty:number,
   Class:string,
   NonStock:boolean,
      /**  Indicates that the PartRev is the root node in the tree  */  
   IsRootNode:boolean,
      /**  Holds the ECORev Approved flag for the last ProcessMfgID specified against the PartRev  */  
   EngineeringApproved:boolean,
   BitFlag:number,
   InspPlanDescription:string,
   PartDescriptionTrackDimension:boolean,
   PartDescriptionSellingFactor:number,
   PartDescriptionPartDescription:string,
   PartDescriptionIUM:string,
   PartDescriptionTrackLots:boolean,
   PartDescriptionPricePerCode:string,
   PartDescriptionSalesUM:string,
   PartDescriptionTrackSerialNum:boolean,
   PartDescriptionTypeCode:string,
   PcStatusConfigType:string,
   PlantName:string,
   RoughCutParamDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  An abbreviated part description field by which the user can search the Part file. In Part maintenance the Search Word is to only be updated upon initial creation of the Part with the first 8 bytes of the Part.Description.  */  
   SearchWord:string,
      /**  Describes the Part.  */  
   PartDescription:string,
      /**   The Inventory class that this Part belongs to. The Class field can be blank or must be valid in the PartClass master file.
Classes could be set up for different type of raw materials. It will primarily be used as a report selection parameter.  */  
   ClassID:string,
      /**  Primary Inventory Unit of Measure. The unit costs, are based on this uom. Used as a default for issue transactions for the part.  Part onhand and allocation quantities are tracked by this uom.  The quantities can also be tracked by other uoms (see PartUOM table) but tracking at this uom is mandatory.   Use UOMClass.DefUOMCode of the system default UOMClass  when creating new part records (see XASyst.DefUOMClassID).  */  
   IUM:string,
      /**  The Purchasing Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Purchase Order entry as the default on line item details.  */  
   PUM:string,
      /**   Classifies Parts into the following...
M = Manufactured Part.
P = Purchased Part.
K = Sales Kit Part.B = Planning BOM.
This type code does limit referencing any part in any way. For example a type "P" can be entered on a sales order, or a type "M" can be referenced in a Purchase Order.
This field will also be used as a selection parameter in certain reports, such as Time Phase Requirements.  */  
   TypeCode:string,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   NonStock:boolean,
      /**   This value is used to convert quantity when there is a difference in the vendors unit of measure and how it is stocked in inventory. Example is purchased in pounds, stocked in sheets.


Formula: Issue Qty * Conversion Factor = Purchased Qty.  */  
   PurchasingFactor:number,
      /**  Base Unit Selling Price for the Item. Maintainable only via Part Master Maintenance program. It is used as a default unit price on Sales Order line detail and on Invoice line details that are not referencing a sales order line.  */  
   UnitPrice:number,
      /**  Indicates the pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Maintainable only via Part Maintenance. The initial default is "E". Used as default PricePerCode in order entry and invoice entry.  */  
   PricePerCode:string,
      /**  Base Internal Unit Selling Price for the Item.  Maintainable only via Part Master Maintenance program.  If zero, then the external unit price (Part.UnitPrice) is used.  */  
   InternalUnitPrice:number,
      /**  Indicates the internal pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand.  Maintainable only via Part Maintenance.  The initial default is "E".  */  
   InternalPricePerCode:string,
      /**  Product Group ID for the Part. This can be blank or must be valid in the ProdGrup file.  This will be used for report sorting and selection. Also as a default in order entry, invoice entry and job entry.  */  
   ProdCode:string,
      /**  Used to enter comments for manufacturing when this part is referenced on a job. These are copied to JobHead.Comment, JobAsmbl.Comment,JobMtl.MfgComment depending on the point of reference. Commens are printed on the routing report.  */  
   MfgComment:string,
      /**   Part Comments that will be used as a default for purchasing. These will be copied into the JobMtl.PurComment which then will be used to pass along to the PO when that JobMtl is referenced. It will also be copied into the PODetail.Comment field when the PO is buying the part for stock and not referencing a Job. View as an EDITOR widget.
To be view-as EDITOR widget.  */  
   PurComment:string,
      /**  Defines the Costing method to be associated with this Part. Use the XaSyst.CostMethod as a default.  When a unit cost is retrieved from the Part file the programs will use this field to determine which one of the Four sets of cost fields should be used.  A = Use Average L= Use Last S = Use Standard T = Use Avg by lot(not found in XaSyst).  */  
   CostMethod:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar1Label
is non blank.  */  
   UserChar1:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar2Label
is non blank.  */  
   UserChar2:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar3Label
is non blank.  */  
   UserChar3:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar4Label
is non blank.  */  
   UserChar4:string,
      /**   User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate1Label
is non blank.  */  
   UserDate1:string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate2Label is non blank.  */  
   UserDate2:string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate3 Label is non blank.  */  
   UserDate3:string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate4 Label is non blank.  */  
   UserDate4:string,
      /**   User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec1Label
is non blank.  */  
   UserDecimal1:number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec2Label is non blank.  */  
   UserDecimal2:number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec3Label is non blank.  */  
   UserDecimal3:number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec4Label is non blank.  */  
   UserDecimal4:number,
      /**  User Defined Integer field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserInt1Label is non blank.  */  
   UserInteger1:number,
      /**  User Defined Integer field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserInt2Label is non blank.  */  
   UserInteger2:number,
      /**  Indicates the Tax Category for this Part. Used as a default to Order line items or Invoice line items. Can be left blank which indicates item is taxable. If entered must be valid in the TaxCat master file.  */  
   TaxCatID:string,
      /**   Flag which indicates if the Part Master is considered as "Inactive".
This flag will be used to exclude parts from certain searches and reports.  */  
   InActive:boolean,
      /**  Internally assigned integer which indicates the deepest level of assembly indention that this part is used at.  This is used by the Cost Rollup routines to control the order in which parts get costed. Part at the bottom (highest levelcode) Product structure are calculated first and continues up the chain, with the final assembly parts being processed last.  This insures that when retrieving the cost of an assemblies components the components will already have had their cost rolled up.  */  
   LowLevelCode:number,
      /**  An internal flag which indicates that this part contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   Method:boolean,
      /**  Indicates if Lot numbers are prompted for in transactions for this part.  Backflushing and AutoReceiving functions are ignored when TrackLots = Yes.  */  
   TrackLots:boolean,
      /**   Onhand quantity is always tracked in the Parts primary inventory uom (Part.IUM). Checking this box indicates that you want to allow tracking of onhand quantity by additional uoms.
The actual UOMs to be tracked for the part are indicated by PartUOM.TrackOnHand. In order to set the PartUOM.TrackOhHand = True the Part.TrackDimension must = true.
This replaces the old 8.3 Track Dimension feature  */  
   TrackDimension:boolean,
      /**  Default dimension code for the part.  Set by selecting a PartDim record as default.  */  
   DefaultDim:string,
      /**  Indicates if this part is serial number tracked  */  
   TrackSerialNum:boolean,
      /**  Intrastat goods classification code following the Intrastat Classification Nomenclature (ICN). The Commodity Code field can be blank to indicate the value from the part class or must be valid in the ICommCode (formerly called IStatGrp) master file.  */  
   CommodityCode:string,
      /**  Unique code for the Warranty for this part  */  
   WarrantyCode:string,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   PhantomBOM:boolean,
      /**  The Selling Unit of measure for the Part. The UOM which the unit prices are based on. Defaults as the Part.IUM.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  The material burden rate for this part.  */  
   MtlBurRate:number,
      /**  The Part's Unit Net Weight.  */  
   NetWeight:number,
      /**  if Yes then the part effective revision is used. If No then the revision of the demand source is used (OrderDtl, JobMtl...)  */  
   UsePartRev:boolean,
      /**  Default for label printing.  Zero indicates that only one label should be produced for the entire quantity.  */  
   PartsPerContainer:number,
      /**  Part's length.  */  
   PartLength:number,
      /**  Part's width.  */  
   PartWidth:number,
      /**  Part's Height.  */  
   PartHeight:number,
      /**  Shelf life of a lot in days.  Zero indicates unlimited shelf life.  */  
   LotShelfLife:number,
      /**  This is a Web saleable part  */  
   WebPart:boolean,
      /**  Indicates that the onhand quantity is to be consumed and no further replenishments should be made.  Similar to Obsolete, however only warning messages will be issued to the user if they attempt new references.  */  
   RunOut:boolean,
      /**  Indicates the default Substitute part number.  This is optional. Must be one of the related PartSub records.  This field is set indirectly when the user checks the default toggle box in Part Substitution dialog.  */  
   SubPart:string,
      /**  Part's diameter.  */  
   Diameter:number,
      /**  Part's gravity.  */  
   Gravity:number,
      /**  Indicates that the part is on hold.  This feature can be used to indicate that a new part is not yet approved, that it is being phased out, has a quality issue, etc.  Further demands/supplies of this part should not be made. Similar to an "Inactive" part. However at the moment it still may have an onhand balance, supply and demands and will be reflected in stock status reporting.  */  
   OnHold:boolean,
      /**  Date that part becomes obsolete.  This can be set to a future date when the part should become obsolete.  */  
   OnHoldDate:string,
      /**  The Reason.Code associate with the reason why the part has been placed on hold. Valid only when Part.OnHold = Yes.  */  
   OnHoldReasonCode:string,
      /**  Default analysis code to be used when this part appears as an assembly  on a quote or a job.  */  
   AnalysisCode:string,
      /**  Marks the Part as a global Part, available to be sent out to other companies  */  
   GlobalPart:boolean,
      /**  MtlAnalysisCode  */  
   MtlAnalysisCode:string,
      /**  Disables this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  This value is used to calculate the Supplementary Units for the Intrastat.  */  
   ISSuppUnitsFactor:number,
      /**  Holds the internal object id of pdm parts.  */  
   PDMObjID:string,
      /**  Path & filename (relative to images/prod_img directory on Web Server) of .jpg product image file.  */  
   ImageFileName:string,
      /**  This field contains the Intrastat Country of Origin Code from the Country table.  */  
   ISOrigCountry:string,
      /**  Current setting for the prefix that will be attached to all new Serial Numbers as they are generated.  */  
   SNPrefix:string,
      /**  Current setting for Format of the Base serial number that will be used as new serial numbers are generated. Expressed in progress syntax. Ex: X(30), 99999999  */  
   SNFormat:string,
      /**  Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer  */  
   SNBaseDataType:string,
      /**  Used by the scheduling process when a part is stocked.  When TRUE,  the availability of this Part must be calculated via the TimePhase process prior to scheduling a Job.  */  
   Constrained:boolean,
      /**  UPS / UCC Code required by some industries.  */  
   UPCCode1:string,
      /**  UPS / UCC Code required by some industries.  */  
   UPCCode2:string,
      /**  UPS / UCC Code required by some industries.  */  
   UPCCode3:string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  For Customer Connect Only.  This field is used in Store Front to indicate if the part is available in stock.  */  
   WebInStock:boolean,
      /**  Should this Part be included in Consolidated Purchasing?  */  
   ConsolidatedPurchasing:boolean,
      /**  Indicates how Purchasing Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   PurchasingFactorDirection:string,
      /**  Indicates how Selling Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**   Receiving Documents Required.
Indicates receiving documents are required when receiving this part.  This pertains only to lot tracked parts that are received to inventory. If checked, then at the time of receiving the system will require that one or more attachments with a reference to a DocType having Receipt = yes be entered.Requires DocManagement license.  */  
   RecDocReq:boolean,
      /**  Maximum daily production value.  Used in demand shipping schedule.  */  
   MDPV:number,
      /**   Shipping Documents Required.
Indicates if shipping documents are required when shipping this part. Pertains to Inventory shipments of lot tracked parts or shipments directly from the job only. If checked, then at the time of shipping the system will require that the PartLot.Ship DocsAvail, or JobPart.ShipDocsAvail flag is true before allowing the shipment.Requires DocManagement license.  */  
   ShipDocReq:boolean,
      /**  The returnable container for this part when the part needs to be returned.  The value is provided by the trading partner.  */  
   ReturnableContainer:string,
      /**  The Part's Net Volume.  */  
   NetVolume:number,
      /**  Indicates a Quantity Bearing part. Works in conjunction with the Non-Stock field to enable the part master parts to be setup for expense items.  Quantity Bearing will be set to Yes by default and only enable to be set to No if the Non-Stock flag is Yes.  */  
   QtyBearing:boolean,
      /**  This field contains the Country of Origin Code from the Country table.  For International shipping.  */  
   NAFTAOrigCountry:string,
      /**  NAFTA Producer Code - For international shipping  */  
   NAFTAProd:string,
      /**  NAFTA Preference Code  */  
   NAFTAPref:string,
      /**  Export License Type  */  
   ExpLicType:string,
      /**  Export License Number  */  
   ExpLicNumber:string,
      /**  ECCN Number  */  
   ECCNNumber:string,
      /**  AES Export code  */  
   AESExp:string,
      /**  Harmonized Tariff Schedule Code  */  
   HTS:string,
      /**  Use HTS description flag - for shippers shippers export declaration  */  
   UseHTSDesc:boolean,
      /**  Schedule B Code  */  
   SchedBcode:string,
      /**  Hazardous Item  */  
   HazItem:boolean,
      /**  Hazardous Technical Name  */  
   HazTechName:string,
      /**  Hazardous Class Number  */  
   HazClass:string,
      /**  Hazardous Subrisk Class  */  
   HazSub:string,
      /**  Hazardous Government Assigned ID  */  
   HazGvrnmtID:string,
      /**  Hazardous Packing instructions  */  
   HazPackInstr:string,
      /**   Indicates what VAT Reverse Charge method needs to be applied for this Part.  The possible values are:
   "RCT"  -  "Reverse Charge with Threshold";
   "RCN"  -  "Reverse Charge with No Threshold"
Leave this field blank if no Reverse Charge should be applied in the invoice line for this Part.  */  
   RevChargeMethod:string,
      /**  Reverse Charge Under Threshold value. If the absolute value of an invoice line is less than the under threshold then the reverse charge tax code will be applied.  */  
   RCUnderThreshold:number,
      /**  Reverse Charge Over Threshold value. If the absolute value of an invoice line is more than the over threshold then the reverse charge tax code will be applied.  */  
   RCOverThreshold:number,
      /**  This field can be used with external system integrations to identify which system currently has ownership of the record.  This field can hold either the name of the external system (example: PDM), ERP (Epicor) or null.  */  
   OwnershipStatus:string,
      /**   The UOM Class that will be used for the Part. The UOM Class establishes the list of unit of measures that can be used in reference to this part.
Must be valid in the UOMClass table.  */  
   UOMClassID:string,
      /**  This is the ID by which the user will reference a particular serial number format mask.  */  
   SNMask:string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   SNMaskExample:string,
      /**  A standard suffix that will be attached to all serial numbers currently used only by SNBaseStructure Mask types.  */  
   SNMaskSuffix:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types.  */  
   SNMaskPrefix:string,
      /**  This is the last used serial sequence default. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It will be used when defaulting the SNLastUsedSeq field for new PartSite records.  */  
   SNLastUsedSeq:string,
      /**  Indicates to use the value in SerialMask.SNLastUsedSeq when generating the next serial number for a Generate Mask type.  */  
   UseMaskSeq:boolean,
      /**   Qualifies the unit of measure of the NetWeight field.
Must be a UOMConv of the UOMClass with ClassType of "weight".   Use UOMClass.DefUOMCode of the "weight" UOMClass as a default  when creating new part records.
Having a NetWeightUOM will provides the ability to calculate total  weight.  */  
   NetWeightUOM:string,
      /**   Qualifies the unit of measure of the NewVolume field.
Must be a UOMConv of the UOMClass with ClassType of "volume".   Use UOMClass.DefUOMCode of the "volume" UOMClass as a default  when creating new part records.
Having a Net Volume UOM will provides the ability to calculate total volume  */  
   NetVolumeUOM:string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotBatch:boolean,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgBatch:boolean,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgLot:boolean,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotHeat:boolean,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotFirmware:boolean,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotBeforeDt:boolean,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgDt:boolean,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotCureDt:boolean,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotExpDt:boolean,
      /**  Defines a prefix to be used when a lot number is generated for the specific part.  */  
   LotPrefix:string,
      /**  When generating the numeric portion of a lot number it can be either based on a next available number for the part (see Part.LotNextNum) or next available number from a Global Sequence (see LotSeq table and Part.LotSeqID)  */  
   LotUseGlobalSeq:boolean,
      /**  The LotSeqID of the LotSeq record to use to retreive next available number when the part is using a Global Sequence  (Part.LotUseGlobalSeq = True). Must be valid in the LotSeq table if Part.LotUseGlobalSeq = True)  */  
   LotSeqID:string,
      /**  The next available number to use to generate new lot numbers a part when the  is configured to use "Part Specific" number sequence. (Part.LotUseGlobalSeq = false).  */  
   LotNxtNum:number,
      /**  Number of digits of the Next Avail Lot Number controls that will be used by system Generate lot number logic.  */  
   LotDigits:number,
      /**  If leading zeros should be included in the numeric portion of the system generated lot number.  */  
   LotLeadingZeros:boolean,
      /**   Option to append a trailing date string to the system generated lot number. The Date is the current system date.
Valid options are: None (Default), DD, MM, YYYY, MMYYYY, MM_YYYY, DDMMYYY, DD-MM-YYY, MMDDYYYY, MM-DD-YYYY,  YYYYMMDD, YYYY-MM-DD  */  
   LotAppendDate:string,
      /**  This flag identifies those parts that will suggest a PO each time than a sales order is created. This flag will be used as a default in the sales order.  */  
   BuyToOrder:boolean,
      /**  This flag identifies those parts that are commonly drop shipped. This flag will be used as a default in the sales order.  */  
   DropShip:boolean,
      /**  Configured Part  */  
   IsConfigured:boolean,
      /**  External Configurator  */  
   ExtConfig:boolean,
      /**  The reference category that this Part belongs to.  */  
   RefCategory:string,
      /**   Malaysia Localization
The flag to indicate that the part is under CJ5 jurisdiction  */  
   CSFCJ5:boolean,
      /**   Malaysa Localization
The flag to indicate that the part is under LMW jurisdiction  */  
   CSFLMW:boolean,
      /**  The Part's Unit Gross Weight.  */  
   GrossWeight:number,
      /**   Qualifies the unit of measure of the GrossWeight field.
Must be a UOMConv of the UOMClass with ClassType of "weight".   Use UOMClass.DefUOMCode of the "weight" UOMClass as a defaul
t  when creating new part records.  */  
   GrossWeightUOM:string,
      /**  The part number used to identify the configured part number this part number was generated from.  */  
   BasePartNum:string,
      /**  Class Code Entry Field  */  
   FSAssetClassCode:string,
      /**  Field Service Sales Unit Price  */  
   FSSalesUnitPrice:number,
      /**  Indicates the field service sales pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. The initial default is "E".  */  
   FSPricePerCode:string,
      /**  Indicates if  Inspection is required upon receipt.  Inspection will also be enforced if the related Part Class, Vendor, PO Detail, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   RcvInspectionReq:boolean,
      /**  EstimateID  */  
   EstimateID:string,
      /**  EstimateOrPlan  */  
   EstimateOrPlan:string,
      /**  DiffPrc2PrchUOM  */  
   DiffPrc2PrchUOM:boolean,
      /**  DupOnJobCrt  */  
   DupOnJobCrt:boolean,
      /**  PricingFactor  */  
   PricingFactor:number,
      /**  PricingUOM  */  
   PricingUOM:string,
      /**  MobilePart  */  
   MobilePart:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  AGUseGoodMark  */  
   AGUseGoodMark:boolean,
      /**  AGProductMark  */  
   AGProductMark:boolean,
      /**  ISRegion  */  
   ISRegion:string,
      /**  INChapterID  */  
   INChapterID:string,
      /**  CSF Peru -  SUNAT Type  */  
   PESUNATType:string,
      /**  PESUNATUOM  */  
   PESUNATUOM:string,
      /**  DEIsServices  */  
   DEIsServices:boolean,
      /**  DEIsSecurityFinancialDerivative  */  
   DEIsSecurityFinancialDerivative:boolean,
      /**  DEInternationalSecuritiesID  */  
   DEInternationalSecuritiesID:string,
      /**  LinkToContract  */  
   LinkToContract:boolean,
      /**  DEIsInvestment  */  
   DEIsInvestment:boolean,
      /**  DEPayStatCode  */  
   DEPayStatCode:string,
      /**  DEDenomination  */  
   DEDenomination:string,
      /**  PartLengthWidthHeightUM  */  
   PartLengthWidthHeightUM:string,
      /**  DiameterUM  */  
   DiameterUM:string,
      /**  DiameterInside  */  
   DiameterInside:number,
      /**  DiameterOutside  */  
   DiameterOutside:number,
      /**  ThicknessUM  */  
   ThicknessUM:string,
      /**  Thickness  */  
   Thickness:number,
      /**  ThicknessMax  */  
   ThicknessMax:number,
      /**  Durometer  */  
   Durometer:string,
      /**  Specification  */  
   Specification:string,
      /**  EngineeringAlert  */  
   EngineeringAlert:string,
      /**  Condition  */  
   Condition:string,
      /**  IsCompliant  */  
   IsCompliant:boolean,
      /**  IsRestricted  */  
   IsRestricted:boolean,
      /**  IsSafetyItem  */  
   IsSafetyItem:boolean,
      /**  CommercialBrand  */  
   CommercialBrand:string,
      /**  CommercialSubBrand  */  
   CommercialSubBrand:string,
      /**  CommercialCategory  */  
   CommercialCategory:string,
      /**  CommercialSubCategory  */  
   CommercialSubCategory:string,
      /**  CommercialStyle  */  
   CommercialStyle:string,
      /**  CommercialSize1  */  
   CommercialSize1:string,
      /**  CommercialSize2  */  
   CommercialSize2:string,
      /**  CommercialColor  */  
   CommercialColor:string,
      /**  IsGiftCard  */  
   IsGiftCard:boolean,
      /**  PhotoFile  */  
   PhotoFile:string,
      /**  PartPhotoExists  */  
   PartPhotoExists:boolean,
      /**  CommentText  */  
   CommentText:string,
      /**  Indicates if the packaging information is part specific or specified at the UOM class level.  */  
   PartSpecificPackingUOM:boolean,
      /**  ImageID  */  
   ImageID:string,
      /**  Specification Code for China GTI purposes  */  
   CNSpecification:string,
      /**  This field defines if the part  is synchronized to an External CRM.  */  
   SyncToExternalCRM:boolean,
      /**  This field holds the id of this part in the External CRM  */  
   ExternalCRMPartID:string,
      /**  This field defines the last time that the  part  has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   ExternalCRMLastSync:string,
      /**  This fields determines if the part needs to be synchronized to the External CRM. If there are changes in the part master file , Epicor ERP automatically turns on this field.  */  
   ExternalCRMSyncRequired:boolean,
      /**  PESUNATTypeCode  */  
   PESUNATTypeCode:string,
      /**  PESUNATUOMCode  */  
   PESUNATUOMCode:string,
      /**  Code Version for China GTI purposes  */  
   CNCodeVersion:string,
      /**  Tax Category Code for China GTI purposes  */  
   CNTaxCategoryCode:string,
      /**  Has Preferential Treatment value for China GTI purposes  */  
   CNHasPreferentialTreatment:boolean,
      /**  Preferential Treatment Content for China GTI purposes  */  
   CNPreferentialTreatmentContent:string,
      /**  Zero Tax Rate Mark for China GTI purposes  */  
   CNZeroTaxRateMark:string,
      /**  SubLevelCode  */  
   SubLevelCode:number,
      /**  Date the Part was created  */  
   CreatedBy:string,
      /**  User the Part was created by  */  
   CreatedOn:string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttBatch:string,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgBatch:string,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgLot:string,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttHeat:string,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttFirmware:string,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttBeforeDt:string,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgDt:string,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttCureDt:string,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttExpDt:string,
      /**  DeferManualEntry  */  
   DeferManualEntry:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Container Receipt, Receipt Entry.  */  
   DeferPurchaseReceipt:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Job Receipt to Job, Job Receipt to Salvage, Job Receipt to Inventory, Kanban Receipts.  */  
   DeferJobReceipt:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Inspection Processing.  */  
   DeferInspection:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Quantity Adjustment.  */  
   DeferQtyAdjustment:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Inventory Transfer.  */  
   DeferInventoryMove:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Customer Shipment Entry, Subcontractor Shipment Entry, Drop Shipment Entry, Order Entry.  */  
   DeferShipments:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Count Tag Entry.  */  
   DeferInventoryCounts:boolean,
      /**  DeferAssetDisposal  */  
   DeferAssetDisposal:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: RMA Processing.  */  
   DeferReturnMaterials:boolean,
      /**  MXProdServCode  */  
   MXProdServCode:string,
      /**  Date/Time when the Part record was updated  */  
   ChangedOn:string,
      /**  MXCustomsDuty  */  
   MXCustomsDuty:string,
      /**  Determines if the Part has to be synchronized with Epicor FSA application.  */  
   SendToFSA:boolean,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   ExternalMESSyncRequired:boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   ExternalMESLastSync:string,
      /**  When the part is marked as Item, it will create an Item Resource in Epicor FSA.  */  
   FSAItem:boolean,
      /**  When the part is marked as Equipment, it will create an Equipment Resource Template in Epicor FSA.  */  
   FSAEquipment:boolean,
      /**  Bill of Lading Class. Additional data for the part required for LTL and International shipments.  */  
   BOLClass:string,
      /**  Fair Market Value. Additional data for the part required for LTL and International shipments.  */  
   FairMarketValue:number,
      /**  SAFTProdCategory  */  
   SAFTProdCategory:string,
      /**  ID of related Attribute Class.  */  
   AttrClassID:string,
      /**  Indicates if this part requires Identification Numbers shipment time.  This is disable if Track Location inventory is false.  */  
   LocationIDNumReq:boolean,
      /**  Indicates if this part tracks Location Inventory.  */  
   LocationTrackInv:boolean,
      /**  Set the default value of Location View for materials added in Engineering Workbench.  */  
   LocationMtlView:boolean,
      /**  LCNRVReporting  */  
   LCNRVReporting:boolean,
      /**  LCNRVEstimatedUnitPrice  */  
   LCNRVEstimatedUnitPrice:number,
      /**  MXCustomsUMFrom  */  
   MXCustomsUMFrom:string,
      /**  Default format ID used when assigning ID Numbers.  */  
   LocationFormatID:string,
      /**  IsServices  */  
   IsServices:boolean,
      /**  PEDetrGoodServiceCode  */  
   PEDetrGoodServiceCode:string,
      /**  PEProductServiceCode  */  
   PEProductServiceCode:string,
      /**  Dual UOM Class ID  */  
   DualUOMClassID:string,
      /**  Product Name  */  
   CNProductName:string,
      /**  Weight  */  
   CNWeight:number,
      /**  Unit of Weight  */  
   CNWeightUOM:string,
      /**  Bonded  */  
   CNBonded:boolean,
      /**  Indicates if inventory for this part is tracked at the attribute level. This feature requires the Advanced Unit of Measure license.  */  
   TrackInventoryAttributes:boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   DefaultAttributeSetID:number,
      /**  Indicates if entry of a County of Origin is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttISOrigCountry:string,
      /**  ISO / IEC 6523  */  
   ExternalSchemeID:string,
      /**  Part ID  */  
   ExternalID:string,
      /**  UNTDID 7143  */  
   CommoditySchemeID:string,
      /**  Part Commodity Scheme Version  */  
   CommoditySchemeVersion:string,
      /**  Indicates if inventory for this part is tracked by revision number.  */  
   TrackInventoryByRevision:boolean,
      /**  Indicates if this part performs MRP by Revision.  Requires Planning by Revision license.  */  
   PlanningByRevision:boolean,
      /**  RcvInspectionReqPart  */  
   RcvInspectionReqPart:string,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMPartType  */  
   FSMPartType:number,
   CountryNumDescription:string,
      /**  Should the Express Part Check Out option be enabled?  */  
   EnableExpressCheckOut:boolean,
   EnableGlobalLock:boolean,
   EnableGlobalPart:boolean,
      /**  Indicates if the InActive flag should be available for input,  */  
   EnableInActive:boolean,
      /**  Flag to tell UI whether the Part.IUM field should be enabled or not.  */  
   EnableIUM:boolean,
      /**  Indicates if Override Reverse Charge check box should be enabled.  */  
   EnableRevCharge:boolean,
      /**  Indicates if the Serial Number button should be enabled.  */  
   EnableSerialNum:boolean,
      /**  This field is used only as a flag to determine in UI, if the Part.TrackSerialNum can be change.  */  
   EnableTrackSerialNum:boolean,
      /**  Flag to tell UI whether the UOMClassID field should be enabled or not.  */  
   EnableUOMClass:boolean,
   ExtCoExist:boolean,
      /**  Default installation price of an equipment that requires installation in Epicor FSA.  */  
   FSAInstallationCost:number,
      /**  Indicates if the equipment requires an installation prior being marked as Installed on a Location in Epicor FSA. If true, at shipment it will create a service order for the installation service in FSA.  */  
   FSAInstallationRequired:boolean,
      /**  Indicates the service order template ID that Epicor FSA will use to create the installation service order.  */  
   FSAInstallationType:string,
   FSAInstTypeDesc:string,
      /**  Indicates if the Part is Global (master or linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany and GlbPartNum that is linking to this part  */  
   GlbLink:string,
      /**  check if TrackDimension is in GlbTable and should be disabled in Part Entry  */  
   GlbTableAllowUpdTrackDim:boolean,
      /**  check if TrackLots is in GlbTable and should be disabled in Part Entry  */  
   GlbTableAllowUpdTrackLots:boolean,
      /**  check if TrackSerialNum is in GlbTable and should be disabled in Part Entry  */  
   GlbTableAllowUpdTrackSerial:boolean,
      /**  Indicates if there is any quantity on hand for this part  */  
   HasOnHandQty:boolean,
      /**  Indicates if part is a component (has a where used list available)  */  
   IsComponent:boolean,
      /**   This field indicates if the part is being used as a co-part anywhere.  This field will be used to prevent a Part from being marked as serial tracked or configured after being added as a co-part.

CoParts Project.  */  
   IsCoPart:boolean,
      /**  This is the numeric value of ISOrigCountry.  */  
   ISOrigCountryNum:number,
      /**  Shows what the next generated lot number for this part would look like  */  
   NextGeneratedLotNum:string,
   PEDetrGoodServiceCodeDesc:string,
   PEProductServiceCodeDesc:string,
   PLM:boolean,
      /**  Indicates if the PLM toggle box is enabled.  */  
   PLMEnabled:boolean,
      /**  Revision  */  
   Revision:boolean,
   SalesUMDisp:string,
   SNLeadingZeros:boolean,
   SNMaskPrefixLength:number,
   SNMaskSuffixLength:number,
   SNNumODigits:number,
      /**  Yes means to copy the NonStock and CostMethod from Part to all the PartPlant records.  */  
   UpdatePartPlant:boolean,
      /**  Indicates whether to update the Part serial number format changes to part plant  */  
   UpdateSNPartPlant:boolean,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
      /**  If this Part is TrackInventoryAttributes = true, and the AttrClassID it is associated to has one or more attributes whose DynAttrClassDtl.UsedInPlanning= true.  */  
   HasMRPPlanningAttribute:boolean,
   UpdatePartPlantOverride:boolean,
      /**  DEPayStatCode Description  */  
   DEPayStatCodeDescr:string,
      /**  DEDenomination Description  */  
   DEDenominationDescr:string,
   DefaultBuyerName:string,
   DefaultPlannerName:string,
      /**  This field is used only as a flag to determine in UI, if the Part.TrackInventoryByRevision can be changed.  */  
   EnableTrackByRevision:boolean,
      /**  indicated if this part has been linked to a global part  */  
   LinkedToGlbPart:boolean,
      /**  Value is from MXProdCls User Code  */  
   MXProductClass:string,
      /**  Active Ingredient Name  */  
   MXActiveIngredientName:string,
      /**  Chemical Name  */  
   MXChemicalName:string,
      /**  Generic Product Name  */  
   MXGenericProductName:string,
      /**  Trademark  */  
   MXTrademark:string,
      /**  Manufacturer Company  */  
   MXManufacturerCompany:string,
      /**  Expiration Date  */  
   MXExpirationDate:string,
      /**  Medication Lot  */  
   MXMedicationLot:string,
      /**  Value is from MXProdForm User Code  */  
   MXPharmaceuticalForm:string,
      /**  Value is from MXProdKCnd User Code  */  
   MXKeepCondition:string,
      /**  Sanitary Registration Number  */  
   MXSanitaryRegistration:string,
      /**  CAS Number  */  
   MXCASNum:string,
      /**  Import Sanitary Registration Number  */  
   MXImportSanitaryRegistration:string,
      /**  Manufacturer Data Description  */  
   MXManufacturerData:string,
      /**  Formulator Data Description  */  
   MXFormulatorData:string,
      /**  Person Data Description  */  
   MXPersonData:string,
      /**  Authorized Use Description  */  
   MXAuthorizedUse:string,
      /**  Value is from MXProdMTyp User Code  */  
   MXMaterialType:string,
      /**  Description of the Other material Type  */  
   MXMaterialTypeDescription:string,
   BitFlag:number,
   AnalysisCdDescription:string,
   ClassDescription:string,
   CommodityCodeSuppUnitsUOM:string,
   CommodityCodeDescription:string,
   CompanySendToFSA:boolean,
   DualUOMClassIDDescription:string,
   DynAttrValueSetShortDescription:string,
   DynAttrValueSetDescription:string,
   FSAssetClassCodeFSAssetClassDesc:string,
   Mtl_AnalysisCdDescription:string,
   MXProdServCodeDesc:string,
   OnHoldReasonCodeDescription:string,
   ProdCodeDescription:string,
   RefCategoryDescription:string,
   SerialMaskMaskType:number,
   SerialMaskDescription:string,
   TaxCatIDDescription:string,
   UOMClassIDDescription:string,
   WarrantyCodeWarrDescription:string,
   XbSystELIEinvoice:boolean,
      /**  RowMod  */  
   RowMod:string,
   UD_SysRevID:string,
   SalesCatID_c:string,
   CustomBuyout_c:boolean,
   NonSellable_c:boolean,
   WebSearchable_c:boolean,
}

export interface Erp_Tablesets_PartSubsRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Part number that this substitute Part is for.  */  
   PartNum:string,
      /**  Substitute Part  */  
   SubPart:string,
      /**  Indicates the record type. "S" = Substitute, "C" = Compliment  */  
   RecType:string,
      /**  Pertains only to Substitute Parts (RecType = "S"). Values are "C" - Comparable, "D" - Downgrade, "U" - Upgrade  */  
   SubType:string,
      /**   The quantity of the alternate part per 1 of the parent part in the parents base inventory uom. Cannot be zero.
To convert an existing OrderDtl.SellingQty to a PartSubs. It is converted to the Parents Part Base Inventory UOM  then multiply PartSubs.QtyPer, then converted to  PartSub.SalesUM.  */  
   QtyPer:number,
      /**  Selling Unit of measure used when this part is used as a substitute/compliment with the parent part (partsubs.partnum).  Defaults as Part.SUM of the PartSub.SubPart.  */  
   SalesUM:string,
      /**  Optional Comment  */  
   Comment:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   DefaultSub:boolean,
      /**  Price for the Suggested Quantity  */  
   Price:number,
      /**  Suggested Quantity  */  
   SuggestedQty:number,
      /**  Selected Row  */  
   Selected:boolean,
      /**  Suggested Quantity for Order Qty in Quote Detail  */  
   SugOrderQty:number,
   BitFlag:number,
   PartNumPricePerCode:string,
   PartNumTrackLots:boolean,
   PartNumPartDescription:string,
   PartNumSalesUM:string,
   PartNumIUM:string,
   PartNumSellingFactor:number,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   SubPartSellingFactor:number,
   SubPartTrackSerialNum:boolean,
   SubPartTrackDimension:boolean,
   SubPartPartDescription:string,
   SubPartIUM:string,
   SubPartSalesUM:string,
   SubPartTrackLots:boolean,
   SubPartPricePerCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartTableset{
   Part:Erp_Tablesets_PartRow[],
   PartAttch:Erp_Tablesets_PartAttchRow[],
   PartCOO:Erp_Tablesets_PartCOORow[],
   PartDim:Erp_Tablesets_PartDimRow[],
   PartLangDesc:Erp_Tablesets_PartLangDescRow[],
   PartPlanningPool:Erp_Tablesets_PartPlanningPoolRow[],
   PartPlant:Erp_Tablesets_PartPlantRow[],
   PartPlantPlanningAttribute:Erp_Tablesets_PartPlantPlanningAttributeRow[],
   PartRestriction:Erp_Tablesets_PartRestrictionRow[],
   PartRestrictSubst:Erp_Tablesets_PartRestrictSubstRow[],
   PartRev:Erp_Tablesets_PartRevRow[],
   PartRevAttch:Erp_Tablesets_PartRevAttchRow[],
   PartAudit:Erp_Tablesets_PartAuditRow[],
   PartCOPart:Erp_Tablesets_PartCOPartRow[],
   PartRevInspPlan:Erp_Tablesets_PartRevInspPlanRow[],
   PartRevInspPlanAttch:Erp_Tablesets_PartRevInspPlanAttchRow[],
   PartRevInspVend:Erp_Tablesets_PartRevInspVendRow[],
   PartSubs:Erp_Tablesets_PartSubsRow[],
   PartPC:Erp_Tablesets_PartPCRow[],
   PartWhse:Erp_Tablesets_PartWhseRow[],
   PartBinInfo:Erp_Tablesets_PartBinInfoRow[],
   PartUOM:Erp_Tablesets_PartUOMRow[],
   EntityGLC:Erp_Tablesets_EntityGLCRow[],
   TaxExempt:Erp_Tablesets_TaxExemptRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_PartUOMPlasticTaxRow{
      /**  Company  */  
   Company:string,
      /**  PartNum  */  
   PartNum:string,
      /**  UOMCode  */  
   UOMCode:string,
      /**  EffectiveFrom  */  
   EffectiveFrom:string,
      /**  Active  */  
   Active:boolean,
      /**  PackagingWeight  */  
   PackagingWeight:number,
      /**  PackagingWeightUOM  */  
   PackagingWeightUOM:string,
      /**  PerItem  */  
   PerItem:number,
      /**  Exempt  */  
   Exempt:boolean,
      /**  ExemptPercent  */  
   ExemptPercent:number,
      /**  ExemptReasonCode  */  
   ExemptReasonCode:string,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
      /**  BaseUOMClassID  */  
   BaseUOMClassID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartUOMPlasticTaxTableset{
   PartUOMPlasticTax:Erp_Tablesets_PartUOMPlasticTaxRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_PartUOMRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  User defined code which uniquely identifies the UOM within the UOMClass.  */  
   UOMCode:string,
      /**   Value used to convert to/from base uom for the specific part. Cannot change if it's base uom of UOMClass (always 1.0) Sometimes a unit of measure conversion is relative to a specific part. These are non-standard conversions.
For example; 1 box(bx) of  Part A is 12ea. 1(bx) of Part B is 24ea. Non-standard conversions are defined in the PartUOM table. When ConvOperator = * then ConvFactor is 1 UOM expressed in Base UOM else it is 1 Base UOM expressed in UOM  */  
   ConvFactor:number,
      /**  Indicates if the PartUOM is Active. This field is ready only and is used for internal logic purposes only.  */  
   Active:boolean,
      /**  If true then Onhand Quantity will be tracked per this UOM for this part.  */  
   TrackOnHand:boolean,
      /**  The Part's Net Volume.  */  
   NetVolume:number,
      /**   Qualifies the unit of measure of the NewVolume field.
Must be a UOMConv of the UOMClass with ClassType of "volume".   Use UOMClass.DefUOMCode of the "volume" UOMClass as a default  when creating new part records.
Having a Net Volume UOM will provides the ability to calculate total volume  */  
   NetVolumeUOM:string,
      /**  This indicates that this Part UOM has been used somewhere.  Therefore we do not want to allow the associated part specific conversion to change.  */  
   HasBeenUsed:boolean,
      /**   Indicates the mathmatical operator that is used for performing the UOM Conversion. Options are "*" (Multiply) or "\" (Divide).
For example for Feet to Inch where Inch is the base uom. 
You could have 1ft / 12 = 1In  */  
   ConvOperator:string,
      /**  WebUOM  */  
   WebUOM:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Qualifies that 1 of this uom = ConvFactor in ConvToUOM. Example: 12in = 1ft or 1ft = 12in  */  
   ConvFromUOM:string,
      /**  External field used to enable/disable the conversion factor to able to change it.  */  
   ConvOverrride:boolean,
      /**  Qualifies UOM of the ConvFactor. This either the UOMClass.BaseUOM or the UOMConv.UOMCode depending on the value of ConvOperator.  */  
   ConvToUOM:string,
      /**  EAN13 product code from PartPC  */  
   EAN13:string,
      /**  EAN14 product code from PartPC  */  
   EAN14:string,
      /**  EAN8 product code from PartPC  */  
   EAN8:string,
      /**  Internal use. To indicate if the ConvFactor should be enabled. This field is set to true if the related UOMClass is non-standard and the UOMCode is not the BaseUOM  */  
   EnableConvFactor:boolean,
      /**  Indicates if the TrackOnHand is enabled. True when Part.TrackMultiUOM = true and UOMCode <> Part.IUM  */  
   EnableTrackOnHand:boolean,
      /**  GTIN14 product code from PartPC  */  
   GTIN14:string,
      /**  HIBC UPN product code from PartPC  */  
   HIBC:string,
      /**  Value of UOMConv.PartSpecific for informational purposes  */  
   PartSpecific:boolean,
   UOMDesc:string,
      /**  UPC12 product code from PartPC  */  
   UPC12:string,
      /**  BaseUOMCode from UOMClass file  */  
   BaseUOMCode:string,
      /**  Used to input/display the package code related to the part/UOM. The user will only be able to update this data if Part.UsePartSpecificPckCode = true  */  
   DispPkgCode:string,
      /**  Description of the PkgCode  */  
   DispPkgCodeDesc:string,
      /**  Indicates the display sequence of the packaging in relation to the other packaging for the part.  */  
   DispPkgDisplaySeq:number,
      /**  Indicates if the PkgCode is the default.  */  
   DispPkgIsDefault:boolean,
      /**  Indicates if the pkg code information seen in PartUOM is part specific (the data came from PackingUOM where PartNum is not blank.) If true the package code data can be updated in Part Maint, if false the PartUOM pkgcode columns will be disabled.  */  
   PartSpecificPkgCode:boolean,
      /**  Indicates if the package code will be displayed in the application. If false, the package codes that are not valid for the MGF process on the shop floor are hidden.  */  
   DispPkgDisplayHidden:boolean,
   StandardUpdate:boolean,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartWhereUsedRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Parent Part number to which this material item is a component of  */  
   PartNum:string,
      /**  Revision number of the part that this material item is a component of.  */  
   RevisionNum:string,
      /**  A sequence number that uniquely defines the Material record within a specific Job/Lot/Assembly. This is system assigned. The next available # is determined by reading last JobMtl record on the Job/Lot/Assembly and then adding one to it.  */  
   MtlSeq:number,
      /**  The Part Number of the component material record for the related Parent Part.  */  
   MtlPartNum:string,
      /**  Quantity per parent  */  
   QtyPer:number,
      /**  Indicates if the QtyPer field represents a "Fixed Quantity".  If Yes, then the required quantity = QtyPer.  That is, the quantity does not change as the number of pieces being produced changes.  This can be used to enter Tooling or Fixture type of requirements.  */  
   FixedQty:boolean,
      /**  This is relevant for assemblies (Part.Method = Yes). Indicates that if this assembly should be pulled from stock or manufactured as part of the job it is pulled into. If PullAsAsm = No only the assembly record will be pulled into the job/quote (as a material), the related material and operations will not be pulled over.  */  
   PullAsAsm:boolean,
      /**  Characters used on the drawing to show where material is used.  */  
   FindNum:string,
      /**  Alternate Routing method for the part revision.  */  
   AltMethod:string,
      /**  Indicates if the base revision method was overridden.  Applies only when the AltMethod field is not blank.  */  
   BaseMethodOverridden:boolean,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The identifier of related Process Manufacturing.  */  
   ProcessMfgID:string,
      /**  If (PartMtl.ViewAsAsm) then xlate("Asm") else xlate("Mtl")  */  
   TypeDesc:string,
      /**  Intended to be used by the UI to control "Track Up" function. Indicates if the PartNum part is a component of another part. If so the system can "Track Up" to view that part.  */  
   CanTrackUp:boolean,
   PartNumPartDescription:string,
      /**   Operation Master Code - Links the JobOper  record with a OpMaster record. Default is given from WrkCenter.OpCode.
Must be valid in the OpMaster file.  */  
   OpCode:string,
      /**  Operation Description.  */  
   OpDesc:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartWhereUsedTableset{
   PartRefDesWhereUsed:Erp_Tablesets_PartRefDesWhereUsedRow[],
   PartWhereUsed:Erp_Tablesets_PartWhereUsedRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_PartWhseRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Part Number  */  
   PartNum:string,
      /**  Warehouse  */  
   WarehouseCode:string,
      /**   A summary of the outstanding quantities for order open sales releases that are being filled from stock and of the open job material requirements that are to be issued from stock (JobMtl.Buyit = No) for this Part within a specific warehouse.
The system calculates Available as OnhandQty - AllocatedQty.  */  
   DemandQty:number,
      /**  A summary of the reserved quantities for order open sales releases for this Part within a specific warehouse. NOTE: This value is the TOTAL of reservations in PartAlloc.  */  
   ReservedQty:number,
      /**  A summary of the allocated quantities for order open sales releases for this Part within a specific warehouse. NOTE: This value is the TOTAL of allocation in PartAlloc.  */  
   AllocatedQty:number,
      /**  Quantity that is in the picking process for orders. A summary of PartAlloc.PickingQty for all demand.  */  
   PickingQty:number,
      /**  Stock Quantity picked for orders.  A summary of PartAlloc.PickedQty for all demand.  */  
   PickedQty:number,
      /**  Date last counted.  Updated during the Inventory Posting Process.  Not directly maintainable by user.  */  
   CountedDate:string,
      /**  A summary of PartBin.OnHandQty for the warehouse where the bin is a nettable bin (WhseBin.NonNettable = NO). Maintained via the PartBin write trigger.  */  
   OnHandQty:number,
      /**  A summary of PartBin.OnHandQty for the warehouse where the bin is a non nettable bin (WhseBin.NonNettable = YES). Maintained via the PartBin write trigger.  */  
   NonNettableQty:number,
      /**  A summary of Demand that is Buy To Order and thus should not take away from Available inventory.  */  
   BuyToOrderQty:number,
      /**   A summary of the outstanding quantities for order open sales releases that are being filled from stock for this Part within a specific warehouse.
The system calculates Available as OnhandQty - AllocatedQty.  */  
   SalesDemandQty:number,
      /**  A total of inventory quantities that has been reserved  for sales orders.   A summary of PartAlloc.ReservedQty for sales order allocations against stock  (PartAlloc.OrderNum > 0 & SupplyJobNum = blank).  */  
   SalesReservedQty:number,
      /**  New in 9.00.  A summary of outstanding quantities for order open sales releases that are being filled from stock and have not been reserved, selected for picking or picked. Calculated as OurStockQty - ReservedQty + PickingQty + PickedQty).  Note: ReservedQty, PickingQty, PickedQty are summaries of PartAlloc records with a blank job,  related to an OrderRel.  The system tracks allocation summaries in the following sequence; AllocQty--> ReservedQty--> PickingQty--> PickedQty.  */  
   SalesAllocatedQty:number,
      /**   Quantity that is in the picking process for sales orders. A summary of PartAlloc.PickingQty where PartAlloc.OrderNum > 0
A summary of PartAlloc.PickingQty for sales order that are being picked from stock (PartAlloc.OrderNum > 0 & SupplyJobNum = blank).  */  
   SalesPickingQty:number,
      /**  Stock Quantity picked for sales orders.  A summary of PartAlloc.PickedQty for sales order picked from stock  (PartAlloc.OrderNum > 0 & SupplyJobNum = blank).  */  
   SalesPickedQty:number,
      /**  A summary of the outstanding quantities for job material requirements that are being filled from stock for this Part within a specific warehouse.  */  
   JobDemandQty:number,
      /**  Summary of mfg demands on released jobs. That is, a summary of outstanding JobMtl and JobAsmbl.PullQty where JobHead.JobFirm = Yes and JobReleased = Yes  */  
   JobReservedQty:number,
      /**  New in 9.00.  Summary of stock allocated for jobs.  */  
   JobAllocatedQty:number,
      /**  Quantity that is in the picking process for jobs. A summary of PartAlloc.PickingQty where PartAlloc.JobNum <> ''.  */  
   JobPickingQty:number,
      /**  Stock Quantity picked for jobs.  */  
   JobPickedQty:number,
      /**  New in 9.00.  Summary of mfg demand requirements on unfirm jobs. That is, a summary of outstanding JobMtl.RequiredQty and JobAsmbl.PullQty where JobHead.JobFirm = No.  */  
   UnfirmJobDemandQty:number,
      /**   A summary of the outstanding quantities for transfer order requirements that are being filled from stock for this Part within a specific warehouse.
The system calculates Available as OnhandQty - AllocatedQty.  */  
   TFOrdDemandQty:number,
      /**  Summary of Transfer Order Reserved Qty for this Part in this Warehouse.  */  
   TFOrdReservedQty:number,
      /**  Summary of Transfer Order Allocated Qty for this Part in this Warehouse.  */  
   TFOrdAllocatedQty:number,
      /**  Quantity that is in the picking process for transfer orders.  A summary of PartAlloc.PickingQty where PartAlloc.TFOrdNum > 0.  */  
   TFOrdPickingQty:number,
      /**  Stock Quantity picked for transfer orders.  */  
   TFOrdPickedQty:number,
      /**  Uniquely indentifies the record.  */  
   KBCode:string,
      /**  Indicates the desired minimum on-hand quantity. This is used by the time phase requirements report when user requests to show any parts that will or have fallen below this level. It is also used as a selection parameter for the inventory reorder report. This is an optional field.  */  
   MinimumQty:number,
      /**  Use to set a Maximum quantity limit that is desired to be on-hand. This field is used as a selection option by the inventory reorder report to show all parts that are over this limit. This field is optional.  */  
   MaximumQty:number,
      /**   Safety quantity is a "purchasing cushion" limit. It's the amount you would need to have to cover your requirements until a shipment arrives from the vendor. If your on-hand quantity falls below this limit it means that there is a good chance that you will run out of material before the next shipment arrives. This value is used by the inventory reorder report and the time phase report. It is an optional field.
Note: Safety + Minimum = Reorder Point...  using this formula the  reorder point is the amount at which to reorder to maintain at least the prescribed minimum quantity.  */  
   SafetyQty:number,
      /**  Purchase order number  that the detail line item is linked to.  */  
   KBPONUM:number,
      /**  The line number of the detail record on the purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   KBPOLine:number,
      /**  Kanban Warehouse  */  
   KBWarehouseCode:string,
      /**  Identifies the Bin location that contains an Onhand quantity for this Part within a warehouse. The PartBin.BinNum can be blank (indicating bin tracking is not used for this part) or it  must be valid in the WhseBin table.  */  
   KBBinNum:string,
      /**  Site Identifier. This field cannot be blank.  */  
   KBPlant:string,
      /**  Indicates the desired minimum on-hand Kanban quantity.  */  
   KBQty:number,
      /**  Percent Tolerance. Entered as a positive number, Used to define the default percent tolerance. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a percentage difference between the count quantity and the frozen quantity by more than the percent tolerance figure is considered out of tolerance. Calculated as ?adjustment qty / frozen qty? expressed as a percent.  */  
   PcntTolerance:number,
      /**  False = there is no percent tolerance consideration and any percent variance is considered within tolerance. True = percent tolerance is active for this part/whs and the value in PcntTolerance will be used to determine if the count variance is within tolerance.  */  
   CalcPcnt:boolean,
      /**  False = there is no quantity tolerance consideration and any quantity variance is considered within tolerance. True = quantity tolerance is active for this part/whse and the value in QtyTolerance will be used to determine if the count variance is within tolerance.  */  
   CalcQty:boolean,
      /**  False = there is no value tolerance consideration and any value variance is considered within tolerance. True = value tolerance is active for this part/whse and the value in ValueTolerance will be used to determine if the count variance is within tolerance.  */  
   CalcValue:boolean,
      /**  Used to provide a means to control whether a count quantity discrepancy should be posted as an adjustment to inventory. Zero indicates all quantity adjustments will be posted. This parameter is used to control the count discrepancy of parts that are counted by weight on a scale. Counts often vary based upon humidity. If the count of the part is within this tolerance but different from the frozen quantity then no inventory adjustment will be posted.  */  
   QtyAdjTolerance:number,
      /**  False = there is no qty adj tolerance setting at the PartWhse level (so the setting in PartSite will be used). True = qty adj tolerance is active for this part/whs and the value in QtyAdjTolerance will be used to determine if the count variance should be  */  
   CalcQtyAdj:boolean,
      /**  Moved from PartSite. When the system sets the ABC class, it will not allow the class to be lower than this class.  */  
   MinAbc:string,
      /**  Moved from PartSite. ABC Classification calculated by the system based on Stock Valuation Percent. This is maintainable by the user if ManualABC = true.  */  
   SystemAbc:string,
      /**  This will lock the SystemABC code preventing the automatic determination by the Calculate ABC Codes process, which will not reset the ABC code on parts that have the flag set.  */  
   ManualABC:boolean,
      /**  The last date this part was cycle counted. This date is used to insure that a part will be selected for cycle counting at the appropriate time. This is different than the CountedDate field, which will be updated for either a cycle count or physical inventory.  */  
   LastCCDate:string,
      /**  This flag indicates whether the CountFreq defined in this record should over ride the count frequency in the AbcCode, SiteConfABC or WarehseABC tables.  */  
   OvrrideCountFreq:boolean,
      /**  If greater than zero this setting overrides values in AbcCode,  SiteConfABC and Warehse.  */  
   CountFreq:number,
      /**  Quantity tolerance. Entered as a positive whole number, Used to define the default quantity tolerance. Zero indicates that any quantity variance is considered out of tolerance. A number greater than zero indicates that a count quantity that varies from the frozen quantity by more than the quantity tolerance figure is considered out of tolerance.  */  
   QtyTolerance:number,
      /**  Value tolerance. Entered as a positive number. Used to define the default value tolerance.  An entry of zero will indicate that any value variance will be considered out of tolerance for this part. Value variance is calculated as the difference in cost between the counted quantity and the frozen quantity.  */  
   ValueTolerance:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Filled in by BO, not phiscally in database.  */  
   Plant:string,
   DefaultWhse:boolean,
   PrimBinNum:string,
   TotalDemand:number,
   PrimBinNumDescription:string,
   KBActionCode:string,
   KBActionDesc:string,
   PlantOwner:string,
   MaxQtyUOM:string,
   MinQtyUOM:string,
   SafetyQtyUOM:string,
      /**  Part Warehouse columns Unit Of Measure.  */  
   IUM:string,
   BitFlag:number,
   KBBinNumDescription:string,
   KBCodeKBActionCode:string,
   KBCodeKBDescription:string,
   KBPlantName:string,
   KBWarehouseCodeDescription:string,
   PartNumIUM:string,
   PartNumPricePerCode:string,
   PartNumTrackSerialNum:boolean,
   PartNumSalesUM:string,
   PartNumSellingFactor:number,
   PartNumTrackLots:boolean,
   PartNumPartDescription:string,
   PartNumTrackDimension:boolean,
   WarehouseDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_TaxExemptRow{
      /**  Company Identifier.  */  
   Company:string,
      /**   Identifies the master file to which the GL Control is related to.  This field is used to properly isolate controls to the masters they are related to.
For example; Customer, PartClass identifies controls that are related to Customers and Part Classes  */  
   RelatedToFile:string,
      /**  Major component of the foreign key of the related master record. For example: For a "Part"  control this field would contain the related Part Number,  for a "Customer"  it contains the Customer.CustNum.  */  
   Key1:string,
      /**   2nd component of the foreign key to the related master record.
The usage of this field is dependent on the type of record.  */  
   Key2:string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   TaxCode:string,
      /**  Tax Rate Code  */  
   RateCode:string,
      /**  Exemption Effective Start Date  */  
   EffectiveFrom:string,
      /**  Exemption Effective End Date  */  
   EffectiveTo:string,
      /**  Exemption Type  */  
   ExemptType:number,
      /**  Exemption Percent  */  
   ExemptPercent:number,
      /**  Tax Legal Text Code  */  
   TextCode:string,
      /**  Tax Resolution Number  */  
   ResolutionNum:string,
      /**  Tax Resolution Date  */  
   ResolutionDate:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  A unique Customer identifier.  */  
   CustNum:number,
      /**  The PartNum field identifies the Part.  */  
   PartNum:string,
      /**  A unique Vendor identifier.  */  
   VendorNum:number,
   BitFlag:number,
   SalesTaxDescription:string,
   SalesTRCDescription:string,
   TaxTextDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_TrackerFilterRow{
   DMRPlant:string,
   EngWkb:boolean,
   Inactive:boolean,
   InspectionPlant:string,
   InTransitPlant:string,
   OnHandLots:boolean,
   PartNum:string,
   RtnStart:boolean,
   SNAsset:boolean,
   SNConsumed:boolean,
   SNInWIP:boolean,
   SNRejAdj:boolean,
   SNShipped:boolean,
   SNWhsePlant:string,
   SNWhsePlantDesc:string,
   TrackDown:boolean,
   TrackUp:boolean,
   Warehouse:string,
   WarehouseDesc:string,
   WhseBin:string,
   WhseBinDesc:string,
   WhseCount:string,
   WhsePlant:string,
   WhsePlantDesc:string,
   WipCompletedOnly:boolean,
   WipExcludeProdLoc:boolean,
   WipPlant:string,
   ActualCostingRevisionNum:string,
   ActualCostingPlant:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_TrackerFilterTableset{
   TrackerFilter:Erp_Tablesets_TrackerFilterRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_UpdExtPartTableset{
   Part:Erp_Tablesets_PartRow[],
   PartAttch:Erp_Tablesets_PartAttchRow[],
   PartCOO:Erp_Tablesets_PartCOORow[],
   PartDim:Erp_Tablesets_PartDimRow[],
   PartLangDesc:Erp_Tablesets_PartLangDescRow[],
   PartPlanningPool:Erp_Tablesets_PartPlanningPoolRow[],
   PartPlant:Erp_Tablesets_PartPlantRow[],
   PartPlantPlanningAttribute:Erp_Tablesets_PartPlantPlanningAttributeRow[],
   PartRestriction:Erp_Tablesets_PartRestrictionRow[],
   PartRestrictSubst:Erp_Tablesets_PartRestrictSubstRow[],
   PartRev:Erp_Tablesets_PartRevRow[],
   PartRevAttch:Erp_Tablesets_PartRevAttchRow[],
   PartAudit:Erp_Tablesets_PartAuditRow[],
   PartCOPart:Erp_Tablesets_PartCOPartRow[],
   PartRevInspPlan:Erp_Tablesets_PartRevInspPlanRow[],
   PartRevInspPlanAttch:Erp_Tablesets_PartRevInspPlanAttchRow[],
   PartRevInspVend:Erp_Tablesets_PartRevInspVendRow[],
   PartSubs:Erp_Tablesets_PartSubsRow[],
   PartPC:Erp_Tablesets_PartPCRow[],
   PartWhse:Erp_Tablesets_PartWhseRow[],
   PartBinInfo:Erp_Tablesets_PartBinInfoRow[],
   PartUOM:Erp_Tablesets_PartUOMRow[],
   EntityGLC:Erp_Tablesets_EntityGLCRow[],
   TaxExempt:Erp_Tablesets_TaxExemptRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_UsedPartsRow{
   PartNum:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_UsedPartsTableset{
   UsedParts:Erp_Tablesets_UsedPartsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

   /** Required : 
      @param ipPartNum
   */  
export interface FindPart_input{
   ipPartNum:string,
}

export interface FindPart_output{
parameters : {
      /**  output parameters  */  
   opPartNum:string,
   opUOM:string,
   opMatchType:string,
}
}

   /** Required : 
      @param partNum
   */  
export interface GetByID_input{
   partNum:string,
}

export interface GetByID_output{
   returnObj:Erp_Tablesets_PartTableset[],
}

   /** Required : 
      @param id
   */  
export interface GetBySysRowID_input{
   id:string,
}

export interface GetBySysRowID_output{
   returnObj:Erp_Tablesets_PartTableset[],
}

   /** Required : 
      @param ids
   */  
export interface GetBySysRowIDs_input{
   ids:string,
}

export interface GetBySysRowIDs_output{
   returnObj:Erp_Tablesets_PartTableset[],
}

   /** Required : 
      @param tableName
      @param fieldName
   */  
export interface GetCodeDescList_input{
   tableName:string,
   fieldName:string,
}

export interface GetCodeDescList_output{
   returnObj:string,
}

export interface GetConfTypeDescList_output{
   returnObj:string,
}

   /** Required : 
      @param part
   */  
export interface GetDMRListSearch_input{
      /**  Part  */  
   part:string,
}

export interface GetDMRListSearch_output{
   returnObj:Erp_Tablesets_PartGetDMRListTableset[],
}

   /** Required : 
      @param uomClassID
   */  
export interface GetDualUomClassList_input{
      /**  The UOM Class ID used to find compatible Dual UOM Classes.  */  
   uomClassID:string,
}

export interface GetDualUomClassList_output{
   returnObj:string,
}

   /** Required : 
      @param configID
   */  
export interface GetDupPartConfigID_input{
      /**  ConfigID  */  
   configID:string,
}

export interface GetDupPartConfigID_output{
parameters : {
      /**  output parameters  */  
   message:string,
   foundConfigID:string,
   foundDescription:string,
   foundType:string,
}
}

export interface GetExternalCRMIntegrationIsEnabled_output{
   returnObj:boolean,
}

   /** Required : 
      @param GlbPartNumList
   */  
export interface GetGlbPartList_input{
      /**  Delimited list of GlbPartNum values  */  
   GlbPartNumList:string,
}

export interface GetGlbPartList_output{
   returnObj:Erp_Tablesets_GlbPartTableset[],
}

   /** Required : 
      @param site_ex
      @param partnum_ex
   */  
export interface GetIfCurrentRevIsSiteExternalMES_input{
   site_ex:string,
   partnum_ex:string,
}

export interface GetIfCurrentRevIsSiteExternalMES_output{
   returnObj:boolean,
}

   /** Required : 
      @param site_ex
   */  
export interface GetIfCurrentSiteHasExternalMES_input{
   site_ex:string,
}

export interface GetIfCurrentSiteHasExternalMES_output{
   returnObj:boolean,
}

   /** Required : 
      @param WhereClause
      @param PartRevWhereClause
      @param PageSize
      @param AbsolutePage
   */  
export interface GetListByConfigID_input{
      /**  Whereclause.  */  
   WhereClause:string,
      /**  PartRevWhereClause.  */  
   PartRevWhereClause:string,
      /**  Page size.  */  
   PageSize:number,
      /**  Absolute page.  */  
   AbsolutePage:number,
}

export interface GetListByConfigID_output{
   returnObj:Erp_Tablesets_PartListTableset[],
parameters : {
      /**  output parameters  */  
   MorePages:boolean,
}
}

   /** Required : 
      @param partWhereClause
      @param warehouseCode
      @param binType
      @param zoneID
      @param fromBinNum
      @param toBinNum
      @param excludeNonNettable
      @param pageSize
      @param absolutePage
   */  
export interface GetListByWarehouseBin_input{
      /**  The where clause the filters the part records.  */  
   partWhereClause:string,
      /**  Search records for this warehouse code only.  */  
   warehouseCode:string,
      /**  Search records for this specific bin type.  */  
   binType:string,
      /**  Get parts for this zone.  */  
   zoneID:string,
      /**  From bin range.  */  
   fromBinNum:string,
      /**  To bin range.  */  
   toBinNum:string,
      /**  Exclude non-nettable bins.  */  
   excludeNonNettable:boolean,
      /**  Page size.  */  
   pageSize:number,
      /**  Absolute page.  */  
   absolutePage:number,
}

export interface GetListByWarehouseBin_output{
   returnObj:Erp_Tablesets_PartListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param custNum
      @param startWith
      @param typeCode
      @param partDescription
      @param primaryColumn
      @param PageSize
      @param AbsolutePage
   */  
export interface GetListFilterCustXPrt_input{
      /**  Customer Part Cross Reference Number.  */  
   custNum:number,
      /**  Start With Part Search Filter.  */  
   startWith:string,
      /**  Type Code Part Search Filter.  */  
   typeCode:string,
      /**  Part Description Part Search Filter.  */  
   partDescription:string,
      /**  Primary Column Part Search Filter.  */  
   primaryColumn:string,
      /**  Page size.  */  
   PageSize:number,
      /**  Absolute page.  */  
   AbsolutePage:number,
}

export interface GetListFilterCustXPrt_output{
   returnObj:Erp_Tablesets_PartListTableset[],
parameters : {
      /**  output parameters  */  
   MorePages:boolean,
}
}

   /** Required : 
      @param WhereClause
      @param PageSize
      @param AbsolutePage
   */  
export interface GetListFilterPlants_input{
      /**  Whereclause.  */  
   WhereClause:string,
      /**  Page size.  */  
   PageSize:number,
      /**  Absolute page.  */  
   AbsolutePage:number,
}

export interface GetListFilterPlants_output{
   returnObj:Erp_Tablesets_PartListTableset[],
parameters : {
      /**  output parameters  */  
   MorePages:boolean,
}
}

   /** Required : 
      @param ds
      @param pageSize
      @param absolutePage
   */  
export interface GetListFromSelectedKeys_input{
   ds:Erp_Tablesets_PartListTableset[],
      /**  The page size, used only for UI adaptor  */  
   pageSize:number,
      /**  The absolute page, used only for the UI adaptor  */  
   absolutePage:number,
}

export interface GetListFromSelectedKeys_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartListTableset[],
   morePages:boolean,
}
}

   /** Required : 
      @param whereClause
      @param pageSize
      @param absolutePage
   */  
export interface GetList_input{
      /**  An expression used to filter the rows. Can be left blank for all rows.  */  
   whereClause:string,
      /**  The maximum number of rows to return. Leave as zero for no maximum.  */  
   pageSize:number,
      /**  Page of rows to return.  */  
   absolutePage:number,
}

export interface GetList_output{
   returnObj:Erp_Tablesets_PartListTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param ds
      @param relatedToFile
      @param key1
      @param key2
      @param key3
      @param key4
      @param key5
      @param key6
   */  
export interface GetNewEntityGLC_input{
   ds:Erp_Tablesets_PartTableset[],
   relatedToFile:string,
   key1:string,
   key2:string,
   key3:string,
   key4:string,
   key5:string,
   key6:string,
}

export interface GetNewEntityGLC_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartAttch_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
      @param processMfgID
      @param changeDate
   */  
export interface GetNewPartAudit_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
   processMfgID:string,
   changeDate:string,
}

export interface GetNewPartAudit_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param plant
      @param warehouseCode
   */  
export interface GetNewPartBinInfo_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   plant:string,
   warehouseCode:string,
}

export interface GetNewPartBinInfo_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartCOO_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartCOO_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
      @param processMfgID
   */  
export interface GetNewPartCOPart_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
   processMfgID:string,
}

export interface GetNewPartCOPart_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartDim_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartDim_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartLangDesc_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartLangDesc_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param pcType
   */  
export interface GetNewPartPC_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   pcType:string,
}

export interface GetNewPartPC_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartPlanningPool_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartPlanningPool_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param plant
      @param attrClassID
   */  
export interface GetNewPartPlantPlanningAttribute_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   plant:string,
   attrClassID:string,
}

export interface GetNewPartPlantPlanningAttribute_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartPlant_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartPlant_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param restrictionTypeID
   */  
export interface GetNewPartRestrictSubst_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   restrictionTypeID:string,
}

export interface GetNewPartRestrictSubst_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartRestriction_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartRestriction_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
      @param processMfgID
   */  
export interface GetNewPartRevAttch_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
   processMfgID:string,
}

export interface GetNewPartRevAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
      @param processMfgID
      @param seqPlan
   */  
export interface GetNewPartRevInspPlanAttch_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
   processMfgID:string,
   seqPlan:number,
}

export interface GetNewPartRevInspPlanAttch_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
      @param processMfgID
   */  
export interface GetNewPartRevInspPlan_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
   processMfgID:string,
}

export interface GetNewPartRevInspPlan_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
      @param processMfgID
   */  
export interface GetNewPartRevInspVend_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
   processMfgID:string,
}

export interface GetNewPartRevInspVend_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param revisionNum
      @param altMethod
   */  
export interface GetNewPartRev_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   revisionNum:string,
   altMethod:string,
}

export interface GetNewPartRev_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartSubs_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartSubs_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param PartNum
      @param UOMCode
   */  
export interface GetNewPartUOMPlasticTax_input{
   ds:Erp_Tablesets_PartUOMPlasticTaxTableset[],
   PartNum:string,
   UOMCode:string,
}

export interface GetNewPartUOMPlasticTax_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartUOMPlasticTaxTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
   */  
export interface GetNewPartUOM_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
}

export interface GetNewPartUOM_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param partNum
      @param plant
   */  
export interface GetNewPartWhse_input{
   ds:Erp_Tablesets_PartTableset[],
   partNum:string,
   plant:string,
}

export interface GetNewPartWhse_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface GetNewPart_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface GetNewPart_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param relatedToFile
      @param key1
      @param key2
      @param taxCode
      @param rateCode
   */  
export interface GetNewTaxExempt_input{
   ds:Erp_Tablesets_PartTableset[],
   relatedToFile:string,
   key1:string,
   key2:string,
   taxCode:string,
   rateCode:string,
}

export interface GetNewTaxExempt_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param PartNum
   */  
export interface GetPartForLink_input{
      /**  Global PartNum field on the GlbPart record to link  */  
   PartNum:string,
}

export interface GetPartForLink_output{
   returnObj:Erp_Tablesets_PartTableset[],
}

   /** Required : 
      @param ipRowType
      @param ipRowID
   */  
export interface GetPartFromRowID_input{
   ipRowType:string,
   ipRowID:string,
}

export interface GetPartFromRowID_output{
parameters : {
      /**  output parameters  */  
   opPartNum:string,
   opUOM:string,
}
}

   /** Required : 
      @param cPartNum
      @param GlobalLock
   */  
export interface GetPartGlobalFields_input{
   cPartNum:string,
   GlobalLock:boolean,
}

export interface GetPartGlobalFields_output{
   returnObj:string,
}

   /** Required : 
      @param part
   */  
export interface GetPartUOMPlasticTax_input{
   part:string,
}

export interface GetPartUOMPlasticTax_output{
   returnObj:Erp_Tablesets_PartUOMPlasticTaxTableset[],
}

   /** Required : 
      @param whereUsedPartNum
      @param pageSize
      @param absolutePage
   */  
export interface GetPartWhereUsed_input{
      /**  Part number which you want the where used dataset for.  */  
   whereUsedPartNum:string,
      /**  pageSize  */  
   pageSize:number,
      /**  absolutePage  */  
   absolutePage:number,
}

export interface GetPartWhereUsed_output{
   returnObj:Erp_Tablesets_PartWhereUsedTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

   /** Required : 
      @param partNum
      @param SysRowID
      @param rowType
   */  
export interface GetPartXRefInfo_input{
      /**  Proposed PartNumber change  */  
   partNum:string,
      /**  RowID of the selected record. Skips find part logic if this has a value.  */  
   SysRowID:string,
      /**  RowType of the selected record. Only used with sysRowID.  */  
   rowType:string,
}

export interface GetPartXRefInfo_output{
parameters : {
      /**  output parameters  */  
   partNum:string,
   serialWarning:string,
   questionString:string,
   multipleMatch:boolean,
}
}

   /** Required : 
      @param configID
   */  
export interface GetPcStatusIsKinetic_input{
      /**  Configurator ID  */  
   configID:string,
}

export interface GetPcStatusIsKinetic_output{
   returnObj:boolean,
}

export interface GetRestrictedMethodsInfo_output{
parameters : {
      /**  output parameters  */  
   opDenyPurchasingInfo:boolean,
   opDenyInventoryInfo:boolean,
   opDenyLotMaintenance:boolean,
}
}

   /** Required : 
      @param whereClausePart
      @param whereClausePartAttch
      @param whereClausePartCOO
      @param whereClausePartDim
      @param whereClausePartLangDesc
      @param whereClausePartPlanningPool
      @param whereClausePartPlant
      @param whereClausePartPlantPlanningAttribute
      @param whereClausePartRestriction
      @param whereClausePartRestrictSubst
      @param whereClausePartRev
      @param whereClausePartRevAttch
      @param whereClausePartAudit
      @param whereClausePartCOPart
      @param whereClausePartRevInspPlan
      @param whereClausePartRevInspPlanAttch
      @param whereClausePartRevInspVend
      @param whereClausePartSubs
      @param whereClausePartPC
      @param whereClausePartWhse
      @param whereClausePartBinInfo
      @param whereClausePartUOM
      @param whereClauseEntityGLC
      @param whereClauseTaxExempt
      @param pageSize
      @param absolutePage
   */  
export interface GetRows_input{
   whereClausePart:string,
   whereClausePartAttch:string,
   whereClausePartCOO:string,
   whereClausePartDim:string,
   whereClausePartLangDesc:string,
   whereClausePartPlanningPool:string,
   whereClausePartPlant:string,
   whereClausePartPlantPlanningAttribute:string,
   whereClausePartRestriction:string,
   whereClausePartRestrictSubst:string,
   whereClausePartRev:string,
   whereClausePartRevAttch:string,
   whereClausePartAudit:string,
   whereClausePartCOPart:string,
   whereClausePartRevInspPlan:string,
   whereClausePartRevInspPlanAttch:string,
   whereClausePartRevInspVend:string,
   whereClausePartSubs:string,
   whereClausePartPC:string,
   whereClausePartWhse:string,
   whereClausePartBinInfo:string,
   whereClausePartUOM:string,
   whereClauseEntityGLC:string,
   whereClauseTaxExempt:string,
   pageSize:number,
   absolutePage:number,
}

export interface GetRows_output{
   returnObj:Erp_Tablesets_PartTableset[],
parameters : {
      /**  output parameters  */  
   morePages:boolean,
}
}

export interface GetSNFormat_output{
   returnObj:string,
}

   /** Required : 
      @param sendToFSA
      @param partNum
      @param ds
   */  
export interface GetSendToFSAChange_input{
   sendToFSA:boolean,
   partNum:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface GetSendToFSAChange_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param SNBaseDataType
      @param SNNumODigits
      @param SNPrefix
      @param SNMaskExample
      @param SNLeadingZeros
   */  
export interface GetSerialNumberFormatLeadingZeros_input{
   SNBaseDataType:string,
   SNNumODigits:number,
   SNPrefix:string,
   SNMaskExample:string,
   SNLeadingZeros:boolean,
}

export interface GetSerialNumberFormatLeadingZeros_output{
   returnObj:string,
}

   /** Required : 
      @param SNBaseDataType
      @param SNNumODigits
      @param SNPrefix
      @param SNMaskExample
   */  
export interface GetSerialNumberFormat_input{
   SNBaseDataType:string,
   SNNumODigits:number,
   SNPrefix:string,
   SNMaskExample:string,
}

export interface GetSerialNumberFormat_output{
   returnObj:string,
}

   /** Required : 
      @param partNum
   */  
export interface GetTrackInventoryByRevision_input{
      /**  Part number  */  
   partNum:string,
}

export interface GetTrackInventoryByRevision_output{
parameters : {
      /**  output parameters  */  
   trackInventoryByRevision:boolean,
}
}

   /** Required : 
      @param partNum
      @param warehouseCode
   */  
export interface GetValidatePartWarehouseBin_input{
   partNum:string,
   warehouseCode:string,
}

export interface GetValidatePartWarehouseBin_output{
parameters : {
      /**  output parameters  */  
   binNum:string,
}
}

   /** Required : 
      @param ds
   */  
export interface GetWhereUsedECORevClause_input{
   ds:Erp_Tablesets_PartWhereUsedTableset[],
}

export interface GetWhereUsedECORevClause_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartWhereUsedTableset[],
   whereClause:string,
}
}

export interface GlbPartsExist_output{
parameters : {
      /**  output parameters  */  
   GlbPartsExist:boolean,
}
}

export interface HasIntrastat_output{
parameters : {
      /**  output parameters  */  
   hasIntrastat:boolean,
}
}

export interface Ice_BOUpdErrorRow{
   TableName:string,
   ErrorLevel:string,
   ErrorType:string,
   ErrorText:string,
   ErrorSysRowID:string,
   SysRowID:string,
   RowMod:string,
}

export interface Ice_BOUpdErrorTableset{
   BOUpdError:Ice_BOUpdErrorRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Ice_Extensions_ExtensionRow{
   ColumnValues:object
   RowMod:string,
   SysRowID:string,
}

export interface Ice_Extensions_ExtensionTableColumn{
   ColumnName:string,
   ColumnType:string,
}

export interface Ice_Extensions_ExtensionTableData{
   Table:Ice_Extensions_ExtensionRow[],
   SystemCode:string,
   TableName:string,
   Columns:Ice_Extensions_ExtensionTableColumn[],
   PrimaryKeyColumns:string,
   PeerTableSystemCode:string,
   PeerTableName:string,
}

export interface InitializeTracker_output{
   returnObj:Erp_Tablesets_TrackerFilterTableset[],
parameters : {
      /**  output parameters  */  
   authorizedPlants:string,
   inTransitPlants:string,
}
}

   /** Required : 
      @param partNum
   */  
export interface IsRunOutOnHand_input{
      /**  The PartNum  */  
   partNum:string,
}

export interface IsRunOutOnHand_output{
parameters : {
      /**  output parameters  */  
   IsRunOutOnHand:boolean,
}
}

   /** Required : 
      @param glbCompany
      @param GlbPartNum
      @param ds
      @param ds1
   */  
export interface LinkGlbPart_input{
      /**  Global Company field on the GlbPart record to link  */  
   glbCompany:string,
      /**  Global PartNum field on the GlbPart record to link  */  
   GlbPartNum:string,
   ds:Erp_Tablesets_GlbPartTableset[],
   ds1:Erp_Tablesets_PartTableset[],
}

export interface LinkGlbPart_output{
parameters : {
      /**  output parameters  */  
   ds1:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param codeType
      @param ds
   */  
export interface OnChangePESUNAT_input{
      /**  User code type  */  
   codeType:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface OnChangePESUNAT_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param partNum
      @param uomCode
      @param pkgCode
      @param ds
   */  
export interface OnChangePkgCode_input{
      /**  Part Number.  */  
   partNum:string,
      /**  UOMCode  */  
   uomCode:string,
      /**  Proposed PkgCode  */  
   pkgCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface OnChangePkgCode_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param plantCode
      @param ds
   */  
export interface OnChangePlant_input{
      /**  Code of Plant which is changed to  */  
   plantCode:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface OnChangePlant_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipGenSeqStr
      @param ipLastUsedSeq
   */  
export interface OnChangeSNLastUsedSeq_input{
   ipGenSeqStr:string,
   ipLastUsedSeq:string,
}

export interface OnChangeSNLastUsedSeq_output{
}

   /** Required : 
      @param newConfigID
      @param partNum
      @param revisionNum
   */  
export interface OnChangedConfigID_input{
      /**  Changed ConfigID  */  
   newConfigID:string,
      /**  Part Num  */  
   partNum:string,
      /**  Revision Num  */  
   revisionNum:string,
}

export interface OnChangedConfigID_output{
parameters : {
      /**  output parameters  */  
   msg:string,
}
}

   /** Required : 
      @param attributeSetID
      @param ds
   */  
export interface OnChangingDefaultAttributeSet_input{
   attributeSetID:number,
   ds:Erp_Tablesets_PartTableset[],
}

export interface OnChangingDefaultAttributeSet_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param PartNumber
   */  
export interface PartExists_input{
   PartNumber:string,
}

export interface PartExists_output{
   returnObj:boolean,
}

   /** Required : 
      @param PartNumber
   */  
export interface PartIsActive_input{
   PartNumber:string,
}

export interface PartIsActive_output{
   returnObj:boolean,
}

   /** Required : 
      @param PartNumber
   */  
export interface PartIsSalesKit_input{
   PartNumber:string,
}

export interface PartIsSalesKit_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   IsSalesKit:boolean,
   IsPhantom:boolean,
}
}

   /** Required : 
      @param sysRowID
   */  
export interface PartUOMPlasticTaxDelete_input{
   sysRowID:string,
}

export interface PartUOMPlasticTaxDelete_output{
}

   /** Required : 
      @param ds
   */  
export interface PartUOMPlasticTaxUpdate_input{
   ds:Erp_Tablesets_PartUOMPlasticTaxTableset[],
}

export interface PartUOMPlasticTaxUpdate_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartUOMPlasticTaxTableset[],
}
}

   /** Required : 
      @param partNum
      @param newTrackByRevision
   */  
export interface PerformTrackByRevisionConversion_input{
   partNum:string,
   newTrackByRevision:boolean,
}

export interface PerformTrackByRevisionConversion_output{
}

   /** Required : 
      @param performInventoryTransfer
      @param defaultRevisionNum
      @param ds
   */  
export interface PerformTrackInventoryAttributeConversion_input{
   performInventoryTransfer:boolean,
   defaultRevisionNum:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface PerformTrackInventoryAttributeConversion_output{
parameters : {
      /**  output parameters  */  
   conversionMessage:string,
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param GlbPartNum
      @param ds
   */  
export interface PreLinkGlbPart_input{
      /**  Global Company field on the GlbPart record to link  */  
   glbCompany:string,
      /**  Global VendorNum field on the GlbPart record to link  */  
   GlbPartNum:string,
   ds:Erp_Tablesets_GlbPartTableset[],
}

export interface PreLinkGlbPart_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbPartTableset[],
   vMessage:string,
}
}

export interface PromptForPassword_output{
parameters : {
      /**  output parameters  */  
   opPromptForPassword:boolean,
}
}

   /** Required : 
      @param company
      @param plant
      @param partNum
   */  
export interface RequestNoRevWithExternalMESForSiteValidation_input{
   company:string,
   plant:string,
   partNum:string,
}

export interface RequestNoRevWithExternalMESForSiteValidation_output{
   returnObj:boolean,
}

   /** Required : 
      @param partNum
      @param plant
   */  
export interface SetMRPRecalcFlag_input{
      /**  Part to update MRP flag for  */  
   partNum:string,
      /**  Plant to update MRP flag for, blank for all plants of part  */  
   plant:string,
}

export interface SetMRPRecalcFlag_output{
   returnObj:Erp_Tablesets_PartTableset[],
}

   /** Required : 
      @param ds
   */  
export interface SetNextGeneratedLotNum_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface SetNextGeneratedLotNum_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param glbPartNum
      @param ds
   */  
export interface SkipGlbPart_input{
      /**  Global Company field on the GlbPart record to skip  */  
   glbCompany:string,
      /**  Global PartNum field on the GlbPart record to skip  */  
   glbPartNum:string,
   ds:Erp_Tablesets_GlbPartTableset[],
}

export interface SkipGlbPart_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbPartTableset[],
}
}

   /** Required : 
      @param glbCompany
      @param glbPartNum
      @param ds
   */  
export interface UnlinkGlbPart_input{
      /**  Global Company field on the GlbPart record to unlink  */  
   glbCompany:string,
      /**  Global CustNum field on the GlbPart record to unlink  */  
   glbPartNum:string,
   ds:Erp_Tablesets_GlbPartTableset[],
}

export interface UnlinkGlbPart_output{
   returnObj:Erp_Tablesets_PartTableset[],
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_GlbPartTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface UpdateAfterGlbPartLink_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface UpdateAfterGlbPartLink_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ds
      @param continueProcessingOnError
      @param rollbackParentOnChildError
   */  
export interface UpdateExt_input{
   ds:Erp_Tablesets_UpdExtPartTableset[],
   continueProcessingOnError:boolean,
   rollbackParentOnChildError:boolean,
}

export interface UpdateExt_output{
   returnObj:Ice_BOUpdErrorTableset[],
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UpdExtPartTableset[],
   errorsOccurred:boolean,
}
}

   /** Required : 
      @param ds
   */  
export interface Update_input{
   ds:Erp_Tablesets_PartTableset[],
}

export interface Update_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipProposedVendor
      @param ds
   */  
export interface ValidateInspVendor_input{
      /**  The new proposed Vendor value  */  
   ipProposedVendor:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ValidateInspVendor_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param ipProposedInspPlan
      @param ipProposedSpecId
      @param iptable
      @param ds
   */  
export interface ValidateInspection_input{
      /**  The new proposed InspPlanPartNum value  */  
   ipProposedInspPlan:string,
      /**  The new proposed SpecID value  */  
   ipProposedSpecId:string,
      /**  table name  */  
   iptable:string,
   ds:Erp_Tablesets_PartTableset[],
}

export interface ValidateInspection_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_PartTableset[],
}
}

   /** Required : 
      @param PartNum
      @param RevisionNum
      @param AltMethod
      @param ProcessMfgID
   */  
export interface ValidateNewPartRevAttch_input{
      /**  PartNum  */  
   PartNum:string,
      /**  Revision Number  */  
   RevisionNum:string,
      /**  Alternate Method  */  
   AltMethod:string,
      /**  Alternate Method  */  
   ProcessMfgID:string,
}

export interface ValidateNewPartRevAttch_output{
}

   /** Required : 
      @param ipPartNum
      @param ipConvUOMClassID
      @param ipConvUOMIUM
   */  
export interface ValidateUOMConvTrans_input{
      /**  Part number.  */  
   ipPartNum:string,
      /**  The new proposed UOM Class to convert to.  */  
   ipConvUOMClassID:string,
      /**  The new proposed UOM IUM to convert to.  */  
   ipConvUOMIUM:string,
}

export interface ValidateUOMConvTrans_output{
}

   /** Required : 
      @param ipPartNum
      @param ipConvUOMClassID
      @param ipConvUOMIUM
   */  
export interface ValidateUOMconvChange_input{
      /**  Part number.  */  
   ipPartNum:string,
      /**  The new proposed UOM Class to convert to.  */  
   ipConvUOMClassID:string,
      /**  The new proposed UOM IUM to convert to.  */  
   ipConvUOMIUM:string,
}

export interface ValidateUOMconvChange_output{
}

   /** Required : 
      @param ds
   */  
export interface WhereUsedRtnStart_input{
   ds:Erp_Tablesets_UsedPartsTableset[],
}

export interface WhereUsedRtnStart_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UsedPartsTableset[],
}
}

   /** Required : 
      @param ds
   */  
export interface WhereUsedTrackDown_input{
   ds:Erp_Tablesets_UsedPartsTableset[],
}

export interface WhereUsedTrackDown_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UsedPartsTableset[],
}
}

   /** Required : 
      @param partNum
      @param ds
   */  
export interface WhereUsedTrackUp_input{
   partNum:string,
   ds:Erp_Tablesets_UsedPartsTableset[],
}

export interface WhereUsedTrackUp_output{
parameters : {
      /**  output parameters  */  
   ds:Erp_Tablesets_UsedPartsTableset[],
}
}

