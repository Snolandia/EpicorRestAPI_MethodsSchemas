import * as configEpicorSchemas from "./configEpicorSchemas"


/** 
// Title: Erp.BO.ECCExtensionSvc
// Description: ECC Extension service the will allow for custom mappings for configurator processing
// Version: v1
*/ 



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// OData methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Get service document
   Description: Get service document for the service
   OperationID: GetServiceDocument
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: OK => application/json
   */  
export function getServiceDocument(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<JSON>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as JSON)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Get metadata document
   Description: Get service ODATA metadata in XML format
   OperationID: GetMetadata
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas headers
   Returns: 
      200 Desc: Returns metadata document => content
   */  
export function get_metadata(epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<any>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/$metadata", {
          method: 'get',
          headers: headers,
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as any)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Custom methods:
//////////////////////////////////////////////////////////////////////////

   /**  
   Summary: Invoke method AltCustomListPart
   OperationID: AltCustomListPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltCustomListPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltCustomListPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltCustomListPart(requestBody:AltCustomListPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltCustomListPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltCustomListPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltCustomListPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AltCustomListPartSubs
   OperationID: AltCustomListPartSubs
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltCustomListPartSubs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltCustomListPartSubs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltCustomListPartSubs(requestBody:AltCustomListPartSubs_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltCustomListPartSubs_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltCustomListPartSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltCustomListPartSubs_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AltCustomTagPart
   OperationID: AltCustomTagPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltCustomTagPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltCustomTagPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltCustomTagPart(requestBody:AltCustomTagPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltCustomTagPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltCustomTagPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltCustomTagPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AltCustomTagPartSubs
   OperationID: AltCustomTagPartSubs
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltCustomTagPartSubs_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltCustomTagPartSubs_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltCustomTagPartSubs(requestBody:AltCustomTagPartSubs_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltCustomTagPartSubs_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltCustomTagPartSubs", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltCustomTagPartSubs_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AltCustomXML
   OperationID: AltCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltCustomXML(requestBody:AltCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AltPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: AltPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltPayload(requestBody:AltPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AltFinalXml
   OperationID: AltFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AltFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AltFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AltFinalXml(requestBody:AltFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AltFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AltFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AltFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCpnCustXPrtUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetCpnCustXPrtUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCpnCustXPrtUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCpnCustXPrtUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCpnCustXPrtUD(requestBody:GetCpnCustXPrtUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCpnCustXPrtUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCpnCustXPrtUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCpnCustXPrtUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCpnPartXRefIntUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetCpnPartXRefIntUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCpnPartXRefIntUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCpnPartXRefIntUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCpnPartXRefIntUD(requestBody:GetCpnPartXRefIntUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCpnPartXRefIntUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCpnPartXRefIntUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCpnPartXRefIntUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnCustomListCustXPrt
   OperationID: CpnCustomListCustXPrt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnCustomListCustXPrt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnCustomListCustXPrt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnCustomListCustXPrt(requestBody:CpnCustomListCustXPrt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnCustomListCustXPrt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnCustomListCustXPrt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnCustomListCustXPrt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnCustomListPartXRefInt
   OperationID: CpnCustomListPartXRefInt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnCustomListPartXRefInt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnCustomListPartXRefInt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnCustomListPartXRefInt(requestBody:CpnCustomListPartXRefInt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnCustomListPartXRefInt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnCustomListPartXRefInt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnCustomListPartXRefInt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnCustomTagCustXPrt
   OperationID: CpnCustomTagCustXPrt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnCustomTagCustXPrt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnCustomTagCustXPrt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnCustomTagCustXPrt(requestBody:CpnCustomTagCustXPrt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnCustomTagCustXPrt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnCustomTagCustXPrt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnCustomTagCustXPrt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnCustomTagPartXRefInt
   OperationID: CpnCustomTagPartXRefInt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnCustomTagPartXRefInt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnCustomTagPartXRefInt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnCustomTagPartXRefInt(requestBody:CpnCustomTagPartXRefInt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnCustomTagPartXRefInt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnCustomTagPartXRefInt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnCustomTagPartXRefInt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnCustomXMLCustXPrt
   OperationID: CpnCustomXMLCustXPrt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnCustomXMLCustXPrt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnCustomXMLCustXPrt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnCustomXMLCustXPrt(requestBody:CpnCustomXMLCustXPrt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnCustomXMLCustXPrt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnCustomXMLCustXPrt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnCustomXMLCustXPrt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnCustomXMLPartXRefInt
   OperationID: CpnCustomXMLPartXRefInt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnCustomXMLPartXRefInt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnCustomXMLPartXRefInt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnCustomXMLPartXRefInt(requestBody:CpnCustomXMLPartXRefInt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnCustomXMLPartXRefInt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnCustomXMLPartXRefInt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnCustomXMLPartXRefInt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnPayloadCustXPrt
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: CpnPayloadCustXPrt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnPayloadCustXPrt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnPayloadCustXPrt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnPayloadCustXPrt(requestBody:CpnPayloadCustXPrt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnPayloadCustXPrt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnPayloadCustXPrt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnPayloadCustXPrt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnPayloadPartXRefInt
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: CpnPayloadPartXRefInt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnPayloadPartXRefInt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnPayloadPartXRefInt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnPayloadPartXRefInt(requestBody:CpnPayloadPartXRefInt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnPayloadPartXRefInt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnPayloadPartXRefInt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnPayloadPartXRefInt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnFinalXmlCustXPrt
   OperationID: CpnFinalXmlCustXPrt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnFinalXmlCustXPrt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnFinalXmlCustXPrt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnFinalXmlCustXPrt(requestBody:CpnFinalXmlCustXPrt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnFinalXmlCustXPrt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnFinalXmlCustXPrt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnFinalXmlCustXPrt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CpnFinalXmlPartXRefInt
   OperationID: CpnFinalXmlPartXRefInt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CpnFinalXmlPartXRefInt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CpnFinalXmlPartXRefInt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CpnFinalXmlPartXRefInt(requestBody:CpnFinalXmlPartXRefInt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CpnFinalXmlPartXRefInt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CpnFinalXmlPartXRefInt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CpnFinalXmlPartXRefInt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSgpPartUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetSgpPartUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetSgpPartUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSgpPartUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSgpPartUD(requestBody:GetSgpPartUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetSgpPartUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetSgpPartUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetSgpPartUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SgpCustomListPart
   OperationID: SgpCustomListPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SgpCustomListPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SgpCustomListPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SgpCustomListPart(requestBody:SgpCustomListPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SgpCustomListPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SgpCustomListPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SgpCustomListPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SgpCustomTagPart
   OperationID: SgpCustomTagPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SgpCustomTagPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SgpCustomTagPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SgpCustomTagPart(requestBody:SgpCustomTagPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SgpCustomTagPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SgpCustomTagPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SgpCustomTagPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SgpCustomXML
   OperationID: SgpCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SgpCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SgpCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SgpCustomXML(requestBody:SgpCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SgpCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SgpCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SgpCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SgpPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: SgpPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SgpPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SgpPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SgpPayload(requestBody:SgpPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SgpPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SgpPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SgpPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SgpFinalXml
   OperationID: SgpFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SgpFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SgpFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SgpFinalXml(requestBody:SgpFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SgpFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SgpFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SgpFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetStgProdGrupUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetStgProdGrupUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetStgProdGrupUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetStgProdGrupUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetStgProdGrupUD(requestBody:GetStgProdGrupUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetStgProdGrupUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetStgProdGrupUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetStgProdGrupUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StgCustomListProdGrup
   OperationID: StgCustomListProdGrup
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StgCustomListProdGrup_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StgCustomListProdGrup_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StgCustomListProdGrup(requestBody:StgCustomListProdGrup_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StgCustomListProdGrup_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StgCustomListProdGrup", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StgCustomListProdGrup_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StgCustomTagProdGrup
   OperationID: StgCustomTagProdGrup
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StgCustomTagProdGrup_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StgCustomTagProdGrup_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StgCustomTagProdGrup(requestBody:StgCustomTagProdGrup_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StgCustomTagProdGrup_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StgCustomTagProdGrup", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StgCustomTagProdGrup_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StgCustomXML
   OperationID: StgCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StgCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StgCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StgCustomXML(requestBody:StgCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StgCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StgCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StgCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StgPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: StgPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StgPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StgPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StgPayload(requestBody:StgPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StgPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StgPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StgPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StgFinalXml
   OperationID: StgFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StgFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StgFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StgFinalXml(requestBody:StgFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StgFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StgFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StgFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetStkPartUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetStkPartUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetStkPartUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetStkPartUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetStkPartUD(requestBody:GetStkPartUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetStkPartUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetStkPartUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetStkPartUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetStkPartUomUD
   OperationID: GetStkPartUomUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetStkPartUomUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetStkPartUomUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetStkPartUomUD(requestBody:GetStkPartUomUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetStkPartUomUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetStkPartUomUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetStkPartUomUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkCustomListPart
   OperationID: StkCustomListPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkCustomListPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkCustomListPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkCustomListPart(requestBody:StkCustomListPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkCustomListPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkCustomListPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkCustomListPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkCustomListPartUOM
   OperationID: StkCustomListPartUOM
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkCustomListPartUOM_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkCustomListPartUOM_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkCustomListPartUOM(requestBody:StkCustomListPartUOM_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkCustomListPartUOM_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkCustomListPartUOM", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkCustomListPartUOM_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkCustomTagPart
   OperationID: StkCustomTagPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkCustomTagPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkCustomTagPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkCustomTagPart(requestBody:StkCustomTagPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkCustomTagPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkCustomTagPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkCustomTagPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkCustomTagPartUOM
   OperationID: StkCustomTagPartUOM
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkCustomTagPartUOM_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkCustomTagPartUOM_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkCustomTagPartUOM(requestBody:StkCustomTagPartUOM_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkCustomTagPartUOM_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkCustomTagPartUOM", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkCustomTagPartUOM_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkAttributeSet
   Description: ECC method used in STK upload to allow for custom coding of the attributeSet tag.
The part row will be supplied for reference to help with the updating of the attributeSet string.
   OperationID: StkAttributeSet
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkAttributeSet_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkAttributeSet_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkAttributeSet(requestBody:StkAttributeSet_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkAttributeSet_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkAttributeSet", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkAttributeSet_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkCustomXML
   OperationID: StkCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkCustomXML(requestBody:StkCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: StkPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkPayload(requestBody:StkPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method StkFinalXml
   OperationID: StkFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/StkFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/StkFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_StkFinalXml(requestBody:StkFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<StkFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/StkFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as StkFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSttPartUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetSttPartUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetSttPartUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSttPartUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSttPartUD(requestBody:GetSttPartUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetSttPartUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetSttPartUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetSttPartUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SttCustomListPart
   OperationID: SttCustomListPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SttCustomListPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SttCustomListPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SttCustomListPart(requestBody:SttCustomListPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SttCustomListPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SttCustomListPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SttCustomListPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SttCustomTagPart
   OperationID: SttCustomTagPart
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SttCustomTagPart_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SttCustomTagPart_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SttCustomTagPart(requestBody:SttCustomTagPart_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SttCustomTagPart_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SttCustomTagPart", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SttCustomTagPart_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SttCustomXML
   OperationID: SttCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SttCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SttCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SttCustomXML(requestBody:SttCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SttCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SttCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SttCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SttPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: SttPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SttPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SttPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SttPayload(requestBody:SttPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SttPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SttPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SttPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SttFinalXml
   OperationID: SttFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SttFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SttFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SttFinalXml(requestBody:SttFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SttFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SttFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SttFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPOHeaderUD
   Description: Return purchase order header UD data
   OperationID: GetPOHeaderUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetPOHeaderUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPOHeaderUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPOHeaderUD(requestBody:GetPOHeaderUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetPOHeaderUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetPOHeaderUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetPOHeaderUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetPODetailUD
   Description: Return purchase order Detail UD data
   OperationID: GetPODetailUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetPODetailUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetPODetailUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetPODetailUD(requestBody:GetPODetailUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetPODetailUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetPODetailUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetPODetailUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpodCustomListPOHeader
   OperationID: SpodCustomListPOHeader
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpodCustomListPOHeader_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpodCustomListPOHeader_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpodCustomListPOHeader(requestBody:SpodCustomListPOHeader_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpodCustomListPOHeader_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpodCustomListPOHeader", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpodCustomListPOHeader_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpodCustomListPODetail
   OperationID: SpodCustomListPODetail
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpodCustomListPODetail_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpodCustomListPODetail_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpodCustomListPODetail(requestBody:SpodCustomListPODetail_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpodCustomListPODetail_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpodCustomListPODetail", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpodCustomListPODetail_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpodCustomTagPOHeader
   OperationID: SpodCustomTagPOHeader
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpodCustomTagPOHeader_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpodCustomTagPOHeader_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpodCustomTagPOHeader(requestBody:SpodCustomTagPOHeader_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpodCustomTagPOHeader_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpodCustomTagPOHeader", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpodCustomTagPOHeader_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpodCustomTagPODetail
   OperationID: SpodCustomTagPODetail
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpodCustomTagPODetail_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpodCustomTagPODetail_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpodCustomTagPODetail(requestBody:SpodCustomTagPODetail_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpodCustomTagPODetail_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpodCustomTagPODetail", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpodCustomTagPODetail_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpodCustomXML
   OperationID: SpodCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpodCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpodCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpodCustomXML(requestBody:SpodCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpodCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpodCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpodCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpodPayload
   OperationID: SpodPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpodPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpodPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpodPayload(requestBody:SpodPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpodPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpodPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpodPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignSugPOChgUD
   Description: Assigns payload and UD columns for PO Suggestion records
   OperationID: AssignSugPOChgUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignSugPOChgUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignSugPOChgUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignSugPOChgUD(requestBody:AssignSugPOChgUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignSugPOChgUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignSugPOChgUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignSugPOChgUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpouCustomListSugPOChg
   OperationID: SpouCustomListSugPOChg
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpouCustomListSugPOChg_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpouCustomListSugPOChg_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpouCustomListSugPOChg(requestBody:SpouCustomListSugPOChg_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpouCustomListSugPOChg_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpouCustomListSugPOChg", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpouCustomListSugPOChg_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpouCustomTagSugPOChg
   OperationID: SpouCustomTagSugPOChg
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpouCustomTagSugPOChg_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpouCustomTagSugPOChg_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpouCustomTagSugPOChg(requestBody:SpouCustomTagSugPOChg_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpouCustomTagSugPOChg_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpouCustomTagSugPOChg", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpouCustomTagSugPOChg_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SpouPayload
   OperationID: SpouPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SpouPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SpouPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SpouPayload(requestBody:SpouPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SpouPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SpouPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SpouPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignQuoteDtlUD
   Description: Assigns UD columns for order detail.
   OperationID: AssignQuoteDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignQuoteDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignQuoteDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignQuoteDtlUD(requestBody:AssignQuoteDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignQuoteDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignQuoteDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignQuoteDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignQuoteHedUD
   Description: Assigns payload and UD columns for order head
   OperationID: AssignQuoteHedUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignQuoteHedUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignQuoteHedUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignQuoteHedUD(requestBody:AssignQuoteHedUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignQuoteHedUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignQuoteHedUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignQuoteHedUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrquCustomListQuoteDtl
   OperationID: CrquCustomListQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrquCustomListQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrquCustomListQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrquCustomListQuoteDtl(requestBody:CrquCustomListQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrquCustomListQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrquCustomListQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrquCustomListQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrquCustomListQuoteHed
   OperationID: CrquCustomListQuoteHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrquCustomListQuoteHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrquCustomListQuoteHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrquCustomListQuoteHed(requestBody:CrquCustomListQuoteHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrquCustomListQuoteHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrquCustomListQuoteHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrquCustomListQuoteHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrquCustomTagQuoteDtl
   OperationID: CrquCustomTagQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrquCustomTagQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrquCustomTagQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrquCustomTagQuoteDtl(requestBody:CrquCustomTagQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrquCustomTagQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrquCustomTagQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrquCustomTagQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrquCustomTagQuoteHed
   OperationID: CrquCustomTagQuoteHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrquCustomTagQuoteHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrquCustomTagQuoteHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrquCustomTagQuoteHed(requestBody:CrquCustomTagQuoteHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrquCustomTagQuoteHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrquCustomTagQuoteHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrquCustomTagQuoteHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrquCustomXML
   OperationID: CrquCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrquCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrquCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrquCustomXML(requestBody:CrquCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrquCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrquCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrquCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrquPayload
   OperationID: CrquPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrquPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrquPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrquPayload(requestBody:CrquPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrquPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrquPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrquPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GqrCustomListQuoteDtl
   OperationID: GqrCustomListQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GqrCustomListQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GqrCustomListQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GqrCustomListQuoteDtl(requestBody:GqrCustomListQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GqrCustomListQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GqrCustomListQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GqrCustomListQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GqrCustomListQuoteHed
   OperationID: GqrCustomListQuoteHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GqrCustomListQuoteHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GqrCustomListQuoteHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GqrCustomListQuoteHed(requestBody:GqrCustomListQuoteHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GqrCustomListQuoteHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GqrCustomListQuoteHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GqrCustomListQuoteHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GqrCustomTagQuoteDtl
   OperationID: GqrCustomTagQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GqrCustomTagQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GqrCustomTagQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GqrCustomTagQuoteDtl(requestBody:GqrCustomTagQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GqrCustomTagQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GqrCustomTagQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GqrCustomTagQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GqrCustomTagQuoteHed
   OperationID: GqrCustomTagQuoteHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GqrCustomTagQuoteHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GqrCustomTagQuoteHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GqrCustomTagQuoteHed(requestBody:GqrCustomTagQuoteHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GqrCustomTagQuoteHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GqrCustomTagQuoteHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GqrCustomTagQuoteHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GqrCustomXML
   OperationID: GqrCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GqrCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GqrCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GqrCustomXML(requestBody:GqrCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GqrCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GqrCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GqrCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GqrPayload
   OperationID: GqrPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GqrPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GqrPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GqrPayload(requestBody:GqrPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GqrPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GqrPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GqrPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCrqdQuoteHedUD
   Description: Return order header UD data for order inquiry
   OperationID: GetCrqdQuoteHedUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCrqdQuoteHedUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCrqdQuoteHedUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCrqdQuoteHedUD(requestBody:GetCrqdQuoteHedUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCrqdQuoteHedUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCrqdQuoteHedUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCrqdQuoteHedUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCrqdQuoteDtlUD
   Description: Return order detail UD data for order inquiry
   OperationID: GetCrqdQuoteDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCrqdQuoteDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCrqdQuoteDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCrqdQuoteDtlUD(requestBody:GetCrqdQuoteDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCrqdQuoteDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCrqdQuoteDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCrqdQuoteDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrqdCustomListQuoteDtl
   OperationID: CrqdCustomListQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrqdCustomListQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrqdCustomListQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrqdCustomListQuoteDtl(requestBody:CrqdCustomListQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrqdCustomListQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrqdCustomListQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrqdCustomListQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrqdCustomTagQuoteDtl
   OperationID: CrqdCustomTagQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrqdCustomTagQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrqdCustomTagQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrqdCustomTagQuoteDtl(requestBody:CrqdCustomTagQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrqdCustomTagQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrqdCustomTagQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrqdCustomTagQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrqdCustomListQuoteHed
   OperationID: CrqdCustomListQuoteHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrqdCustomListQuoteHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrqdCustomListQuoteHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrqdCustomListQuoteHed(requestBody:CrqdCustomListQuoteHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrqdCustomListQuoteHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrqdCustomListQuoteHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrqdCustomListQuoteHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrqdCustomTagQuoteHed
   OperationID: CrqdCustomTagQuoteHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrqdCustomTagQuoteHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrqdCustomTagQuoteHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrqdCustomTagQuoteHed(requestBody:CrqdCustomTagQuoteHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrqdCustomTagQuoteHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrqdCustomTagQuoteHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrqdCustomTagQuoteHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrqdCustomXML
   OperationID: CrqdCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrqdCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrqdCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrqdCustomXML(requestBody:CrqdCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrqdCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrqdCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrqdCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrqdPayload
   OperationID: CrqdPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrqdPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrqdPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrqdPayload(requestBody:CrqdPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrqdPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrqdPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrqdPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetGqrQuoteHedUD
   Description: Return order header UD data for order inquiry
   OperationID: GetGqrQuoteHedUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetGqrQuoteHedUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetGqrQuoteHedUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetGqrQuoteHedUD(requestBody:GetGqrQuoteHedUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetGqrQuoteHedUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetGqrQuoteHedUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetGqrQuoteHedUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetGqrQuoteDtlUD
   Description: Return order detail UD data for order inquiry
   OperationID: GetGqrQuoteDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetGqrQuoteDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetGqrQuoteDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetGqrQuoteDtlUD(requestBody:GetGqrQuoteDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetGqrQuoteDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetGqrQuoteDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetGqrQuoteDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRFQHeadUD
   Description: Return RFQ header UD data
   OperationID: GetRFQHeadUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetRFQHeadUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRFQHeadUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRFQHeadUD(requestBody:GetRFQHeadUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetRFQHeadUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetRFQHeadUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetRFQHeadUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetRFQItemUD
   Description: Return RFQ Line UD data
   OperationID: GetRFQItemUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetRFQItemUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetRFQItemUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetRFQItemUD(requestBody:GetRFQItemUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetRFQItemUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetRFQItemUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetRFQItemUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SurdCustomListRFQHead
   OperationID: SurdCustomListRFQHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SurdCustomListRFQHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SurdCustomListRFQHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SurdCustomListRFQHead(requestBody:SurdCustomListRFQHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SurdCustomListRFQHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SurdCustomListRFQHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SurdCustomListRFQHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SurdCustomListRFQItem
   OperationID: SurdCustomListRFQItem
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SurdCustomListRFQItem_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SurdCustomListRFQItem_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SurdCustomListRFQItem(requestBody:SurdCustomListRFQItem_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SurdCustomListRFQItem_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SurdCustomListRFQItem", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SurdCustomListRFQItem_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SurdCustomTagRFQHead
   OperationID: SurdCustomTagRFQHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SurdCustomTagRFQHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SurdCustomTagRFQHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SurdCustomTagRFQHead(requestBody:SurdCustomTagRFQHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SurdCustomTagRFQHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SurdCustomTagRFQHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SurdCustomTagRFQHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SurdCustomTagRFQItem
   OperationID: SurdCustomTagRFQItem
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SurdCustomTagRFQItem_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SurdCustomTagRFQItem_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SurdCustomTagRFQItem(requestBody:SurdCustomTagRFQItem_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SurdCustomTagRFQItem_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SurdCustomTagRFQItem", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SurdCustomTagRFQItem_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SurdCustomXML
   OperationID: SurdCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SurdCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SurdCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SurdCustomXML(requestBody:SurdCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SurdCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SurdCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SurdCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SurdPayload
   OperationID: SurdPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SurdPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SurdPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SurdPayload(requestBody:SurdPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SurdPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SurdPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SurdPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignRFQHeadUD
   Description: Assigns payload and UD columns for RFQ Head records
   OperationID: AssignRFQHeadUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignRFQHeadUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignRFQHeadUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignRFQHeadUD(requestBody:AssignRFQHeadUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignRFQHeadUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignRFQHeadUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignRFQHeadUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignRFQItemUD
   Description: Assigns payload and UD columns for RFQ Item records
   OperationID: AssignRFQItemUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignRFQItemUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignRFQItemUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignRFQItemUD(requestBody:AssignRFQItemUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignRFQItemUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignRFQItemUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignRFQItemUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuruCustomListRFQHead
   OperationID: SuruCustomListRFQHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuruCustomListRFQHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuruCustomListRFQHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuruCustomListRFQHead(requestBody:SuruCustomListRFQHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuruCustomListRFQHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuruCustomListRFQHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuruCustomListRFQHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuruCustomListRFQItem
   OperationID: SuruCustomListRFQItem
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuruCustomListRFQItem_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuruCustomListRFQItem_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuruCustomListRFQItem(requestBody:SuruCustomListRFQItem_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuruCustomListRFQItem_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuruCustomListRFQItem", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuruCustomListRFQItem_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuruCustomTagRFQHead
   OperationID: SuruCustomTagRFQHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuruCustomTagRFQHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuruCustomTagRFQHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuruCustomTagRFQHead(requestBody:SuruCustomTagRFQHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuruCustomTagRFQHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuruCustomTagRFQHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuruCustomTagRFQHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuruCustomTagRFQItem
   OperationID: SuruCustomTagRFQItem
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuruCustomTagRFQItem_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuruCustomTagRFQItem_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuruCustomTagRFQItem(requestBody:SuruCustomTagRFQItem_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuruCustomTagRFQItem_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuruCustomTagRFQItem", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuruCustomTagRFQItem_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuruPayload
   OperationID: SuruPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuruPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuruPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuruPayload(requestBody:SuruPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuruPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuruPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuruPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignRMADtlUD
   Description: Assigns UD columns for order detail.
   OperationID: AssignRMADtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignRMADtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignRMADtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignRMADtlUD(requestBody:AssignRMADtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignRMADtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignRMADtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignRMADtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignRMAHeadUD
   Description: Assigns payload and UD columns for order head
   OperationID: AssignRMAHeadUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignRMAHeadUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignRMAHeadUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignRMAHeadUD(requestBody:AssignRMAHeadUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignRMAHeadUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignRMAHeadUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignRMAHeadUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrruCustomListRMADtl
   OperationID: CrruCustomListRMADtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrruCustomListRMADtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrruCustomListRMADtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrruCustomListRMADtl(requestBody:CrruCustomListRMADtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrruCustomListRMADtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrruCustomListRMADtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrruCustomListRMADtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrruCustomListRMAHead
   OperationID: CrruCustomListRMAHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrruCustomListRMAHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrruCustomListRMAHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrruCustomListRMAHead(requestBody:CrruCustomListRMAHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrruCustomListRMAHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrruCustomListRMAHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrruCustomListRMAHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrruCustomTagRMADtl
   OperationID: CrruCustomTagRMADtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrruCustomTagRMADtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrruCustomTagRMADtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrruCustomTagRMADtl(requestBody:CrruCustomTagRMADtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrruCustomTagRMADtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrruCustomTagRMADtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrruCustomTagRMADtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrruCustomTagRMAHead
   OperationID: CrruCustomTagRMAHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrruCustomTagRMAHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrruCustomTagRMAHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrruCustomTagRMAHead(requestBody:CrruCustomTagRMAHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrruCustomTagRMAHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrruCustomTagRMAHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrruCustomTagRMAHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrruCustomXML
   OperationID: CrruCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrruCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrruCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrruCustomXML(requestBody:CrruCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrruCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrruCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrruCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrruPayload
   OperationID: CrruPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrruPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrruPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrruPayload(requestBody:CrruPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrruPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrruPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrruPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCrrdRMAHeadUD
   Description: Return order header UD data for order inquiry
   OperationID: GetCrrdRMAHeadUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCrrdRMAHeadUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCrrdRMAHeadUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCrrdRMAHeadUD(requestBody:GetCrrdRMAHeadUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCrrdRMAHeadUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCrrdRMAHeadUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCrrdRMAHeadUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCrrdRMADtlUD
   Description: Return order detail UD data for order inquiry
   OperationID: GetCrrdRMADtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCrrdRMADtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCrrdRMADtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCrrdRMADtlUD(requestBody:GetCrrdRMADtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCrrdRMADtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCrrdRMADtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCrrdRMADtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrdCustomListRMADtl
   OperationID: CrrdCustomListRMADtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrdCustomListRMADtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrdCustomListRMADtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrdCustomListRMADtl(requestBody:CrrdCustomListRMADtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrdCustomListRMADtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrdCustomListRMADtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrdCustomListRMADtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrdCustomTagRMADtl
   OperationID: CrrdCustomTagRMADtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrdCustomTagRMADtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrdCustomTagRMADtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrdCustomTagRMADtl(requestBody:CrrdCustomTagRMADtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrdCustomTagRMADtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrdCustomTagRMADtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrdCustomTagRMADtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrdCustomListRMAHead
   OperationID: CrrdCustomListRMAHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrdCustomListRMAHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrdCustomListRMAHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrdCustomListRMAHead(requestBody:CrrdCustomListRMAHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrdCustomListRMAHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrdCustomListRMAHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrdCustomListRMAHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrdCustomTagRMAHead
   OperationID: CrrdCustomTagRMAHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrdCustomTagRMAHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrdCustomTagRMAHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrdCustomTagRMAHead(requestBody:CrrdCustomTagRMAHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrdCustomTagRMAHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrdCustomTagRMAHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrdCustomTagRMAHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrdCustomXML
   OperationID: CrrdCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrdCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrdCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrdCustomXML(requestBody:CrrdCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrdCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrdCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrdCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrdPayload
   OperationID: CrrdPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrdPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrdPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrdPayload(requestBody:CrrdPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrdPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrdPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrdPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCdmPcECCOrderDtlUD
   Description: Return order detail UD data for order inquiry
   OperationID: GetCdmPcECCOrderDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCdmPcECCOrderDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCdmPcECCOrderDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCdmPcECCOrderDtlUD(requestBody:GetCdmPcECCOrderDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCdmPcECCOrderDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCdmPcECCOrderDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCdmPcECCOrderDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCdmQuoteDtlUD
   Description: Return order detail UD data for order inquiry
   OperationID: GetCdmQuoteDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCdmQuoteDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCdmQuoteDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCdmQuoteDtlUD(requestBody:GetCdmQuoteDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCdmQuoteDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCdmQuoteDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCdmQuoteDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CdmCustomListQuoteDtl
   OperationID: CdmCustomListQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CdmCustomListQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CdmCustomListQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CdmCustomListQuoteDtl(requestBody:CdmCustomListQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CdmCustomListQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CdmCustomListQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CdmCustomListQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CdmCustomListPcECCOrderDtl
   OperationID: CdmCustomListPcECCOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CdmCustomListPcECCOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CdmCustomListPcECCOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CdmCustomListPcECCOrderDtl(requestBody:CdmCustomListPcECCOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CdmCustomListPcECCOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CdmCustomListPcECCOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CdmCustomListPcECCOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CdmCustomTagQuoteDtl
   OperationID: CdmCustomTagQuoteDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CdmCustomTagQuoteDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CdmCustomTagQuoteDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CdmCustomTagQuoteDtl(requestBody:CdmCustomTagQuoteDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CdmCustomTagQuoteDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CdmCustomTagQuoteDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CdmCustomTagQuoteDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CdmCustomTagPcECCOrderDtl
   OperationID: CdmCustomTagPcECCOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CdmCustomTagPcECCOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CdmCustomTagPcECCOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CdmCustomTagPcECCOrderDtl(requestBody:CdmCustomTagPcECCOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CdmCustomTagPcECCOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CdmCustomTagPcECCOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CdmCustomTagPcECCOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignHDCaseUD
   Description: Assigns payload and UD columns for Help Desk Case header
   OperationID: AssignHDCaseUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignHDCaseUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignHDCaseUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignHDCaseUD(requestBody:AssignHDCaseUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignHDCaseUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignHDCaseUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignHDCaseUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDcldHDCaseUD
   Description: Return Help Desk Case UD data for claims inquiry
   OperationID: GetDcldHDCaseUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetDcldHDCaseUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDcldHDCaseUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDcldHDCaseUD(requestBody:GetDcldHDCaseUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetDcldHDCaseUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetDcldHDCaseUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetDcldHDCaseUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignLocationInventoryUD
   Description: Assigns payload and UD columns for order head
   OperationID: AssignLocationInventoryUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignLocationInventoryUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignLocationInventoryUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignLocationInventoryUD(requestBody:AssignLocationInventoryUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignLocationInventoryUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignLocationInventoryUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignLocationInventoryUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDeidLocationInventoryUD
   Description: Return Location Inventory UD data for location inventory inquiry
   OperationID: GetDeidLocationInventoryUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetDeidLocationInventoryUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDeidLocationInventoryUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDeidLocationInventoryUD(requestBody:GetDeidLocationInventoryUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetDeidLocationInventoryUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetDeidLocationInventoryUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetDeidLocationInventoryUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignLocationWarrantyTranUD
   Description: Assigns payload and UD columns for order head
   OperationID: AssignLocationWarrantyTranUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignLocationWarrantyTranUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignLocationWarrantyTranUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignLocationWarrantyTranUD(requestBody:AssignLocationWarrantyTranUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignLocationWarrantyTranUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignLocationWarrantyTranUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignLocationWarrantyTranUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDebmLocationMtlUD
   Description: Return location material UD data for location BOM inquiry
   OperationID: GetDebmLocationMtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetDebmLocationMtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDebmLocationMtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDebmLocationMtlUD(requestBody:GetDebmLocationMtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetDebmLocationMtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetDebmLocationMtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetDebmLocationMtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDebmLocationWarrantyTranUD
   Description: Return location material UD data for location BOM inquiry
   OperationID: GetDebmLocationWarrantyTranUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetDebmLocationWarrantyTranUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDebmLocationWarrantyTranUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDebmLocationWarrantyTranUD(requestBody:GetDebmLocationWarrantyTranUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetDebmLocationWarrantyTranUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetDebmLocationWarrantyTranUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetDebmLocationWarrantyTranUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetDebmPayloadXml
   OperationID: GetDebmPayloadXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetDebmPayloadXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetDebmPayloadXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetDebmPayloadXml(requestBody:GetDebmPayloadXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetDebmPayloadXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetDebmPayloadXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetDebmPayloadXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcldCustomListHDCase
   OperationID: DcldCustomListHDCase
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcldCustomListHDCase_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcldCustomListHDCase_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcldCustomListHDCase(requestBody:DcldCustomListHDCase_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcldCustomListHDCase_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcldCustomListHDCase", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcldCustomListHDCase_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcldCustomTagHDCase
   OperationID: DcldCustomTagHDCase
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcldCustomTagHDCase_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcldCustomTagHDCase_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcldCustomTagHDCase(requestBody:DcldCustomTagHDCase_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcldCustomTagHDCase_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcldCustomTagHDCase", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcldCustomTagHDCase_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcldPayload
   OperationID: DcldPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcldPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcldPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcldPayload(requestBody:DcldPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcldPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcldPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcldPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcldCustomXML
   OperationID: DcldCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcldCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcldCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcldCustomXML(requestBody:DcldCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcldCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcldCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcldCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcluCustomListHDCase
   OperationID: DcluCustomListHDCase
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcluCustomListHDCase_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcluCustomListHDCase_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcluCustomListHDCase(requestBody:DcluCustomListHDCase_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcluCustomListHDCase_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcluCustomListHDCase", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcluCustomListHDCase_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcluCustomTagHDCase
   OperationID: DcluCustomTagHDCase
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcluCustomTagHDCase_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcluCustomTagHDCase_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcluCustomTagHDCase(requestBody:DcluCustomTagHDCase_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcluCustomTagHDCase_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcluCustomTagHDCase", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcluCustomTagHDCase_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcluCustomXML
   OperationID: DcluCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcluCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcluCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcluCustomXML(requestBody:DcluCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcluCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcluCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcluCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DcluPayload
   OperationID: DcluPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DcluPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DcluPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DcluPayload(requestBody:DcluPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DcluPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DcluPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DcluPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DebmCustomListLocationMtl
   OperationID: DebmCustomListLocationMtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DebmCustomListLocationMtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DebmCustomListLocationMtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DebmCustomListLocationMtl(requestBody:DebmCustomListLocationMtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DebmCustomListLocationMtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DebmCustomListLocationMtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DebmCustomListLocationMtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DebmCustomTagLocationMtl
   OperationID: DebmCustomTagLocationMtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DebmCustomTagLocationMtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DebmCustomTagLocationMtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DebmCustomTagLocationMtl(requestBody:DebmCustomTagLocationMtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DebmCustomTagLocationMtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DebmCustomTagLocationMtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DebmCustomTagLocationMtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DebmCustomListLocationWarrantyTran
   OperationID: DebmCustomListLocationWarrantyTran
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DebmCustomListLocationWarrantyTran_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DebmCustomListLocationWarrantyTran_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DebmCustomListLocationWarrantyTran(requestBody:DebmCustomListLocationWarrantyTran_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DebmCustomListLocationWarrantyTran_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DebmCustomListLocationWarrantyTran", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DebmCustomListLocationWarrantyTran_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DebmCustomTagLocationWarrantyTran
   OperationID: DebmCustomTagLocationWarrantyTran
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DebmCustomTagLocationWarrantyTran_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DebmCustomTagLocationWarrantyTran_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DebmCustomTagLocationWarrantyTran(requestBody:DebmCustomTagLocationWarrantyTran_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DebmCustomTagLocationWarrantyTran_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DebmCustomTagLocationWarrantyTran", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DebmCustomTagLocationWarrantyTran_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DebmCustomXML
   OperationID: DebmCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DebmCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DebmCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DebmCustomXML(requestBody:DebmCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DebmCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DebmCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DebmCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DebmPayload
   OperationID: DebmPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DebmPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DebmPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DebmPayload(requestBody:DebmPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DebmPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DebmPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DebmPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DmauCustomListLocationWarrantyTran
   OperationID: DmauCustomListLocationWarrantyTran
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DmauCustomListLocationWarrantyTran_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DmauCustomListLocationWarrantyTran_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DmauCustomListLocationWarrantyTran(requestBody:DmauCustomListLocationWarrantyTran_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DmauCustomListLocationWarrantyTran_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DmauCustomListLocationWarrantyTran", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DmauCustomListLocationWarrantyTran_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DmauCustomTagLocationWarrantyTran
   OperationID: DmauCustomTagLocationWarrantyTran
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DmauCustomTagLocationWarrantyTran_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DmauCustomTagLocationWarrantyTran_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DmauCustomTagLocationWarrantyTran(requestBody:DmauCustomTagLocationWarrantyTran_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DmauCustomTagLocationWarrantyTran_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DmauCustomTagLocationWarrantyTran", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DmauCustomTagLocationWarrantyTran_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DmauPayload
   OperationID: DmauPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DmauPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DmauPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DmauPayload(requestBody:DmauPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DmauPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DmauPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DmauPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeidCustomListLocationInventory
   OperationID: DeidCustomListLocationInventory
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeidCustomListLocationInventory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeidCustomListLocationInventory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeidCustomListLocationInventory(requestBody:DeidCustomListLocationInventory_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeidCustomListLocationInventory_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeidCustomListLocationInventory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeidCustomListLocationInventory_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeidCustomTagLocationInventory
   OperationID: DeidCustomTagLocationInventory
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeidCustomTagLocationInventory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeidCustomTagLocationInventory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeidCustomTagLocationInventory(requestBody:DeidCustomTagLocationInventory_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeidCustomTagLocationInventory_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeidCustomTagLocationInventory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeidCustomTagLocationInventory_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeidCustomXML
   OperationID: DeidCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeidCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeidCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeidCustomXML(requestBody:DeidCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeidCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeidCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeidCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeidPayload
   OperationID: DeidPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeidPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeidPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeidPayload(requestBody:DeidPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeidPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeidPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeidPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeiuCustomListLocationInventory
   OperationID: DeiuCustomListLocationInventory
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeiuCustomListLocationInventory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeiuCustomListLocationInventory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeiuCustomListLocationInventory(requestBody:DeiuCustomListLocationInventory_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeiuCustomListLocationInventory_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeiuCustomListLocationInventory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeiuCustomListLocationInventory_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeiuCustomTagLocationInventory
   OperationID: DeiuCustomTagLocationInventory
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeiuCustomTagLocationInventory_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeiuCustomTagLocationInventory_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeiuCustomTagLocationInventory(requestBody:DeiuCustomTagLocationInventory_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeiuCustomTagLocationInventory_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeiuCustomTagLocationInventory", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeiuCustomTagLocationInventory_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeiuCustomXML
   OperationID: DeiuCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeiuCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeiuCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeiuCustomXML(requestBody:DeiuCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeiuCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeiuCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeiuCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DeiuPayload
   OperationID: DeiuPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DeiuPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DeiuPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DeiuPayload(requestBody:DeiuPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DeiuPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DeiuPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DeiuPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ECCSvcInbound
   Description: Generic method to allow for custom inbound request message processing.
   OperationID: ECCSvcInbound
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/ECCSvcInbound_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ECCSvcInbound_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ECCSvcInbound(requestBody:ECCSvcInbound_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<ECCSvcInbound_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/ECCSvcInbound", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as ECCSvcInbound_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ExtendedInbound
   Description: Generic method to allow for custom inbound request message processing.
   OperationID: ExtendedInbound
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/ExtendedInbound_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ExtendedInbound_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ExtendedInbound(requestBody:ExtendedInbound_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<ExtendedInbound_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/ExtendedInbound", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as ExtendedInbound_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method ExtendedOutbound
   Description: Generic method to allow for custom outbound request message processing.
   OperationID: ExtendedOutbound
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/ExtendedOutbound_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/ExtendedOutbound_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_ExtendedOutbound(requestBody:ExtendedOutbound_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<ExtendedOutbound_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/ExtendedOutbound", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as ExtendedOutbound_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method UDMapIsEnabled
   OperationID: UDMapIsEnabled
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/UDMapIsEnabled_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/UDMapIsEnabled_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_UDMapIsEnabled(requestBody:UDMapIsEnabled_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<UDMapIsEnabled_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/UDMapIsEnabled", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as UDMapIsEnabled_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCUIDInvcHeadUD
   Description: Return Invoice header UD data for Invoice Inquiry
   OperationID: GetCUIDInvcHeadUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCUIDInvcHeadUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCUIDInvcHeadUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCUIDInvcHeadUD(requestBody:GetCUIDInvcHeadUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCUIDInvcHeadUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCUIDInvcHeadUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCUIDInvcHeadUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCuidInvcDtlUD
   Description: Return Invoice detail UD data for Invoice inquiry
   OperationID: GetCuidInvcDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCuidInvcDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCuidInvcDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCuidInvcDtlUD(requestBody:GetCuidInvcDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCuidInvcDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCuidInvcDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCuidInvcDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuidCustomListInvcDtl
   OperationID: CuidCustomListInvcDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuidCustomListInvcDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuidCustomListInvcDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuidCustomListInvcDtl(requestBody:CuidCustomListInvcDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuidCustomListInvcDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuidCustomListInvcDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuidCustomListInvcDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuidCustomTagInvcDtl
   OperationID: CuidCustomTagInvcDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuidCustomTagInvcDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuidCustomTagInvcDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuidCustomTagInvcDtl(requestBody:CuidCustomTagInvcDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuidCustomTagInvcDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuidCustomTagInvcDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuidCustomTagInvcDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuidCustomListInvcHead
   OperationID: CuidCustomListInvcHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuidCustomListInvcHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuidCustomListInvcHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuidCustomListInvcHead(requestBody:CuidCustomListInvcHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuidCustomListInvcHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuidCustomListInvcHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuidCustomListInvcHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuidCustomTagInvcHead
   OperationID: CuidCustomTagInvcHead
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuidCustomTagInvcHead_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuidCustomTagInvcHead_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuidCustomTagInvcHead(requestBody:CuidCustomTagInvcHead_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuidCustomTagInvcHead_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuidCustomTagInvcHead", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuidCustomTagInvcHead_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuidCustomXML
   OperationID: CuidCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuidCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuidCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuidCustomXML(requestBody:CuidCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuidCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuidCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuidCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuidPayload
   OperationID: CuidPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuidPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuidPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuidPayload(requestBody:CuidPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuidPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuidPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuidPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignCustomerUD
   Description: Assigns UD columns for customer.
   OperationID: AssignCustomerUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignCustomerUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignCustomerUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignCustomerUD(requestBody:AssignCustomerUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignCustomerUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignCustomerUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignCustomerUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCncCustomerUD
   Description: Returns all Customer UD data for CNC request.
Note intended to be used by BPM.
   OperationID: GetCncCustomerUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCncCustomerUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCncCustomerUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCncCustomerUD(requestBody:GetCncCustomerUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCncCustomerUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCncCustomerUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCncCustomerUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignShipToUD
   Description: Assigns UD columns for ShipTo.
   OperationID: AssignShipToUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignShipToUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignShipToUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignShipToUD(requestBody:AssignShipToUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignShipToUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignShipToUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignShipToUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCncShipToUD
   Description: Returns all ShipTo UD data for CNC request.
Note intended to be used by BPM.
   OperationID: GetCncShipToUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCncShipToUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCncShipToUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCncShipToUD(requestBody:GetCncShipToUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCncShipToUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCncShipToUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCncShipToUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CncCustomListCustomer
   Description: Process Customer custom list for CNC request and response
   OperationID: CncCustomListCustomer
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CncCustomListCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CncCustomListCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CncCustomListCustomer(requestBody:CncCustomListCustomer_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CncCustomListCustomer_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CncCustomListCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CncCustomListCustomer_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CncCustomListShipTo
   Description: Process ShipTo custom list for CNC request and response
   OperationID: CncCustomListShipTo
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CncCustomListShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CncCustomListShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CncCustomListShipTo(requestBody:CncCustomListShipTo_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CncCustomListShipTo_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CncCustomListShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CncCustomListShipTo_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CncCustomTagCustomer
   Description: Process Customer custom tag for CNC request and response
   OperationID: CncCustomTagCustomer
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CncCustomTagCustomer_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CncCustomTagCustomer_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CncCustomTagCustomer(requestBody:CncCustomTagCustomer_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CncCustomTagCustomer_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CncCustomTagCustomer", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CncCustomTagCustomer_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CncCustomTagShipTo
   Description: Process ShipTo custom tag for CNC request and response
   OperationID: CncCustomTagShipTo
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CncCustomTagShipTo_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CncCustomTagShipTo_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CncCustomTagShipTo(requestBody:CncCustomTagShipTo_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CncCustomTagShipTo_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CncCustomTagShipTo", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CncCustomTagShipTo_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CncPayload
   Description: Process payload for CNC request and response
   OperationID: CncPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CncPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CncPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CncPayload(requestBody:CncPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CncPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CncPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CncPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCadShipToUD
   Description: Returns all ShipTo UD data for CAD sync.
Note intended to be used by BPM.
   OperationID: GetCadShipToUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCadShipToUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCadShipToUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCadShipToUD(requestBody:GetCadShipToUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCadShipToUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCadShipToUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCadShipToUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CadCustomList
   OperationID: CadCustomList
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CadCustomList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CadCustomList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CadCustomList(requestBody:CadCustomList_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CadCustomList_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CadCustomList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CadCustomList_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CadCustomTag
   OperationID: CadCustomTag
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CadCustomTag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CadCustomTag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CadCustomTag(requestBody:CadCustomTag_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CadCustomTag_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CadCustomTag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CadCustomTag_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CadCustomXML
   OperationID: CadCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CadCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CadCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CadCustomXML(requestBody:CadCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CadCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CadCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CadCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CadPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: CadPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CadPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CadPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CadPayload(requestBody:CadPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CadPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CadPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CadPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CadFinalXml
   OperationID: CadFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CadFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CadFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CadFinalXml(requestBody:CadFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CadFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CadFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CadFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCucoCustCntUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetCucoCustCntUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCucoCustCntUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCucoCustCntUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCucoCustCntUD(requestBody:GetCucoCustCntUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCucoCustCntUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCucoCustCntUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCucoCustCntUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CucoCustomList
   OperationID: CucoCustomList
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CucoCustomList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CucoCustomList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CucoCustomList(requestBody:CucoCustomList_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CucoCustomList_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CucoCustomList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CucoCustomList_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CucoCustomTag
   OperationID: CucoCustomTag
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CucoCustomTag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CucoCustomTag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CucoCustomTag(requestBody:CucoCustomTag_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CucoCustomTag_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CucoCustomTag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CucoCustomTag_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CucoCustomXML
   OperationID: CucoCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CucoCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CucoCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CucoCustomXML(requestBody:CucoCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CucoCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CucoCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CucoCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CucoPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: CucoPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CucoPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CucoPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CucoPayload(requestBody:CucoPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CucoPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CucoPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CucoPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CucoFinalXml
   OperationID: CucoFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CucoFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CucoFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CucoFinalXml(requestBody:CucoFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CucoFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CucoFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CucoFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCusCustomerUD
   Description: Returns all Customer UD data for CUS sync.
Note intended to be used by BPM.
   OperationID: GetCusCustomerUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCusCustomerUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCusCustomerUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCusCustomerUD(requestBody:GetCusCustomerUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCusCustomerUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCusCustomerUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCusCustomerUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CusCustomList
   OperationID: CusCustomList
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CusCustomList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CusCustomList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CusCustomList(requestBody:CusCustomList_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CusCustomList_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CusCustomList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CusCustomList_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CusCustomTag
   OperationID: CusCustomTag
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CusCustomTag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CusCustomTag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CusCustomTag(requestBody:CusCustomTag_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CusCustomTag_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CusCustomTag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CusCustomTag_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CusCustomXML
   OperationID: CusCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CusCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CusCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CusCustomXML(requestBody:CusCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CusCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CusCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CusCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CusPayload
   Description: ECC method used in CNC to allow for custom coding of the payload.  The Customer row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: CusPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CusPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CusPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CusPayload(requestBody:CusPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CusPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CusPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CusPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CusFinalXml
   OperationID: CusFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CusFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CusFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CusFinalXml(requestBody:CusFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CusFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CusFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CusFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCrrcReasonUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetCrrcReasonUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCrrcReasonUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCrrcReasonUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCrrcReasonUD(requestBody:GetCrrcReasonUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCrrcReasonUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCrrcReasonUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCrrcReasonUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrcCustomList
   OperationID: CrrcCustomList
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrcCustomList_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrcCustomList_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrcCustomList(requestBody:CrrcCustomList_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrcCustomList_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrcCustomList", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrcCustomList_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrcCustomTag
   OperationID: CrrcCustomTag
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrcCustomTag_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrcCustomTag_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrcCustomTag(requestBody:CrrcCustomTag_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrcCustomTag_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrcCustomTag", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrcCustomTag_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrcCustomXML
   OperationID: CrrcCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrcCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrcCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrcCustomXML(requestBody:CrrcCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrcCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrcCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrcCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrcPayload
   Description: ECC method used in STK upload to allow for custom coding of the payload.  The part row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: CrrcPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrcPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrcPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrcPayload(requestBody:CrrcPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrcPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrcPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrcPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CrrcFinalXml
   OperationID: CrrcFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CrrcFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CrrcFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CrrcFinalXml(requestBody:CrrcFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CrrcFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CrrcFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CrrcFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSuspVendorUD
   Description: Returns all Vendor UD data for SUSP.
Note intended to be used by BPM.
   OperationID: GetSuspVendorUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetSuspVendorUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSuspVendorUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSuspVendorUD(requestBody:GetSuspVendorUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetSuspVendorUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetSuspVendorUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetSuspVendorUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuspCustomListVendor
   OperationID: SuspCustomListVendor
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuspCustomListVendor_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuspCustomListVendor_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuspCustomListVendor(requestBody:SuspCustomListVendor_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuspCustomListVendor_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuspCustomListVendor", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuspCustomListVendor_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuspCustomTagVendor
   OperationID: SuspCustomTagVendor
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuspCustomTagVendor_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuspCustomTagVendor_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuspCustomTagVendor(requestBody:SuspCustomTagVendor_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuspCustomTagVendor_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuspCustomTagVendor", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuspCustomTagVendor_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuspCustomXML
   OperationID: SuspCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuspCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuspCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuspCustomXML(requestBody:SuspCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuspCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuspCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuspCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuspPayload
   Description: ECC method used in SUSP upload to allow for custom coding of the payload.  The vendor row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: SuspPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuspPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuspPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuspPayload(requestBody:SuspPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuspPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuspPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuspPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SuspFinalXml
   OperationID: SuspFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SuspFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SuspFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SuspFinalXml(requestBody:SuspFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SuspFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SuspFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SuspFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetSucoVendCntUD
   Description: Returns all VendCnt UD data for SUCO.
Note intended to be used by BPM.
   OperationID: GetSucoVendCntUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetSucoVendCntUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetSucoVendCntUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetSucoVendCntUD(requestBody:GetSucoVendCntUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetSucoVendCntUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetSucoVendCntUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetSucoVendCntUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SucoCustomListVendCnt
   OperationID: SucoCustomListVendCnt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SucoCustomListVendCnt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SucoCustomListVendCnt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SucoCustomListVendCnt(requestBody:SucoCustomListVendCnt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SucoCustomListVendCnt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SucoCustomListVendCnt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SucoCustomListVendCnt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SucoCustomTagVendCnt
   OperationID: SucoCustomTagVendCnt
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SucoCustomTagVendCnt_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SucoCustomTagVendCnt_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SucoCustomTagVendCnt(requestBody:SucoCustomTagVendCnt_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SucoCustomTagVendCnt_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SucoCustomTagVendCnt", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SucoCustomTagVendCnt_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SucoCustomXML
   OperationID: SucoCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SucoCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SucoCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SucoCustomXML(requestBody:SucoCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SucoCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SucoCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SucoCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SucoPayload
   Description: ECC method used in SUCO upload to allow for custom coding of the payload.  The vendCnt row will be supplied for reference to help
with the updating of the payLoad string.
   OperationID: SucoPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SucoPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SucoPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SucoPayload(requestBody:SucoPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SucoPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SucoPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SucoPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method SucoFinalXml
   OperationID: SucoFinalXml
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/SucoFinalXml_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/SucoFinalXml_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_SucoFinalXml(requestBody:SucoFinalXml_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<SucoFinalXml_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/SucoFinalXml", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as SucoFinalXml_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignOrderDtlUD
   Description: Assigns UD columns for order detail.
   OperationID: AssignOrderDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignOrderDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignOrderDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignOrderDtlUD(requestBody:AssignOrderDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignOrderDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignOrderDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignOrderDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method AssignOrderHedUD
   Description: Assigns payload and UD columns for order head
   OperationID: AssignOrderHedUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/AssignOrderHedUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/AssignOrderHedUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_AssignOrderHedUD(requestBody:AssignOrderHedUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<AssignOrderHedUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/AssignOrderHedUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as AssignOrderHedUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method BsvCustomListOrderDtl
   OperationID: BsvCustomListOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/BsvCustomListOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/BsvCustomListOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_BsvCustomListOrderDtl(requestBody:BsvCustomListOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<BsvCustomListOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/BsvCustomListOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as BsvCustomListOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method BsvCustomListOrderHed
   OperationID: BsvCustomListOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/BsvCustomListOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/BsvCustomListOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_BsvCustomListOrderHed(requestBody:BsvCustomListOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<BsvCustomListOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/BsvCustomListOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as BsvCustomListOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method BsvCustomTagOrderDtl
   OperationID: BsvCustomTagOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/BsvCustomTagOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/BsvCustomTagOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_BsvCustomTagOrderDtl(requestBody:BsvCustomTagOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<BsvCustomTagOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/BsvCustomTagOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as BsvCustomTagOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method BsvCustomTagOrderHed
   OperationID: BsvCustomTagOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/BsvCustomTagOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/BsvCustomTagOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_BsvCustomTagOrderHed(requestBody:BsvCustomTagOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<BsvCustomTagOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/BsvCustomTagOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as BsvCustomTagOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method BsvPayload
   OperationID: BsvPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/BsvPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/BsvPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_BsvPayload(requestBody:BsvPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<BsvPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/BsvPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as BsvPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GorCustomListOrderDtl
   OperationID: GorCustomListOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GorCustomListOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GorCustomListOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GorCustomListOrderDtl(requestBody:GorCustomListOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GorCustomListOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GorCustomListOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GorCustomListOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GorCustomListOrderHed
   OperationID: GorCustomListOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GorCustomListOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GorCustomListOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GorCustomListOrderHed(requestBody:GorCustomListOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GorCustomListOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GorCustomListOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GorCustomListOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GorCustomTagOrderDtl
   OperationID: GorCustomTagOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GorCustomTagOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GorCustomTagOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GorCustomTagOrderDtl(requestBody:GorCustomTagOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GorCustomTagOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GorCustomTagOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GorCustomTagOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GorCustomTagOrderHed
   OperationID: GorCustomTagOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GorCustomTagOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GorCustomTagOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GorCustomTagOrderHed(requestBody:GorCustomTagOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GorCustomTagOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GorCustomTagOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GorCustomTagOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GorPayload
   OperationID: GorPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GorPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GorPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GorPayload(requestBody:GorPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GorPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GorPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GorPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCuodOrderHedUD
   Description: Return order header UD data for order inquiry
   OperationID: GetCuodOrderHedUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCuodOrderHedUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCuodOrderHedUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCuodOrderHedUD(requestBody:GetCuodOrderHedUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCuodOrderHedUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCuodOrderHedUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCuodOrderHedUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCuodOrderDtlUD
   Description: Return order detail UD data for order inquiry
   OperationID: GetCuodOrderDtlUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCuodOrderDtlUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCuodOrderDtlUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCuodOrderDtlUD(requestBody:GetCuodOrderDtlUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCuodOrderDtlUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCuodOrderDtlUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCuodOrderDtlUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuodCustomListOrderDtl
   OperationID: CuodCustomListOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuodCustomListOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuodCustomListOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuodCustomListOrderDtl(requestBody:CuodCustomListOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuodCustomListOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuodCustomListOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuodCustomListOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuodCustomTagOrderDtl
   OperationID: CuodCustomTagOrderDtl
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuodCustomTagOrderDtl_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuodCustomTagOrderDtl_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuodCustomTagOrderDtl(requestBody:CuodCustomTagOrderDtl_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuodCustomTagOrderDtl_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuodCustomTagOrderDtl", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuodCustomTagOrderDtl_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuodCustomListOrderHed
   OperationID: CuodCustomListOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuodCustomListOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuodCustomListOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuodCustomListOrderHed(requestBody:CuodCustomListOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuodCustomListOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuodCustomListOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuodCustomListOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuodCustomTagOrderHed
   OperationID: CuodCustomTagOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuodCustomTagOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuodCustomTagOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuodCustomTagOrderHed(requestBody:CuodCustomTagOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuodCustomTagOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuodCustomTagOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuodCustomTagOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuodCustomXML
   OperationID: CuodCustomXML
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuodCustomXML_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuodCustomXML_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuodCustomXML(requestBody:CuodCustomXML_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuodCustomXML_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuodCustomXML", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuodCustomXML_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuodPayload
   OperationID: CuodPayload
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuodPayload_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuodPayload_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuodPayload(requestBody:CuodPayload_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuodPayload_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuodPayload", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuodPayload_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetCuosOrderHedUD
   OperationID: GetCuosOrderHedUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetCuosOrderHedUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetCuosOrderHedUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetCuosOrderHedUD(requestBody:GetCuosOrderHedUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetCuosOrderHedUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetCuosOrderHedUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetCuosOrderHedUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuosCustomListOrderHed
   OperationID: CuosCustomListOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuosCustomListOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuosCustomListOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuosCustomListOrderHed(requestBody:CuosCustomListOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuosCustomListOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuosCustomListOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuosCustomListOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method CuosCustomTagOrderHed
   OperationID: CuosCustomTagOrderHed
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/CuosCustomTagOrderHed_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/CuosCustomTagOrderHed_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_CuosCustomTagOrderHed(requestBody:CuosCustomTagOrderHed_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<CuosCustomTagOrderHed_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/CuosCustomTagOrderHed", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as CuosCustomTagOrderHed_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DdaXmlInbound
   Description: DDA inbound message handler to allow for a complete override of ERP DDA message handling.
Custom code responsible for created the XML response.
BPM should not be attached to this method but rather DdaXmlOverride
   OperationID: DdaXmlInbound
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DdaXmlInbound_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DdaXmlInbound_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DdaXmlInbound(requestBody:DdaXmlInbound_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DdaXmlInbound_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DdaXmlInbound", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DdaXmlInbound_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DdaXmlOverride
   Description: Generic method to allow for complete override of ERP DDA message handling.
Custom code responsible for created the XML response.
   OperationID: DdaXmlOverride
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DdaXmlOverride_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DdaXmlOverride_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DdaXmlOverride(requestBody:DdaXmlOverride_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DdaXmlOverride_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DdaXmlOverride", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DdaXmlOverride_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method DdaLineOverride
   Description: Generic method to allow for override of DDA per line
   OperationID: DdaLineOverride
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/DdaLineOverride_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/DdaLineOverride_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_DdaLineOverride(requestBody:DdaLineOverride_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<DdaLineOverride_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/DdaLineOverride", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as DdaLineOverride_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method MsqOverride
   Description: Generic method to allow for override of MSQ price per part and quantity
   OperationID: MsqOverride
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/MsqOverride_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/MsqOverride_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_MsqOverride(requestBody:MsqOverride_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<MsqOverride_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/MsqOverride", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as MsqOverride_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetAltPartUD
   Description: Returns all Part UD data for ALT.
Note intended to be used by BPM.
   OperationID: GetAltPartUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetAltPartUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetAltPartUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetAltPartUD(requestBody:GetAltPartUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetAltPartUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetAltPartUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetAltPartUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}

   /**  
   Summary: Invoke method GetAltPartSubsUD
   Description: Returns all Part UD data for STK.
Note intended to be used by BPM.
   OperationID: GetAltPartSubsUD
      @param epicorHeaders A string representing the epicor log in information to be used, 
         already converted to base64 in the format username:password, defaults to the configEpicorSchemas creds
      @param requestBody Desc: Input parameters  => reference#/components/schemas/GetAltPartSubsUD_input
   Returns: 
      200 Desc: OK => reference#/components/schemas/GetAltPartSubsUD_output
      500 Desc: Internal server error. Server is unable to process the request.
   */  
export function post_GetAltPartSubsUD(requestBody:GetAltPartSubsUD_input, epicorHeaders?:Headers){

   var headers = configEpicorSchemas.epicorHeaders
   if(typeof epicorHeaders !== 'undefined'){
         headers = epicorHeaders
   }

   return (new Promise<GetAltPartSubsUD_output>((resolve, reject) => {
      const request: RequestInfo = new Request(configEpicorSchemas.epicorURL + "Erp.BO.ECCExtensionSvc/GetAltPartSubsUD", {
          method: 'post',
          headers: headers,
          body: JSON.stringify(requestBody)
      })
      fetch(request)
      .then((res) => {
         if(res.ok){
             return res.json()
         }
         else{
             return res.json().then(text => {throw new Error(text["ErrorMessage"]) })
         }
      })
      .then((data) => {
         resolve(data as GetAltPartSubsUD_output)
          })
      .catch((error) => {
          reject(error)
      })
   }))
}



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// OData Schemas:
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Custom Schemas:
//////////////////////////////////////////////////////////////////////////
   /** Required : 
      @param eccExtPartSubs
      @param eccExtList
   */  
export interface AltCustomListPartSubs_input{
   eccExtPartSubs:Erp_Tablesets_ECCExtensionPartSubsTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface AltCustomListPartSubs_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPart
      @param eccExtList
   */  
export interface AltCustomListPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface AltCustomListPart_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPartSubs
      @param columnName
      @param customValue
   */  
export interface AltCustomTagPartSubs_input{
   eccExtPartSubs:Erp_Tablesets_ECCExtensionPartSubsTableset[],
   columnName:string,
   customValue:string,
}

export interface AltCustomTagPartSubs_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPart
      @param columnName
      @param customValue
   */  
export interface AltCustomTagPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   columnName:string,
   customValue:string,
}

export interface AltCustomTagPart_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlDoc
   */  
export interface AltCustomXML_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlDoc:string,
}

export interface AltCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlOverride
      @param xmlDoc
   */  
export interface AltFinalXml_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface AltFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param payLoad
   */  
export interface AltPayload_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   payLoad:string,
}

export interface AltPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtCustomerRow
      @param reqType
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignCustomerUD_input{
   eccExtCustomerRow:Erp_Tablesets_CustomerRow[],
   reqType:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignCustomerUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtCustomerRow:Erp_Tablesets_CustomerRow,
}
}

   /** Required : 
      @param eccExtHDCaseRow
      @param reqType
      @param payload
      @param userDefinedSet
   */  
export interface AssignHDCaseUD_input{
   eccExtHDCaseRow:Erp_Tablesets_HDCaseRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
}

export interface AssignHDCaseUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtHDCaseRow:Erp_Tablesets_HDCaseRow,
}
}

   /** Required : 
      @param eccExtLocationInventoryRow
      @param reqType
      @param payload
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignLocationInventoryUD_input{
   eccExtLocationInventoryRow:Erp_Tablesets_LocationInventoryRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignLocationInventoryUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtLocationInventoryRow:Erp_Tablesets_LocationInventoryRow,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTranRow
      @param reqType
      @param payload
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignLocationWarrantyTranUD_input{
   eccExtLocationWarrantyTranRow:Erp_Tablesets_LocationWarrantyTranRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignLocationWarrantyTranUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtLocationWarrantyTranRow:Erp_Tablesets_LocationWarrantyTranRow,
}
}

   /** Required : 
      @param eccExtOrderDtlRow
      @param reqType
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignOrderDtlUD_input{
   eccExtOrderDtlRow:Erp_Tablesets_OrderDtlRow[],
   reqType:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignOrderDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtOrderDtlRow:Erp_Tablesets_OrderDtlRow,
}
}

   /** Required : 
      @param eccExtOrderHedRow
      @param reqType
      @param payload
      @param userDefinedSet
   */  
export interface AssignOrderHedUD_input{
   eccExtOrderHedRow:Erp_Tablesets_OrderHedRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
}

export interface AssignOrderHedUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtOrderHedRow:Erp_Tablesets_OrderHedRow,
}
}

   /** Required : 
      @param eccExtQuoteDtlRow
      @param reqType
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignQuoteDtlUD_input{
   eccExtQuoteDtlRow:Erp_Tablesets_QuoteDtlRow[],
   reqType:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignQuoteDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtQuoteDtlRow:Erp_Tablesets_QuoteDtlRow,
}
}

   /** Required : 
      @param eccExtQuoteHedRow
      @param reqType
      @param payload
      @param userDefinedSet
   */  
export interface AssignQuoteHedUD_input{
   eccExtQuoteHedRow:Erp_Tablesets_QuoteHedRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
}

export interface AssignQuoteHedUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtQuoteHedRow:Erp_Tablesets_QuoteHedRow,
}
}

   /** Required : 
      @param eccExtRFQHeadRow
      @param reqType
      @param payload
      @param userDefinedSet
   */  
export interface AssignRFQHeadUD_input{
   eccExtRFQHeadRow:Erp_Tablesets_RFQHeadRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
}

export interface AssignRFQHeadUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtRFQHeadRow:Erp_Tablesets_RFQHeadRow,
}
}

   /** Required : 
      @param eccExtRFQItemRow
      @param reqType
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignRFQItemUD_input{
   eccExtRFQItemRow:Erp_Tablesets_RFQItemRow[],
   reqType:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignRFQItemUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtRFQItemRow:Erp_Tablesets_RFQItemRow,
}
}

   /** Required : 
      @param eccExtRMADtlRow
      @param reqType
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignRMADtlUD_input{
   eccExtRMADtlRow:Erp_Tablesets_RMADtlRow[],
   reqType:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignRMADtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtRMADtlRow:Erp_Tablesets_RMADtlRow,
}
}

   /** Required : 
      @param eccExtRMAHeadRow
      @param reqType
      @param payload
      @param userDefinedSet
   */  
export interface AssignRMAHeadUD_input{
   eccExtRMAHeadRow:Erp_Tablesets_RMAHeadRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
}

export interface AssignRMAHeadUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtRMAHeadRow:Erp_Tablesets_RMAHeadRow,
}
}

   /** Required : 
      @param eccExtShipToRow
      @param reqType
      @param userDefinedSet
   */  
export interface AssignShipToUD_input{
   eccExtShipToRow:Erp_Tablesets_ShipToRow[],
   reqType:string,
   userDefinedSet:System_Xml_Linq_XElement[],
}

export interface AssignShipToUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtShipToRow:Erp_Tablesets_ShipToRow,
}
}

   /** Required : 
      @param eccExtSugPOChgRowRow
      @param reqType
      @param payload
      @param userDefinedSet
      @param attributeSet
   */  
export interface AssignSugPOChgUD_input{
   eccExtSugPOChgRowRow:Erp_Tablesets_SugPOChgRow[],
   reqType:string,
   payload:string,
   userDefinedSet:System_Xml_Linq_XElement[],
   attributeSet:System_Xml_Linq_XElement[],
}

export interface AssignSugPOChgUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   eccExtSugPOChgRowRow:Erp_Tablesets_SugPOChgRow,
}
}

   /** Required : 
      @param eccExtOrderDtl
      @param eccExtList
   */  
export interface BsvCustomListOrderDtl_input{
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface BsvCustomListOrderDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param eccExtList
   */  
export interface BsvCustomListOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface BsvCustomListOrderHed_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderDtl
      @param columnName
      @param customValue
   */  
export interface BsvCustomTagOrderDtl_input{
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface BsvCustomTagOrderDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param columnName
      @param customValue
   */  
export interface BsvCustomTagOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   columnName:string,
   customValue:string,
}

export interface BsvCustomTagOrderHed_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param payload
   */  
export interface BsvPayload_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   payload:string,
}

export interface BsvPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset,
   payload:string,
}
}

   /** Required : 
      @param eccExtShipTo
      @param eccExtList
   */  
export interface CadCustomList_input{
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CadCustomList_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtShipTo
      @param columnName
      @param customValue
   */  
export interface CadCustomTag_input{
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   columnName:string,
   customValue:string,
}

export interface CadCustomTag_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtShipTo
      @param xmlDoc
   */  
export interface CadCustomXML_input{
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   xmlDoc:string,
}

export interface CadCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtShipTo
      @param xmlOverride
      @param xmlDoc
   */  
export interface CadFinalXml_input{
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface CadFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtShipTo
      @param payLoad
   */  
export interface CadPayload_input{
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   payLoad:string,
}

export interface CadPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtPcECCOrderDtl
      @param eccExtList
   */  
export interface CdmCustomListPcECCOrderDtl_input{
   eccExtPcECCOrderDtl:Erp_Tablesets_ECCExtensionPcECCOrderDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CdmCustomListPcECCOrderDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param eccExtList
   */  
export interface CdmCustomListQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CdmCustomListQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPcECCOrderDtl
      @param columnName
      @param customValue
   */  
export interface CdmCustomTagPcECCOrderDtl_input{
   eccExtPcECCOrderDtl:Erp_Tablesets_ECCExtensionPcECCOrderDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CdmCustomTagPcECCOrderDtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param columnName
      @param customValue
   */  
export interface CdmCustomTagQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CdmCustomTagQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param isInboundOutbound
      @param eccExtCustomer
      @param eccExtList
   */  
export interface CncCustomListCustomer_input{
      /**  "I" if Inbound CNC request or "O" if Outbound CNC response  */  
   isInboundOutbound:string,
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CncCustomListCustomer_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param isInboundOutbound
      @param eccExtShipTo
      @param eccExtList
   */  
export interface CncCustomListShipTo_input{
      /**  "I" if Inbound CNC request or "O" if Outbound CNC response  */  
   isInboundOutbound:string,
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CncCustomListShipTo_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param isInboundOutbound
      @param eccExtCustomer
      @param columnName
      @param customValue
   */  
export interface CncCustomTagCustomer_input{
      /**  "I" if Inbound CNC request or "O" if Outbound CNC response  */  
   isInboundOutbound:string,
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   columnName:string,
   customValue:string,
}

export interface CncCustomTagCustomer_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param isInboundOutbound
      @param eccExtShipTo
      @param columnName
      @param customValue
   */  
export interface CncCustomTagShipTo_input{
      /**  "I" if Inbound CNC request or "O" if Outbound CNC response  */  
   isInboundOutbound:string,
   eccExtShipTo:Erp_Tablesets_ECCExtensionShipToTableset[],
   columnName:string,
   customValue:string,
}

export interface CncCustomTagShipTo_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param isInboundOutbound
      @param eccExtCustomer
      @param payload
   */  
export interface CncPayload_input{
      /**  "I" if Inbound CNC request or "O" if Outbound CNC response  */  
   isInboundOutbound:string,
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   payload:string,
}

export interface CncPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset,
   payload:string,
}
}

   /** Required : 
      @param eccExtCustXPrt
      @param eccExtList
   */  
export interface CpnCustomListCustXPrt_input{
   eccExtCustXPrt:Erp_Tablesets_ECCExtensionCustXPrtTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CpnCustomListCustXPrt_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPartXRefInt
      @param eccExtList
   */  
export interface CpnCustomListPartXRefInt_input{
   eccExtPartXRefInt:Erp_Tablesets_ECCExtensionPartXRefIntTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CpnCustomListPartXRefInt_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtCustXPrt
      @param columnName
      @param customValue
   */  
export interface CpnCustomTagCustXPrt_input{
   eccExtCustXPrt:Erp_Tablesets_ECCExtensionCustXPrtTableset[],
   columnName:string,
   customValue:string,
}

export interface CpnCustomTagCustXPrt_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPartXRefInt
      @param columnName
      @param customValue
   */  
export interface CpnCustomTagPartXRefInt_input{
   eccExtPartXRefInt:Erp_Tablesets_ECCExtensionPartXRefIntTableset[],
   columnName:string,
   customValue:string,
}

export interface CpnCustomTagPartXRefInt_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtCustXPrt
      @param xmlDoc
   */  
export interface CpnCustomXMLCustXPrt_input{
   eccExtCustXPrt:Erp_Tablesets_ECCExtensionCustXPrtTableset[],
   xmlDoc:string,
}

export interface CpnCustomXMLCustXPrt_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPartXRefInt
      @param xmlDoc
   */  
export interface CpnCustomXMLPartXRefInt_input{
   eccExtPartXRefInt:Erp_Tablesets_ECCExtensionPartXRefIntTableset[],
   xmlDoc:string,
}

export interface CpnCustomXMLPartXRefInt_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtCustXPrt
      @param xmlOverride
      @param xmlDoc
   */  
export interface CpnFinalXmlCustXPrt_input{
   eccExtCustXPrt:Erp_Tablesets_ECCExtensionCustXPrtTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface CpnFinalXmlCustXPrt_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPartXRefInt
      @param xmlOverride
      @param xmlDoc
   */  
export interface CpnFinalXmlPartXRefInt_input{
   eccExtPartXRefInt:Erp_Tablesets_ECCExtensionPartXRefIntTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface CpnFinalXmlPartXRefInt_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtCustXPrt
      @param payLoad
   */  
export interface CpnPayloadCustXPrt_input{
   eccExtCustXPrt:Erp_Tablesets_ECCExtensionCustXPrtTableset[],
   payLoad:string,
}

export interface CpnPayloadCustXPrt_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtPartXRefInt
      @param payLoad
   */  
export interface CpnPayloadPartXRefInt_input{
   eccExtPartXRefInt:Erp_Tablesets_ECCExtensionPartXRefIntTableset[],
   payLoad:string,
}

export interface CpnPayloadPartXRefInt_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param eccExtList
   */  
export interface CrqdCustomListQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrqdCustomListQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param eccExtList
   */  
export interface CrqdCustomListQuoteHed_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrqdCustomListQuoteHed_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param columnName
      @param customValue
   */  
export interface CrqdCustomTagQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CrqdCustomTagQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param columnName
      @param customValue
   */  
export interface CrqdCustomTagQuoteHed_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   columnName:string,
   customValue:string,
}

export interface CrqdCustomTagQuoteHed_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param xmlDoc
   */  
export interface CrqdCustomXML_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   xmlDoc:string,
}

export interface CrqdCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param payLoad
   */  
export interface CrqdPayload_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   payLoad:string,
}

export interface CrqdPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param eccExtList
   */  
export interface CrquCustomListQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrquCustomListQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param eccExtList
   */  
export interface CrquCustomListQuoteHed_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrquCustomListQuoteHed_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param columnName
      @param customValue
   */  
export interface CrquCustomTagQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CrquCustomTagQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param columnName
      @param customValue
   */  
export interface CrquCustomTagQuoteHed_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   columnName:string,
   customValue:string,
}

export interface CrquCustomTagQuoteHed_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param xmlDoc
   */  
export interface CrquCustomXML_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   xmlDoc:string,
}

export interface CrquCustomXML_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param payload
   */  
export interface CrquPayload_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   payload:string,
}

export interface CrquPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   payload:string,
}
}

   /** Required : 
      @param eccExtReason
      @param eccExtList
   */  
export interface CrrcCustomList_input{
   eccExtReason:Erp_Tablesets_ECCExtensionReasonTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrrcCustomList_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtReason
      @param columnName
      @param customValue
   */  
export interface CrrcCustomTag_input{
   eccExtReason:Erp_Tablesets_ECCExtensionReasonTableset[],
   columnName:string,
   customValue:string,
}

export interface CrrcCustomTag_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtReason
      @param xmlDoc
   */  
export interface CrrcCustomXML_input{
   eccExtReason:Erp_Tablesets_ECCExtensionReasonTableset[],
   xmlDoc:string,
}

export interface CrrcCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtReason
      @param xmlOverride
      @param xmlDoc
   */  
export interface CrrcFinalXml_input{
   eccExtReason:Erp_Tablesets_ECCExtensionReasonTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface CrrcFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtReason
      @param payLoad
   */  
export interface CrrcPayload_input{
   eccExtReason:Erp_Tablesets_ECCExtensionReasonTableset[],
   payLoad:string,
}

export interface CrrcPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtRMADtl
      @param eccExtList
   */  
export interface CrrdCustomListRMADtl_input{
   eccExtRMADtl:Erp_Tablesets_ECCExtensionRMADtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrrdCustomListRMADtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param eccExtList
   */  
export interface CrrdCustomListRMAHead_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrrdCustomListRMAHead_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRMADtl
      @param columnName
      @param customValue
   */  
export interface CrrdCustomTagRMADtl_input{
   eccExtRMADtl:Erp_Tablesets_ECCExtensionRMADtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CrrdCustomTagRMADtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param columnName
      @param customValue
   */  
export interface CrrdCustomTagRMAHead_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   columnName:string,
   customValue:string,
}

export interface CrrdCustomTagRMAHead_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param xmlDoc
   */  
export interface CrrdCustomXML_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   xmlDoc:string,
}

export interface CrrdCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param payLoad
   */  
export interface CrrdPayload_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   payLoad:string,
}

export interface CrrdPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtRMADtl
      @param eccExtList
   */  
export interface CrruCustomListRMADtl_input{
   eccExtRMADtl:Erp_Tablesets_ECCExtensionRMADtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrruCustomListRMADtl_output{
parameters : {
      /**  output parameters  */  
   eccExtRMADtl:Erp_Tablesets_ECCExtensionRMADtlTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param eccExtList
   */  
export interface CrruCustomListRMAHead_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CrruCustomListRMAHead_output{
parameters : {
      /**  output parameters  */  
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRMADtl
      @param columnName
      @param customValue
   */  
export interface CrruCustomTagRMADtl_input{
   eccExtRMADtl:Erp_Tablesets_ECCExtensionRMADtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CrruCustomTagRMADtl_output{
parameters : {
      /**  output parameters  */  
   eccExtRMADtl:Erp_Tablesets_ECCExtensionRMADtlTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param columnName
      @param customValue
   */  
export interface CrruCustomTagRMAHead_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   columnName:string,
   customValue:string,
}

export interface CrruCustomTagRMAHead_output{
parameters : {
      /**  output parameters  */  
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param xmlDoc
   */  
export interface CrruCustomXML_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   xmlDoc:string,
}

export interface CrruCustomXML_output{
parameters : {
      /**  output parameters  */  
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtRMAHead
      @param payload
   */  
export interface CrruPayload_input{
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset[],
   payload:string,
}

export interface CrruPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtRMAHead:Erp_Tablesets_ECCExtensionRMAHeadTableset,
   payload:string,
}
}

   /** Required : 
      @param eccExtCustCnt
      @param eccExtList
   */  
export interface CucoCustomList_input{
   eccExtCustCnt:Erp_Tablesets_ECCExtensionCustCntTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CucoCustomList_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtCustCnt
      @param columnName
      @param customValue
   */  
export interface CucoCustomTag_input{
   eccExtCustCnt:Erp_Tablesets_ECCExtensionCustCntTableset[],
   columnName:string,
   customValue:string,
}

export interface CucoCustomTag_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtCustCnt
      @param xmlDoc
   */  
export interface CucoCustomXML_input{
   eccExtCustCnt:Erp_Tablesets_ECCExtensionCustCntTableset[],
   xmlDoc:string,
}

export interface CucoCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtCustCnt
      @param xmlOverride
      @param xmlDoc
   */  
export interface CucoFinalXml_input{
   eccExtCustCnt:Erp_Tablesets_ECCExtensionCustCntTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface CucoFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtCustCnt
      @param payLoad
   */  
export interface CucoPayload_input{
   eccExtCustCnt:Erp_Tablesets_ECCExtensionCustCntTableset[],
   payLoad:string,
}

export interface CucoPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtInvcDtl
      @param eccExtList
   */  
export interface CuidCustomListInvcDtl_input{
   eccExtInvcDtl:Erp_Tablesets_ECCExtensionInvcDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CuidCustomListInvcDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtInvcHead
      @param eccExtList
   */  
export interface CuidCustomListInvcHead_input{
   eccExtInvcHead:Erp_Tablesets_ECCExtensionInvcHeadTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CuidCustomListInvcHead_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtInvcDtl
      @param columnName
      @param customValue
   */  
export interface CuidCustomTagInvcDtl_input{
   eccExtInvcDtl:Erp_Tablesets_ECCExtensionInvcDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CuidCustomTagInvcDtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtInvcHead
      @param columnName
      @param customValue
   */  
export interface CuidCustomTagInvcHead_input{
   eccExtInvcHead:Erp_Tablesets_ECCExtensionInvcHeadTableset[],
   columnName:string,
   customValue:string,
}

export interface CuidCustomTagInvcHead_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtInvcHead
      @param xmlDoc
   */  
export interface CuidCustomXML_input{
   eccExtInvcHead:Erp_Tablesets_ECCExtensionInvcHeadTableset[],
   xmlDoc:string,
}

export interface CuidCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtInvcHead
      @param payLoad
   */  
export interface CuidPayload_input{
   eccExtInvcHead:Erp_Tablesets_ECCExtensionInvcHeadTableset[],
   payLoad:string,
}

export interface CuidPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtOrderDtl
      @param eccExtList
   */  
export interface CuodCustomListOrderDtl_input{
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CuodCustomListOrderDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param eccExtList
   */  
export interface CuodCustomListOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CuodCustomListOrderHed_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderDtl
      @param columnName
      @param customValue
   */  
export interface CuodCustomTagOrderDtl_input{
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface CuodCustomTagOrderDtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param columnName
      @param customValue
   */  
export interface CuodCustomTagOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   columnName:string,
   customValue:string,
}

export interface CuodCustomTagOrderHed_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param xmlDoc
   */  
export interface CuodCustomXML_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   xmlDoc:string,
}

export interface CuodCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param payLoad
   */  
export interface CuodPayload_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   payLoad:string,
}

export interface CuodPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param eccExtList
   */  
export interface CuosCustomListOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CuosCustomListOrderHed_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param columnName
      @param customValue
   */  
export interface CuosCustomTagOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   columnName:string,
   customValue:string,
}

export interface CuosCustomTagOrderHed_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtCustomer
      @param eccExtList
   */  
export interface CusCustomList_input{
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface CusCustomList_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtCustomer
      @param columnName
      @param customValue
   */  
export interface CusCustomTag_input{
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   columnName:string,
   customValue:string,
}

export interface CusCustomTag_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtCustomer
      @param xmlDoc
   */  
export interface CusCustomXML_input{
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   xmlDoc:string,
}

export interface CusCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtCustomer
      @param xmlOverride
      @param xmlDoc
   */  
export interface CusFinalXml_input{
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface CusFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtCustomer
      @param payLoad
   */  
export interface CusPayload_input{
   eccExtCustomer:Erp_Tablesets_ECCExtensionCustomerTableset[],
   payLoad:string,
}

export interface CusPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtHDCase
      @param eccExtList
   */  
export interface DcldCustomListHDCase_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DcldCustomListHDCase_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtHDCase
      @param columnName
      @param customValue
   */  
export interface DcldCustomTagHDCase_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   columnName:string,
   customValue:string,
}

export interface DcldCustomTagHDCase_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtHDCase
      @param xmlDoc
   */  
export interface DcldCustomXML_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   xmlDoc:string,
}

export interface DcldCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtHDCase
      @param payLoad
   */  
export interface DcldPayload_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   payLoad:string,
}

export interface DcldPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtHDCase
      @param eccExtList
   */  
export interface DcluCustomListHDCase_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DcluCustomListHDCase_output{
parameters : {
      /**  output parameters  */  
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtHDCase
      @param columnName
      @param customValue
   */  
export interface DcluCustomTagHDCase_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   columnName:string,
   customValue:string,
}

export interface DcluCustomTagHDCase_output{
parameters : {
      /**  output parameters  */  
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtHDCase
      @param xmlDoc
   */  
export interface DcluCustomXML_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   xmlDoc:string,
}

export interface DcluCustomXML_output{
parameters : {
      /**  output parameters  */  
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtHDCase
      @param payload
   */  
export interface DcluPayload_input{
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset[],
   payload:string,
}

export interface DcluPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtHDCase:Erp_Tablesets_ECCExtensionHDCaseTableset,
   payload:string,
}
}

   /** Required : 
      @param ddaLines
      @param ddaRounds
      @param ddaDates
   */  
export interface DdaLineOverride_input{
   ddaLines:Erp_Tablesets_ECCExtensionDdaLinesTableset[],
   ddaRounds:Erp_Tablesets_ECCExtensionDdaRoundsTableset[],
   ddaDates:Erp_Tablesets_ECCExtensionDdaDatesTableset[],
}

export interface DdaLineOverride_output{
parameters : {
      /**  output parameters  */  
   ddaLineOrverride:boolean,
   ddaRounds:Erp_Tablesets_ECCExtensionDdaRoundsTableset,
   ddaDates:Erp_Tablesets_ECCExtensionDdaDatesTableset,
}
}

   /** Required : 
      @param requestMsg
   */  
export interface DdaXmlInbound_input{
   requestMsg:System_Xml_Linq_XElement[],
}

export interface DdaXmlInbound_output{
   returnObj:System_Xml_Linq_XElement[],
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
}
}

   /** Required : 
      @param requestXmlDoc
   */  
export interface DdaXmlOverride_input{
   requestXmlDoc:string,
}

export interface DdaXmlOverride_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   responseXmlDoc:string,
}
}

   /** Required : 
      @param eccExtLocationMtl
      @param eccExtList
   */  
export interface DebmCustomListLocationMtl_input{
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationMtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DebmCustomListLocationMtl_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTran
      @param eccExtList
   */  
export interface DebmCustomListLocationWarrantyTran_input{
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DebmCustomListLocationWarrantyTran_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtLocationMtl
      @param columnName
      @param customValue
   */  
export interface DebmCustomTagLocationMtl_input{
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationMtlTableset[],
   columnName:string,
   customValue:string,
}

export interface DebmCustomTagLocationMtl_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTran
      @param columnName
      @param customValue
   */  
export interface DebmCustomTagLocationWarrantyTran_input{
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset[],
   columnName:string,
   customValue:string,
}

export interface DebmCustomTagLocationWarrantyTran_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtLocationInventory
      @param xmlDoc
   */  
export interface DebmCustomXML_input{
   eccExtLocationInventory:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   xmlDoc:string,
}

export interface DebmCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtLocationInventory
      @param payLoad
   */  
export interface DebmPayload_input{
   eccExtLocationInventory:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   payLoad:string,
}

export interface DebmPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtLocationInventory
      @param eccExtList
   */  
export interface DeidCustomListLocationInventory_input{
   eccExtLocationInventory:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DeidCustomListLocationInventory_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtLocationInventory
      @param columnName
      @param customValue
   */  
export interface DeidCustomTagLocationInventory_input{
   eccExtLocationInventory:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   columnName:string,
   customValue:string,
}

export interface DeidCustomTagLocationInventory_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtLocationInventory
      @param xmlDoc
   */  
export interface DeidCustomXML_input{
   eccExtLocationInventory:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   xmlDoc:string,
}

export interface DeidCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtLocationInventory
      @param payLoad
   */  
export interface DeidPayload_input{
   eccExtLocationInventory:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   payLoad:string,
}

export interface DeidPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtLocationMtl
      @param eccExtList
   */  
export interface DeiuCustomListLocationInventory_input{
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DeiuCustomListLocationInventory_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtLocationMtl
      @param columnName
      @param customValue
   */  
export interface DeiuCustomTagLocationInventory_input{
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   columnName:string,
   customValue:string,
}

export interface DeiuCustomTagLocationInventory_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtLocationMtl
      @param xmlDoc
   */  
export interface DeiuCustomXML_input{
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   xmlDoc:string,
}

export interface DeiuCustomXML_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtLocationMtl
      @param payload
   */  
export interface DeiuPayload_input{
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset[],
   payload:string,
}

export interface DeiuPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationMtl:Erp_Tablesets_ECCExtensionLocationInventoryTableset,
   payload:string,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTran
      @param eccExtList
   */  
export interface DmauCustomListLocationWarrantyTran_input{
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface DmauCustomListLocationWarrantyTran_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTran
      @param columnName
      @param customValue
   */  
export interface DmauCustomTagLocationWarrantyTran_input{
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset[],
   columnName:string,
   customValue:string,
}

export interface DmauCustomTagLocationWarrantyTran_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTran
      @param payload
   */  
export interface DmauPayload_input{
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset[],
   payload:string,
}

export interface DmauPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtLocationWarrantyTran:Erp_Tablesets_ECCExtensionLocationWarrTranTableset,
   payload:string,
}
}

   /** Required : 
      @param requestMsg
   */  
export interface ECCSvcInbound_input{
   requestMsg:System_Xml_Linq_XElement[],
}

export interface ECCSvcInbound_output{
   returnObj:System_Xml_Linq_XElement[],
}

export interface Erp_Tablesets_CustCntRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the contact is related to.  */  
   CustNum:number,
      /**  The ShipTo.ShipToNum of the Ship To that the customer  */  
   ShipToNum:string,
      /**  A system generated number used to uniquely identify the contact record for the related customer or ship to. When creating new contacts the system reads the last existing contact record for the customer or ship to being processed and then uses its number plus one as the number for the new contact.  */  
   ConNum:number,
      /**  Full name of the contact.  */  
   Name:string,
      /**  Used to enter a short description that should indicate what the contacts main function is. Ex: Shipping, Buyer, Engineer. This is an optional field.  */  
   Func:string,
      /**  The contact's fax number. When displaying phone numbers of contacts the system will use the phone number found in the Customer or Shipto file if the contact's number is blank.  */  
   FaxNum:string,
      /**  The contact's business telephone number. When displaying phone numbers of contacts the system will use the phone number found in the Customer or Shipto file if the contacts number is blank.  */  
   PhoneNum:string,
      /**  A logical flag that indicates if this contact has a mailing address different from the one found in the associated Customer master. This flag is only applicable to contacts related to the Customer. That is where CustCnt.ShipToNum = "". During maintenance if this flag is Yes then access is allowed to the Address, City, State, Zip and Country fields. Otherwise those fields are protected. During maintenance when SpecialAddress is toggled to Yes and the address1 field is blank the program defaults all the address fields equal to the customers, thinking that much of it will be the same, saving keying time. When it's toggled to "No", then program sets all the address field to blank.  */  
   SpecialAddress:boolean,
      /**  Line 1 of the contact's mailing address if different from that of the customer. The contacts associated with a customer (not ship to) are allowed to have address, city, state, zip and country fields that are different from that of their associated customer. If not blank, these address fields are printed on the Quote form; otherwise the customer address is used.  */  
   Address1:string,
      /**  Line 2 of the contact's mailing address if different from that of the customer. (See Address1 for additional information).  */  
   Address2:string,
      /**  Line 3 of the contact's mailing address if different from that of the customer. (See Address1 for additional information).  */  
   Address3:string,
      /**  The city portion of the contact's mailing address. (See Address1 for additional information).  */  
   City:string,
      /**  The state or province portion of the contact's mailing address. (See Address1 for additional information).  */  
   State:string,
      /**  The zip or postal code portion of the contact's mailing address. (See Address1 for additional information).  */  
   Zip:string,
      /**  The Country portion of the contact's mailing address. (See Address1 for additional information).  */  
   Country:string,
      /**  The company name of the contact's mailing address. (See Address1 for additional information).  */  
   CorpName:string,
      /**  The contact's email address.  */  
   EMailAddress:string,
      /**  The Country.CountryNum value of the country selected for the contact's mailing address.  */  
   CountryNum:number,
      /**  Customer Connect password for this contact.  */  
   SFPortalPassword:string,
      /**  Indicates if able to create Orders  */  
   SFUser:boolean,
      /**  Indicates if "Order History" is functional  */  
   PortalUser:boolean,
      /**  RoleCD.RoleCode value of the role assigned to the contact.  */  
   RoleCode:string,
      /**  The contact's cell phone number.  */  
   CellPhoneNum:string,
      /**  The contact's pager number.  */  
   PagerNum:string,
      /**  The contact's Home number.  */  
   HomeNum:string,
      /**  The contact's alternate phone number.  */  
   AltNum:string,
      /**  The contact's title.  */  
   ContactTitle:string,
      /**  The name of the person this contact reports to.  */  
   ReportsTo:string,
      /**  Comments are intended to be internal comments about a specific contact.  */  
   Comment:string,
      /**  Indicates whether or not this contact should be included in marketing lists.  */  
   NoContact:boolean,
      /**  The date that the contact was entered into the database.  */  
   CreateDate:string,
      /**  The UserFile.DCDUserID of the user that entered the contact into the database.  */  
   CreateDcdUserID:string,
      /**  **NOTE cannot find any code that maintains this field.  */  
   ChangeDate:string,
      /**  **NOTE cannot find any code that maintains this field.  */  
   ChangeDcdUserID:string,
      /**  Determines whether or not this contact can be referenced on a quote, order, packing slip or invoice.  */  
   Inactive:boolean,
      /**  Contact's first name.  */  
   FirstName:string,
      /**  Contact's middle name.  */  
   MiddleName:string,
      /**  Contact's last name.  */  
   LastName:string,
      /**  Contact's prefix.  */  
   Prefix:string,
      /**  Contact's suffix.  */  
   Suffix:string,
      /**  Contact's initials.  */  
   Initials:string,
      /**  External ID  */  
   ExternalID:string,
      /**  Determines whether or not this record receives global updates  */  
   GlobalLock:boolean,
      /**  If TRUE then the input prices will be shown in the Customer Connect Configuration Review.  */  
   ShowInputPrice:boolean,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  Pertains to Alternate Shipto. Contains the CustNum of the CustCnt record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterCustNum:number,
      /**  Pertains to Alternate Shipto. Contains the ShipToNum of the CustCnt record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterShipToNum:string,
      /**  Pertains to Alternate Shipto. Contains the ConNum of the CustCnt record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterConNum:number,
      /**  Unique identifier for a PerCon record.  */  
   PerConID:number,
      /**  Default to True. If unchecked then changes to the Name fields on PerCon won't affect this record and vice versa.  */  
   SyncNameToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the Address fields on PerCon won't affect this record and visa versa.  */  
   SyncAddressToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the Phone fields on PerCon won't affect this record and vice versa.  */  
   SyncPhoneToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the email fields on PerCon won't affect this record and vice versa.  */  
   SyncEmailToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the Web link fields on PerCon won't affect this record and vice versa.  */  
   SyncLinksToPerCon:boolean,
      /**  Contact's Website.  */  
   WebSite:string,
      /**  Contact's IM.  */  
   IM:string,
      /**  Contact's Twitter.  */  
   Twitter:string,
      /**  Contact's LinkedIn.  */  
   LinkedIn:string,
      /**  Contact's FaceBook.  */  
   FaceBook:string,
      /**  User defined Link 1.  */  
   WebLink1:string,
      /**  User defined Link 2.  */  
   WebLink2:string,
      /**  User defined Link 3.  */  
   WebLink3:string,
      /**  User defined Link 4.  */  
   WebLink4:string,
      /**  User defined Link 5.  */  
   WebLink5:string,
      /**  Indicates if the Person/Contact address should be used as the Special Quoting Address.  */  
   PerConAddress:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  This field defines if the customer contact  is synchronized to an External CRM.  */  
   SyncToExternalCRM:boolean,
      /**  This field holds the id of this customer in the External CRM  */  
   ExternalCRMCustomerID:string,
      /**  This field holds the id of this customer contact in the External CRM  */  
   ExternalCRMContactID:string,
   RoleDescription:string,
      /**   This check box indicates that this contact is the customer's main billing contact. 
When an AR invoice is created for this customer, this contact's name will automatically appear on the invoice.  */  
   PrimaryBilling:boolean,
      /**   This check box indicates that this contact is the customer's main purchasing contact. 
When a quote or sales order is created for this customer, this contact's name will automatically appear on the order or quote.  */  
   PrimaryPurchasing:boolean,
      /**   This check box indicates that this contact is the customer's main shipping contact. 
When a packing slip is created for this customer, this contact's name will automatically appear on the slip.  */  
   PrimaryShipping:boolean,
      /**  Indicates if the Contact is global (Master or Linked)  */  
   GlbFlag:boolean,
      /**  delimited list of CustCnAttr codes  */  
   AttrCodeList:string,
      /**  GlbCustCnt fields in a linked list to find the linking record  */  
   GlbLink:string,
      /**  Used for ContactTracker.  This is needed so the UI can relate the Contact Tracker tables together.  */  
   ContactName:string,
   PerConName:string,
   BitFlag:number,
   CustNumName:string,
   CustNumBTName:string,
   CustNumCustID:string,
   MasterCustNumBTName:string,
   MasterCustNumName:string,
   MasterCustNumCustID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustXPrtRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Our Part number used to identify this part.  */  
   PartNum:string,
      /**  Contains the Customer number of this part cross reference record  */  
   CustNum:number,
      /**  Part Number that the customer uses to identify the Part.  */  
   XPartNum:string,
      /**  Customers Part Revision Number.  */  
   XRevisionNum:string,
      /**  Description Customer uses to describes the Part.  */  
   PartDescription:string,
      /**  Recid of this record in the source database.  This is necessary because this table does not have a unique index that can be used to find the record in another database.  */  
   SourceDBRecid:string,
      /**  The part number used to identify the configured part number initially entered on the line.  */  
   BasePartNum:string,
      /**  The revision number used to identify the configured part/revision number initially entered on the line.  */  
   BaseRevisionNum:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  If the SNBaseDataType is Mask this is the Serial Mask ID assigned for format validation/generation.  */  
   SNMask:string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   SNMaskExample:string,
      /**  A standard suffix that will be attached to all serial numbers generated for the PartSite currently used only by SNBaseStructure Mask types  */  
   SNMaskSuffix:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types  */  
   SNMaskPrefix:string,
      /**  This is the last used serial sequence. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It can be altered by the user and several PartSites can have the same counter values defined, but  */  
   SNLastUsedSeq:string,
      /**  Override serial mask settings? SN fields are ignored unless this is true.  */  
   SNOverride:boolean,
      /**  Marks this CustXPrt as global, available to be sent out to other companies.  */  
   GlobalCustXPrt:boolean,
      /**  Disables this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  WIApplication  */  
   WIApplication:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  EDIContainerType  */  
   EDIContainerType:string,
      /**  ProductionPartNum  */  
   ProductionPartNum:string,
      /**  ProductionPartNumIsValid  */  
   ProductionPartNumIsValid:boolean,
      /**  ServicePartNum  */  
   ServicePartNum:string,
      /**  ServicePartNumIsValid  */  
   ServicePartNumIsValid:boolean,
      /**  Prefix + Example + Suffix  */  
   SNPrefixExampleSuffix:string,
      /**  SuffixLength  */  
   SuffixLength:number,
      /**  PrefixLength  */  
   PrefixLength:number,
   BitFlag:number,
   CustNumName:string,
   CustNumBTName:string,
   CustNumCustID:string,
   PartSalesUM:string,
   PartIUM:string,
   PartPartDescription:string,
   PartSellingFactor:number,
   PartTrackLots:boolean,
   PartTrackDimension:boolean,
   PartPricePerCode:string,
   PartTrackSerialNum:boolean,
   SerialMaskDescription:string,
   SerialMaskMaskType:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_CustomerRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A user defined external customer ID.  This must be unique within the file.  This ID may be used in certain screen displays or reports where a full customer name is inappropriate. Therefore users should use meaningful characters as they would in any other master file. This master file key is a little different in that the user can change. This change is allowed because the system is not using the CustID as a foreign key in any other file.  Rather it uses the CustNum field which is assigned to the customer by the system.  */  
   CustID:string,
      /**  A  unique integer assigned by the system to new customers by the customer maintenance program.  This field is used as the foreign key to identify the customer in other files such as OrderHed or InvcHead.  The end user should never see this field in the application but can use it for reporting purposes.  */  
   CustNum:number,
      /**  The full name of the customer.  */  
   Name:string,
      /**  The first line of the customer's main address.  */  
   Address1:string,
      /**  The second line of the customer's main address.  */  
   Address2:string,
      /**  The third line of the customer's main address.  */  
   Address3:string,
      /**  The city portion of the customer's main address.  */  
   City:string,
      /**  The state or province portion of the customer's main address.  */  
   State:string,
      /**  The zip or postal code portion of the customer's main address.  */  
   Zip:string,
      /**  The country of the main customer address.  */  
   Country:string,
      /**  Optional field used to record the customer's State Tax Identification number, which is displayed on Sales Acknowledgments.  */  
   ResaleID:string,
      /**  The SalesRep.SalesRepCode of the default salesperson for the customer. This field is used to supply defaults to Order Entry and Invoice entry for invoices that do not reference a sales orders.  */  
   SalesRepCode:string,
      /**  The SalesTer.TerritoryID value of the territory assigned to the customer.  */  
   TerritoryID:string,
      /**  Contains the key of the default ship to for the customer. A blank value indicates that the name and address in the Customer file is considered the default ship to. This field is updated when the user marks the check box in ship to maintenance indicating that the ship to is to be designated as the default. This default will be used in areas such as Sales Order entry.  */  
   ShipToNum:string,
      /**   The Terms.TermsCode value of the default sales terms associated with the customer. A default may be supplied by XaSyst.TermsCode if not blank. The terms will default into quotes and orders for this customer.
For invoices not related to a sales order, these terms will also default into the invoice.  */  
   TermsCode:string,
      /**  Contains the ShipVia.ShipViaCode value of the default ShipVia for the customer.  */  
   ShipViaCode:string,
      /**  Controls whether or not this customer's statement will print when   printing of customer statements.  */  
   PrintStatements:boolean,
      /**  Only customers that are PrintLabels = Yes will be selected for printing of mailing labels.  */  
   PrintLabels:boolean,
      /**   Allows the user to establish whether or not a specific customer requires Sales Order Acknowledgements.  This does not force or limit the printing of sales acknowledgments directly from within Order Entry.  Order entry displays this setting to the user so that they know if they should print the acknowledgment.
For batch mode printing, (where ranges of sales orders are selected...future release) this setting will be used to exclude orders from printing.  */  
   PrintAck:boolean,
      /**  Controls whether or not the customer will be included in the finance charge calculation process.  */  
   FinCharges:boolean,
      /**  Indicates if customer has been placed into a "Credit Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   CreditHold:boolean,
      /**  Contains the CustGrup.GroupCode value of the customer group that the customer has been assigned to. This field is used by the application for sorting or filtering on reports and can also be associated with price lists.  */  
   GroupCode:string,
      /**  An optional field used to establish a default purchasing discount percentage for any order placed by customer. This value is supplied to order entry as a default for line item discount percent.  */  
   DiscountPercent:number,
      /**  Contains the CustCnt.ConNum value of the Primary Purchasing contact for the customer. This field is not directly maintainable. Instead it is set during contact maintenance by having the user mark a check box indicating primary Purchaser.  This is the contact that is used as a default in Order Entry and Quoting.  */  
   PrimPCon:number,
      /**  The same as the PrimPCon except that this is the Primary Billing Contact and this is used as a default in invoice entry.  */  
   PrimBCon:number,
      /**  Same as PrimPCon except that this the Primary Shipping Contact and is used as a default in Packing Slip entry.  */  
   PrimSCon:number,
      /**   Comments are intended to be internal comments about a specific customer. These do get pulled into other programs. They are mainly intended as an online storage facility.
To be view-as EDITOR widget.  */  
   Comment:string,
      /**  The date when the customer was established as a customer. Use the system date as a default when creating new customers.  */  
   EstDate:string,
      /**  The Fax Number for the customer. Optional field. Field is displayed in Order entry when no contact is specifically given or the contact has a blank fax number.  */  
   FaxNum:string,
      /**  The general Business Phone Number for the customer. Displayed in Order entry when no contact is given or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Indicates the reason why the customer is normally exempt from sales tax. Used as a default in invoice entry.  If field is non-blank it is considered exempt.  */  
   TaxExempt:string,
      /**  The QMarkup.MarkupID value of the quote markup table which will be used to provide default markup percents in quote entry for this customer. If left blank the quote module will use the default quote markup table for the customer. (See EQSyst.MarkupID).  */  
   MarkUpID:string,
      /**   Represents the day of the week or month that this customer is invoiced on. The possible choices are determined by the Customer.Bill-Frequency field value.

When the Bill-Frequency is "W" (Weeky):
The valid values are 0-7 where 0=All Days,1=Sun,2=Mon,...,7=Sat.  

ll-frequency is 'M' (Monthly) this field contains the 1st -> 31st as possible choices to represent the day of the month to bill on.  */  
   BillDay:number,
      /**  Determines whether or not packing slips for the same Sales Order and Fiscal Period will combined into a single invoice or not. If the packing slips are for different sales orders for the customer or fall in different fiscal periods, seperate invoices will be created even when this field is set to Yes.  */  
   OneInvPerPS:boolean,
      /**  Contains the default FOB.FOB value of the FOB policy for this  customers orders.  Default used in sales order entry for this customer.  */  
   DefaultFOB:string,
      /**  Determines whether or not Open Sales Orders are to be included in the credit limit checking process for the customer. This checkbox will also include open service contracts.  */  
   CreditIncludeOrders:boolean,
      /**  Date on which the next credit review should be conducted for the customer.  */  
   CreditReviewDate:string,
      /**  Date on which the customer was last placed on credit hold. This field is maintained by the system.  */  
   CreditHoldDate:string,
      /**  Indicates how the customer was placed on credit hold.  Valid values are "MANUAL", "INVOICES", "ORDERS", and "CONTRACTS".  "MANUAL" means that the user placed the customer on hold.  INVOICES means that the customer's open A/R balance exceeded the credit limit.  ORDERS means that the sum of the open A/R and the open orders exceeded the credit limit. This field is maintained by the system.  */  
   CreditHoldSource:string,
      /**  The UserFile.DCDUSERID value of the user that last cleared the customer's credit hold. This field is maintained by the system.  */  
   CreditClearUserID:string,
      /**  The date that the user last cleared the customer's credit hold. This field is maintained by the system.  */  
   CreditClearDate:string,
      /**  The time that the user last cleared the customer's credit hold in HH:MM:SS format. This field is maintained by the system.  */  
   CreditClearTime:string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  Contains the Currency.CurrencyCode value of the customer's base currency.  */  
   CurrencyCode:string,
      /**  Contains the Country.CountryNum value of the country the customer is located in.  */  
   CountryNum:number,
      /**  Contains the LangName.LangNameID value of the customer's language. This controls which language will be selected when extracting part descriptions from PartLangDesc table and report labels for customer related forms such as orders, packing slips and invoices.  */  
   LangNameID:string,
      /**  Area/City code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Country table.  This field is only visible if ISSyst.EnableHarbour is set to yes.  */  
   BorderCrossing:string,
      /**  Optional custom address format used to format the customer's main address.  */  
   FormatStr:string,
      /**  The Bill To name of this customer. Will be used by the AR module for Invoices. This defaults to the Customer.Name but can be overrode by the user.  */  
   BTName:string,
      /**  The first line of the customer's Bill To address.  */  
   BTAddress1:string,
      /**  The second line of the customer's Bill To address.  */  
   BTAddress2:string,
      /**  The second line of the customer's Bill To address.  */  
   BTAddress3:string,
      /**  The city portion of the customer's Bill To address.  */  
   BTCity:string,
      /**  The state or province portion of the customer's Bill To address.  */  
   BTState:string,
      /**  The zip or postal code portion of the customer's Bill To address.  */  
   BTZip:string,
      /**  The Country.Countrynum value of the Country portion of the customer's Bill To address.  */  
   BTCountryNum:number,
      /**  Contains the Country.Description value of the Country portion of the customer's Bill To address.  */  
   BTCountry:string,
      /**  The phone number related to the customer's Bill To Address.  */  
   BTPhoneNum:string,
      /**  The fax number of the customer's Bill To address.  */  
   BTFaxNum:string,
      /**  Optional custom address format used to format the customer's Bill To address.  */  
   BTFormatStr:string,
      /**  The Customer.CustNum value of the customer's parent company.  */  
   ParentCustNum:number,
      /**  Contains the TaxRgn.TaxRegionCode value of the customer's tax region for purposes of Sales Tax calculations.  */  
   TaxRegionCode:string,
      /**  Determines whether or not this customer is an inter-company customer.  */  
   ICCust:boolean,
      /**  The day of the month that service contracts for the customer marked for recurring invoicing are billed on.  If the invoice group's invoice date is greater than or equal to this date then the invoice will be generated.  */  
   ContBillDay:number,
      /**  Default email address for the customer.  */  
   EMailAddress:string,
      /**  Determines whether or not the customer will accept partial shipments at the line or order level. This functionality is only available with the Advanced Material Management module.  */  
   ShippingQualifier:string,
      /**  Contains the AllocPri.PriorityCode value of the priority that this customer's orders receive. This functionality is only available with the Advanced Material Management module.  */  
   AllocPriorityCode:string,
      /**  Contains the ReservePri.PriorityCode value of the priority that this customer's orders receive. This functionality is only available with the Advanced Material Management module.  */  
   ReservePriorityCode:string,
      /**  Used with Global alerts  */  
   LinkPortNum:number,
      /**  Indicates if this customer will be able to access Customer Connect.  Only Customers with this equal to YES will be synchronized between the Manufacturing System DB and Customer Connect DB.  */  
   WebCustomer:boolean,
      /**  Used to define the type of the customer record.  */  
   CustomerType:string,
      /**  Indicates whether or not this customer will be included in marketing lists.  */  
   NoContact:boolean,
      /**  Determines whether or not the customer's territory can be changed by system processes that could potentially change the territory from its current value.  */  
   TerritoryLock:boolean,
      /**  The Customer's website URL.  */  
   CustURL:string,
      /**  The pending sales territory that the customer will be assigned to based on changes to the territory boundaries.  This functionality is only available with the CRM module.  */  
   PendingTerritoryID:string,
      /**  External Company  ID  */  
   ExtID:string,
      /**  Determines whether or not shipments to this customer for different sales orders within the same fiscal period wil be consolidated into one invoice. (See Customer.OneInvPerPS - for the shipments from the same sales order are handled).  */  
   ConsolidateSO:boolean,
      /**  BillFrequency  */  
   BillFrequency:string,
      /**  Indicates that Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking.  */  
   CreditIncludePI:boolean,
      /**  Determines whether or not this customer is shared between more than one company.  */  
   GlobalCust:boolean,
      /**  Indicates if this customer participates in the Inter-Company Trading.  */  
   ICTrader:boolean,
      /**  Establishes the tax authority for this customer.  */  
   TaxAuthorityCode:string,
      /**  Determines whether or not an external delivery note is required for the customer.  This field is available only when ExtCompany.SendShip is set to Yes.  This will provide the default for the ShipHead record.  */  
   ExternalDeliveryNote:boolean,
      /**  Determines whether or not Open Orders are to be included in the global credit limit checking process. This checkbox will also include open service contracts.  */  
   GlobalCredIncOrd:boolean,
      /**  Indicates whether or not Payment Instruments (bank drafts, post dated checks) are to be included in the credit limit checking process.  */  
   GlobalCredIncPI:boolean,
      /**  Holds the Currency.CurrencyCode value of that the global customer will exchange data in.  */  
   GlobalCurrencyCode:string,
      /**  Customer ID  */  
   ExternalID:string,
      /**  Determines whether or not the customer has been placed into a "Global Credit Hold" status.  Any non-blank value will trigger notification of this condition in Order Entry and Shipping.  */  
   GlobalCreditHold:string,
      /**  Determines whether or not this customer record will receive global updates.  */  
   GlobalLock:boolean,
      /**  Determines whether or not the system should check existing orders for this customer to insure that the same PO number is not used twice by the customer.  */  
   CheckDuplicatePO:boolean,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit.  A credit limit of zero is considered as having unlimited credit.  */  
   CreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a credit limit for payment instruments such as post dated checks or bank drafts.  A credit limit of zero is considered as having unlimited credit.  */  
   CustPILimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit Limit.  A credit limit of zero is considered as having unlimited credit.  */  
   GlobalCreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a credit limit for payment instruments such as post dated checks or bank drafts.  A credit limit of zero is considered as having unlimited credit.  */  
   GlobalPILimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Global Credit limit.  Credit limit of zero is considered as having unlimited credit. Stored in Global Currency.  */  
   DocGlobalCreditLimit:number,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit. Stored in Global currency  */  
   DocGlobalPILimit:number,
      /**  Indicates whether RFQ Attachments are allowed for this Customer  */  
   RfqAttachAllow:boolean,
      /**   The discount qualifier is primarily used when applying order value based discounts to the customer's sales orders.  The value of this field affects the discount percent given to the customer.  Here's the rule:
"MIN" = means that the default order discount percent is the minimum discount the customer could get as compared to the order value based discount.
"MAX" = means that the default order discount percent is the maximum discount the customer could get as compared to the order value based discount.
"ADD" = means that the customer could get the order value based discount in addition to the default order discount.  */  
   DiscountQualifier:string,
      /**  Specifies the current customer can be an alternate bill to customer.  */  
   AllowAltBillTo:boolean,
      /**  Days to use in calculating the Order Detail Ship By date from the incoming need by date.  */  
   DemandDeliveryDays:number,
      /**   Indicates incoming date type.  Values are:
S - Shipping Date
N - Need By Date  */  
   DemandDateType:string,
      /**  The number of days from today to give a warning when adding a new order release record from an incoming shipping schedule.  */  
   DemandAddLeadTime:number,
      /**  Indicates what type of action to take if the add lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandAddAction:string,
      /**  The number of days from today to give a warning when changing an order release record from an incoming shipping schedule.  This does not include changes to quantity or dates.  */  
   DemandChangeLeadTime:number,
      /**  Indicates what type of action to take if the change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeAction:string,
      /**  The number of days from today to give a warning when canceling an order release record from an incoming shipping schedule.  */  
   DemandCancelLeadTime:number,
      /**  Indicates what type of action to take if the cancel lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandCancelAction:string,
      /**  The number of days from today to give a warning when adding a new order line record from an incoming shipping schedule.  */  
   DemandNewLineLeadTime:number,
      /**  Indicates what type of action to take if the new line lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandNewLineAction:string,
      /**  The number of days from today to give a warning when changing the quantity on an order release record from an incoming shipping schedule.  */  
   DemandQtyChangeLeadTime:number,
      /**  Indicates what type of action to take if the quantity change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandQtyChangeAction:string,
      /**  The number of days from today to give a warning when changing the date on an order release record from an incoming shipping schedule.  */  
   DemandChangeDateLeadTime:number,
      /**  Indicates what type of action to take if the change date lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeDateAction:string,
      /**  The trading partner name.  */  
   TradingPartnerName:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  Periodicity Code.  Must be a valid code in the Periodicity table.  */  
   PeriodicityCode:number,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Used to calculate on-time delivery performance rating  */  
   EarlyBuffer:number,
      /**  Used to calculate on-time delivery performance rating  */  
   LateBuffer:number,
      /**  Indicates if the unit price between the demand and the contract should be validated.  If this flag is checked, and the prices are different, when the demand is accepted a record will be written to the DemandLog table.  */  
   DemandUnitPriceDiff:boolean,
      /**  Indicates what type of action to take if the unit price between the demand and the contract is different.  Options are B (reject the change) or W (warning - alert that the unit price is different but allow the record to be accepted).  */  
   DemandUnitPriceDiffAction:string,
      /**  A flag that indicates whether this address should be validated by the tax service.  */  
   ExcFromVal:boolean,
      /**  A flag indicating that an address has already been validated. This helps improve the performance of the bulk address validation process by allowing address that have already been validated to be skipped. This flag is set anytime a successful validation is performed, either by the bulk address validation or validation from the Customer form.  */  
   AddressVal:boolean,
      /**  This is the Vendor ID to be used when generating a Rebate for the customer  */  
   RebateVendorNum:number,
      /**  Indicates if the rebate should be a Check or a Credit Memo  */  
   RebateForm:string,
      /**  Indicates if the order should default as a credit card order.  Can be overriden at the order level.  */  
   CreditCardOrder:boolean,
      /**  Check for the part in the Part master.  */  
   DemandCheckForPart:boolean,
      /**  Indicates what type of action to take if the Check for Part options is selected and the part is not in the part master file.  Options are B (reject the change) or W (warning - alert that the part is not in the part master but allow the record to be accepted).  */  
   DemandCheckForPartAction:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Unique Identifier for the Finance Charges  */  
   ChargeCode:string,
      /**  Individual Pack ID'srequired. Used in manifesting.  */  
   IndividualPackIDs:boolean,
      /**  International Shipment flag. Used in manifesting.  */  
   IntrntlShip:boolean,
      /**  Certificates of Origin required flag. Used in manifesting.  */  
   CertOfOrigin:boolean,
      /**  Commercial Invoice required flag. Used in manifesting.  */  
   CommercialInvoice:boolean,
      /**  Ship Export Declaration required flag. Used in manifesting.  */  
   ShipExprtDeclartn:boolean,
      /**  Letter of Instruction required. Used in manifesting.  */  
   LetterOfInstr:boolean,
      /**  Freight Forwarder ID.  */  
   FFID:string,
      /**  Freight Forwarder Company Name  */  
   FFCompName:string,
      /**  Freight Forwarder first address line.  */  
   FFAddress1:string,
      /**  Freight Forwarder second address line.  */  
   FFAddress2:string,
      /**  Freight Forwarder third address line.  */  
   FFAddress3:string,
      /**  Freight Forwarder city portion of address.  */  
   FFCity:string,
      /**  Freight Forwarder state portion of address.  */  
   FFState:string,
      /**  Freight Forwarder postal code or zip code portion of address.  */  
   FFZip:string,
      /**  Freight Forwarder country portion of address.  */  
   FFCountry:string,
      /**  Freight Forwarder country number portion of address.  */  
   FFCountryNum:number,
      /**  Freight Forwarder phone Number.  */  
   FFPhoneNum:string,
      /**  Non Standard Package flag. Used in manifesting.  */  
   NonStdPkg:boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Additional Handling flag. Used in manifesting.  */  
   AddlHdlgFlag:boolean,
      /**  UPS Quantum View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View From Name  */  
   UPSQVShipFromName:string,
      /**  UPS Quantum View Memo  */  
   UPSQVMemo:string,
      /**  Always equal to Customer.  Used to link the customer table to the UPSQVEmail table.  */  
   UPSQVEmailType:string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   FFContact:string,
      /**  Used to determine if an address changed because of the tax integration.  If true, the tax integration changed the address.  */  
   ETCAddrChg:boolean,
      /**  Define the rule how Tax amount from for sales related documents shall be rounded to the general number of decimals from the Currency:  0 - Use rounding rules from Currency; 1 - Round up; 2 - Round down; 3 - Normal rounding.  Used when Company parameter - Customer specific Tax Rounding is set.  */  
   TaxRoundRule:number,
      /**  Tax calculation per line or invoice.  It can be "L" = per line or "I" = per invoice.  Default is "L".  */  
   TaxMethod:string,
      /**  Remit cash receipts in AR. No cash receipts will be accepted from customers without this authorization  */  
   ValidPayer:boolean,
      /**  Sold to customer in the AR Invoice Entry. The user will not be able to enter invoices for customers without this authorization  */  
   ValidSoldTo:boolean,
      /**  Receive shipments for orders entered in OE. Unless the user selects this option, the user must enter a Ship-to address in the Order Entry form.  */  
   ValidShipTo:boolean,
      /**  Children are allowed to pay for their parents  */  
   OverrideRlsClass:boolean,
      /**  Accept payments from any customer within the national account, regardless of parent-child status  */  
   AcrossNatAcc:boolean,
      /**  allow use Parent Credit in National Account  */  
   NAParentCreditIsUsed:boolean,
      /**  allow/deny to a customer share his own credit with other customers within the National account  */  
   NACreditIsShare:boolean,
      /**  define what type of credit will be used first when the customer  */  
   NACreditPreferenceList:string,
      /**  Max Percent of Parent Credit to Use  */  
   NAParentCreditPrc:number,
      /**  Percentage of the customer credit shared to his Children.  */  
   NACreditSharedPrc:number,
      /**  Indicates if One Time Shipto information can be entered for this customer.  OTS, are entered in Quote, Sales Order, RMA, Service Contract and Service Call. In Shipping and Invoicing the OTS infomation is used.  */  
   AllowOTS:boolean,
      /**  Flag indicating that this is a 3PL customer.  */  
   ThirdPLCust:boolean,
      /**  VendID of the associated supplier.  Only populated if ManagedCust flag = true.  Entered through Supplier Entry  */  
   ManagedVendID:string,
      /**  VendNum associated with VendID of associated supplier.  Only populated if ManagedCust flag = true.  */  
   ManagedVendNum:number,
      /**  Code of Overriden Relationship Class  */  
   NARlsClassCode:string,
      /**  Direct Debiting flag for use with Promissory Notes.  */  
   DirectDebiting:boolean,
      /**  Unique Identifier for the Reminder Group.  */  
   ReminderCode:string,
      /**  allow use Global Parent Credit in National Account  */  
   GlbNAParentCreditIsUsed:boolean,
      /**  allow/deny to a customer share his own credit with other customers within the Global National account  */  
   GlbNACreditIsShare:boolean,
      /**  Max Percent of Global Parent Credit to Use  */  
   GlbNAParentCreditPrc:number,
      /**  Percentage of the customer credit shared to his Global Children.  */  
   GlbNACreditSharedPrc:number,
      /**  When yes, a ShipTo CustID on certain forms will be enabled. This allows a shipto of a different customer to be referenced as a 3rd party for a document.  */  
   AllowShipTo3:boolean,
      /**  The default value used on One Time Ship To panels. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   OTSSaveAs:string,
      /**   Determines print options for any customer parts related to this customer.

M = Main Part Reference (Default)
S = Secondary Part Reference
O = Only Part Reference Printed
N = Customer Part Not Printed  */  
   CustPartOpts:string,
      /**  If yes, indicates that Customer has at least one associated CustBank record.  */  
   HasBank:boolean,
      /**  Unique identifier of the payment method  */  
   PMUID:number,
      /**  Check for Revision  */  
   DemandCheckForRev:boolean,
      /**  Hold for Review  */  
   OrderHoldForReview:boolean,
      /**  Check for Revision Action  */  
   DemandCheckForRevAction:string,
      /**  List of all ship to territories for the customer  */  
   ShipToTerrList:string,
      /**  The Banking Reference number to be used on AR Invoice sent to the customer  */  
   AcctRefNumber:string,
      /**  Full Legal name  */  
   LegalName:string,
      /**  Tax Payer Registration Reason Code  */  
   TaxRegReason:string,
      /**  If this flag it?s turned on then one invoice per packing line will be created when invoicing a packing slip at the ?Get Shipments? action on the AR Invoice entry.  */  
   InvPerPackLine:boolean,
      /**  Organization Registration Code  */  
   OrgRegCode:string,
      /**  Define if at the moment of processing a demand the process should also close those rejected schedules that remain at demand entry  */  
   DemandCloseRejSkd:boolean,
      /**  Our Bank Code  */  
   OurBankCode:string,
      /**  Flag that indicates if the Demand non matched will be closed.  */  
   DemandCloseNoMatch:boolean,
      /**  Flag to Check Partial Shipments  */  
   DmdCheckPartialShip:boolean,
      /**  Flag to Check Partial Shipments Action B = Stop W = Warning  */  
   DmdCheckShipAction:string,
      /**  Flag to check for cummulative info.  */  
   DemandCheckCUMM:boolean,
      /**  Flag to Check what action should the system take the options are B = Stop and  W Warning  */  
   DemandCheckCUMMAction:string,
      /**  Defines if Internal Pricing or Customer Pricing will be used for checking price differences  */  
   DemandPricing:string,
      /**  Defines the tolerance for price difference validations  */  
   PriceTolerance:number,
      /**  Preferred bank for cash receipts from sale to customer.  */  
   PreferredBank:string,
      /**  If this flags is turned on then Demand CTP will automatically be executed as a part of the demand to order process.  */  
   CheckDateCapPromise:boolean,
      /**  Confirm or not the Capable to Promise jobs from Demand Entry  */  
   CheckConfirmCapPromise:boolean,
      /**  If checked, Updates the date in Demand Entry  */  
   CheckUpdateCapPromise:boolean,
      /**  This field will define the dates that will be validated as a part of the demand to order process. The valid values for this combo will be:  Need By (N), Ship By (S) and Both (B)  */  
   DemandCapPromiseDate:string,
      /**  The value on this field will define the action to be taken when validating CTP. The valid values for this combo box will be: Warning (W) and Stop (S)  */  
   DemandCapPromiseAction:string,
      /**   This field will define the dates that will be updated as a part of the demand to order process. The valid options will be:
Need By (N), Ship By (S) and Both  (B) NOTE .-In all the cases above the update of date will only be done if the CTP dates are beyond the dates on the file.  */  
   DemandCapPromiseUpdate:string,
      /**  Status of the Periodic Billing  */  
   PeriodicBilling:boolean,
      /**  Criteria used for the calculation of the due date. Only enable if Periodic Billing status is active.  */  
   DueDateCriteria:string,
      /**  Periodic Billing Terms. A period between the billing or summarizing date and the due date (for example: 30 days, 45 days, 60 days).  */  
   PBTerms:number,
      /**  Evaluated Receipt Settlement Order. This flag will be used as a default when the user creates a Demand Entry PO or a Sales Order  */  
   ERSOrder:boolean,
      /**  This checkbox indicates if the Demand schedule could be splited when there are not enough stock for a part, from the CTP.  */  
   DemandSplitSched:boolean,
      /**  When set to TRUE the smart string functionality will only be processed when the incoming demand is new. After it has been processed and saved, if a retransmission is sent the smart string values will be ignored.  */  
   OTSmartString:boolean,
      /**  Indicates if revenue is deferred for contracts assigned to this group.  */  
   DeferredRev:boolean,
      /**  Revenue Amortization Code.  */  
   RACode:string,
      /**  If true then demand will be rejected when one or more demand lines are not configured properly. Applies only to Configurable parts.  */  
   DemandCheckConfig:boolean,
      /**  Indicates the action to be taken if configuration values have not been entered for one or more demand lines.  */  
   DemandCheckCfgAction:string,
      /**  AllowAsAltRemitTo  */  
   AllowAsAltRemitTo:boolean,
      /**  FederalID  */  
   FederalID:string,
      /**  WIApplication  */  
   WIApplication:string,
      /**  WICustomer  */  
   WICustomer:string,
      /**  WIShippingCosts  */  
   WIShippingCosts:boolean,
      /**  LOQBookPCFinishing  */  
   LOQBookPCFinishing:boolean,
      /**  LOQBookPCPaper  */  
   LOQBookPCPaper:boolean,
      /**  LOQBookPCPress  */  
   LOQBookPCPress:boolean,
      /**  LOQBookPCPlates  */  
   LOQBookPCPlates:boolean,
      /**  Variations  */  
   Variations:boolean,
      /**  OversPct  */  
   OversPct:number,
      /**  UndersPct  */  
   UndersPct:number,
      /**  DefaultLOQstyle  */  
   DefaultLOQstyle:string,
      /**  DefaultOrderAcknowledgement  */  
   DefaultOrderAcknowledgement:string,
      /**  DefaultPackSlip  */  
   DefaultPackSlip:string,
      /**  DefaultOversPricing  */  
   DefaultOversPricing:string,
      /**  LOQPrepressStyle  */  
   LOQPrepressStyle:string,
      /**  CSR  */  
   CSR:string,
      /**  LOQBookCaFinishing  */  
   LOQBookCaFinishing:boolean,
      /**  LOQBookCapaper  */  
   LOQBookCapaper:boolean,
      /**  LOQBookCaPress  */  
   LOQBookCaPress:boolean,
      /**  LOQBookCatPlates  */  
   LOQBookCatPlates:boolean,
      /**  LOQVariations  */  
   LOQVariations:boolean,
      /**  DefaultInvoicestyle  */  
   DefaultInvoicestyle:string,
      /**  AEPLOQType  */  
   AEPLOQType:string,
      /**  BusinessCust  */  
   BusinessCust:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  THBranchID  */  
   THBranchID:string,
      /**  CustPricingSchema  */  
   CustPricingSchema:string,
      /**  ParamCode  */  
   ParamCode:string,
      /**  AGAFIPResponsibilityCode  */  
   AGAFIPResponsibilityCode:string,
      /**  AGBillToProvinceCode  */  
   AGBillToProvinceCode:string,
      /**  AGGrossIncomeTaxID  */  
   AGGrossIncomeTaxID:string,
      /**  AGIDDocTypeCode  */  
   AGIDDocTypeCode:string,
      /**  AGIDDocumentNumber  */  
   AGIDDocumentNumber:string,
      /**  AGProvinceCode  */  
   AGProvinceCode:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  In Collections  */  
   Collections:boolean,
      /**  CollectionsDate  */  
   CollectionsDate:string,
      /**  Date Collection Posted  */  
   DateCollectionPosted:string,
      /**  MXMunicipio  */  
   MXMunicipio:string,
      /**  Displays list of Peru Identity Types.  */  
   PEIdentityDocType:string,
      /**  Peru Document ID.  */  
   PEDocumentID:string,
      /**  Peru Goods Contributor withholding status.  */  
   PEGoodsContributor:boolean,
      /**  Peru Withholding Agent status.  */  
   PEWithholdAgent:boolean,
      /**  Peru Collection Agent withholding status.  */  
   PECollectionAgent:boolean,
      /**  Peru Not Found withholding status.  */  
   PENotFound:boolean,
      /**  Peru No Address Provided withholding status.  */  
   PENoAddress:boolean,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  InvcOrderCmpDflt  */  
   InvcOrderCmpDflt:boolean,
      /**  EInvoice  */  
   EInvoice:boolean,
      /**  RegistrationCode  */  
   RegistrationCode:string,
      /**  EAddress  */  
   EAddress:string,
      /**  Check if the part is a run out part.  */  
   DemandCheckForRunOutPart:boolean,
      /**  Indicates what type of action to take if the Check for Run Out Part option is selected and the part is marked as a run out part.  Options are B (reject the change) or W (warning - alert that the part is marked as run out but allow the record to be accepted).  */  
   DemandCheckForRunOutPartAction:string,
      /**  E-Invoice CompanyID Attribute  */  
   EInvCompanyIDAttr:string,
      /**  INCSTNumber  */  
   INCSTNumber:string,
      /**  INPANNumber  */  
   INPANNumber:string,
      /**  Colombia Loc Field. OneTimeCustVend new table ID  */  
   COOneTimeID:string,
      /**  Colombia Loc Field.  */  
   COIsOneTimeCust:boolean,
      /**  DEOrgType  */  
   DEOrgType:string,
      /**  PEGuaranteeName  */  
   PEGuaranteeName:string,
      /**  PEGuaranteeAddress1  */  
   PEGuaranteeAddress1:string,
      /**  PEGuaranteeAddress2  */  
   PEGuaranteeAddress2:string,
      /**  PEGuaranteeAddress3  */  
   PEGuaranteeAddress3:string,
      /**  PEGuaranteeCity  */  
   PEGuaranteeCity:string,
      /**  PEGuaranteeState  */  
   PEGuaranteeState:string,
      /**  PEGuaranteeZip  */  
   PEGuaranteeZip:string,
      /**  PEGuaranteeCountry  */  
   PEGuaranteeCountry:string,
      /**  PEGuaranteePhoneNum  */  
   PEGuaranteePhoneNum:string,
      /**  PEGuaranteeTaxID  */  
   PEGuaranteeTaxID:string,
      /**  Our Supplier Code  */  
   OurSupplierCode:string,
      /**  Type of customer created by ECC.  Valid values are: B=B2b, C=B2C  */  
   ECCType:string,
      /**  MYIndustryCode  */  
   MYIndustryCode:string,
      /**  This field defines if the customer is synchronized to an External CRM. Only enabled if the External CRM integration is on at the Company configuration.  */  
   SyncToExternalCRM:boolean,
      /**  This field holds the id of this customer in the External CRM  */  
   ExternalCRMCustomerID:string,
      /**  This fields holds the customer type of this customer in the External CRM.  */  
   ExternalCRMCustomerType:string,
      /**  This field defines the last time that the  Customer  has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   ExternalCRMLastSync:string,
      /**  This fields determines if the customer needs to be synchronized to the External CRM. If there are changes in the customer master file , Epicor ERP automatically turns on this field.  */  
   ExternalCRMSyncRequired:boolean,
      /**  Ownership of the customer  */  
   Ownership:string,
      /**  Industry of the customer  */  
   Industry:string,
      /**  Annual revenue of the customer  */  
   AnnualRevenue:number,
      /**  Number of employees of the customer  */  
   NumberOfEmployees:number,
      /**  Location of the ticker of this customer  */  
   TickerLocation:string,
      /**  Ticker for the customer  */  
   TickerSymbol:string,
      /**  Rating for the customer  */  
   Rating:string,
      /**  TW GUI Code  */  
   TWGUIRegNum:string,
      /**  MXAccountNumber  */  
   MXAccountNumber:string,
      /**  Indicates that the shipment lines will be consolidated within the invoice for the same part, the same order, and the same packing slip.  */  
   ConsolidateLinesPerPart:boolean,
      /**  TWTaxPayerType  */  
   TWTaxPayerType:number,
      /**  TWDeductGUIFormatCode  */  
   TWDeductGUIFormatCode:string,
      /**  MXCURP  */  
   MXCURP:string,
      /**  PEAddressID  */  
   PEAddressID:string,
      /**  PEPerceptionRegime  */  
   PEPerceptionRegime:string,
      /**  TaxEntityType  */  
   TaxEntityType:string,
      /**  GST Compliance Rate field for India  */  
   INGSTComplianceRate:number,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  MXPurchaseType  */  
   MXPurchaseType:string,
      /**  Determines if the customer has to be synchronized with Epicor FSA application.  */  
   SendToFSA:boolean,
      /**  MXGeneralPublic  */  
   MXGeneralPublic:boolean,
      /**  Indicates if customer has been placed into an "Aging Hold" status. A "yes" will trigger notification of this condition in Order Entry and Shipping.  */  
   AgingCreditHold:boolean,
      /**  Date on which the customer was last placed on aging hold. This field is maintained by the system.  */  
   AgingCreditHoldDate:string,
      /**  Indicates how the customer was placed on aging hold.  Valid values are "MANUAL" and "PROCESS".  "MANUAL" means that the user placed the customer on hold.  PROCESS means that the Mass Credit Information Update Process places the customer on aging hold.  This field is maintained by the system.  */  
   AgingCreditHoldSource:string,
      /**  The UserFile.DCDUSERID value of the user that last cleared the customer's aging hold. This field is maintained by the system.  */  
   AgingCreditClearUserID:string,
      /**  The date that the user last cleared the customer's aging hold. This field is maintained by the system.  */  
   AgingCreditClearDate:string,
      /**  The aging code assigned to the customer.  */  
   AgingCreditCode:string,
      /**  Indicates whether this customer is importer of records or not. Used for Avalara Tax Connect calculation.  */  
   ImporterOfRecord:boolean,
      /**  Standard Entry Class Code  */  
   SEC:string,
      /**  E-Invoice EndpointID Attribute  */  
   EInvEndpointIDAttr:string,
      /**  Indicates whether sales orders from this sold to customer should be treated as Blind Shipments by Manifest.  */  
   UseBlindShipping:boolean,
      /**  ELIEinvoice  */  
   ELIEinvoice:boolean,
      /**  ELIDefReportID  */  
   ELIDefReportID:string,
      /**  ELIDefStyleNum  */  
   ELIDefStyleNum:number,
      /**  ELIDefToMail  */  
   ELIDefToMail:string,
      /**  ELIDefCCMail  */  
   ELIDefCCMail:string,
      /**  ELIDefMailTempID  */  
   ELIDefMailTempID:string,
      /**  ELISendMail  */  
   ELISendMail:boolean,
      /**  COFiscalResp1  */  
   COFiscalResp1:string,
      /**  COFiscalResp2  */  
   COFiscalResp2:string,
      /**  COFiscalResp3  */  
   COFiscalResp3:string,
      /**  COOperType  */  
   COOperType:string,
      /**  Flag that indicates if the Customer is for Central Collection.  */  
   CentralCollection:boolean,
      /**  NettingVendorNum  */  
   NettingVendorNum:number,
      /**  EORI Number  */  
   EORINumber:string,
      /**  AGIsElectronicCreditInvEligible  */  
   AGIsElectronicCreditInvEligible:boolean,
      /**  Tax ID Validation Status. Not Validated  0, Valid  1, Invalid  2.  */  
   TaxValidationStatus:number,
      /**  Tax Validation Date  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Indicates if the record is inactive.  */  
   Inactive:boolean,
      /**  Customer Scheme ID  */  
   ExternalSchemeID:string,
      /**  EInvoice Operator Code  */  
   ELIOperatorCode:string,
      /**  Sending Option  */  
   ELISendingOption:number,
      /**  EInvoice Operator ID  */  
   ELIOperatorID:string,
      /**  EInvExternalID  */  
   EInvExternalID:string,
      /**  Tax Regime  */  
   MXTaxRegime:string,
      /**  ExclusionMonth  */  
   ExclusionMonth:number,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMRegionCode  */  
   FSMRegionCode:string,
      /**  FSMArea  */  
   FSMArea:string,
      /**  Default E-invoice Report Style  */  
   ELIRcptDefStyleNum:number,
      /**  CovenantDiscPercent  */  
   CovenantDiscPercent:number,
   ACATCommCare:boolean,
   ACATRespCareType:string,
   ACATRespCareTypeDesc:string,
      /**  Customer Address in format delimited string  */  
   AddrList:string,
      /**  This value is a temp field that is populated from JCSyst.AdvancedLaborRate  */  
   AdvancedLaborRate:boolean,
      /**  Apply credit hold status to orders  */  
   ApplyHoldToOrders:boolean,
      /**  delimited list of customer attributes  */  
   AttrCodeList:string,
      /**  Company base currency.  */  
   BaseCurrCode:string,
   BillDayDesc:string,
   BillFreqDescription:string,
      /**  Bill To Address in format delimited list  */  
   BTAddrList:string,
      /**  Delimited list of Business Categories  */  
   BusinessCatList:string,
      /**  ChargeCode Description  */  
   ChargeCodeDesc:string,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
   COOperTypeDesc:string,
   CustTypeDescription:string,
   DiscQualDescription:string,
   DspBTFormatStr:string,
      /**  Display Format String  */  
   DspFormatStr:string,
   DspRlsClass:string,
      /**  List of available ECC Payment Method codes  */  
   ECCPaymentCodes:string,
      /**  List of available ECC Payment Method descriptions  */  
   ECCPaymentDesc:string,
      /**  List of ECC Payment Method codes selected  */  
   ECCPaymentList:string,
      /**  List of ECC Payment Method descriptions selected  */  
   ECCPaymentXDesc:string,
      /**  List of ECC Ship Via codes selected  */  
   ECCShipViaList:string,
   EnableGlobalCust:boolean,
   EnableGlobalLock:boolean,
      /**  Indicates if an "Multi" External Company record exists to enable GlobalCust  */  
   ExtCoExist:boolean,
   FxdGlbOrdCredit:number,
   FxdGlbPICredit:number,
   FxdOrderCredit:number,
   FxdPICredit:number,
   FxdTotOrders:number,
   FxdTotPI:number,
      /**  Indicates if the Customer is Global (master or linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany and GlbCustNum that is linking to this customer  */  
   GlbLink:string,
      /**  Global Shared Credit Available  */  
   GlbNAChildCrdAvail:number,
      /**  Global Own Credit Available  */  
   GlbNAOwnCreditAvail:number,
   GlbNAOwnCreditUsedDsp:number,
      /**  Global Parents Credit Available  */  
   GlbNAParentCrdAvail:number,
   GlbNAParentsCreditUsedDsp:number,
   GlbNAPoolCrdAvail:number,
   GlbNAPoolCreditUsed:number,
   GlbNASharedCreditUsedDsp:number,
      /**  Indicates if integrated with a financial package  */  
   IntegrationFlag:boolean,
      /**  Flag used for integrations whether to run the on change country logic.  */  
   IntRunChangeCountry:boolean,
      /**  Identifies the default price list for the customer.  Must be unique and present in PriceLst table.  */  
   ListCode:string,
   LLLBAnnualHomeCap:number,
   LLLBAnnualPartPenCap:number,
   LLLBAnnualResiCap:number,
   LLLBAnnualSelfFndCap:number,
   LLLBAsAtDate:string,
      /**  Indicates if the Clients Asset and Income Assessment has been received  */  
   LLLBAssetAssess:boolean,
   LLLBLifeTimeCap:number,
   LLLBMeansTestAmt:number,
   LLLBMeansTestFeeAmt:number,
   LLLBPrevEntryDate:string,
      /**  Customer?s credit available to be shared with his Children in National Account  */  
   NAChildCrdAvail:number,
      /**  If the customer in the Credit Checking National Account  */  
   NACreditCust:boolean,
      /**  Customer is in Credit National Account and his Credit data have been updated, so recalculation is needed  */  
   NACreditUpdated:boolean,
      /**  Own Credit Available  */  
   NAOwnCreditAvail:number,
   NAOwnCreditUsedDsp:number,
      /**  Available Parent?s Credit in National Accout  */  
   NAParentCrdAvail:number,
   NAParentsCreditUsedDsp:number,
      /**  Available credit from credit pools to be used by this customer in National account.  */  
   NAPoolCrdAvail:number,
   NAPoolCreditUsed:number,
   NASharedCreditUsedDsp:number,
      /**  Total Credit Available from National Account  */  
   NATotalCreditAvail:number,
      /**  Total Credit Used from National Account  */  
   NATotalCreditUsed:number,
      /**  A user defined external Netting Vendor ID.  This must be existing Vendor ID within the file.  */  
   NettingVendorID:string,
      /**  CustID of Parent Customer  */  
   ParentCustID:string,
      /**  Name of Parent Customer  */  
   ParentName:string,
   PeriodicityDesc:string,
      /**  List of available Periodicity values.  */  
   PeriodicityList:string,
      /**  Indicates whether PI fields should be enabled or not  */  
   PIFlag:boolean,
      /**  Reminder Group Description  */  
   ReminderGroupDesc:string,
      /**  Sales Tax ID  */  
   SalesTaxID:string,
      /**  Automated Bank Reconciliation: Search IDs.  */  
   SearchIDs:string,
      /**  flag indicating whether packing slips are sent to integration partner  */  
   SendShipment:boolean,
      /**  Service Tax ID  */  
   ServiceTaxID:string,
   ShippingQualifierDesc:string,
      /**  Total Global Invoice Credit (including current company)  */  
   TotGlbInvoiceCredit:number,
      /**  Total Global Open Credit (based on GlbCredInc flags)  */  
   TotGlbOpenCredit:number,
      /**  Total Global Order Credit (including current company)  */  
   TotGlbOrderCredit:number,
      /**  Total Global Payment Instruments Credit (including current company)  */  
   TotGlbPICredit:number,
   TotInvoiceCredit:number,
   TotLCCredit:number,
   TotLCCumInvoices:number,
   TotLCInvoiceBal:number,
   TotLCOpenOrders:number,
   TotLCUsed:number,
      /**  Total Credit based on CredInc flags  */  
   TotOpenCredit:number,
      /**  Total number of open invoices  */  
   TotOpenInvoices:number,
      /**  Total number of open invoices for LCs  */  
   TotOpenInvoicesLC:number,
      /**  Total number of open LCs  */  
   TotOpenLC:number,
      /**  Total number of open orders for LCs  */  
   TotOpenOrderLC:number,
      /**  Total number of open orders  */  
   TotOpenOrders:number,
      /**  Total number of open Payment Instruments  */  
   TotOpenPI:number,
   TotOrderCredit:number,
   TotPICredit:number,
   ACATOtherCare:boolean,
   LanguageDescription:string,
   BitFlag:number,
   AGAFIPResponsibilityDescription:string,
   AGBillToProvinceDescription:string,
   AGIDDocTypeCUITMark:boolean,
   AGIDDocTypeDescription:string,
   AgingCreditDescription:string,
   AGProvinceDescription:string,
   BTCountryISOCode:string,
   BTCountryEUMember:boolean,
   CompanySendToFSA:boolean,
   CountryISOCode:string,
   CountryFormatStr:string,
   CountryEUMember:boolean,
   CurrencyCurrName:string,
   CurrencyCurrencyID:string,
   CurrencyCurrSymbol:string,
   CurrencyCurrDesc:string,
   CurrencyDocumentDesc:string,
   CustGrupGroupDesc:string,
   DeliveryTypeDescription:string,
   FOBDescription:string,
   GlobalCurrencyCurrSymbol:string,
   GlobalCurrencyCurrDesc:string,
   GlobalCurrencyDocumentDesc:string,
   GlobalCurrencyCurrencyID:string,
   GlobalCurrencyCurrName:string,
   MarkUpDescription:string,
   MXPurchaseTypeCodeDesc:string,
   PayMethodSummarizePerCustomer:boolean,
   PayMethodType:number,
   PayMethodName:string,
   PreferredBankBankName:string,
   PreferredBankDescription:string,
   RASchedCdRADesc:string,
   ReservePriDescription:string,
   SalesRepName:string,
   ShipViaWebDesc:string,
   ShipViaDescription:string,
   TATaxAuthorityDescription:string,
   TaxRegionDescription:string,
   TermsDescription:string,
   TerritoryTerritoryDesc:string,
   XbSystELIEinvoice:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ECCExtensionCustCntTableset{
   CustCnt:Erp_Tablesets_CustCntRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionCustXPrtTableset{
   CustXPrt:Erp_Tablesets_CustXPrtRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionCustomerTableset{
   Customer:Erp_Tablesets_CustomerRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionDdaDatesRow{
      /**  Next available delivery date  */  
   DeliveryDate:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ECCExtensionDdaDatesTableset{
   ECCExtensionDdaDates:Erp_Tablesets_ECCExtensionDdaDatesRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionDdaLinesRow{
   Address1:string,
   Address2:string,
   Address3:string,
   City:string,
   ContactName:string,
   Country:string,
   CustNum:number,
   Name:string,
   PartNum:string,
   Plant:string,
   SellingQuantity:number,
   ShipToNum:string,
   State:string,
   WareHouseCode:string,
   Zip:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ECCExtensionDdaLinesTableset{
   ECCExtensionDdaLines:Erp_Tablesets_ECCExtensionDdaLinesRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionDdaRoundsRow{
      /**  Interger value representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday  */  
   DayOfWeek:number,
      /**  Daily, Weekly, Fortnightly or an integer indicating the number of weeks.  */  
   Frequency:string,
      /**  Next Delivery Date  */  
   NextDeliveryDate:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ECCExtensionDdaRoundsTableset{
   ECCExtensionDdaRounds:Erp_Tablesets_ECCExtensionDdaRoundsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionHDCaseTableset{
   HDCase:Erp_Tablesets_HDCaseRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionInvcDtlTableset{
   InvcDtl:Erp_Tablesets_InvcDtlRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionInvcHeadTableset{
   InvcHead:Erp_Tablesets_InvcHeadRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionLocationInventoryTableset{
   LocationInventory:Erp_Tablesets_LocationInventoryRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionLocationMtlTableset{
   LocationMtl:Erp_Tablesets_LocationMtlRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionLocationWarrTranTableset{
   LocationWarrantyTran:Erp_Tablesets_LocationWarrantyTranRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionOrderDtlTableset{
   OrderDtl:Erp_Tablesets_OrderDtlRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionOrderHedTableset{
   OrderHed:Erp_Tablesets_OrderHedRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPODetailTableset{
   PODetail:Erp_Tablesets_PODetailRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPOHeaderTableset{
   POHeader:Erp_Tablesets_POHeaderRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPartSubsTableset{
   PartSubs:Erp_Tablesets_PartSubsRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPartTableset{
   Part:Erp_Tablesets_PartRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPartUOMTableset{
   PartUOM:Erp_Tablesets_PartUOMRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPartXRefIntTableset{
   PartXRefInt:Erp_Tablesets_PartXRefIntRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionPcECCOrderDtlTableset{
   PcECCOrderDtl:Erp_Tablesets_PcECCOrderDtlRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionProdGrupTableset{
   ProdGrup:Erp_Tablesets_ProdGrupRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionQuoteDtlTableset{
   QuoteDtl:Erp_Tablesets_QuoteDtlRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionQuoteHedTableset{
   QuoteHed:Erp_Tablesets_QuoteHedRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionRFQHeadTableset{
   RFQHead:Erp_Tablesets_RFQHeadRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionRFQItemTableset{
   RFQItem:Erp_Tablesets_RFQItemRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionRMADtlTableset{
   RMADtl:Erp_Tablesets_RMADtlRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionRMAHeadTableset{
   RMAHead:Erp_Tablesets_RMAHeadRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionReasonTableset{
   Reason:Erp_Tablesets_ReasonRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionRow{
      /**  Column name of custom column.  */  
   ColumnName:string,
      /**  Value for custom column  */  
   ColumnValue:string,
   SysRowID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ECCExtensionShipToTableset{
   ShipTo:Erp_Tablesets_ShipToRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionSugPOChgTableset{
   SugPOChg:Erp_Tablesets_SugPOChgRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionTableset{
   ECCExtension:Erp_Tablesets_ECCExtensionRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionVendCntTableset{
   VendCnt:Erp_Tablesets_VendCntRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_ECCExtensionVendorTableset{
   Vendor:Erp_Tablesets_VendorRow[],
   ExtensionTables:Ice_Extensions_ExtensionTableData[],
}

export interface Erp_Tablesets_HDCaseRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique help desk case number.  This number is system generated when the help desk case is created.  */  
   HDCaseNum:number,
      /**  The customer associated with this case.  */  
   CustNum:number,
      /**  The customer ship-to associate with the Help Desk case.  This is used with the ShpConNum to reference a contact in the CustCont table.  */  
   ShipToNum:string,
      /**  Customer contact number.  This is used with the ShipToNum to reference a contact in the CustCont table.  */  
   ShpConNum:number,
      /**  The parent Help Desk case number of this case.  */  
   ParentCase:number,
      /**  The description of the case issue.  */  
   Description:string,
      /**  A description if the resolution for the case.  */  
   ResolutionText:string,
      /**  Publishable text of the issue and resolution of the case.  */  
   PublishedText:string,
      /**  A summary of the issue/resolution of the help desk case.  */  
   PublishedSummary:string,
      /**  If true this is a Knowledge Base entry.  */  
   KBEntry:boolean,
      /**  If true this item can be published.  If false this item is for internal use only.  */  
   PublishedItem:boolean,
      /**  The part that is associated with this Help Desk case.  The part is in the Part table.  */  
   PartNum:string,
      /**  An serial number associated with the Help Desk case.  The serial number is in the SerialNo table.  */  
   SerialNumber:string,
      /**  The Quote associated with the Help Desk case.  The Quote is in the QuoteHed table.  */  
   QuoteNum:number,
      /**  The order associated with the Help Desk case.  The order is in the OrderHed table.  */  
   OrderNum:number,
      /**  A Field Service call that is associated with the Help Desk case.  The field service call is in the FSCallHd table.  */  
   CallNum:number,
      /**  A Service Contract associated with the Help Desk case.  The service contract is in the FSContHd table.  */  
   ContractNum:number,
      /**  The warranty associated with the Help Desk case.  The warranty is in the FSWarrCd table.  */  
   WarrantyCode:string,
      /**  The priority of the Help Desk case  */  
   Priority:number,
      /**  Unique identifier of the task set.  */  
   TaskSetID:string,
      /**  The identifier of the workflow stage.  */  
   CurrentWFStageID:string,
      /**  The Currently active milestone task  */  
   ActiveTaskID:string,
      /**  The Last Complete Milestone task  */  
   LastTaskID:string,
      /**  The SalesRepCode of the owner of the Help Desk case.  The people are stored in the SalesRep table.  */  
   CaseOwner:string,
      /**  The identifier of the workflow group  */  
   WFGroupID:string,
      /**  This indicates if the workflow for this case is complete.  */  
   WFComplete:boolean,
      /**  Date which this Help Desk case was created.  Not maintainable by the user.  */  
   CreatedDate:string,
      /**  UserID who created the Help Desk case.  Not maintainable by the user.  */  
   CreatedBy:string,
      /**  The time (in milliseconds) that the Help Desk case was created.  */  
   CreatedTime:number,
      /**  UserID who last updated the Help Desk case.  Not maintainable by the user.  */  
   LastUpdatedBy:string,
      /**  Date which this Help Desk case was last updated.  Not maintainable by the user.  */  
   LastUpdatedDate:string,
      /**  The time (in milliseconds) that the Help Desk case was last updated.  Not maintainable by the user.  */  
   LastUpdatedTime:number,
      /**  A unique identifier for the Help Desk Topic.  This is a top level topic (no parents).  */  
   TopicID1:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID1.  */  
   TopicID2:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID2.  */  
   TopicID3:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID3.  */  
   TopicID4:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID4.  */  
   TopicID5:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID5.  */  
   TopicID6:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID6.  */  
   TopicID7:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID7.  */  
   TopicID8:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID8.  */  
   TopicID9:string,
      /**  A unique identifier for the Help Desk Topic.  This is a child to TopicID9.  */  
   TopicID10:string,
      /**  This is the combination of TopicID1 - TopicID10.  This is system maintained and provides a single word-indexed field for searching.  */  
   CaseTopics:string,
      /**  Link to the Marketing Campaign related to this Help Desk case.  */  
   MktgCampaignID:string,
      /**  Link to the marketing event associated with this Help Desk case.  */  
   MktgEvntSeq:number,
      /**  Revision number  */  
   RevisionNum:string,
      /**  Describes the Part.  */  
   PartDescription:string,
      /**  A general quantity field.  */  
   Quantity:number,
      /**   Unit of Measure which qualifies the HDCase.Quantity.
Mandatory. Must be a valid UOM.  */  
   QuantityUOM:string,
      /**  Order line number.  */  
   OrderLine:number,
      /**  The order release number.  */  
   OrderRelNum:number,
      /**  The quote line number  */  
   QuoteLine:number,
      /**  Field service call line number  */  
   CallLine:number,
      /**  The RMA Number.  */  
   RMANum:number,
      /**  The RMA line number.  */  
   RMALine:number,
      /**  Foreign key to the InvcHead.  */  
   InvoiceNum:number,
      /**  The invoice line.  */  
   InvoiceLine:number,
      /**  Contains the key  value for the Purchasing Contact. This can be blank or it must be valid in the CUSTCNT  table. Use the CUSTOMER.PRIMPCON as the default.  */  
   PrcConNum:number,
      /**  Descriptive code assigned by the user to uniquely identify the Jobs, Orders, POs, and Tasks in a Project.  Cannot be blank.  */  
   ProjectID:string,
      /**  Customer Name  */  
   CustomerName:string,
      /**  Packing slip number that this Service call is linked with.  */  
   PackNum:number,
      /**  The packing slip line that holds the warranty information for this service call  */  
   PackLine:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Case Completed By  */  
   CompletedBy:string,
      /**  Case Completion Date  */  
   CompletionDate:string,
      /**  Case Completion Time  */  
   CompletionTime:number,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  The drop shipment packing slip number that this Service call is linked with  */  
   DropShipPackSlip:string,
      /**  The drop shipment packing slip line that holds the warranty information for this service call  */  
   DropShipPackLine:number,
      /**  Supplier number of the drop shipment and part of the primary key of a drop shipment line.  */  
   VendorNum:number,
      /**  The supplier purchase point id of the drop shipment and part of the primary key of a drop shipment line.  */  
   PurPoint:string,
      /**  Related Equip.EquipID.  */  
   EquipID:string,
      /**  Unique identifier of the primary Employee contact.  */  
   EmpID:string,
      /**  Unique identifier of the primary Buyer contact.  */  
   BuyerID:string,
      /**  Unique identifier of the Primary Vendor contact.  */  
   VendorNumCon:number,
      /**  Unique identifier of the Primary Vendor PP contact.  */  
   PurPointCon:string,
      /**  Unique identifier of the Primary Vendor contact num.  */  
   VenConNum:number,
      /**  Contact number.  Unique identifier for the Primary Purchase Point contact record.  */  
   PurPointConNum:number,
      /**  Unit price for the PartNum.  */  
   UnitPrice:number,
      /**  Same as UnitPrice except that this field contains the unit price in the case currency.  */  
   DocUnitPrice:number,
      /**  Unit Price in Report currency 1.  */  
   Rpt1UnitPrice:number,
      /**  Unit Price in Report currency 2.  */  
   Rpt2UnitPrice:number,
      /**  Unit Price in Report currency 3.  */  
   Rpt3UnitPrice:number,
      /**  Extended price. Calculated as Quantity * (UnitPrice / PFactor).  */  
   ExtPrice:number,
      /**  Same as ExtPrice except that this field contains the extended price in the case currency.  */  
   DocExtPrice:number,
      /**  Extended Price in Report currency 1.  */  
   Rp1ExtPrice:number,
      /**  Extended Price in Report currency 2.  */  
   Rp2ExtPrice:number,
      /**  Extended Price in Report currency 3.  */  
   Rp3ExtPrice:number,
      /**  Currency Code  */  
   CurrencyCode:string,
      /**  Rate Type Code  */  
   RateGrpCode:string,
      /**  Used with the currency module.  When TRUE the currency rate can be changed by the user and cannot be changed by the system.  */  
   LockRate:boolean,
      /**  Exchange rate that will be used for this role code entry.  */  
   ExchangeRate:number,
      /**  Unique identifier of the case type.  */  
   CaseTypeID:string,
      /**  This field will mainly be used when a part is found to be faulty and the purchase order and receipt that were used for the part need to be recorded  */  
   PONum:number,
      /**  Link to the territory ID.  */  
   TerritoryID:string,
      /**  This field will mainly be used when a part is found to be faulty and the purchase order and receipt that were used for the part need to be recorded  */  
   POLine:number,
      /**  The type of workflow.  */  
   WorkflowType:string,
      /**  This field will mainly be used when a part is found to be faulty and the purchase order and receipt that were used for the part need to be recorded  */  
   POPackSlip:string,
      /**  This field will mainly be used when a part is found to be faulty and the purchase order and receipt that were used for the part need to be recorded  */  
   POPackLine:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  HDCaseStatus  */  
   HDCaseStatus:string,
      /**  ReqPerConID  */  
   ReqPerConID:number,
      /**  PerConID  */  
   PerConID:number,
      /**  Case was initiated from the web  */  
   WebCase:boolean,
      /**  Comment used for discussion through web  */  
   WebComment:string,
      /**  Identification Number of related Location Inventory record.  */  
   IDNum:string,
      /**  Unique ID Num of related Location Inventory record.  */  
   LocationNum:number,
      /**  Field service contract line number. The service contract line is in the FSContDt table.  */  
   ContractLine:number,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMCurrentStatus  */  
   FSMCurrentStatus:string,
      /**  FSMServiceReportID  */  
   FSMServiceReportID:string,
      /**  FSMNumberOfFollowups  */  
   FSMNumberOfFollowups:number,
      /**  FSMReceivedBy  */  
   FSMReceivedBy:string,
      /**  FSMOriginalScheduleDate  */  
   FSMOriginalScheduleDate:string,
      /**  FSMCompletedDate  */  
   FSMCompletedDate:string,
      /**  If true the MilestoneSeq field can be modified  */  
   AllowMilestoneUpdate:boolean,
      /**  Case attribute code list  */  
   AttrCodeList:string,
      /**  Available PrcConNum values  */  
   AvailablePrcConNum:string,
      /**  Available AvailablePurPointConNum values  */  
   AvailablePurPointConNum:string,
      /**  Available ShpConNum values  */  
   AvailableShpConNum:string,
      /**  a delimited list of Task Sets that can be selected in the TaskSetId field  */  
   AvailableTaskSets:string,
      /**  Available AvailableVenConNum values  */  
   AvailableVenConNum:string,
   BaseCurrencyID:string,
   BaseCurrSymbol:string,
      /**  Code of the event. Selected from predefined list of codes.  */  
   CaseCode:string,
      /**  Indicates the current status of the case.  */  
   CaseStatus:string,
      /**  List of children linked to the case. Case numbers are separated by commas.  */  
   ChildCases:string,
      /**  The current milestone in tasks  */  
   CurrentMilestone:number,
      /**  Description of current milestone.  */  
   CurrentMilestoneDesc:string,
   CustCntCorpName:string,
   CustCntEMail:string,
   CustCntFaxNum:string,
   CustCntFirstName:string,
   CustCntLastName:string,
   CustCntMiddleName:string,
   CustCntName:string,
   CustCntPhoneNum:string,
      /**  If true the customer requires a unique PO on Sales Orders  */  
   CustomerRequiresPO:boolean,
      /**  String version of the creation time  */  
   DispCreateTime:string,
      /**  String version of the last update time  */  
   DispLastUpdateTime:string,
   DropShip:boolean,
      /**  Evaluation status of the event. Possible values are user defined.  */  
   EvaluationStatus:string,
      /**  Description of Evaluation Status  */  
   EvaluationStatusDesc:string,
      /**  String version of HDCaseNum (used for relationships)  */  
   HDCaseNumString:string,
   Inactive:boolean,
      /**  Short summary if the issue  */  
   IssueSummary:string,
      /**  Long issue description  */  
   IssueText:string,
      /**  Date of the next review.  */  
   NextReviewDate:string,
      /**  The SalesUM of the part  */  
   PartSalesUM:string,
   PPCntEmailAddress:string,
   PPCntFaxNum:string,
   PPCntName:string,
   PPCntPhoneNum:string,
   PricePerCode:string,
   PurPointConName:string,
      /**  Requestor Context Link  */  
   ReqContextLink:string,
      /**  Holds the first ID for the linked record.  */  
   ReqPerConLnkID1:string,
      /**  Holds the second ID for the linked record. Used with compound key records like ShipTo or PurPoint.  */  
   ReqPerConLnkID2:string,
      /**  The display name for the link.  */  
   ReqPerConLnkName:string,
      /**  The SysRowId of the linked PerConLnk.  */  
   ReqPerConLnkRowID:string,
      /**  Requestor PerCon Name  */  
   ReqPerConName:string,
      /**  Requestor is primary contact.  */  
   ReqPrimary:boolean,
      /**  Extended Price in Report currency 1.  */  
   Rpt1ExtPrice:number,
      /**  Extended Price in Report currency 2.  */  
   Rpt2ExtPrice:number,
      /**  Extended Price in Report currency 3.  */  
   Rpt3ExtPrice:number,
   ShipCntCorpName:string,
   ShipCntEMail:string,
   ShipCntFaxNum:string,
   ShipCntFirstName:string,
   ShipCntLastName:string,
   ShipCntMiddleName:string,
   ShipCntName:string,
   ShipCntPhoneNum:string,
      /**  Customer Id of the third-party Ship To  */  
   ShipToCustID:string,
   ShipToNumName:string,
      /**  TargetUOM  */  
   TargetUOM:string,
      /**  A flag to indicate the user password was validated  */  
   TaskCompletePasswordIsValid:boolean,
      /**  Indicates if a the user password should be validated to complete a task  */  
   TaskCompletePasswordRequired:boolean,
   VendCntEmailAddress:string,
   VendCntFaxNum:string,
   VendCntName:string,
   VendCntPhoneNum:string,
      /**  The Quote Num that created a case number from the web  */  
   WebQuoteNum:number,
      /**  The available next milestones for the MilestoneSeq.  */  
   AvailableMilestones:string,
      /**  Translated description of current FSM status for FSM related cases  */  
   FSMCurrentStatusDesc:string,
   BitFlag:number,
   ActiveTaskIDTaskDescription:string,
   BuyerIDName:string,
   CaseOwnerName:string,
   CurrencyCodeCurrName:string,
   CurrencyCodeCurrSymbol:string,
   CurrencyCodeCurrDesc:string,
   CurrencyCodeDocumentDesc:string,
   CurrencyCodeCurrencyID:string,
   CustNumBTName:string,
   CustNumCustID:string,
   CustNumName:string,
   CustNumAllowShipTo3:boolean,
   DropShipDtlLineDesc:string,
   EmpIDName:string,
   EquipIDDescription:string,
   LastTaskIDTaskDescription:string,
   LocationInventoryLotNum:string,
   LocationInventorySerialNumber:string,
   LocationInventoryIDNum:string,
   MktgCampaignIDCampDescription:string,
   MktgEventEvntDescription:string,
   PackLineLineDesc:string,
   PartNumTrackDimension:boolean,
   PartNumSalesUM:string,
   PartNumPartDescription:string,
   PartNumPricePerCode:string,
   PartNumSellingFactor:number,
   PartNumTrackSerialNum:boolean,
   PartNumTrackLots:boolean,
   PartNumIUM:string,
   ProjectIDDescription:string,
   ShipToCustNumName:string,
   ShipToCustNumCustID:string,
   TaskSetIDWorkflowType:string,
   TaskSetIDTaskSetDescription:string,
   TerritoryIDTerritoryDesc:string,
   VendorNumConVendorID:string,
   VendorNumConName:string,
   WarrantyCodeWarrDescription:string,
   WFGroupIDDescription:string,
   WFStageIDDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_InvcDtlRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Foreign key to the InvcHead.  */  
   InvoiceNum:number,
      /**  This field along with Company and InvoiceNum make up the unique key to the table.  The system generates this number during entry of new detail records.  The system determines next available number by finding the last InvcDtl record for the Invoice and adding 1 to it.  */  
   InvoiceLine:number,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT" and line for service calls  "CALL".  */  
   LineType:string,
      /**  Contract Number of the related Service Contract when the LineType field is "CONTRACT"  */  
   ContractNum:number,
      /**  An optional field that is used if the customer has a different Part number than the internal part number.  This field is defaulted from the OrderDtl or ShipDtl files.  */  
   XPartNum:string,
      /**  Optional field that contains the customers revision.  Default from the ShipDtl.XRevisionNum for shipment lines or from OrderDtl.XRevisionNum, otherwise left blank.  */  
   XRevisionNum:string,
      /**  Part number used to identify line item part.  This would be used as "Our" part number if there is a difference between us and the customers part numbering scheme.  Defaults from the OrderDtl.PartNum or the ShipDtl.PartNum.  */  
   PartNum:string,
      /**  Description of the line item.  Defaults from ShipDtl.LineDesc, OrderDtl.LineDesc or Part.PartDescription.  */  
   LineDesc:string,
      /**  Unit Of Measure.  Defaulted from ShipDtl.IUM, OrderRel.IUM or Part.IUM.  */  
   IUM:string,
      /**  Our Current Revision Number for this Part.  */  
   RevisionNum:string,
      /**  Contains the line reference of the item on the customers PO. This is for reference and printing purposes.  Defaults from the OrderDtl.POLine.  */  
   POLine:string,
      /**  Indicates if this customer is exempt from sales tax for this line item.  If field is non-blank it is considered exempt.  This code is totally user definable and no validation is required.  This field will be printed on the Tax report if this item is reportable.  When the value is changed from blank to non-blank or vice versa tax calculation logic kicks in to calculate the sales tax info in the InvcTax file.  */  
   TaxExempt:string,
      /**  Indicates the Tax Category for this record.  Defaults from the OrderDtl if related to an Order or from the Part Master.  */  
   TaxCatID:string,
      /**   Indicates if this line is commissionable for the related sales rep's.
Defaults from the OrderDtl.  Note: "Deposit" invoice is always No.  */  
   Commissionable:boolean,
      /**   Unit price discount percent.  User can enter a percentage and the system calculates the  discount amount.
NOT MAINTAINABLE & zero if Advance Bill.  */  
   DiscountPercent:number,
      /**  Unit Price.  Can be defaulted from the OrderDtl.UnitPrice.  Always zero and not maintainable if this is a progress billing type of invoice.  */  
   UnitPrice:number,
      /**  Unit Price.  Can be defaulted from the OrderDtl.UnitPrice.  Always zero and not maintainable if this is a progress billing type of invoice.  */  
   DocUnitPrice:number,
      /**   Indicates the pricing per quantity.  It can be "E" = per each,
"C" = per hundred,  "M" = per thousand.  Used to calculate the extended unit price for the line item.  The logic is to divide the InvcDtl.ShipQty by the appropriate "per" value and then multiply by unit price.  Use the OrderDtl.PricePerCode as default if referenced to an order else use Part.PricePerCode as a default.  If Part record does not exist then default as "E".  */  
   PricePerCode:string,
      /**  The planned order release quantity.  This is not maintainable.  If and only if an order is referenced then it is set equal to the OrderRel.OurReqQty.  */  
   OurOrderQty:number,
      /**  Extended Price for the invoice line item.  If not a ProgressBill or "Deposit" invoice then it is not maintainable and is calculated as the (ShipQty/PricePer) * UnitPrice.  If it is a ProgressBill or "Deposit Invoice"  then the ShipQty and UnitPrice fields are zero and the user is allowed entry to this field.  */  
   ExtPrice:number,
      /**  Extended Price for the invoice line item.  If not a ProgressBill or "Deposit" invoice then it is not maintainable and is calculated as the (ShipQty/PricePer) * UnitPrice.  If it is a ProgressBill or "Deposit Invoice"  then the ShipQty and UnitPrice fields are zero and the user is allowed entry to this field.  */  
   DocExtPrice:number,
      /**   A flat discount amount for the line item.  It can be zero.  This is calculated using the DiscountPercent * (ShipQty * UnitPrice)).  This field can also be directly updated by the user, however it is refreshed whenever the DiscountPercent, UnitPrice or ShipQty fields are changed.  Discount CANNOT EXCEED THE EXTENDED LINE AMOUNT.  Note a discount entered here reduces the "net" sale amount, while miscellaneous amounts are not.
NOT MAINTAINABLE & Zero if ProgressBill.  */  
   Discount:number,
      /**   A flat discount amount for the line item.  It can be zero.  This is calculated using the DiscountPercent * (ShipQty * UnitPrice)).  This field can also be directly updated by the user, however it is refreshed whenever the DiscountPercent, UnitPrice or ShipQty fields are changed.  Discount CANNOT EXCEED THE EXTENDED LINE AMOUNT.  Note a discount entered here reduces the "net" sale amount, while miscellaneous amounts are not.
NOT MAINTAINABLE & Zero if ProgressBill.  */  
   DocDiscount:number,
      /**  Non-Maintainable.  Rolled up total of all misc. charge records for this invoice detail line.  */  
   TotalMiscChrg:number,
      /**  Non-Maintainable.  Rolled up total of all misc. charge records for this invoice detail line.  */  
   DocTotalMiscChrg:number,
      /**  Contains the foreign key to the ProdGrup file.  Can be blank or must be valid.  Defaults from the OrderDtl or Part file.  */  
   ProdCode:string,
      /**  Our Quantity Shipped/billed.  Can be defaulted from ShipDtl.OurShipQty.  Not maintainable & Zero for ProgressBill.  */  
   OurShipQty:number,
      /**  Packing slip number that this detail record is linked with.  */  
   PackNum:number,
      /**  The packing slip line number that is being invoiced.  */  
   PackLine:number,
      /**  Sales Order number.  This is not maintainable by the user.  The system duplicates it from the InvcHead.OrderNum.  */  
   OrderNum:number,
      /**  The associated sales order line number.  */  
   OrderLine:number,
      /**  Contains the release number of the order line item that is being invoiced.  */  
   OrderRelNum:number,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  Customer Ship To ID for the item.  Defaults from the Customer, OrderRel or ShipDtl records.  If invoice details reference only one ship to then the ship to info is printed as heading info. otherwise a "See Below" message is printed and the Ship To info is printed as part of the invoice detail body.  */  
   ShipToNum:string,
      /**  Ship date of the invoice line item.  Defaults from the ShipHead or from the invoice date when not referencing a packing slip.  When printed on the invoice it is printed as part of the heading if only one date exists else it is printed as part of the detail line.  */  
   ShipDate:string,
      /**  ShipVia for the invoice detail lines.  Contains the Foreign key to the SHIPVIA master file. Can be left blank or must be valid.  Default from the OrderRel, ShipHead, Customer or ShipTo.  If invoice contains only a single ship via then it is printed as part of the heading; otherwise, it prints as part of the line item detail.  */  
   ShipViaCode:string,
      /**  The amount this line item that is reduced by due to prior advanced billings.  This is only valid for "Shipment" or Miscellaneous" types.  It is defaulted from the OrderDtl.AdvanceBillBal.  This value reduces the OrderDtl.AdvanceBillBal.  */  
   AdvanceBillCredit:number,
      /**  The amount this line item that is reduced by due to prior advanced billings.  This is only valid for "Shipment" or Miscellaneous" types.  It is defaulted from the OrderDtl.AdvanceBillBal.  This value reduces the OrderDtl.AdvanceBillBal.  */  
   DocAdvanceBillCredit:number,
      /**  The CustNum field is the internal number that is used to link the invoice to the Customer master file.  This is not maintainable, it is duplicated from the InvcHead.CustNum field.  */  
   CustNum:number,
      /**  Used to enter comments about the invoice line item.  These are printed on the invoice.  When invoice is referenced to a sales order line then this is defaulted from OrderDtl.InvoiceComment.  */  
   InvoiceComment:string,
      /**  Contains the key value for the shipping contact in the CUSTCNT table.  Can be blank or must be valid in the CUSTCNT table.  Use the Customer.PrimSCon as a default or from OrderRel record.  */  
   ShpConNum:number,
      /**  Material Unit Cost.  The cost is initially captured on the PartTran record for the shipments (MFG-CUS, STK-CUS).  It is duplicated from the PartTran when invoiced.  If shipped from inventory then it is the cost captured from the part master at time of shipment.  If shipped from job it is calculated during the Calculate WIP/COS period end process.  Note: the Calculate WIP/COS will also update this cost for invoiced job shipments which had been invoiced prior to having the costs calculated.  */  
   MtlUnitCost:number,
      /**  Labor Unit Cost. The cost is initially captured on the PartTran record for the shipments (MFG-CUS, STK-CUS).  It is duplicated from the PartTran when invoiced. If shipped from inventory then it is the cost captured from the part master at time of shipment.  If shipped from job it is calculated during the Calculate WIP/COS period end process. Note: the Calculate WIP/COS will also update this cost for invoiced job shipments which had been invoiced prior to having the costs calculated.  */  
   LbrUnitCost:number,
      /**  Burden Unit Cost.  The cost is initially captured on the PartTran record for the shipments (MFG-CUS, STK-CUS).  It is duplicated from the PartTran when invoiced. If shipped from inventory then it is the cost captured from the part master at time of shipment.  If shipped from job it is calculated during the Calculate WIP/COS period end process. Note: the Calculate WIP/COS will also update this cost for invoiced job shipments which had been invoiced prior to having the costs calculated.  */  
   BurUnitCost:number,
      /**  Subcontract Unit Cost.  If shipped from inventory then it is zero. (Subcontract cost is combined with material cost on part master) The cost is initially captured on the PartTran record for the shipments (MFG-CUS, STK-CUS).  It is duplicated from the PartTran when invoiced.  If shipped from inventory then it is the cost captured from the part master at time of shipment.  If shipped from job it is calculated during the Calculate WIP/COS period end process. Note: the Calculate WIP/COS will also update this cost for invoiced job shipments which had been invoiced prior to having the costs calculated.  */  
   SubUnitCost:number,
      /**  Material Burden Unit Cost.  The cost is initially captured on the PartTran record for the shipments (MFG-CUS, STK-CUS).  It is duplicated from the PartTran when invoiced.  If shipped from inventory then it is the cost captured from the part master at time of shipment.  If shipped from job it is calculated during the Calculate WIP/COS period end process.  Note: the Calculate WIP/COS will also update this cost for invoiced job shipments which had been invoiced prior to having the costs calculated.  */  
   MtlBurUnitCost:number,
      /**  Answers the question, "Does this InvcDtl need to have cost of sales posted to G/L?"  If the Manufacturing System is not using a A/R clearing account (XASyst.ARClearingDiv = "") then the costs were already posted to the Cost Of Sales account by the COS/WIP procedure (JCP80.W), so there are no costs to move.  */  
   COSPostingReqd:boolean,
      /**   If the amount of this InvcDtl was posted to the A/R clearing account (COSPostingReq = Yes), then at sometime the amount needs to be moved to the COS account.   When the costs are moved, this flag is set to Yes.
When a product is shipped it's costs are put in A/R Clearing.  When it's invoiced the costs are ready to be moved to COS.  The Capture WIP/COS Activity procedure (JCP80.W) moves these costs.  */  
   COSPosted:boolean,
      /**  A unique code that identifies the Service Contract when the Line Type is "CONTRACT"  */  
   ContractCode:string,
      /**  this is a link to the service call that this invoice is for.  Linetype = "CALL"  */  
   CallNum:number,
      /**  A unique code that identifies the type of service call.  Link to GL accounts when LineType = "CALL"  */  
   CallCode:string,
      /**   The related RMA number. Note: This only applies to Credit Memos.
It is assigned as part of the Request Credit process for an RMA and is not directly maintainable by Invoice Entry.  */  
   RMANum:number,
      /**   The related RMA Line number.  This along with the RMANum provides the foreign key to the related RMADtl record.
(See InvcDtl.RMANum)  */  
   RMALine:number,
      /**  A Cod which uniquely identfies SalesCat record. Can't be blank.  */  
   SalesCatID:string,
      /**   Fiscal year that clearing/cos entry was posted to in G/L.
Note: The Fiscal Year, Period, Journal Code, JournalNum pertain only to records which were used to post to the ARClearing/COS. This condition is indicated if  COSPostingReqd = Yes.  */  
   FiscalYear:number,
      /**   Fiscal period that entry was posted to.
Note: applicable only when posted to G/L.  */  
   FiscalPeriod:number,
      /**   Journal Code of the related GLJrnDtl.
Note: This is set as the Inventory Journal code defined in the inventory configuration options.  */  
   JournalCode:string,
      /**   Journal # that entry was posted to.
Note: applicable only when posted to G/L.  */  
   JournalNum:number,
      /**  The planned order release quantity.  This is not maintainable.  If and only if an order is referenced then it is set equal to the OrderRel.SellingReqQty.  */  
   SellingOrderQty:number,
      /**  Selling Quantity Shipped/billed.  Can be defaulted from ShipDtl.SellingShipQty.  Not maintainable & Zero for ProgressBill.  */  
   SellingShipQty:number,
      /**  Selling Unit Of Measure.  Defaulted from ShipDtl.SUM, OrderDtl.SUM or Part.SUM.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  Project Id that links the invoice detail  to the Project table.  */  
   ProjectID:string,
      /**  Milestone id that links the invoice detail  to the ProjectMilestone.  */  
   MilestoneID:string,
      /**  This is the unit price returned by the price list before quantity based or order value based discounts are applied.  Will default from the OrderDtl.ListPrice.  */  
   ListPrice:number,
      /**  This is the list price in customer currency.  Will default from the OrderDtl.DocListPrice.  */  
   DocListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied.  Will default from the OrderDtl.OrdBasedPrice.  */  
   OrdBasedPrice:number,
      /**  This is the order based price in customer currency.  Will default from the OrderDtl.DocOrdBasedPrice.  */  
   DocOrdBasedPrice:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   AdvGainLoss:number,
      /**  Indicates how Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**  Sales representative commission rate.  */  
   RepRate1:number,
      /**  Sales representative commission rate.  */  
   RepRate2:number,
      /**  Sales representative commission rate.  */  
   RepRate3:number,
      /**  Sales representative commission rate.  */  
   RepRate4:number,
      /**  Sales representative commission rate.  */  
   RepRate5:number,
      /**  Sales representative commission percentage.  */  
   RepSplit1:number,
      /**  Sales representative commission percentage.  */  
   RepSplit2:number,
      /**  Sales representative commission percentage.  */  
   RepSplit3:number,
      /**  Sales representative commission percentage.  */  
   RepSplit4:number,
      /**  Sales representative commission percentage.  */  
   RepSplit5:number,
      /**  Bill To Customer Number used for consolidated invoices  */  
   BTCustNum:number,
      /**  Job Closing Material Unit Cost.  The cost is captured on the final Job Assembley. It is  duplicated from the JobAsmbl when the job is closed.  */  
   JCMtlUnitCost:number,
      /**  Job Closing Labor Unit Cost. The cost is captured on the final Job Assembley. It is  duplicated from the JobAsmbl when the job is closed.  */  
   JCLbrUnitCost:number,
      /**  Job Closing Burden Unit Cost.  The cost is captured on the final Job Assembley. It is  duplicated from the JobAsmbl when the job is closed.  */  
   JCBurUnitCost:number,
      /**  Job Closing Subcontract Unit Cost.  The cost is captured on the final Job Assembley. It is  duplicated from the JobAsmbl when the job is closed.  */  
   JCSubUnitCost:number,
      /**  Job Closing Material Burden Unit Cost.  The cost is captured on the final Job Assembley. It is  duplicated from the JobAsmbl when the job is closed.  */  
   JCMtlBurUnitCost:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**   Indicates what VAT Reverse Charge method needs to be applied for this invoice line.  The possible values are:
   "RCT"  -  "Reverse Charge with Threshold";
   "RCN"  -  "Reverse Charge with No Threshold"
Leave this field blank if no Reverse Charge should be applied in the AR invoice line.  */  
   RevChargeMethod:string,
      /**  Indicates if the user overrides the Reverse Charge Method.  */  
   OverrideReverseCharge:boolean,
      /**  Indicates if Reverse Charge tax line has been applied.  */  
   RevChargeApplied:boolean,
      /**  If true, the InvcTax records tied to this line are calculated using Tax Connect logic. If  false, taxes are calculated using the standard calc methods.  */  
   TaxConnectCalc:boolean,
      /**  If set to true, the tax calculation logic will retrieve the default SalesTax ids for the line before calculating taxes. It will also be reset to true if the TaxConnectCalc flag switches from true to false.  */  
   GetDfltTaxIds:boolean,
      /**  Reporting currency value of this field  */  
   Rpt1AdvanceBillCredit:number,
      /**  Reporting currency value of this field  */  
   Rpt2AdvanceBillCredit:number,
      /**  Reporting currency value of this field  */  
   Rpt3AdvanceBillCredit:number,
      /**  Reporting currency value of this field  */  
   Rpt1Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt2Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt3Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt1ExtPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2ExtPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3ExtPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1ListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2ListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3ListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1OrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2OrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3OrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1TotalMiscChrg:number,
      /**  Reporting currency value of this field  */  
   Rpt2TotalMiscChrg:number,
      /**  Reporting currency value of this field  */  
   Rpt3TotalMiscChrg:number,
      /**  Reporting currency value of this field  */  
   Rpt1UnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2UnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3UnitPrice:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   Rpt1AdvGainLoss:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   Rpt2AdvGainLoss:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   Rpt3AdvGainLoss:number,
      /**  Fiscal year suffix.  */  
   FiscalYearSuffix:string,
      /**  The fiscal calendar year/suffix/period were derived from.  */  
   FiscalCalendarID:string,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**   Indicates if the One Time Shipto information is to be used.
Note: This can only be true when if the OTSName is not blank. 
UI disables this when Customer.AllowQTS = False,  */  
   UseOTS:boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   OTSName:string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   OTSAddress1:string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   OTSAddress2:string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   OTSAddress3:string,
      /**  City portion of the One Time Shipto  address.  */  
   OTSCity:string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   OTSState:string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   OTSZIP:string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   OTSResaleID:string,
      /**  Contains the TaxRgn.TaxRegionCode value of the One Time ShipTo tax region for purposes of Sales Tax calculations.  */  
   OTSTaxRegionCode:string,
      /**  One Time Ship To Contact Name  */  
   OTSContact:string,
      /**  Fax number for the One Time ShipTo.  */  
   OTSFaxNum:string,
      /**  Phone number for the One Time ShipTo  */  
   OTSPhoneNum:string,
      /**  One Time Shipping adress country Number.  */  
   OTSCountryNum:number,
      /**  Value is copied from PartTran for PE  */  
   Plant:string,
      /**  value is copied from PartTran for PE  */  
   WarehouseCode:string,
      /**  value is copied from PartTran for PE  */  
   CallLine:number,
      /**  Drop Shipment Pack Line  */  
   DropShipPackLine:number,
      /**  Drop shipment Packing Slip.  */  
   DropShipPackSlip:string,
      /**  FK to the Finance Charges table  */  
   FinChargeCode:string,
      /**  Reference to the ABT, it is GUID, used in PostingEngine  */  
   ABTUID:string,
      /**  Unit Price including taxes.  Can be defaulted from the OrderDtl.InUnitPrice.  Always zero and not maintainable if this is a progress billing type of invoice.  */  
   InUnitPrice:number,
      /**  Unit Price including taxes.  Can be defaulted from the OrderDtl.InUnitPrice.  Always zero and not maintainable if this is a progress billing type of invoice.  */  
   DocInUnitPrice:number,
      /**  Extended Price for the invoice line item including taxes.  If not a ProgressBill or "Deposit" invoice then it is not maintainable and is calculated as the (ShipQty/PricePer) * UnitPrice.  If it is a ProgressBill or "Deposit Invoice"  then the ShipQty and UnitPrice fields are zero and the user is allowed entry to this field.  */  
   InExtPrice:number,
      /**  Extended Price for the invoice line item including taxes.  If not a ProgressBill or "Deposit" invoice then it is not maintainable and is calculated as the (ShipQty/PricePer) * UnitPrice.  If it is a ProgressBill or "Deposit Invoice"  then the ShipQty and UnitPrice fields are zero and the user is allowed entry to this field.  */  
   DocInExtPrice:number,
      /**   A flat discount amount for the line item including taxes.  It can be zero.  This is calculated using the DiscountPercent * (ShipQty * InUnitPrice)).  This field can also be directly updated by the user, however it is refreshed whenever the DiscountPercent, InUnitPrice or ShipQty fields are changed.  Discount CANNOT EXCEED THE EXTENDED LINE AMOUNT.  Note a discount entered here reduces the "net" sale amount, while miscellaneous amounts are not.
NOT MAINTAINABLE & Zero if ProgressBill.  */  
   InDiscount:number,
      /**   A flat discount amount for the line item including taxes.  It can be zero.  This is calculated using the DiscountPercent * (ShipQty * InUnitPrice)).  This field can also be directly updated by the user, however it is refreshed whenever the DiscountPercent, InUnitPrice or ShipQty fields are changed.  Discount CANNOT EXCEED THE EXTENDED LINE AMOUNT.  Note a discount entered here reduces the "net" sale amount, while miscellaneous amounts are not.
NOT MAINTAINABLE & Zero if ProgressBill.  */  
   DocInDiscount:number,
      /**  Non-Maintainable.  Rolled up total of all misc. charge records for this invoice detail line (includes taxes).  */  
   InTotalMiscChrg:number,
      /**  Non-Maintainable.  Rolled up total of all misc. charge records for this invoice detail line (includes taxes).  */  
   DocInTotalMiscChrg:number,
      /**  This is the unit price returned by the price list before quantity based or order value based discounts are applied (includes taxes).  Will default from the OrderDtl.InListPrice.  */  
   InListPrice:number,
      /**  This is the list price in customer currency.  Will default from the OrderDtl.DocInListPrice.  */  
   DocInListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied (includes taxes).  Will default from the OrderDtl.InOrdBasedPrice.  */  
   InOrdBasedPrice:number,
      /**  This is the order based price in customer currency.  Will default from the OrderDtl.DocInOrdBasedPrice.  */  
   DocInOrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1InDiscount:number,
      /**  Reporting currency value of this field  */  
   Rpt2InDiscount:number,
      /**  Reporting currency value of this field  */  
   Rpt3InDiscount:number,
      /**  Reporting currency value of this field  */  
   Rpt1InExtPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2InExtPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3InExtPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1InListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2InListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3InListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1InOrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2InOrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3InOrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1InTotalMiscChrg:number,
      /**  Reporting currency value of this field  */  
   Rpt2InTotalMiscChrg:number,
      /**  Reporting currency value of this field  */  
   Rpt3InTotalMiscChrg:number,
      /**  Reporting currency value of this field  */  
   Rpt1InUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2InUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3InUnitPrice:number,
      /**  Will be set to Yes if the Invoice Detail was created by the Correction (Reversing) logic.  */  
   CorrectionDtl:boolean,
      /**  Asset number of the linked Asset Disposal transaction.  */  
   AssetNum:string,
      /**  Unique number to identify the linked Asset Disposal transaction.  */  
   DisposalNum:number,
      /**   Project Billing transactuion type with following options:
MWA = Measured Work, 
LBD = Employee Labor (Direct Labor), 
LBC = Contract Labor, 
MTL = Material, 
SUB = Subcontract, 
MSC = Other,
RET = Retention, 
FLBR = Fee Labor
FMTL = Fee Material,
FSUB = Fee Subcontract, 
FMSC = Fee ODC,
FPRJ = Fee of total project,
FRET = Fee retention,
BDN  = Burden,
CEIL = Reduce by Ceiling,
CLFR = Close ? Fee retention,
CLPR = Close ? Project Retention (CP)
CLSR = Close Billing schedule - Reverse retention
CLSA = Close Project ? Unassigned activities  */  
   PBLineType:string,
      /**  Invoice line reference  */  
   InvoiceLineRef:number,
      /**  Invoice Number Reference  */  
   InvoiceRef:number,
      /**  Lot Number.  This field should be set according to the linked Shipment Line.  */  
   LotNum:string,
      /**  Reference to the draft invoice line created in Invoice Preparation  */  
   PBInvoiceLine:number,
      /**  Contains the value of the AC_RAHead.RAID client accommodation.  */  
   RAID:number,
      /**  Contains the value of the AC_RADtl.RADtlID client detail accommodation.  */  
   RADtlID:number,
      /**  Indicates if revenue is deferred for contracts assigned to this group.  */  
   DeferredRev:boolean,
      /**  Revenue Amortization Code.  */  
   RACode:string,
      /**  Starting date the revenue is deferred.  */  
   DefRevStart:string,
      /**  When Yes the decision to defer revenue on an invoice line was made after the invoice was posted and the deferred revenue account has not yet been charged.  This flag is used internally to determine whether or not a journal clearing the sales and charging the deferrred revenue account needs to be created.  */  
   ChargeDefRev:boolean,
      /**  Contract renewal number. If the value is zero then the contract is not for a renewal.  */  
   RenewalNbr:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  DefRevPosted  */  
   DefRevPosted:boolean,
      /**  Unit price of Invoice linked to Bill of Exchange in original currency.  */  
   LinkedInvcUnitPrice:number,
      /**  Withholding Tax Amount in reporting currency  */  
   DspWithholdAmt:number,
      /**  Withholding Tax Amount in document currency  */  
   DocDspWithholdAmt:number,
      /**  Withholding tax amount in reporting currency  */  
   Rpt1DspWithholdAmt:number,
      /**  Withholding tax amount in reporting currency  */  
   Rpt2DspWithholdAmt:number,
      /**  Withholding tax amount in reporting currency  */  
   Rpt3DspWithholdAmt:number,
      /**  Currency code from linked Invoice Header  */  
   LinkedCurrencyCode:string,
      /**  Project Phase ID  */  
   PhaseID:string,
      /**  PEBOEHeadNum  */  
   PEBOEHeadNum:number,
      /**  MXSellingShipQty  */  
   MXSellingShipQty:number,
      /**  MXUnitPrice  */  
   MXUnitPrice:number,
      /**  DocMXUnitPrice  */  
   DocMXUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1MXUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2MXUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3MXUnitPrice:number,
      /**  CustCostCenter  */  
   CustCostCenter:string,
      /**  DEIsServices  */  
   DEIsServices:boolean,
      /**  DEIsSecurityFinancialDerivative  */  
   DEIsSecurityFinancialDerivative:boolean,
      /**  DEInternationalSecuritiesID  */  
   DEInternationalSecuritiesID:string,
      /**  DEIsInvestment  */  
   DEIsInvestment:boolean,
      /**  DEPayStatCode  */  
   DEPayStatCode:string,
      /**  DefRevEndDate  */  
   DefRevEndDate:string,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  Indicates tha this invoice Line was reclassified.  */  
   Reclassified:boolean,
      /**  Enables the user the ability to override the Percent or Amount of revenue to be deferred  */  
   PartiallyDefer:boolean,
      /**  Percentage of revenue to be deferred for this line item  */  
   DeferredPercent:number,
      /**  Enables the user the ability tp reclassify deferred revenue and select a reclassification code and reason code.  */  
   Reclass:boolean,
      /**  Defines if the reclassification posting will only reclass the deferred revenue, or if the recognized revenue will be reclassed as well  */  
   DeferredOnly:boolean,
      /**  Reclassification Code. This field will be required if Reclass is checked.  */  
   ReclassCodeID:string,
      /**  Reason Code for reclassification from Reason Code Maintanance that have type 'Deferred Revenue'. This field will be required if reclass is checked.  */  
   ReclassReasonCode:string,
      /**  Internal comments for reclassification entered by the user.  */  
   ReclassComments:string,
      /**  Deferred Revenue Amount in base currency  */  
   DeferredRevAmt:number,
      /**  Deferred Revenue Amount in document currency  */  
   DocDeferredRevAmt:number,
      /**  Reporting currency value of Deferred Revenue Amount  */  
   Rpt1DeferredRevAmt:number,
      /**  Reporting currency value of Deferred Revenue Amount  */  
   Rpt2DeferredRevAmt:number,
      /**  Reporting currency value of Deferred Revenue Amount  */  
   Rpt3DeferredRevAmt:number,
      /**  ChargeReclass  */  
   ChargeReclass:boolean,
      /**  DEDenomination  */  
   DEDenomination:string,
      /**  DropShipPONum  */  
   DropShipPONum:number,
      /**  DocInAdvanceBillCredit  */  
   DocInAdvanceBillCredit:number,
      /**  InAdvanceBillCredit  */  
   InAdvanceBillCredit:number,
      /**  Rpt1InAdvanceBillCredit  */  
   Rpt1InAdvanceBillCredit:number,
      /**  Rpt2InAdvanceBillCredit  */  
   Rpt2InAdvanceBillCredit:number,
      /**  Rpt3InAdvanceBillCredit  */  
   Rpt3InAdvanceBillCredit:number,
      /**  MYIndustryCode  */  
   MYIndustryCode:string,
      /**  The dockingstation of the shipto address.  For future use.  */  
   DockingStation:string,
      /**  ConsolidateLines  */  
   ConsolidateLines:boolean,
      /**  MXCustomsDuty  */  
   MXCustomsDuty:string,
      /**  CommodityCode  */  
   CommodityCode:string,
      /**  MXProdServCode  */  
   MXProdServCode:string,
      /**  Quote number to which this line item detail record is associated with.  */  
   QuoteNum:number,
      /**  Quote Line number from which this invoice line was created from.  */  
   QuoteLine:number,
      /**  True if transaction is related to Epicor FSA  */  
   EpicorFSA:boolean,
      /**  MXCustomsUMFrom  */  
   MXCustomsUMFrom:string,
      /**  PE Detraction good or service code  */  
   PEDetrGoodServiceCode:string,
      /**  PETaxExempt  */  
   PETaxExempt:string,
      /**  Order number on the Invoicing Company.  */  
   CColOrderNum:number,
      /**  Order number line the Invoicing Company.  */  
   CColOrderLine:number,
      /**  Order number release the Invoicing Company.  */  
   CColOrderRel:number,
      /**  Invoice Line reference on the Invoicing Company.  */  
   CColInvoiceLineRef:number,
      /**  Packing slip number on the Invoicing Company.  */  
   CColPackNum:number,
      /**  Packing slip line number on the Invoicing Company.  */  
   CColPackLine:number,
      /**  Drop shipment packing slip number on the Invoicing Company.  */  
   CColDropShipPackSlip:string,
      /**  Drop shipment packing slip line number on the Invoicing Company.  */  
   CColDropShipPackSlipLine:number,
      /**  Ship To Customer ID from the Invoice Line in the subsidiary company.  */  
   CColShipToCustID:string,
      /**  Ship To from the Invoice Line in the subsidiary company.  */  
   CColShipToNum:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  The Full Description of the Attribute Set.  */  
   AttributeSetDescription:string,
      /**  The Short Description of the Attribute Set.  */  
   AttributeSetShortDescription:string,
      /**  Exempt Reason Code  */  
   ExemptReasonCode:string,
      /**  Associates the Call Line record back its linked jobnum  */  
   JobNum:string,
      /**  Indicates where invoice detail was created from when created from a service call job. Not maintainable. Summarized Labor, Summarized Material, Labor, Material  */  
   ServiceSource:string,
      /**  OTSTaxValidationStatus  */  
   OTSTaxValidationStatus:number,
      /**  OTSTaxValidationDate  */  
   OTSTaxValidationDate:string,
      /**  AssemblySeq related to JobMtl or JobOper used to create invoice line from service call job  */  
   AssemblySeq:number,
      /**  Job Mtl seq used to create invoice line from service call job  */  
   MtlSeq:number,
      /**  Job subcontract oper seq used to create invoice line from service call job  */  
   OprSeq:number,
      /**  Indicates the labor type of the LaborDtl used to create invoice from service call job.  */  
   LaborType:string,
      /**  LaborDtl hours summed by labor rate. Used to create invoice line from labor related to service call job.  */  
   BillableLaborHrs:number,
      /**  Billable rate used to create invoice line from labor related to service call job. In base currency.  */  
   BillableLaborRate:number,
      /**  Indicates the type of service call transaction data used to create the invoice detail from a service call job. MT (material), LB (labor), SC (subcontract), MC (misc charge), SM (summarized material), SL (summarized labor), SS (summarized subcontract) No summarization for MC.  */  
   ServiceSourceType:string,
      /**  TotalCovenantDiscount  */  
   TotalCovenantDiscount:number,
      /**  DocCovenantDiscount  */  
   DocCovenantDiscount:number,
      /**  Rpt1CovenantDiscount  */  
   Rpt1CovenantDiscount:number,
      /**  Rpt2CovenantDiscount  */  
   Rpt2CovenantDiscount:number,
      /**  Rpt3CovenantDiscount  */  
   Rpt3CovenantDiscount:number,
      /**  TotalInCovenantDiscount  */  
   TotalInCovenantDiscount:number,
      /**  DocInCovenantDiscount  */  
   DocInCovenantDiscount:number,
      /**  Rpt1InCovenantDiscount  */  
   Rpt1InCovenantDiscount:number,
      /**  Rpt2InCovenantDiscount  */  
   Rpt2InCovenantDiscount:number,
      /**  Rpt3InCovenantDiscount  */  
   Rpt3InCovenantDiscount:number,
      /**  Adv bill enabled flag  */  
   AdvBillEnabled:boolean,
   AllowTaxCodeUpd:boolean,
      /**  This flag not allow updating PartiallyDefer in 'Posted Invoice Update' if  AR Invoice Line was  marked as Partially Defer in AR Invoice Entry.  */  
   AllowUpdPartDefer:boolean,
      /**  CustID associated with the InvcDtl.BTCustNum field.  */  
   BillToCustID:string,
      /**  Customer Name associated with the InvcDtl.BTCustNum field.  */  
   BTCustName:string,
      /**  The date and time that the record was last changed  */  
   ChangeDateTime:string,
      /**  Used internally to determine when the user needs to be prompted to recalculate the amortization schedules.  This is not intended for use by the customers.  */  
   CheckAmortAmounts:boolean,
   CNGTIDescription1:string,
   CNGTIDescription2:string,
   CNGTIDescription3:string,
      /**  CSF China, discount tax amount  */  
   CNGTIDiscountTaxAmount:number,
   CNGTIIUM:string,
   CNGTINetAmount:number,
   CNGTIPartDescription:string,
   CNGTISpecification:string,
   CNGTITaxAmount:number,
   CNGTITaxCode:string,
   CNGTITaxPercent:number,
   CNGTITotalAmount:number,
      /**  CSF China, Unit price = if InvcHead.InPrice then InvcDtl.InUnitPrice else InvcDtl.UnitPrice  */  
   CNGTIUnitPrice:number,
   ContractSuspended:boolean,
      /**  Currency code from InvcHead.  */  
   CurrencyCode:string,
      /**  Currncy switch used to determine what currency to display amounts in.  */  
   CurrencySwitch:boolean,
      /**  CustID associated with the InvcDtl.CustNum field.  */  
   CustID:string,
      /**  Customer Name associated with the InvcDtl.CustNum field.  */  
   CustName:string,
      /**  Invoice Detail Customer Name  */  
   CustomerName:string,
      /**  Intended for internal use.  This is set to yes when the user answers yes to the prompt asking if they want to delete schedules after they unchecked the deferred revenue flag.  */  
   DeleteRASchedule:boolean,
   DispGLAcct:string,
      /**  Currency display symbol  */  
   DisplaySymbol:string,
      /**  PO number for display.  */  
   DispPONum:string,
      /**  Ship to display address  */  
   DispShipToAddr:string,
      /**  Document display symbol.  */  
   DocDisplaySymbol:string,
   DocDspUnitPrice:number,
      /**  Document discount amount  */  
   DocLessDiscount:number,
      /**  Doc line tax  */  
   DocLineTax:number,
      /**  ExtPrice-disc+misc charges.  */  
   DocLineTotal:number,
      /**  CSF Peru - Field used to display Detraction Amount for Bill of Exchange Invoices.  */  
   DocPEDetAmt:number,
      /**  Drop Shipment  */  
   DropShipment:boolean,
      /**  Display advance bill credit  */  
   DspAdvanceBillCredit:number,
      /**  Display discount  */  
   DspDiscount:number,
      /**  Display documents advance bill credit  */  
   DspDocAdvanceBillCredit:number,
      /**  Display document discount  */  
   DspDocDiscount:number,
      /**  Display document ext price  */  
   DspDocExtPrice:number,
      /**  Display document less discount  */  
   DspDocLessDiscount:number,
      /**  Display document line tax  */  
   DspDocLineTax:number,
      /**  Display document line total  */  
   DspDocLineTotal:number,
      /**  Display document total misc. charge  */  
   DspDocTotalMiscChrg:number,
      /**  Display ext price  */  
   DspExtPrice:number,
      /**  Display Invoice Reference  */  
   DspInvoiceRef:number,
      /**  Display less discount  */  
   DspLessDiscount:number,
      /**  Display line tax  */  
   DspLineTax:number,
      /**  Display line total  */  
   DspLineTotal:number,
      /**  Display our ship qty  */  
   DspOurShipQty:number,
      /**  Display selling ship qty  */  
   DspSellingShipQty:number,
   DspTaxExempt:string,
      /**  Display total misc. charges  */  
   DspTotalMiscChrg:number,
   DspUnitPrice:number,
      /**  Invoice head due date.  */  
   DueDate:string,
      /**  FSA Technician  */  
   EmpID:string,
   EnableDspWithholdAmt:boolean,
   EnableRMADelete:boolean,
   EnableRMAUpdate:boolean,
      /**  Has the Transaction Type field set in FSA and is stored on FSAExtData db table.  */  
   FSAAction:string,
      /**  Is the Call Type created on ERP and mapped through System External Key table with Service Type in FSA, stored on FSAExtData db table.  */  
   FSACallCode:string,
      /**  Contract Code created on ERP and processed by FSA, stored on FSAExtData db table.  */  
   FSAContractCode:string,
      /**  Contract created in ERP generated on FSA as Service Agreement, stored on FSAExtData db table.  */  
   FSAContractNum:number,
      /**  Employee created in ERP and processed on FSA as Service Technician, stored on FSAExtData db table.  */  
   FSAEmpID:string,
      /**  Resource ID for Equipment in FSAOffice ( this can be found in the Equipment information/Administrative tab in the Resource ID). Stored on FSAExtData db table.  */  
   FSAEquipmentInstallID:number,
      /**  Part created as equipment in ERP and Installed through FSA process, stored in FSAExtData.  */  
   FSAEquipmentPartNum:string,
      /**  Service Order number generated on FSA, stored on FSAExtData db table.  */  
   FSAServiceOrderNum:number,
      /**  Service Order Resource generated on FSA, stored on FSAExtData db table.  */  
   FSAServiceOrderResourceNum:number,
      /**  Warranty created in ERP and processed on FSA, stored on FSAExtData db table.  */  
   FSAWarrantyCode:string,
      /**  GL Journal Source Transaction Amount  */  
   GLTranAmt:number,
      /**  GL Journal Source Transaction Date  */  
   GLTranDate:string,
      /**  Group associated to the invoice  */  
   GroupID:string,
   InPrice:boolean,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
      /**  Invoice Header Legal Number  */  
   InvLegalNum:string,
      /**  Invoice Date from InvcHead.  */  
   InvoiceDate:string,
      /**  Invoice header type  */  
   InvoiceType:string,
      /**  Is commission button sensitive  */  
   IsCommisBtnSensitive:boolean,
      /**  Set to true if intrastat is enabled.  */  
   IsIntrastatSensitive:boolean,
      /**  Tax buton sensitive or not.  */  
   IsTaxBtnSensitive:boolean,
      /**  display discount  */  
   LessDiscount:number,
      /**  Line tax amount  */  
   LineTax:number,
      /**  ExtPrice-disc+misc charges.  */  
   LineTotal:number,
   LinkedCurrencySymbol:string,
      /**  The flag based on the user responce to indicate if Ship To to be chnaged on Invoice detail record without tax information from Ship To because of the different tax pricing  */  
   NoShipTaxRgnInfo:boolean,
      /**  Open invoice flag from InvcHead.  */  
   OpenInvoice:boolean,
      /**  OrderUM display  */  
   OrderUM:string,
      /**  original tax category  */  
   OrigTaxCat:string,
      /**  CSF Peru - Field used to display Detraction Amount for Bill of Exchange Invoices.  */  
   PEDetAmt:number,
      /**  PE Detraction good or service code description  */  
   PEDetrGoodServiceCodeDesc:string,
   PEDspCurrencySymbol:string,
      /**  PE VAT Exemption Reason  */  
   PEVATExemptionReason:string,
      /**  Posted flag from the InvcHead.  */  
   Posted:boolean,
   RADesc:string,
      /**  Intended for internal use.  Indicates whether or not revenue amortization schedules exist.  */  
   RASchedExists:boolean,
      /**  The internal flag to indicate if the logic is supposed to remove manual and/or manually added tax records per User request if the Line Tax Exempt field is populated  */  
   RemoveManAdTax:boolean,
   Rpt1DspAdvanceBillCredit:number,
   Rpt1DspDiscount:number,
   Rpt1DspExtPrice:number,
   Rpt1DspLessDiscount:number,
   Rpt1DspLineTax:number,
   Rpt1DspLineTotal:number,
   Rpt1DspTotalMiscChrg:number,
   Rpt1DspUnitPrice:number,
   Rpt1LineTax:number,
   Rpt1LineTotal:number,
      /**  CSF Peru - Field used to display Detraction Amount for Bill of Exchange Invoices.  */  
   Rpt1PEDetAmt:number,
   Rpt2DspAdvanceBillCredit:number,
   Rpt2DspDiscount:number,
   Rpt2DspExtPrice:number,
   Rpt2DspLessDiscount:number,
   Rpt2DspLineTax:number,
   Rpt2DspLineTotal:number,
   Rpt2DspTotalMiscChrg:number,
   Rpt2DspUnitPrice:number,
   Rpt2LineTax:number,
   Rpt2LineTotal:number,
      /**  CSF Peru - Field used to display Detraction Amount for Bill of Exchange Invoices.  */  
   Rpt2PEDetAmt:number,
   Rpt3DspAdvanceBillCredit:number,
   Rpt3DspDiscount:number,
   Rpt3DspExtPrice:number,
   Rpt3DspLessDiscount:number,
   Rpt3DspLineTax:number,
   Rpt3DspLineTotal:number,
   Rpt3DspTotalMiscChrg:number,
   Rpt3DspUnitPrice:number,
   Rpt3LineTax:number,
   Rpt3LineTotal:number,
      /**  CSF Peru - Field used to display Detraction Amount for Bill of Exchange Invoices.  */  
   Rpt3PEDetAmt:number,
      /**  1st sales rep of the invoice.  */  
   SalesRepCode1:string,
      /**  2nd sales rep of the invoice header.  */  
   SalesRepCode2:string,
      /**  3rd sales rep code of the invoice header.  */  
   SalesRepCode3:string,
      /**  4th sales rep code of the invoice header.  */  
   SalesRepCode4:string,
      /**  5th salesrep code of the invoice header.  */  
   SalesRepCode5:string,
      /**  1st sales rep name  */  
   SalesRepName1:string,
      /**  2nd sales rep name  */  
   SalesRepName2:string,
      /**  3rd sales rep name  */  
   SalesRepName3:string,
      /**  4th sales rep name  */  
   SalesRepName4:string,
      /**  5th sales rep name  */  
   SalesRepName5:string,
   ShipToContactEMailAddress:string,
   ShipToContactFaxNum:string,
   ShipToContactName:string,
   ShipToContactPhoneNum:string,
      /**  Ship Head Legal Number  */  
   ShpLegalNum:string,
      /**  CustID associated with the InvcDtl.CustNum field.  */  
   SoldToCustID:string,
      /**  Customer Name associated with the InvcDtl.CustNum field.  */  
   SoldToCustName:string,
      /**  Terms code from InvcHead.  */  
   TermsCode:string,
      /**  Warranty linked to part and processed by FSA, stored on FSAExtData db table.  */  
   WarrantyCode:string,
      /**  This flag allow updating Reclassification data.  */  
   AllowReclassify:boolean,
      /**  The flag to indicate if the amount  is re-calculated to doc/base/rpt currencies after entered and no need to re-calculate on save.  */  
   LineAmtRecalcd:boolean,
      /**  Set to true if extra trade statistics is enabled.  */  
   IsExtrastatSensitive:boolean,
      /**  Indicates if inventory for this part is tracked by revision number.  */  
   TrackInventoryByRevision:boolean,
   BitFlag:number,
   CallCodeCallDescription:string,
   CommodityCodeDescription:string,
   ContractCodeContractDescription:string,
   ContractNumSuspended:boolean,
   CustCntName:string,
   CustCntMiddleName:string,
   CustCntFirstName:string,
   CustCntFaxNum:string,
   CustCntCorpName:string,
   CustCntPhoneNum:string,
   CustCntLastName:string,
   CustNumCustID:string,
   CustNumName:string,
   CustNumAllowShipTo3:boolean,
   CustNumBTName:string,
   InvoiceNumTermsCode:string,
   InvoiceNumCardMemberName:string,
   JournalCodeJrnlDescription:string,
   MilestoneIDDescription:string,
   MXProdServCodeDesc:string,
   OrderLineLineDesc:string,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
   OTSCntryEUMember:boolean,
   OTSCntryISOCode:string,
   OTSCntryDescription:string,
   PackLineLineDesc:string,
   PartNumPartDescription:string,
   PartNumTrackDimension:boolean,
   PartNumIUM:string,
   PartNumSellingFactor:number,
   PartNumSalesUM:string,
   PartNumPricePerCode:string,
   PartNumTrackLots:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumAttrClassID:string,
   PartNumTrackInventoryAttributes:boolean,
   PartNumTrackInventoryByRevision:boolean,
   ProdCodeDescription:string,
   ProjectIDDescription:string,
   ReclassCodeDescription:string,
   ReclassReasonDescription:string,
   RMALineLineDesc:string,
   SalesCatIDDescription:string,
   ShipToCustCustID:string,
   ShipToCustName:string,
   ShipToCustBTName:string,
   ShipToNumInactive:boolean,
   ShipToNumName:string,
   ShipViaCodeDescription:string,
   ShipViaCodeWebDesc:string,
   TaxCatIDDescription:string,
   TaxRegionDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_InvcHeadRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates if invoice is "open".  */  
   OpenInvoice:boolean,
      /**  The latest transaction date (CashDtl) which was available when the invoice was closed. This is used to improve record selection performance when selecting invoices that were open as of a certain date. (Used by the aged invoice report). This is updated during the CashReceipt posting process, Adjustment entry or Apply Credit memos programs..  */  
   ClosedDate:string,
      /**   Indicates the type of document. Yes = Credit Memo No= Invoice. This value can't be changed after the record has been created.
Credit memos affect the way detail quantities and amounts are stored in the database. They will always be stored with a negative sign but will entered as a positive.
Credit Memos created by invoice entry also set the InvoiceSuffix field = "CM"  */  
   CreditMemo:boolean,
      /**  An internal flag that represents Credit Memo was due to Unapplied Receipts. Created by the Cash Receipts Entry program.   This is only applicable with CreditMemo = Yes.  */  
   UnappliedCash:boolean,
      /**   The Check reference number that the Unapplied Receipt Credit Memo was created from. Cash receipts entry sets this field equal to the CashHead.CheckRef when it creates the Unapplied Receipt Credit Memo.  Primarily used as a reference.
This is used when TranType = PrePay, MisPay or PayInv.  */  
   CheckRef:string,
      /**  An internally assigned field that further identifies an invoice. This field will be displayed as a suffix to the invoice number.  The possible values are "CM" = Credit memo created by invoice entry, UR = Unapplied Receipt Credit Memo,  DN = Debit Note, and FC = Finance Charge invoice.  */  
   InvoiceSuffix:string,
      /**  The Group that the invoice was associated with  during the data entry process. This field is not directly maintainable, it is assigned by the invoice entry program using the BatchID of the "current " batch that the user is working with.  */  
   GroupID:string,
      /**  Indicates if this invoice has been Posted to the receivables file.    Only invoices that have been Posted (true) will be included as part of the open receivables, that is they will not appear on reports or inquiries other than those used within invoice entry. Otherwise they are considered as still being in data entry. This field is always "no" when the invoice is created. It is set to "yes"  by the  "Post function". Once an invoice is posted it can't be maintained via data entry.  */  
   Posted:boolean,
      /**  If this field is left blank the system assigns the next available #. The next available # is the greater of last # on file plus one or the XaSyst.StartInvNum.  */  
   InvoiceNum:number,
      /**  There are four types of invoices:  "Shp" = Invoice for Shipment, "Adv" = Advanced Billing, "Dep" = For Deposit Payments, "Mis" = Miscellaneous.  The setting of this field affects invoice entry:  "Shipments" - These are generated by the "Get Shipments function" and is not selectable directly by the user.  "Advanced"  - Must have a sales order reference. The detail lines on this type of invoice update the OrderDtl.AdvanceBillBal. Also the user indicates if this should be considered as deferred revenue. Which changes which G/L accounts are used for the line item credits.  "Deposit" - invoices are used to request a "deposit" on an order. A Sales Order is mandatory. No line items or Miscellaneous records are allowed. The user enters a flat amount on the header (InvcHead.PrePayAmt) which will be printed in the body of the invoice. This also updates the OrderHed.PrePayBal field.   "Miscellaneous" - These invoices may or may not reference a Sales Order.  If Invoice is generated in Project Billing then there are following options: "PFF" - Fixed Fee project;  "PCP" - Cost Plus project;  "PTM" - Time and Material project;  "PPP" - Progress Payment project.  */  
   InvoiceType:string,
      /**  Only used when InvoiceType = "Adv" (Advanced Billing).  Indicates if the detail line amounts are to be considered as sales or deferred revenue.  If "No" then the G/L accounts on the detail lines are the Sales Accounts otherwise they will be set to the Deferred Revenue accounts established in the ARSyst/ARAcct files.  */  
   DeferredRevenue:boolean,
      /**  Sales Order #. This is a mandatory entry for all InvoiceType except "Miscellaneous". If entered it must be valid in the OrderHed file. The OrderHed supplies the invoice with many defaults, including; CustNum, PONum, TermsCode,  FOB, RepRate, RepSplit, SalesRepList, InvoiceComments  */  
   OrderNum:number,
      /**  The CustNum field is the internal # that is used to link the invoice to the Customer master file.  This field is not directly maintained by the user.  In most cases it will be duplicated from the referenced OrderHed. For "Miscellaneous" invoices the user can enter either a Sales Order Number or a Customer ID which will supply the CustNum.  */  
   CustNum:number,
      /**  Customer's PO#.   This is a reference field which will be printed on the invoice. Defaults from the OrderHed.PONum.  */  
   PONum:string,
      /**  User ID that entered the invoice. This is not maintainable by the user.  */  
   EntryPerson:string,
      /**  Defaults from sales order ORderHed.FOB  */  
   FOB:string,
      /**  Contains the foreign key to the TERMS master file.  Defaults from OrderHed if OrderNum > 0 else from the Customer master. This IS A MANDATORY ENTRY. User maintainable via a combo-box for terms description.  */  
   TermsCode:string,
      /**  Invoice date is duplicated from the InvcGrp record.  */  
   InvoiceDate:string,
      /**  The due date of the earlist unpaid scheduled payment amount. Normally invoices only have a single due date and amount. However we provide for installment payments which have multiple due dates and associated amounts. When invoices are first created this date will always be equal to the first entry in the DateDueList. Then as transactions are applied this "Current" Due Date is refreshed by figuring out which is the earliest unpaid scheduled payment.  */  
   DueDate:string,
      /**  Fiscal Year is duplicated from the related InvcGrp or based on ShipDate of Packing Slip. This is also refreshed if the InvoiceDate is changed.  */  
   FiscalYear:number,
      /**  Fiscal period of invoice. This is duplicated in from the InvcBatc or during the "get shipments" function it is determined based on the ShipDate of the packing slip or when the invoice date is changed. It is overrideable.  */  
   FiscalPeriod:number,
      /**  Once posted, maintenance is not allowed.  */  
   GLPosted:boolean,
      /**  Used to establish invoice comments about the overall order. These will copied into the Invoice detail file as defaults.  */  
   InvoiceComment:string,
      /**  Total invoice Amount. This field is an accumulation of the extended net amounts of the detail line items (InvcDtl) and of the miscellaneous charges/credits (InvcMisc) records.  This field has a true sign. (credit memos are negative).  */  
   InvoiceAmt:number,
      /**  Total invoice Amount. This field is an accumulation of the extended net amounts of the detail line items (InvcDtl) and of the miscellaneous charges/credits (InvcMisc) records.  This field has a true sign. (credit memos are negative).  */  
   DocInvoiceAmt:number,
      /**  Current outstanding balance. Carries a true sign. (Credit memos are negative).  */  
   InvoiceBal:number,
      /**  Current outstanding balance. Carries a true sign. (Credit memos are negative).  */  
   DocInvoiceBal:number,
      /**  Current outstanding balance which includes the unposted cash receipt amounts. This balance is updated immediately as cash is applied to the invoice, while the InvoiceBal field is not updated until the cash is posted.  Used by cash receipts to validate  online that an invoice is not over paid. Carries a true sign. (Credit memos are negative).  */  
   UnpostedBal:number,
      /**  Current outstanding balance which includes the unposted cash receipt amounts. This balance is updated immediately as cash is applied to the invoice, while the InvoiceBal field is not updated until the cash is posted.  Used by cash receipts to validate  online that an invoice is not over paid. Carries a true sign. (Credit memos are negative).  */  
   DocUnpostedBal:number,
      /**  Amount to be credited against the invoice total due to deposit payments against the sales order. This can be defaulted from OrderHed.DepositBal. This will be printed on the invoice as a separate line "Less Deposit of:"  This value updates the OrderHed.DepositBal. Do not allow OrderHed.DepositBal to become negative.  */  
   DepositCredit:number,
      /**  Amount to be credited against the invoice total due to deposit payments against the sales order. This can be defaulted from OrderHed.DepositBal. This will be printed on the invoice as a separate line "Less Deposit of:"  This value updates the OrderHed.DepositBal. Do not allow OrderHed.DepositBal to become negative.  */  
   DocDepositCredit:number,
      /**  Stores the Sales Rep Codes for the invoice. Up to five codes can be  established. This field is not directly maintainable.  Instead temp widgets are used for entry of each individual code and then put together as one comma delimited string field and assigned to this field.  This field will have a Word index, it then will make reporting and data base integrity checking much easier through the use of the "contains phrase" when retrieving records. These codes can be left blank or must be valid in the SalesRep master. The defaults are based on the OrderHed.SalesRepList if a valid Order is referenced or first one is defaulted from the Customer master if ship to is blank else from the ShipTo.  */  
   SalesRepList:string,
      /**   This field is maintainable/viewable only for Credit Memos. It represents the invoice # that this credit memo relates to. It can be left blank. If entered it must be a valid InvcHead record where the InvcHead.CreditMemo = No. This field is also used to order the invoices when printing aging reports. The idea is to be able to print the credit memos next to their corresponding invoice. Therefore, this field will always have a value.

For Invoices it is equal to the InvoiceNum.

For Credit memos where they are not related to an invoice it is also set equal to the credit memo's InvoiceNum. In this later case when InvcHead.Credit = Yes and InvcHead.InvoiceNum = InvcHead.InvoiceRef the InvoiceRef is reset to zero before being displayed, then when written back to the database it is set = to the InvoiceNum if the user did not enter a related invoice.  */  
   InvoiceRef:number,
      /**  Value of this field is reference to invoice which has been cancelled by current invoice.  */  
   RefCancelled:number,
      /**  Value of this field is reference to invoice that cancelled this invoice.  */  
   RefCancelledBy:number,
      /**  An internal flag to indicate if this invoice was created by the Open Invoice Load program.  These records are not maintainable/viewable via invoice entry.  */  
   StartUp:boolean,
      /**  Contains the "list" of due dates for the scheduled payments. Delimited by the character defined in the "List-Delim" variable.  */  
   PayDates:string,
      /**  The scheduled payment amounts. Corresponds with the PayDates list. Delimited by the character defined in the "list-delim" variable.  */  
   PayAmounts:string,
      /**  The scheduled payment amounts. Corresponds with the PayDates list. Delimited by the character defined in the "list-delim" variable.  */  
   DocPayAmounts:string,
      /**  Prompt payment discount date. This is calculated based on the Invoice date + Terms.DiscountDays. Not user maintainable. This will default into the cash receipt record if the scheduled due amount is being paid in full.  */  
   PayDiscDate:string,
      /**  Amount of discount that would be given if paid on or before the specified PayDiscDate. Calculated using the Terms.DiscountPercent X Invoice total amount.  */  
   PayDiscAmt:number,
      /**  Amount of discount that would be given if paid on or before the specified PayDiscDate. Calculated using the Terms.DiscountPercent X Invoice total amount.  */  
   DocPayDiscAmt:number,
      /**  Contains the key  value for the Billing Contact. This can be blank or it must be valid in the CUSTCNT  table. Use the CUSTOMER.PRIMBCON as the default.  */  
   BillConNum:number,
      /**  Invoices that are within a data entry group can be put on "Hold". They will not be posted until InvoiceHeld=No.  This flag can be used for whatever the reason the user may wish to keep an invoice in a data entry group from being posted.  The Manufacturing System sets this flag when creating invoices for order line items which had been flagged for "Time & Material Invoicing" (OrderDtl.TMBilling)  */  
   InvoiceHeld:boolean,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**   Exchange rate that will be used for this invoice.  Defaults from
CurrRate.CurrentRate. Conversion rates will be calculated as System Base = Foreign value * rate, Foreign value = system base * (1/rate). This is the dollar in foreign currency from the exchange rate tables in the newspapers.  */  
   ExchangeRate:number,
      /**  Used with the currency module.  When TRUE the currency rate can be changed by the user and cannot be changed by the system.  This will also be the default for the invoice.  */  
   LockRate:boolean,
      /**   Journal number that invoice was posted to.  This can also be thought of as the Voucher Number. If ARSyst.ARVoucherInvoices = Yes then this value will be printed on the Invoice.
Note: applicable only when posted to G/L.  */  
   JournalNum:number,
      /**  Journal that invoice was posted to.  */  
   JournalCode:string,
      /**  Used to differentiate between invoiced with standard lines which are for parts "PART"  and lines for service calls  "CALL" .  */  
   LineType:string,
      /**   The RMA number which generated this Credit Memo.
Note: This only applies to Credit Memos. 
It is assigned as part of the Request Credit process for an RMA and is not directly maintainable by Invoice Entry.  */  
   RMANum:number,
      /**  The Site that the invoice is relate to.  */  
   Plant:string,
      /**  The member's name on the credit card.  */  
   CardMemberName:string,
      /**  The credit card account identifier.  */  
   CardNumber:string,
      /**  A code assigned by the user to uniquely identify a Credit Card Type master. This can't be blank.  */  
   CardType:string,
      /**  The expiration month of the credit card.  */  
   ExpirationMonth:number,
      /**  The expiration year of the credit card.  */  
   ExpirationYear:number,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention.  */  
   CardID:string,
      /**  Up to 17 alphnumeric characters provided by customer. This is used to track information on customer spending (e.g., cost center, project code). This field is especially critical, since inaccurate information will affect the general ledger. If no reference number is provided, leave this field blank.  */  
   CardmemberReference:string,
      /**  The Legal Number for the record.  This number is created based on setup parameters in table LegalNumber.  */  
   LegalNumber:string,
      /**  External Identifier  */  
   ExternalID:string,
      /**  Cross reference invoice number used when converting data from another ERP system when the previous system data has alphanumeric content.  This field is not used by MfgSys.  This field can be used in searches and can be added to screens through customization.  */  
   XRefInvoiceNum:string,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   DepGainLoss:number,
      /**  For the Debit Note invoices this field contains the detail comments for the Debit Note. For the regular invoices this field contains the list of Debit Notes related to this invoice.  */  
   DNComments:string,
      /**  For the Debit Note invoice this field contains A Debit Note number assigned by the customer. The Debit Note number is supposed to be unique for the customer.  */  
   DNCustNbr:string,
      /**   Indicates the type of documents. Yes = Debit Note. This value can't be changed (the record is created on Invoice payment posting).
Debit Notes  also have the InvoiceSuffix field = "DN".  */  
   DebitNote:boolean,
      /**  This is populated from ShipHead.CustNum representing the Sold To customer.  */  
   SoldToCustNum:number,
      /**  Default is false.  This is only set to true if this invoice was generated via Get Shipments and shipments were combined based on common Bill To customer.  This is used by ARInvoice Entry to properly enable/disable Bill To customer field (InvcHead.CustNum) and to identify the record as a consolidated Invoice.  */  
   Consolidated:boolean,
      /**  If InvcHead.CustNum (BillTo) is different from InvcHead.SoldToCustNum (SoldTo), then this field defaults to the CustBillTo (Alt BillTo). InvoiceAddress status and SoldToInvoiceAddress is set to the opposite status.  */  
   BillToInvoiceAddress:boolean,
      /**  Always the opposite status of BillToInvoiceAddress.  If true, Invoice address for printing will use the Bill To address on the Sold-to customer.  If false, will use the Bill To address of the Bill to customer.  */  
   SoldToInvoiceAddress:boolean,
      /**  Stores the encrypted credit card number  */  
   ProcessCard:string,
      /**  Contains the total commission amount for the corresponding sales rep (SalesRepList). This total is NOT MAINTAINABLE. It is updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain this total;  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount) * RepSplit) * RepRate).  */  
   RepComm1:number,
      /**  Contains the total commission amount for the corresponding sales rep (SalesRepList). This total is NOT MAINTAINABLE. It is updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain this total;  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount) * RepSplit) * RepRate).  */  
   RepComm2:number,
      /**  Contains the total commission amount for the corresponding sales rep (SalesRepList). This total is NOT MAINTAINABLE. It is updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain this total;  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount) * RepSplit) * RepRate).  */  
   RepComm3:number,
      /**  Contains the total commission amount for the corresponding sales rep (SalesRepList). This total is NOT MAINTAINABLE. It is updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain this total;  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount) * RepSplit) * RepRate).  */  
   RepComm4:number,
      /**  Contains the total commission amount for the corresponding sales rep (SalesRepList). This total is NOT MAINTAINABLE. It is updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain this total;  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount) * RepSplit) * RepRate).  */  
   RepComm5:number,
      /**  Establishes the default commission rates used for invoice line items. Defaults to OrderHed.RepRate if related to sales order.  */  
   RepRate1:number,
      /**  Establishes the default commission rates used for invoice line items. Defaults to OrderHed.RepRate if related to sales order.  */  
   RepRate2:number,
      /**  Establishes the default commission rates used for invoice line items. Defaults to OrderHed.RepRate if related to sales order.  */  
   RepRate3:number,
      /**  Establishes the default commission rates used for invoice line items. Defaults to OrderHed.RepRate if related to sales order.  */  
   RepRate4:number,
      /**  Establishes the default commission rates used for invoice line items. Defaults to OrderHed.RepRate if related to sales order.  */  
   RepRate5:number,
      /**  An array of five elements containing the total invoice sales amount for the corresponding sales reps (SalesRepList). These totals are NOT MAINTAINABLE. They are updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain these totals:  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount . NOTE: miscellaneous charges/credits are NOT part of the sales total.  */  
   RepSales1:number,
      /**  An array of five elements containing the total invoice sales amount for the corresponding sales reps (SalesRepList). These totals are NOT MAINTAINABLE. They are updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain these totals:  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount . NOTE: miscellaneous charges/credits are NOT part of the sales total.  */  
   RepSales2:number,
      /**  An array of five elements containing the total invoice sales amount for the corresponding sales reps (SalesRepList). These totals are NOT MAINTAINABLE. They are updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain these totals:  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount . NOTE: miscellaneous charges/credits are NOT part of the sales total.  */  
   RepSales3:number,
      /**  An array of five elements containing the total invoice sales amount for the corresponding sales reps (SalesRepList). These totals are NOT MAINTAINABLE. They are updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain these totals:  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount . NOTE: miscellaneous charges/credits are NOT part of the sales total.  */  
   RepSales4:number,
      /**  An array of five elements containing the total invoice sales amount for the corresponding sales reps (SalesRepList). These totals are NOT MAINTAINABLE. They are updated via write triggers on the InvcDtl record.  The following basic formula is used to maintain these totals:  If InvcDtl.Commissionable = Yes then the sales amount to accumulate is calculated as (((ShipQty/PriceFactor) * UnitPrice) - Discount . NOTE: miscellaneous charges/credits are NOT part of the sales total.  */  
   RepSales5:number,
      /**  Default Split percent for the invoice detail lines.  If related to a sales order then defaults to the OrderHed.RepSplit.  */  
   RepSplit1:number,
      /**  Default Split percent for the invoice detail lines.  If related to a sales order then defaults to the OrderHed.RepSplit.  */  
   RepSplit2:number,
      /**  Default Split percent for the invoice detail lines.  If related to a sales order then defaults to the OrderHed.RepSplit.  */  
   RepSplit3:number,
      /**  Default Split percent for the invoice detail lines.  If related to a sales order then defaults to the OrderHed.RepSplit.  */  
   RepSplit4:number,
      /**  Default Split percent for the invoice detail lines.  If related to a sales order then defaults to the OrderHed.RepSplit.  */  
   RepSplit5:number,
      /**  Indicates if the Credit Memo is for a Rebate  */  
   CMType:string,
      /**  Address used during AVS validation for credit transactions  */  
   CCStreetAddr:string,
      /**  Zip used during AVS validation in credit transactions  */  
   CCZip:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  This flag will be used to indicate if the invoice is ready for calculations. When set to true, tax calculations will take place whenever a save takes place for any tables tied to the invoice which could affect taxes (InvcDtl, InvcHead, InvcMisc, etc). It defaults from ARSyst.InvcReadyToCalcDflt field when an invoice is created.  */  
   ReadyToCalc:boolean,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**  Defines if this document is marked as EDI Ready  */  
   EDIReady:boolean,
      /**  used to force the recalc of an invoice before posting due to changes in tax connect data that could not be resolved at the time the change was made to the Epicor data.  */  
   RecalcBeforePost:boolean,
      /**  Rounding in Base is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   Rounding:number,
      /**  Rounding in Customer currency  */  
   DocRounding:number,
      /**  Reporting currency value of this field  */  
   Rpt1DepositCredit:number,
      /**  Reporting currency value of this field  */  
   Rpt2DepositCredit:number,
      /**  Reporting currency value of this field  */  
   Rpt3DepositCredit:number,
      /**  Reporting currency value of this field  */  
   Rpt1InvoiceAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2InvoiceAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3InvoiceAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1InvoiceBal:number,
      /**  Reporting currency value of this field  */  
   Rpt2InvoiceBal:number,
      /**  Reporting currency value of this field  */  
   Rpt3InvoiceBal:number,
      /**  Reporting currency value of this field  */  
   Rpt1PayAmounts:string,
      /**  Reporting currency value of this field  */  
   Rpt2PayAmounts:string,
      /**  Reporting currency value of this field  */  
   Rpt3PayAmounts:string,
      /**  Reporting currency value of this field  */  
   Rpt1PayDiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2PayDiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3PayDiscAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt2Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt3Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt1UnpostedBal:number,
      /**  Reporting currency value of this field  */  
   Rpt2UnpostedBal:number,
      /**  Reporting currency value of this field  */  
   Rpt3UnpostedBal:number,
      /**  Unique identifier  */  
   RateGrpCode:string,
      /**  Amount of deposit applied  */  
   DocDepApplied:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   Rpt1DepGainLoss:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   Rpt2DepGainLoss:number,
      /**  Wherever the Less Advanced or Less Deposited is calculated, put any gain-loss difference into this field.  */  
   Rpt3DepGainLoss:number,
      /**  The date this invoice will get applied to the books when it is posted.  */  
   ApplyDate:string,
      /**  Fiscal year suffix.  */  
   FiscalYearSuffix:string,
      /**  The fiscal calendar year/suffix/period were derived from.  */  
   FiscalCalendarID:string,
      /**  Tax point  */  
   TaxPoint:string,
      /**  Date Used to calculate Tax Rates  */  
   TaxRateDate:string,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**  The last date finance/late charges have been calculated for this invoice.  */  
   LastChrgCalcDate:string,
      /**  Transaction document type id.  */  
   TranDocTypeID:string,
      /**  Total Finance Charge amount.  */  
   TotFinChrg:number,
      /**  Indicates if the document has been printed.  */  
   DocumentPrinted:boolean,
      /**  Contains the "list" of pay discount days for the scheduled discounts. Delimited by the character defined in the "List-Delim" variable.  */  
   PayDiscDays:string,
      /**  The discount percents. Corresponds with the PayDisDays list. Delimited by the character defined in the "list-delim" variable.  */  
   PayDiscPer:string,
      /**  Blocks certain invoice from generating finance/later charge.  */  
   BlockedFinChrg:boolean,
      /**  Reason why invoice has been blocked generating finance/later charge and only is enabled if the invoice is blocked.  */  
   BlockedFinChrgReason:string,
      /**  Withholding Tax Amount.  */  
   WithholdAmt:number,
      /**  Withholding Tax Amount.  */  
   DocWithholdAmt:number,
      /**  Withholding Tax Amount.  */  
   Rpt1WithholdAmt:number,
      /**  Withholding Tax Amount.  */  
   Rpt2WithholdAmt:number,
      /**  Withholding Tax Amount.  */  
   Rpt3WithholdAmt:number,
      /**  Blocks certain invoice from being printed on reminder letters.  */  
   BlockedRemLetters:boolean,
      /**  Field to define when apply the discount percentage, can be when invoice is paid in full or Cash amount  */  
   PayDiscPartPay:boolean,
      /**  Reason why invoice has been blocked from being printed on reminder letters and only is enabled if the invoice is blocked.  */  
   BlockedRemLettersReason:string,
      /**  The actual ship date for the packing slip. Default as system date.  */  
   ShipDate:string,
      /**  Currency Rate Date  */  
   CurrRateDate:string,
      /**   Indicates if the invoice has been paid by a Payment Instrument.
Values:
blank = Not linked to a Payment Instrument
"O" = Paid by outstanding Payment Instrument
"C" = Paid by colledted Payment instument  */  
   PIPayment:string,
      /**  Unique identifier of the payment method  */  
   PMUID:number,
      /**  If TRUE taxes will be calculated based on the Alternate Bill To, if FALSE it will proceed normally.  */  
   UseAltBillTo:boolean,
      /**  Indicates that the tax is included in the unit price  */  
   InPrice:boolean,
      /**  Will be se to Yes if the Invoice was created by the Correction (Reversing) logic.  */  
   CorrectionInv:boolean,
      /**  Tax Rate Group Code  */  
   TaxRateGrpCode:string,
      /**  Locks Tax Rate and allows user to edit the tax exchange rate  */  
   LockTaxRate:boolean,
      /**  Sweden Finland Localization field - Banking Reference  */  
   SEBankRef:string,
      /**  Government Uniform Invoice Tax Type Code (Taiwan Localization field)  */  
   GUITaxTypeCode:string,
      /**  Government Uniform Invoice Format Code (Taiwan Localization field)  */  
   GUIFormatCode:string,
      /**  Government Uniform Invoice Deduct Code (Taiwan Localization field)  */  
   GUIDeductCode:string,
      /**  Reversal Doucment Amount  */  
   ReversalDocAmount:number,
      /**  Original Due Date at posting time  */  
   OrigDueDate:string,
      /**  The reference to CashHead.HeadNum.Used in deposit invoices  */  
   HeadNum:number,
      /**  Letter of Credit ID.  */  
   ARLOCID:string,
      /**  The free text field which can contain reference (such as Contract)  */  
   ContractRef:string,
      /**  Bank for Cash receipts. For Shipment Invoices it comes from Packing Slip. For Deposit Invoices created based on deposit payments it is actual bank money are received to. For other  Invoice types, default comes from 1) Sales Order 2) Bill To Customer 3) System default (Company).  */  
   OurBank:string,
      /**  Addition to Contract  */  
   ContractDate:string,
      /**  If the invoice was generated in Project Billing then it is reference to the project.  */  
   PBProjectID:string,
      /**  Deposit amount is transaction amount of deposit payment  */  
   DepositAmt:number,
      /**   Taiwan Localization
Export Bill Number  */  
   GUIExportBillNumber:string,
      /**  Deposit amount is transaction amount of deposit payment in document currency  */  
   DocDepositAmt:number,
      /**   Taiwan Localization
Date of Export  */  
   GUIDateOfExport:string,
      /**  Deposit amount is transaction amount of deposit payment in Rpt1 currency  */  
   Rpt1DepositAmt:number,
      /**   Taiwan Localization
Export Type  */  
   GUIExportType:string,
      /**  Deposit amount is transaction amount of deposit payment in Rpt2 currency  */  
   Rpt2DepositAmt:number,
      /**   Taiwan Localization
Export Mark  */  
   GUIExportMark:string,
      /**  Deposit amount is transaction amount of deposit payment in Rpt23currency  */  
   Rpt3DepositAmt:number,
      /**   Taiwan Localization
Export Bill Type  */  
   GUIExportBillType:string,
      /**  Deposit unallocated amount in base currency  */  
   DepUnallocatedAmt:number,
      /**  Day when a company sums up accounts receivables for each customer.  */  
   SummarizationDate:string,
      /**  Deposit unallocated amount in document currency  */  
   DocDepUnallocatedAmt:number,
      /**  Date when a company bills the customer  */  
   BillingDate:string,
      /**  Deposit unallocated amount in Rpt1 currency  */  
   Rpt1DepUnallocatedAmt:number,
      /**  Billing Number to be generated from Legal Numbering upon printing of billing statement.  */  
   BillingNumber:string,
      /**  Deposit unallocated amount in Rpt2 currency  */  
   Rpt2DepUnallocatedAmt:number,
      /**  Only records ready to bill will be printed in the Billing Statement  */  
   ReadyToBill:boolean,
      /**  Deposit unallocated amount in Rpt3 currency  */  
   Rpt3DepUnallocatedAmt:number,
      /**  Flag to indicate if the DefTaxDate will be overwritten when Tax Point change on Invoice Header.  */  
   OvrDefTaxDate:boolean,
      /**  Cross Reference Contract Number.  */  
   XRefContractNum:string,
      /**  Cross Reference Contract Date.  */  
   XRefContractDate:string,
      /**  Main Site  */  
   MainSite:boolean,
      /**  Site Code  */  
   SiteCode:string,
      /**  Branch ID  */  
   BranchID:string,
      /**  Customer Agent Name  */  
   CustAgentName:string,
      /**  Customer Agent Tax Region Number  */  
   CustAgentTaxRegNo:string,
      /**  Export Type: 0-No Export, 1-Normal Export(S04), 2-Material Export(S05), 3-Service Export(S06)  */  
   ExportType:string,
      /**  Export Report Number  */  
   ExportReportNo:string,
      /**  Real Estate Number  */  
   RealEstateNo:string,
      /**  Excluded  */  
   Excluded:boolean,
      /**  Deferred  */  
   Deferred:boolean,
      /**  CycleCode  */  
   CycleCode:string,
      /**  Duration  */  
   Duration:number,
      /**  EndDate  */  
   EndDate:string,
      /**  MaxValueAmt  */  
   MaxValueAmt:number,
      /**  DocMaxValueAmt  */  
   DocMaxValueAmt:number,
      /**  Rpt1MaxValueAmt  */  
   Rpt1MaxValueAmt:number,
      /**  Rpt2MaxValueAmt  */  
   Rpt2MaxValueAmt:number,
      /**  Rpt3MaxValueAmt  */  
   Rpt3MaxValueAmt:number,
      /**  HoldInvoice  */  
   HoldInvoice:boolean,
      /**  CopyLatestInvoice  */  
   CopyLatestInvoice:boolean,
      /**  OverrideEndDate  */  
   OverrideEndDate:boolean,
      /**  CycleInactive  */  
   CycleInactive:boolean,
      /**  RecurSource  */  
   RecurSource:boolean,
      /**  InstanceNum  */  
   InstanceNum:number,
      /**  RecurBalance  */  
   RecurBalance:number,
      /**  DocRecurBalance  */  
   DocRecurBalance:number,
      /**  Rpt1RecurBalance  */  
   Rpt1RecurBalance:number,
      /**  Rpt2RecurBalance  */  
   Rpt2RecurBalance:number,
      /**  Rpt3RecurBalance  */  
   Rpt3RecurBalance:number,
      /**  LastDate  */  
   LastDate:string,
      /**  RecurringState  */  
   RecurringState:string,
      /**  IsRecurring  */  
   IsRecurring:boolean,
      /**  InvoiceNumList  */  
   InvoiceNumList:string,
      /**  IsAddedToGTI  */  
   IsAddedToGTI:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  CHISRCodeLine  */  
   CHISRCodeLine:string,
      /**  CMReason  */  
   CMReason:string,
      /**  THIsImmatAdjustment  */  
   THIsImmatAdjustment:boolean,
      /**  AGAuthorizationCode  */  
   AGAuthorizationCode:string,
      /**  AGAuthorizationDate  */  
   AGAuthorizationDate:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  AGDocumentLetter  */  
   AGDocumentLetter:string,
      /**  AGInvoicingPoint  */  
   AGInvoicingPoint:string,
      /**  AGLegalNumber  */  
   AGLegalNumber:string,
      /**  AGPrintingControlType  */  
   AGPrintingControlType:string,
      /**  RevisionDate  */  
   RevisionDate:string,
      /**  RevisionNum  */  
   RevisionNum:number,
      /**  TWDeclareYear  */  
   TWDeclareYear:number,
      /**  TWDeclarePeriod  */  
   TWDeclarePeriod:number,
      /**  TWGenerationType  */  
   TWGenerationType:string,
      /**  TWGUIGroup  */  
   TWGUIGroup:string,
      /**  TWPeriodPrefix  */  
   TWPeriodPrefix:string,
      /**  Indicates if the Invoice is in Collections status  */  
   InvInCollections:boolean,
      /**   Indicates if the Customer of the Invoice is in Collections
(Peru Localization)  */  
   CollectionsCust:boolean,
      /**  A counter of the number of times an AR Invoice has been transmitted via EDI.  The counter is automatically incremented each time the EDIReady flag changes from False to True.  */  
   CounterARForm:number,
      /**  flag indicates if Revenue of the invoice has been already posted  */  
   PostedRecog:boolean,
      /**  Confirmation Date  */  
   CNConfirmDate:string,
      /**  MXSATSeal  */  
   MXSATSeal:string,
      /**  MXSerie  */  
   MXSerie:string,
      /**  MXTaxRcptType  */  
   MXTaxRcptType:string,
      /**  MXFiscalFolio  */  
   MXFiscalFolio:string,
      /**  MXTotalPayments  */  
   MXTotalPayments:number,
      /**  MXFolio  */  
   MXFolio:string,
      /**  MXCertifiedTimestamp  */  
   MXCertifiedTimestamp:string,
      /**  MXSATCertificateSN  */  
   MXSATCertificateSN:string,
      /**  MXDigitalSeal  */  
   MXDigitalSeal:string,
      /**  MXPostedTimeStamp  */  
   MXPostedTimeStamp:string,
      /**  MXCertificate  */  
   MXCertificate:string,
      /**  MXApprovalYear  */  
   MXApprovalYear:number,
      /**  MXCBB  */  
   MXCBB:string,
      /**  MXApprovalNum  */  
   MXApprovalNum:number,
      /**  MXOriginalStringTFD  */  
   MXOriginalStringTFD:string,
      /**  MXPaymentNum  */  
   MXPaymentNum:number,
      /**  MXPaidAs  */  
   MXPaidAs:string,
      /**  MXCertificateSN  */  
   MXCertificateSN:string,
      /**  MXOriginalAmount  */  
   MXOriginalAmount:number,
      /**  MXAccountNumber  */  
   MXAccountNumber:string,
      /**  MXOriginalDate  */  
   MXOriginalDate:string,
      /**  MXOriginalSeries  */  
   MXOriginalSeries:string,
      /**  MXOriginalFolio  */  
   MXOriginalFolio:string,
      /**  MXTaxRegime  */  
   MXTaxRegime:string,
      /**  MXOriginalString  */  
   MXOriginalString:string,
      /**  MXPaymentName  */  
   MXPaymentName:string,
      /**  EInvoice  */  
   EInvoice:boolean,
      /**  EInvStatus  */  
   EInvStatus:number,
      /**  EInvTimestamp  */  
   EInvTimestamp:string,
      /**  EInvUpdatedBy  */  
   EInvUpdatedBy:string,
      /**  EInvException  */  
   EInvException:string,
      /**  Flagged that this invoice has taxes which were necessary or is necessary now.  */  
   WithTaxConfirm:boolean,
      /**  UseAltBillToID  */  
   UseAltBillToID:boolean,
      /**  MXCancelledDate  */  
   MXCancelledDate:string,
      /**  Overpaid  */  
   Overpaid:boolean,
      /**  OrdExchangeRate  */  
   OrdExchangeRate:number,
      /**  PEAPPayNum  */  
   PEAPPayNum:number,
      /**  PEBankNumber  */  
   PEBankNumber:string,
      /**  PECharges  */  
   PECharges:number,
      /**  PECommissions  */  
   PECommissions:number,
      /**  PEDetTaxAmt  */  
   PEDetTaxAmt:number,
      /**  PEDetTaxCurrencyCode  */  
   PEDetTaxCurrencyCode:string,
      /**  PEDischargeAmt  */  
   PEDischargeAmt:number,
      /**  PEDischargeDate  */  
   PEDischargeDate:string,
      /**  PEInterest  */  
   PEInterest:number,
      /**  PENoPayPenalty  */  
   PENoPayPenalty:number,
      /**  CSF Peru - SUNAT Deposit Amount  */  
   PESUNATDepAmt:number,
      /**  CSF Peru - SUNAT Deposit Date  */  
   PESUNATDepDate:string,
      /**  CSF Peru -  SUNAT Deposit Number  */  
   PESUNATDepNum:string,
      /**  PEBOEPosted  */  
   PEBOEPosted:boolean,
      /**  DocPEInterest  */  
   DocPEInterest:number,
      /**  DocPECommissions  */  
   DocPECommissions:number,
      /**  DocPECharges  */  
   DocPECharges:number,
      /**  DocPENoPayPenalty  */  
   DocPENoPayPenalty:number,
      /**  DocPEDischargeAmt  */  
   DocPEDischargeAmt:number,
      /**  DocPEDetTaxAmt  */  
   DocPEDetTaxAmt:number,
      /**  Rpt1PEInterest  */  
   Rpt1PEInterest:number,
      /**  Rpt1PECommissions  */  
   Rpt1PECommissions:number,
      /**  Rpt1PECharges  */  
   Rpt1PECharges:number,
      /**  Rpt1PENoPayPenalty  */  
   Rpt1PENoPayPenalty:number,
      /**  Rpt1PEDischargeAmt  */  
   Rpt1PEDischargeAmt:number,
      /**  Rpt2PEInterest  */  
   Rpt2PEInterest:number,
      /**  Rpt2PECommissions  */  
   Rpt2PECommissions:number,
      /**  Rpt2PECharges  */  
   Rpt2PECharges:number,
      /**  Rpt2PENoPayPenalty  */  
   Rpt2PENoPayPenalty:number,
      /**  Rpt2PEDischargeAmt  */  
   Rpt2PEDischargeAmt:number,
      /**  Rpt3PEInterest  */  
   Rpt3PEInterest:number,
      /**  Rpt3PECommissions  */  
   Rpt3PECommissions:number,
      /**  Rpt3PECharges  */  
   Rpt3PECharges:number,
      /**  Rpt3PENoPayPenalty  */  
   Rpt3PENoPayPenalty:number,
      /**  Rpt3PEDischargeAmt  */  
   Rpt3PEDischargeAmt:number,
      /**  Our Supplier Code  */  
   OurSupplierCode:string,
      /**  PEGuaranteeName  */  
   PEGuaranteeName:string,
      /**  PEGuaranteeAddress1  */  
   PEGuaranteeAddress1:string,
      /**  PEGuaranteeAddress2  */  
   PEGuaranteeAddress2:string,
      /**  PEGuaranteeAddress3  */  
   PEGuaranteeAddress3:string,
      /**  PEGuaranteeCity  */  
   PEGuaranteeCity:string,
      /**  PEGuaranteeState  */  
   PEGuaranteeState:string,
      /**  PEGuaranteeZip  */  
   PEGuaranteeZip:string,
      /**  PEGuaranteeCountry  */  
   PEGuaranteeCountry:string,
      /**  PEGuaranteeTaxID  */  
   PEGuaranteeTaxID:string,
      /**  PEGuaranteePhoneNum  */  
   PEGuaranteePhoneNum:string,
      /**  PEBOEStatus  */  
   PEBOEStatus:string,
      /**  PEBOEIsMultiGen  */  
   PEBOEIsMultiGen:boolean,
      /**  PE Reference Document ID  */  
   PERefDocID:string,
      /**  PE Reason Code  */  
   PEReasonCode:string,
      /**  PE Reason Description  */  
   PEReasonDesc:string,
      /**  TW GUI Code Seller  */  
   TWGUIRegNumSeller:string,
      /**  TW GUI Code Buyer  */  
   TWGUIRegNumBuyer:string,
      /**  Document Name  */  
   TWGUIExportDocumentName:string,
      /**  Remarks  */  
   TWGUIExportRemarks:string,
      /**  Verification  */  
   TWGUIExportVerification:string,
      /**  PEDebitNoteReasonCode  */  
   PEDebitNoteReasonCode:string,
      /**  PEDebitNote  */  
   PEDebitNote:boolean,
      /**  MXPartPmt  */  
   MXPartPmt:boolean,
      /**  Tax Invoice Type  */  
   CNTaxInvoiceType:number,
      /**  MXExportOperationType  */  
   MXExportOperationType:string,
      /**  MXExportCustDocCode  */  
   MXExportCustDocCode:string,
      /**  MXExportCertOriginNum  */  
   MXExportCertOriginNum:string,
      /**  MXExportConfNum  */  
   MXExportConfNum:string,
      /**  MXExportCertOrigin  */  
   MXExportCertOrigin:boolean,
      /**  MXIncoterm  */  
   MXIncoterm:string,
      /**  AGDocConcept  */  
   AGDocConcept:number,
      /**  Electronic Invoice reference number  */  
   EInvRefNum:string,
      /**  Export document reference number  */  
   ExportDocRefNum:string,
      /**  Export document date  */  
   ExportDocDate:string,
      /**  Tax Transaction ID  */  
   INTaxTransactionID:string,
      /**  MXMovingReasonFlag  */  
   MXMovingReasonFlag:boolean,
      /**  MXMovingReason  */  
   MXMovingReason:string,
      /**  MXNumRegIdTrib  */  
   MXNumRegIdTrib:string,
      /**  MXResidenCountryNum  */  
   MXResidenCountryNum:number,
      /**  MXPurchaseType  */  
   MXPurchaseType:string,
      /**  MXConfirmationCode  */  
   MXConfirmationCode:string,
      /**  MXExternalCode  */  
   MXExternalCode:string,
      /**  This invoice was created via an integration with a third-party field service.  */  
   ServiceInvoice:boolean,
      /**  MXDomesticTransfer  */  
   MXDomesticTransfer:boolean,
      /**  MXCancellationMode  */  
   MXCancellationMode:string,
      /**  Shipping Port Code  */  
   INShippingPortCode:string,
      /**  Export Procedure  */  
   INExportProcedure:string,
      /**  CreatedOn  */  
   CreatedOn:string,
      /**  DigitalSignature  */  
   DigitalSignature:string,
      /**  SignedOn  */  
   SignedOn:string,
      /**  SignedBy  */  
   SignedBy:string,
      /**  FirstPrintDate  */  
   FirstPrintDate:string,
      /**  DocCopyNum  */  
   DocCopyNum:number,
      /**  DepositBalance  */  
   DepositBalance:number,
      /**  DocDepositBalance  */  
   DocDepositBalance:number,
      /**  Rpt1DepositBalance  */  
   Rpt1DepositBalance:number,
      /**  Rpt2DepositBalance  */  
   Rpt2DepositBalance:number,
      /**  Rpt3DepositBalance  */  
   Rpt3DepositBalance:number,
      /**  Quote number to which this invoice record is associated with.  */  
   QuoteNum:number,
      /**  The help desk case related to this invoice.  */  
   HDCaseNum:number,
      /**  Indicates that the credit hold was overridden for this invoice.  */  
   CreditOverride:boolean,
      /**  Description	Indicates that the credit hold was overridden for this invoice.	The date and time the user override the invoice credit hold.  */  
   CreditOverrideDate:string,
      /**  The user id that override the invoice credit hold.  */  
   CreditOverrideUserID:string,
      /**  Indicates the invoice is on credit hold.  Applicable to miscellaneous invoices only.  */  
   CreditHold:boolean,
      /**  Peru Electronic Invoice XML Type  */  
   PEXMLType:number,
      /**  COCreditMemoReasonCode  */  
   COCreditMemoReasonCode:string,
      /**  CODebitMemoReasonCode  */  
   CODebitMemoReasonCode:string,
      /**  COReasonDesc  */  
   COReasonDesc:string,
      /**  CODebitNote  */  
   CODebitNote:boolean,
      /**  PEDetractionTranNum  */  
   PEDetractionTranNum:number,
      /**  PEProductCode  */  
   PEProductCode:string,
      /**  PECollectionGroupID  */  
   PECollectionGroupID:string,
      /**  PE Caption Code  */  
   PECaptionCode:string,
      /**  PE Caption Code Description  */  
   PECaption:string,
      /**  PE Reference DocumentType 1  */  
   PERefDocumentType:string,
      /**  PE Reference Document Number 1  */  
   PERefDocumentNumber:string,
      /**  PE Detraction good or service code  */  
   PEDetrGoodServiceCode:string,
      /**  PE Reference DocumentType 2  */  
   PERefDocumentType2:string,
      /**  PE Reference DocumentType 3  */  
   PERefDocumentType3:string,
      /**  PE Reference DocumentType 4  */  
   PERefDocumentType4:string,
      /**  PE Reference DocumentType 5  */  
   PERefDocumentType5:string,
      /**  PE Reference Document Number 2  */  
   PERefDocumentNumber2:string,
      /**  PE Reference Document Number 3  */  
   PERefDocumentNumber3:string,
      /**  PE Reference Document Number 4  */  
   PERefDocumentNumber4:string,
      /**  PE Reference Document Number 5  */  
   PERefDocumentNumber5:string,
      /**  E-invoice  */  
   ELIEInvoice:boolean,
      /**  Status of E-invoice (1 - Open, 2 - Generated, 3 - Sent, 4 - Error).  */  
   ELIEInvStatus:number,
      /**  User Id of the person generated E-invoice.  */  
   ELIEInvUpdatedBy:string,
      /**  E-invoice error description.  */  
   ELIEInvException:string,
      /**  Date and Time of E-invoice generation.  */  
   ELIEInvUpdatedOn:string,
      /**  COOperType  */  
   COOperType:string,
      /**  Flag that indicates if the Invoice is for Central Collection.  */  
   CentralCollection:boolean,
      /**  Company that created this invoice.  */  
   CColChildCompany:string,
      /**  Central Collection company.  */  
   CColParentCompany:string,
      /**  Order number on the invoicing company.  */  
   CColOrderNum:number,
      /**  Invoice number on the invoicing company.  */  
   CColChildInvoiceNum:number,
      /**  Invoice number on central collection company  */  
   CColInvoiceNum:number,
      /**  Legal number on the invoicing company invoice.  */  
   CColChildLegalNumber:string,
      /**  Legal number on central collection company.  */  
   CColLegalNumber:string,
      /**  Invoice reference on the Invoicing Company.  */  
   CColInvoiceRef:number,
      /**  Invoice Balance in the Central Collection company.  */  
   CColInvBal:number,
      /**  Central Collection Doc Invoice Balance.  */  
   DocCColInvBal:number,
      /**  Invoice Amount on the Invoicing Company.  */  
   CColInvAmt:number,
      /**  Invoice Amount on the Invoicing Company.  */  
   DocCColInvAmt:number,
      /**  Rpt 1 Parent Invoice Balance  */  
   Rpt1CColInvBal:number,
      /**  Rpt 2 Parent Invoice Balance  */  
   Rpt2CColInvBal:number,
      /**  Rpt 3 Parent Invoice Balance  */  
   Rpt3CColInvBal:number,
      /**  Rpt 1 Child Invoice Amount  */  
   Rpt1CColInvAmt:number,
      /**  Rpt 2 Child Invoice Amount  */  
   Rpt2CColInvAmt:number,
      /**  Rpt 3 Child Invoice Amount  */  
   Rpt3CColInvAmt:number,
      /**  Id of the netting transaction that generated this document.  */  
   NettingID:number,
      /**  User terminal name  */  
   ELIEInvTerminalName:string,
      /**  User terminal IP  */  
   ELIEInvTerminalIP:string,
      /**  GL Description  */  
   Description:string,
      /**  WithholdAcctToInterim  */  
   WithholdAcctToInterim:boolean,
      /**  Indicates if the Central Collection parent invoice is open.  */  
   CColOpenInvoice:boolean,
      /**  AGQRCodeData  */  
   AGQRCodeData:string,
      /**  Exempt Reason Code  */  
   ExemptReasonCode:string,
      /**  EInvoice ID  */  
   ELIEInvID:string,
      /**  this is a link to the service call that this invoice is for.  Linetype = "CALL"  */  
   CallNum:number,
      /**  this is a link to the service call line that this invoice is for.  Linetype = "CALL"  */  
   CallLine:number,
      /**  Associates the Call Line record back its linked jobnum  */  
   JobNum:string,
      /**  MXCancelReasonCode  */  
   MXCancelReasonCode:string,
      /**  MXSubstInvoiceNum  */  
   MXSubstInvoiceNum:number,
      /**  MXExportType  */  
   MXExportType:string,
      /**  MXGlobalInvoicePeriod  */  
   MXGlobalInvoicePeriod:string,
      /**  MXGlobalInvoiceMonth  */  
   MXGlobalInvoiceMonth:string,
      /**  ELIEInvServiceProviderStatus  */  
   ELIEInvServiceProviderStatus:number,
      /**  Incoterm Code  */  
   IncotermCode:string,
      /**  Incoterm Location  */  
   IncotermLocation:string,
      /**  CovenantDiscPercent  */  
   CovenantDiscPercent:number,
      /**  TotalCovenantDiscount  */  
   TotalCovenantDiscount:number,
      /**  DocCovenantDiscount  */  
   DocCovenantDiscount:number,
      /**  Rpt1CovenantDiscount  */  
   Rpt1CovenantDiscount:number,
      /**  Rpt2CovenantDiscount  */  
   Rpt2CovenantDiscount:number,
      /**  Rpt3CovenantDiscount  */  
   Rpt3CovenantDiscount:number,
      /**  TotalInCovenantDiscount  */  
   TotalInCovenantDiscount:number,
      /**  DocInCovenantDiscount  */  
   DocInCovenantDiscount:number,
      /**  Rpt1InCovenantDiscount  */  
   Rpt1InCovenantDiscount:number,
      /**  Rpt2InCovenantDiscount  */  
   Rpt2InCovenantDiscount:number,
      /**  Total advanced billing amount.  */  
   ABAmt:number,
      /**  Indicates if changes can occur after the document has been printed  */  
   AllowChgAfterPrint:boolean,
      /**  Rpt3InCovenantDiscount  */  
   Rpt3InCovenantDiscount:number,
      /**  ARPNHead's HeadNum  */  
   ARPNHeadNum:number,
      /**  when InvcHead.PIPayment = O then populate ARPaymentInstrumentID with a value of PI.  */  
   ARPromNoteID:string,
      /**  Auto generate payment instruments  */  
   AutoGenPN:boolean,
      /**  Delimited list of available bill to customers.  */  
   AvailBTCustList:string,
      /**  Used for Bill of Exchange.  Indicates the bank to use when a payment instrument for the invoice is created.  */  
   BankForPI:string,
   BankForPIName:string,
      /**  Customer ID for the bill to customer (InvcHead.CustNum).  */  
   BTCustID:string,
      /**  Bill to customer name.  */  
   BTCustomerName:string,
      /**  The date and time that the record was last changed  */  
   ChangeDateTime:string,
   CNGTIAction:string,
   CNGTIAddress:string,
   CNGTIBankAccount:string,
   CNGTIComment:string,
   CNGTICustomerName:string,
   CNGTIExportAddress:string,
      /**  CSF China, Gross Invoice Amount  */  
   CNGTIGrossInvcAmt:number,
      /**  CSF China, Total invoice amount = InvcHead.InvoiceAmt - InvcHead.WithholdAmt  */  
   CNGTIInvoiceAmt:number,
   CNGTINote:string,
   CNGTIShipToNum:string,
   CNGTIStatus1:string,
   CNGTIStatus2:boolean,
   CNGTITaxCode:string,
      /**  IFRS Calculation. If the checkbox is not checked then all the elements below are disabled. If the checkbox is checked, then some elements below become enabled showing default values so that the NPV can be calculated  */  
   COIFRSCalculation:boolean,
      /**  If true then Colombia IFRS Net Present Value calculation is enabled  */  
   COIFRSEnabled:boolean,
      /**  Financial Charge  */  
   COIFRSFinancialCharge:number,
   COIFRSInterestRate:number,
      /**  Number of Periods for payment  */  
   COIFRSNumberOfPeriods:number,
      /**  Present Value  */  
   COIFRSPresentValue:number,
      /**  Indicates if Invoice is in Collections (Peru localization)  */  
   CollectionsInv:boolean,
      /**  Contact email address.  */  
   ContactEmailAddr:string,
      /**  Contact fax number  */  
   ContactFaxNum:string,
      /**  Contact name  */  
   ContactName:string,
      /**  Contact phone number  */  
   ContactPhoneNum:string,
      /**  record converted from deposit  */  
   ConvertedFromDep:boolean,
   COOperTypeDesc:string,
      /**  True if the Country set for the current company contains an Intrastat code.  */  
   CountryIntrastat:boolean,
   CumulativeBalance:number,
      /**  Currncy switch used to determine what currency to display amounts in.  */  
   CurrencySwitch:boolean,
   CurrentInstanceNum:number,
   CustAllowOTS:boolean,
   CustOnCreditHold:boolean,
      /**  Deposit balance from CashHed  */  
   DepBal:number,
      /**  Deposit credit enabled flag.  */  
   DepositCreditEnabled:boolean,
   DirectDebiting:boolean,
      /**  The flag to indicate if Invoice Header Apply Date is supposed to be Read Only  */  
   DisableAplDate:boolean,
      /**  The net of Invoice Balance and unposted Debit Note value(s) applied to the invoice during one particular Cash Receipt application.  */  
   DispBalDN:number,
      /**  Bill to address in list format.  */  
   DisplayBillAddr:string,
      /**  Display field for the masked credit card number  */  
   DisplayCreditCardNum:string,
   DisplayCurrencyID:string,
      /**  Currency display symbol  */  
   DisplaySymbol:string,
      /**  The unposted Debit Note value(s) applied to the invoice during the particular invoice payment transaction.  */  
   DNPmtAmt:number,
      /**  Document Total advanced billing amount.  */  
   DocABAmt:number,
      /**  Financial Charge  */  
   DocCOIFRSFinancialCharge:number,
      /**  Present Value  */  
   DocCOIFRSPresentValue:number,
   DocCumulativeBalance:number,
      /**  Document deposit amount from cashhead.  */  
   DocDepBal:number,
      /**  The net of Invoice Balance and unposted Debit Note value(s) applied to the invoice during one particular Cash Receipt application.  */  
   DocDispBalDN:number,
      /**  Document display symbol  */  
   DocDisplaySymbol:string,
      /**  The unposted Debit Note value(s) applied to the invoice during the particular invoice payment transaction.  */  
   DocDNPmtAmt:number,
   DocDspPrepDeposit:number,
   DocDspTaxAmt:number,
      /**  CSF Peru - SUNAT Deposit Amount  */  
   DocPESUNATDepAmt:number,
   DocRemainTaxAmt:number,
   DocReverseTaxAmt:number,
   DocSATaxAmt:number,
   DocSourceRecurBalance:number,
      /**  Document sub total  */  
   DocSubTotal:number,
      /**  Document Total tax amount from InvcTax for Collection type 'Invoice'  */  
   DocTaxAmt:number,
      /**  Difference between Deposit Amount from invoice header and Total Line Amount in document currency.  */  
   DocVr:number,
   DocWHTaxAmt:number,
      /**  Display advance billing amount  */  
   DspABAmt:number,
      /**  Display deposit balance.  */  
   DspDepBal:number,
      /**  Display deposit credit.  */  
   DspDepCr:number,
   DspDigitalSignature:string,
      /**  Display document advance billing amount  */  
   DspDocABAmt:number,
      /**  Display document deposit balance  */  
   DspDocDepBal:number,
      /**  Display document deposit credit.  */  
   DspDocDepCr:number,
      /**  Display document invoice amount  */  
   DspDocInvoiceAmt:number,
      /**  Display document invoice balance  */  
   DspDocInvoiceBal:number,
      /**  Display Invoice Doc Rounding  */  
   DspDocRounding:number,
      /**  display document sub total  */  
   DspDocSubTotal:number,
      /**  Display invoice amount  */  
   DspInvoiceAmt:number,
      /**  Display Invoice Balance.  */  
   DspInvoiceBal:number,
      /**  Display invoice reference  */  
   DspInvoiceRef:number,
   DspPayDiscDays:string,
   DspPrepDeposit:number,
      /**  Display Rounding in Base  */  
   DspRounding:number,
      /**  If SoldTo and Alt-Bill to are the same, this displays as null.  */  
   dspSoldToCustID:string,
      /**  Display sub total  */  
   DspSubTotal:number,
   DspTaxAmt:number,
      /**  Indicates if assign legal number option is available.  */  
   EnableAssignLegNum:boolean,
   EnableCentralCollection:boolean,
      /**  Flag to determine if UseSOCCDefaults should be enabled.  */  
   EnableSOCCDefaults:boolean,
      /**  Indicates if TranDocTypeID is available for input.  */  
   EnableTranDocType:boolean,
      /**  Indicates if the void legal number option is available  */  
   EnableVoidLegNum:boolean,
      /**  It will be displayed to identify invoices automatically generated due ERS shipments.  */  
   ERSInvoice:boolean,
      /**  Indicates which date to be used to calculate the exchange rate, I for Invoice Date, A for Apply Date.  */  
   ExchangeRateDate:string,
      /**  Flag for update of InvcHead to allow when group id is "RMACRREQ"  */  
   GenedFromRMA:boolean,
      /**  CustBank record exists for customer  */  
   HasBank:boolean,
      /**  Indicates if a legal number configuration exists for ar invoices/credit memos  */  
   HasLegNumCnfg:boolean,
      /**  In case if Invoice Header Tax Liability is not assigned this flag indicates if any of Invoice lines has Tax inclusive Tax Liability assinged  */  
   InPriceLn:boolean,
      /**  Integration invoice type.  Used for setting of InvoiceType.  */  
   IntInvoiceType:string,
      /**  InvoiceType description  */  
   InvoiceTypeDesc:string,
      /**  Denmark localization external field  */  
   IsDK:boolean,
      /**  Set to true if intrastat is enabled.  */  
   IsIntrastatSensitive:boolean,
   IsLatestRecurrence:boolean,
      /**  shows is this invoice is blocked in RvLock.  */  
   IsLcked:boolean,
      /**  Indicates if the UR Invoice was created from an On Account PI instead of an on account cash receipt.  */  
   IsPIUnappliedReceipt:boolean,
   IsPMForGenPIType:boolean,
   LatestInvoice:number,
      /**  Stores the message when a legal number is generated.  */  
   LegalNumberMessage:string,
      /**  locked means can not be posted: an invoice is already in review journal or in posting process.  */  
   LockStatus:string,
      /**  MXCancellationID  */  
   MXCancellationID:string,
      /**  MXCancellationStatus  */  
   MXCancellationStatus:string,
      /**  It indicates that this Invoice has taxes, for which the confirmation is required.  */  
   NeedConfirmTaxes:boolean,
      /**  This field is to display in Cash Receipt Entry the Discount Date that the payment will take.  */  
   NextDiscDate:string,
      /**  NextInvoiceDate = InvcRecurringCycle.LastDate + RecurringCycle.Interval in RecurringCycle.Modifier units  */  
   NextInvoiceDate:string,
      /**  Pack slip number from the 1st line item.  */  
   PackSlipNum:number,
      /**  Pay schedule enabled flag  */  
   PaySchedEnabled:boolean,
      /**  Indicates what the user will change the status to  */  
   PEBOEChangeStatusTo:string,
   PEBOEStatusDesc:string,
      /**  Peru CSF: Collections date  */  
   PECollectionsDate:string,
      /**  PE Detraction good or service code description  */  
   PEDetrGoodServiceCodeDesc:string,
   PEDspCurrencySymbol:string,
      /**  Peru CSF: No if the invoice is moved out of collections, Yes if the invoice is moved into colletions.  */  
   PEInCollections:boolean,
      /**  PE Document Type Description  */  
   PERefDocumentTypeDesc:string,
      /**  PE Document Type Description 2  */  
   PERefDocumentTypeDesc2:string,
      /**  PE Document Type Description 3  */  
   PERefDocumentTypeDesc3:string,
      /**  PE Document Type Description 4  */  
   PERefDocumentTypeDesc4:string,
      /**  PE Document Type Description 5  */  
   PERefDocumentTypeDesc5:string,
      /**  PI - Bank account  */  
   PIBankAcctID:string,
      /**  PI Customer bank required  */  
   PICustBankDtl:boolean,
      /**  PI Initiation - generated or received  */  
   PIInitiation:string,
      /**  Prep Deposit enabled flag.  */  
   PrepDepositEnabled:boolean,
      /**  The description of the proposed Tax Region  */  
   ProposedTaxRgn:string,
      /**   This field indicates id all the amounts related to the invoice are supposed to be re-calculated on change of the Applate Date.
"R" - the user's answer is recalculate the amounts
"N" the user's answer is  do not recalculate the amount
Blank - user is not asked  */  
   RecalcAmts:string,
      /**  Recurring flag  */  
   Recurring:boolean,
   RemainTaxAmt:number,
   ReminderSeq:number,
      /**  Accumulate all reversal amounts of Credit Memos with the reference to the invoice  */  
   ReversalDocAmt:number,
   ReverseTaxAmt:number,
   Rpt1ABAmt:number,
      /**  Financial Charge  */  
   Rpt1COIFRSFinancialCharge:number,
      /**  Present Value  */  
   Rpt1COIFRSPresentValue:number,
   Rpt1CumulativeBalance:number,
   Rpt1DepBal:number,
   Rpt1DspABAmt:number,
   Rpt1DspDepBal:number,
   Rpt1DspDepCr:number,
   Rpt1DspInvoiceAmt:number,
   Rpt1DspInvoiceBal:number,
   Rpt1DspPrepDeposit:number,
   Rpt1DspRounding:number,
   Rpt1DspSubTotal:number,
   Rpt1DspTaxAmt:number,
   Rpt1RemainTaxAmt:number,
   Rpt1ReverseTaxAmt:number,
   Rpt1SATaxAmt:number,
   Rpt1SourceRecurBalance:number,
   Rpt1SubTotal:number,
   Rpt1TaxAmt:number,
      /**  Difference between Deposit Amount from invoice header and Total Line Amount in Rpt1 currency.  */  
   Rpt1Vr:number,
   Rpt1WHTaxAmt:number,
   Rpt2ABAmt:number,
      /**  Financial Charge  */  
   Rpt2COIFRSFinancialCharge:number,
      /**  Present Value  */  
   Rpt2COIFRSPresentValue:number,
   Rpt2CumulativeBalance:number,
   Rpt2DepBal:number,
   Rpt2DspABAmt:number,
   Rpt2DspDepBal:number,
   Rpt2DspDepCr:number,
   Rpt2DspInvoiceAmt:number,
   Rpt2DspInvoiceBal:number,
   Rpt2DspPrepDeposit:number,
   Rpt2DspRounding:number,
   Rpt2DspSubTotal:number,
   Rpt2DspTaxAmt:number,
   Rpt2RemainTaxAmt:number,
   Rpt2ReverseTaxAmt:number,
   Rpt2SATaxAmt:number,
   Rpt2SourceRecurBalance:number,
   Rpt2SubTotal:number,
   Rpt2Taxamt:number,
      /**  Difference between Deposit Amount from invoice header and Total Line Amount in Rpt2 currency.  */  
   Rpt2Vr:number,
   Rpt2WHTaxAmt:number,
   Rpt3ABAmt:number,
      /**  Financial Charge  */  
   Rpt3COIFRSFinancialCharge:number,
      /**  Present Value  */  
   Rpt3COIFRSPresentValue:number,
   Rpt3CumulativeBalance:number,
   Rpt3DepBal:number,
   Rpt3DspABAmt:number,
   Rpt3DspDepBal:number,
   Rpt3DspDepCr:number,
   Rpt3DspInvoiceAmt:number,
   Rpt3DspInvoiceBal:number,
   Rpt3DspPrepDeposit:number,
   Rpt3DspRounding:number,
   Rpt3DspSubTotal:number,
   Rpt3DspTaxAmt:number,
   Rpt3RemainTaxAmt:number,
   Rpt3ReverseTaxAmt:number,
   Rpt3SATaxAmt:number,
   Rpt3SourceRecurBalance:number,
   Rpt3SubTotal:number,
   Rpt3TaxAmt:number,
      /**  Difference between Deposit Amount from invoice header and Total Line Amount in Rpt3 currency.  */  
   Rpt3Vr:number,
   Rpt3WHTaxAmt:number,
      /**  Review Journal UID  */  
   RvnJrnUID:number,
      /**  1st entry in SalesRepList  */  
   SalesRepCode1:string,
      /**  2nd entry in SalesRepList  */  
   SalesRepCode2:string,
      /**  3rd entry in SalesRepList.  */  
   SalesRepCode3:string,
      /**  4th entry in SalesRepList  */  
   SalesRepCode4:string,
      /**  5th entry in SalesRepList  */  
   SalesRepCode5:string,
      /**  1st sales rep name  */  
   SalesRepName1:string,
      /**  2nd sales rep name  */  
   SalesRepName2:string,
      /**  3rd sales rep name  */  
   SalesRepName3:string,
      /**  4th sales rep name  */  
   SalesRepName4:string,
      /**  5th sales rep name  */  
   SalesRepName5:string,
   SATaxAmt:number,
      /**  Boolean for selection of invoices in grid  */  
   Selected:boolean,
   SkipRecurring:boolean,
      /**  Sold to address list.  */  
   SoldToAddressList:string,
      /**  Sold to customer id  */  
   SoldToCustID:string,
      /**  Sold to customer name.  */  
   SoldToCustomerName:string,
   SourceInvoiceNum:number,
   SourceLastDate:string,
   SourceRecurBalance:number,
      /**  Sub total for invoice  */  
   SubTotal:number,
      /**  The system transaction type - ARInvoice or CreditMemo.  Used to filter combo list for TranDocTypeID.  */  
   SystemTranType:string,
      /**  Total tax amount from InvcTax  */  
   TaxAmt:number,
   TaxExchangeRate:number,
      /**  The flag to indicate if the user is supposed to be asked about Tax Liability change  */  
   TaxRgnLineChange:boolean,
   TotalInstanceNum:number,
      /**  This field is used when invoice is transferred to another Invoice Group and the user has a chance to change the Apply date of the invoice transferred.  */  
   TransApplyDate:string,
      /**  If true, the credit card info will come from the sales order.  */  
   UseSOCCDefaults:boolean,
   UseTaxRate:boolean,
   VNInvDescription:string,
   VNInvoiceType:string,
      /**  Difference between Deposit Amount from invoice header and Total Line Amount in base currency.  */  
   Vr:number,
   WHTaxAmt:number,
      /**  Currency label  */  
   XRateLabel:string,
   zEnableCreditHold:boolean,
      /**  The number of days the invoice is past due.  */  
   AgingDays:number,
      /**   The list of prohibited statuses.for the Invoice
For examle, if contains 2 (EINVOICE_STATUS_GENERATED) then Generate E-invoice is not allowed.
if contains 2 (EINVOICE_STATUS_SENT) then Sending Invoice via Service provider is not allowed  */  
   ELIEInvProhibitedStatuses:string,
      /**  Flag indicating whether to enable Incoterm Location  */  
   EnableIncotermLocation:boolean,
   BitFlag:number,
   AGInvoicingPointDescription:string,
   ARSystLNReqForInvc:boolean,
   CardTypeDescription:string,
   CurrencyCodeCurrencyID:string,
   CurrencyCodeCurrSymbol:string,
   CurrencyCodeCurrDesc:string,
   CurrRateGrpDescription:string,
   CustomerInactive:boolean,
   CustomerMXGeneralPublic:boolean,
   CustomerCustID:string,
   CustomerBTName:string,
   CustomerName:string,
   CustomerELISendingOption:number,
   FOBDescription:string,
   IncotermsDescription:string,
   JournalCodeJrnlDescription:string,
   MXPurchaseTypeCodeDesc:string,
   MXSubstInvoiceMXFiscalFolio:string,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
   OurBankPayerRef:string,
   OurBankBankIdentifier:string,
   OurBankTypeCode:string,
   OurBankBankAcctID:string,
   OurBankCheckingAccount:string,
   OurBankBankName:string,
   OurBankIBANCode:string,
   OurBankLocalBIC:string,
   OurBankDescription:string,
   PayMethodName:string,
   PayMethodSummarizePerCustomer:boolean,
   PayMethodType:number,
   PlantName:string,
   ProjectDescription:string,
   RecurringCycleMaximumValue:boolean,
   SoldToCustNumInactive:boolean,
   SoldToCustNumCustID:string,
   SoldToCustNumName:string,
   TaxRateGrpDescription:string,
   TaxRegionDescription:string,
   TermsCodeDescription:string,
   TranDocTypeDescription:string,
   XbSystOCRCalcType:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_LocationInventoryRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Unique ID for Location Inventory record  */  
   LocationNum:number,
      /**  Part number of item actually shipped. Duplicated from OrderDtl.PartNum at time of creation.  */  
   PartNum:string,
      /**  Site that the shipment is from.  */  
   Plant:string,
      /**  Packing slip number that this detail record is linked with.  */  
   PackNum:number,
      /**  An integer that uniquely identifies a detail record within a Packing slip.  */  
   PackLine:number,
      /**  The sales order number that this detail shipment line is linked to.  */  
   OrderNum:number,
      /**  The sales order line that this shipment detail line is linked to.  M  */  
   OrderLine:number,
      /**  The sales order release number that this shipment detail is linked to.  */  
   OrderRelNum:number,
      /**  Job Number that supplied the quantity that was shipped.  */  
   JobNum:string,
      /**  This is the current owner.  Valid values are (D)istributor, (C)ustomer  */  
   CurrentOwner:string,
      /**  Order Comment  */  
   OrderComment:string,
      /**  Line Description  */  
   LineDesc:string,
      /**  The type of listing the location inventory item is: L=Leaser, S=Sale  */  
   Listing:string,
      /**  Date when the location inventory was listed.  */  
   ListingStartDate:string,
      /**  Unique code for the Warranty that ties this record to a type of warranty.  */  
   WarrantyCode:string,
      /**  Warranty Comment  */  
   WarrantyComment:string,
      /**  Date the warrany started.  */  
   WarrantyStartDate:string,
      /**  Date the warranty will expired.  */  
   WarrantyExpirationDate:string,
      /**  Lot Num  */  
   LotNum:string,
      /**  Serial number of part.  */  
   SerialNumber:string,
      /**  Identification Number (example HIN, VIN).  */  
   IDNum:string,
      /**  What kind of warranty transfer this is: (F)ull/(L)imited/(N)o  */  
   WarrantyTransfer:string,
      /**  An optional field that is used if the customer has a different Part number.  */  
   XPartNum:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   InventoryAttributeSetID:number,
      /**  Shipping Address  */  
   AddrList:string,
      /**  Billing Address  */  
   BillAddr:string,
   ExtAddress1:string,
   ExtAddress2:string,
   ExtAddress3:string,
   ExtCity:string,
   ExtContact:string,
   ExtCountryNum:number,
   ExtEmailAddress:string,
   ExtFaxNum:string,
   ExtName:string,
   ExtPhoneNum:string,
   ExtState:string,
   ExtZIP:string,
   NewAddrList:string,
   NewCustID:string,
   NewCustNum:number,
   NewShipToNum:string,
   NewUseOTMF:boolean,
   TrackIDNum:boolean,
   TrackSerialNum:boolean,
      /**  Transaction Comment  */  
   TranComment:string,
      /**  Use OTS  */  
   UseOTMF:boolean,
   CustomerCustID:string,
   ShipToNum:string,
      /**  Sold to address  */  
   SoldToAddrList:string,
      /**  Owner address.  */  
   OwnerAddrList:string,
      /**  Location Address.  */  
   LocationAddrList:string,
      /**  Where is the transfer going to: (N)o Address Change,  (L)ocation, (O)wner, (B)oth.  Blank will be for a warranty change only.  */  
   TransferAddrType:string,
      /**  Owner Busines Model  */  
   OwnerBusinessModel:string,
      /**  Location Business Model  */  
   LocationBusinessModel:string,
      /**  Owner Customer ID  */  
   OwnerCustID:string,
      /**  Owner Ship To.  */  
   OwnerShipToNum:string,
      /**  Owner Use One Time Mark For.  */  
   OwnerUseOTMF:boolean,
      /**  Location Customer ID.  */  
   LocationCustID:string,
      /**  Location Ship To.  */  
   LocationShipToNum:string,
      /**  Location Use One Time Mark For.  */  
   LocationUseOTMF:boolean,
      /**  Sold To Customer ID.  */  
   SoldToCustID:string,
      /**  Sold To Ship To.  */  
   SoldToShipToNum:string,
      /**  Sold To Use Ont Time Mark For.  */  
   SoldToUseOTMF:boolean,
      /**  Sold To Business Model  */  
   SoldToBusinessModel:string,
      /**  Addres type of owner : L=Locatoin, O=Owner, S=Sold To  */  
   OwnerAddrType:string,
      /**  Date when transfer occured - writes to LocationTran.EffectiveDate  */  
   EffectiveDate:string,
   EnableDynAttrButton:boolean,
      /**  Establishes the contact to be used for the Location Inventory Address records. The contact will be specific for the address type (Lease, Owner, Sold To).  Contains the key value for the contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table.  */  
   NewConNum:number,
      /**  External field to hold the name of the selected customer contact for the Location record  */  
   LocationAttn:string,
      /**  External field to hold the name of the selected customer contact for the selected record  */  
   NewConName:string,
      /**  External field to hold the name of the selected customer contact for the Owner record  */  
   OwnerAttn:string,
   BitFlag:number,
   FSWarrCdWarrDescription:string,
   PartNumIUM:string,
   PartNumPartDescription:string,
   PartNumPricePerCode:string,
   PartNumSalesUM:string,
   PartNumTrackLots:boolean,
   PartNumTrackInventoryAttributes:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   PartNumAttrClassID:string,
   PartNumSellingFactor:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_LocationMtlRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates if  "Job"  is complete.  This is a mirror image of JobHead.Complete.  Not directly maintainable.  When the Job is completed, then all JobMtl records are also marked.  This is used to make database access to open material records more efficient.  */  
   JobComplete:boolean,
      /**  Indicates if this material requirement has been issued complete.  If "yes" then this record is NOT part of the Part.AllocQty total even if it had been issued less than the original required quantity.  The user may toggle the setting if the JobHead.Complete is "NO".  When it is toggled the allocation logic will be triggered if necessary.  */  
   IssuedComplete:boolean,
      /**  Job Number.  */  
   JobNum:string,
      /**  Assembly sequence number that this material is associated with.  */  
   AssemblySeq:number,
      /**  A sequence number that uniquely defines the Material (JobMtl) record within a specific Job/Assembly.  This is system assigned.  The next available number is determined by reading last JobMtl record on the Job/Assembly and then adding ten to it.  */  
   MtlSeq:number,
      /**  Part number.  If the material is being purchased (JobMtl.BuyIt = yes) this does need to be a valid part in the Part file.  */  
   PartNum:string,
      /**  A description of the material.  */  
   Description:string,
      /**  Quantity per parent.  Field Service was EstQty in FSCallMt.  */  
   QtyPer:number,
      /**  Required Quantity per END ITEM.  This is a calculated field.  Calculated as (Parent Required Qty X QtyPer) + calculated Scrap.  The parent quantity is either the JobHead.ProdQty if  JobMtl.AssemblySeq = 0 or (JobAsmbl.RequireQty - JobAsmbl.PullQty) if JobMtl.AssemblySeq > 0.  */  
   RequiredQty:number,
      /**  Internal unit of measure.  The unit used to measure the material.  */  
   IUM:string,
      /**  Expected purchasing lead time (in days).  This field is only valid if JobMtl.BuyIt = yes.  This can be used to calculate a suggested "Order By Date" based off the Required Date field.  When scheduling the job, purchased material can push a schedule out if the material lead time prevents the material from being available when the operation could start.  */  
   LeadTime:number,
      /**  A material record can be related to a specific operation.  This field contains the JobOper.OprSeq of the operation that it is related to.  It can be left as zero meaning that this material is required at the very beginning of the production job.  The related operation is also used to calculate the JobMtl.ReqDate based on the operations scheduled start date and materials lead time.  */  
   RelatedOperation:number,
      /**  The material burden rate for this Job Material.  */  
   MtlBurRate:number,
      /**  Estimated Material Burden Unit Cost of the material.  Defaults from the Part table if valid PartNum.  */  
   EstMtlBurUnitCost:number,
      /**  Estimated Unit Cost of the material.  Defaults from the Part table if valid PartNum.  */  
   EstUnitCost:number,
      /**  This quantity is a summary of all Issue Transactions.  For FS this was FSCallMt.ActQty  */  
   IssuedQty:number,
      /**  Total cost to date.  A summary of issue transactions.  This DOES NOT include the salvageable scrap credit amounts.  FS - was UnitCost in FSCallMt  */  
   TotalCost:number,
      /**  Total Material Burden cost to date.  A summary of issue transactions.  This DOES NOT include the salvageable scrap credit amounts.  */  
   MtlBurCost:number,
      /**  Mirror image of related operation (JobOper) or assembly (JobAsmbl) Start Date. (system maintained)  */  
   ReqDate:string,
      /**  The warehouse that the material is allocated against.  */  
   WarehouseCode:string,
      /**  Part number for salvageable scrap from this material record.  An optional field.  This does not have to be valid in the Part master. Salvage info is mainly to allow the credit back to a job for this type of scrap via salvage receipt process.  */  
   SalvagePartNum:string,
      /**  Description of Salvageable material.  Use Part.Description for a default.  */  
   SalvageDescription:string,
      /**  A factor that multiplied by the JobMtl.RequiredQty results in the expected total salvage quantity.  */  
   SalvageQtyPer:number,
      /**  Default unit of measure for the Salvaged Part.  Default from the Part.IUM.  */  
   SalvageUM:string,
      /**  The salvage material burden rate for this Job Material.  */  
   SalvageMtlBurRate:number,
      /**  Estimated Salvage Unit Credit.  Use the appropriate cost from the Part master as a default.  */  
   SalvageUnitCredit:number,
      /**  Estimated Salvage Mtl burden Unit Credit.  Use the appropriate cost from the Part master as a default.  */  
   SalvageEstMtlBurUnitCredit:number,
      /**  This quantity is a summary of all transactions for receipt of salvage to inventory.  This is not directly maintainable.  */  
   SalvageQtyToDate:number,
      /**  Total salvage credit to date.  A summary of salvage receipt transactions.  */  
   SalvageCredit:number,
      /**  Total salvage Mtl Burden credit to date.  A summary of salvage receipt transactions.  */  
   SalvageMtlBurCredit:number,
      /**  Comments for manufacturing about this material record.  These comments are printed on manufacturing reports, such as the router.  For valid Parts use the Part.MfgComment as a default.  */  
   MfgComment:string,
      /**  Used to identify a default vendor.  Use the Part.VendorNum as a default.  This will be used as a default for purchasing and miscellaneous receipts.  This field is not directly maintainable, instead its assigned by having the user either entering the "VendorID" and then finding the VendorNum in the Vendor file or by selection list processing.  An optional field, but if entered must be valid.  */  
   VendorNum:number,
      /**  The Vendors Purchase Point ID.  Along with the VendorNum is used to tie back to the VendorPP master file.  Use the default purchase point defined in the Vendor file.  */  
   PurPoint:string,
      /**  Indicates if this material is to be purchased for the Job.  If this is a non inventory part then this is "Yes" and cannot be changed.  If this is a valid Part then set it to "NO" but the user can override it. Material that is marked to be purchased (BuyIt = Yes) are NOT included in the PartWhse.AllocatedQty.  */  
   BuyIt:boolean,
      /**  FUTURE IMPLEMENTATION.  This logical relates to material that is flagged to be purchased (BuyIt = Yes).  When purchase orders are created for this job material requirement this flag is set to Yes indicating that a purchase order has been placed.  The idea would be to use this within purchasing to quickly see the "direct job requirements" where no purchase orders have been placed.  */  
   Ordered:boolean,
      /**  Comments for purchasing about this material record on this job. These comments will be used as defaults to the PODetail.Comment field when the purchase order references this JobMtl record.  */  
   PurComment:string,
      /**  Indicates if this material will be backflushed.  Note: this field is defaulted from Part.BackFlush Backflushing occurs via the write trigger on LaborDtl.  The basic idea is to issue material based on the labor quantities reported. The formula for the issue quantity is: (JobMtl.RequiredQty/JobOper.RunQty) * (LaborDtl.LaborQty + LaborDtl.SrapQty).  */  
   BackFlush:boolean,
      /**  Estimated Scrap.  */  
   EstScrap:number,
      /**  Qualifies the EstScrapQty entry as being a fixed quantity or a percentage of required quantity.  */  
   EstScrapType:string,
      /**  Indicates if the QtyPer field represents a "Fixed Quantity".  If Yes, then the required quantity = QtyPer.  That is, the quantity does not change as the number of pieces being produced changes.  This can be used to enter Tooling or Fixture type of requirements.  */  
   FixedQty:boolean,
      /**  Characters used on the drawing to show where material is used.  */  
   FindNum:string,
      /**  The revision number for the material.  An optional field. Defaults from the most current  PartRev.RevisionNum.  */  
   RevisionNum:string,
      /**  Controls if an alert is to be sent when this JobMtl is completed.  */  
   SndAlrtCmpl:boolean,
      /**  Indicates if inspection is required when items are received to this JobMtl.  Inspection may also be enforced if the related PartClass, Vendor, PODetail have their "RcvInspectionReq" fields set to Yes.  */  
   RcvInspectionReq:boolean,
      /**  Site Identifier.  */  
   Plant:string,
      /**  Indicates if this material requirement is going to be satisfied by another job (possibly in another Site), as opposed to a warehouse.  If "yes" a WarehouseCode will not be specified.  */  
   Direct:boolean,
      /**  Total Mtl cost to date.  A summary of issue transactions - used track all costs for manufacured parts that were received into inventory then issued as material..  MaterialMtlCost +  MaterialLabCost +  MaterialSubCost + MaterialBurCost = TotalCost  */  
   MaterialMtlCost:number,
      /**  Total Lab cost to date from parts issued from inventory.  A summary of issue transactions - used track all costs for manufacured parts that were received into inventory then issued as material..  IssuedMtlCost + IssuedLabCost + IssuedSubCost + IssuedBurCost = TotalCost  */  
   MaterialLabCost:number,
      /**  Total  Sub cost to date from part issued from inventory.  A summary of issue transactions used track all costs for manufacured parts that were received into inventory then issued as material..  IssuedMtlCost + IssuedLabCost + IssuedSubCost + IssuedBurCost = TotalCost  */  
   MaterialSubCost:number,
      /**  Total Bur cost to date from part issued from inventory.   A summary of issue transactions - used track all costs for manufacured parts that were received into inventory then issued as material.  IssuedMtlCost + IssuedLabCost + IssuedSubCost + IssuedBurCost = TotalCost  */  
   MaterialBurCost:number,
      /**  Total salvage Mtl credit to date.  A summary of salvage receipt transactions.  SalvageCredit = SalvageMtlCredit + SalvageLbrCredit + SalvageBurCredit + SalvageSubCredit  */  
   SalvageMtlCredit:number,
      /**  Total salvage Lbr credit to date.  A summary of salvage receipt transactions.  SalvageCredit = SalvageMtlCredit + SalvageLbrCredit + SalvageBurCredit + SalvageSubCredit  */  
   SalvageLbrCredit:number,
      /**  Total salvage Burden credit to date.  A summary of salvage receipt transactions.  SalvageCredit = SalvageMtlCredit + SalvageLbrCredit + SalvageBurCredit + SalvageSubCredit  */  
   SalvageBurCredit:number,
      /**  Total salvage Subcontract credit to date.  A summary of salvage receipt transactions.  SalvageCredit = SalvageMtlCredit + SalvageLbrCredit + SalvageBurCredit + SalvageSubCredit  */  
   SalvageSubCredit:number,
      /**  Advanced Planning and Scheduling Additional Resource Type.  Indicates whether the Part should be treated as an AdditionalResourceType by eScheduler: 'I' to ignore in eScheduler.  */  
   APSAddResType:string,
      /**  The service call that this Material belongs to.  */  
   CallNum:number,
      /**  The Service Call Line that this material relates to.  */  
   CallLine:number,
      /**  Product Group Code. Use the Part.ProdCode as a default.  This can be blank or must be valid in the ProdGrup table.  */  
   ProdCode:string,
      /**  FS - Unit Price for the Material in base currency.  */  
   UnitPrice:number,
      /**  FS - Billable Unit Price for the Material in base currency.  */  
   BillableUnitPrice:number,
      /**  FS - Billable Price per unit for the material in customers currency.  */  
   DocBillableUnitPrice:number,
      /**  Problem reason code from the reason master table. type Service call.  */  
   ResReasonCode:string,
      /**  Indicates the pricing per quantity for this part. It can be "E" = per each,"C" = per hundred,  "M" = per thousand. Maintainable only via Part Maintenance. The initial default is "E".  */  
   PricePerCode:string,
      /**  Is this a billable material item.  */  
   Billable:boolean,
      /**  Holds the quantity of the item that has been shipped through misc.  shipments  */  
   ShippedQty:number,
      /**  FS - Unit Price for the Material in Customer currency.  */  
   DocUnitPrice:number,
      /**  The todate quantity that has been moved to the work centers input Warehouse/Bin.  This is NOT A balance.  It is a todate value. It is not reduced as it is consumed. Used in calculation of "Outstanding" material in the Request Material program (ame30-dg.w). Only updated if the Advanced Material Mgmt module is installed and only by transactions which "move" the material in/out of the staging area(Issues,Returns).  */  
   QtyStagedToDate:number,
      /**  This material was added after initial setup of the job  */  
   AddedMtl:boolean,
      /**  This indicates that this JobMtl record is for a Misc charge related to this job/assembly.  */  
   MiscCharge:boolean,
      /**  The Miscellaneous Charge Code. This must be valid in the PurMisc master file.   It must be a AP Misc. charge.  */  
   MiscCode:string,
      /**  The Miscellaneous Charge Code for Service Call billing. This must be valid in the MiscChrg master file.   It must be a AR Misc. charge.  */  
   SCMiscCode:string,
      /**  A flag to indicate that this job material requires an RFQ.  If it does require an RFQ, the user must enter the number of vendor quotes that are required.  */  
   RFQNeeded:boolean,
      /**  The number of vendor quotes that are required for this job material.  Can be zero if RFQ(s) are not required.  */  
   RFQVendQuotes:number,
      /**  RFQ number that the item is linked to.  */  
   RFQNum:number,
      /**  The line number of this detail record on the RFQ. This number uniquely identifies the record within the RFQ. The number is not directly maintainable, it's assigned by the system when records are created.  */  
   RFQLine:number,
      /**  RFQ SRFQ Status: W= Waiting, A = Accepted, R = Requested, C = Receivedtatus.  */  
   RFQStat:string,
      /**  Analysis Code  */  
   AnalysisCode:string,
      /**  Global RFQ flag.  Used in Consolidated Purchasing.  */  
   GlbRFQ:boolean,
      /**  Indicates if the PartWhse allocation needs to be/has been updated by the new time delated process.  */  
   WhseAllocFlag:boolean,
      /**  Mirror image of related operation (JobOper) or assembly (JobAsmbl) Start Date. (system maintained)  */  
   WIReqDate:string,
      /**  Reporting currency value of this field  */  
   Rpt1BillableUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2BillableUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3BillableUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1UnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2UnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3UnitPrice:number,
      /**  Required Quantity in the Parts Base UOM.  Set by the system by doing a UOM conversion of the JobMtl.RequiredQty which is in the UOM of the requirement to the JobMtl.BaseUOM which is the UOM of the Part and it's unit costs.  */  
   BaseRequiredQty:number,
      /**  Unit of Measure of the JobMtl.BaseRequiredQty.  If valid part, then it is the Parts Primary Inventory UOM otherwise it is the same as JobMtl.IUM  */  
   BaseUOM:string,
      /**  Material Weight defaulted from Part Master.  */  
   Weight:number,
      /**  Material Weight UOM defaulted from Part Master.  */  
   WeightUOM:string,
      /**  Required number of designators  */  
   ReqRefDes:number,
      /**  Base Part Number. Used in the configurator to identify the configurator part Number.  */  
   BasePartNum:string,
      /**  Base Revision Number. Used in the configurator to identify the configurator part revision Number.  */  
   BaseRevisionNum:string,
      /**  Indicates if the job material is selected to be submitted to the picking queue. When submitted for picking a record is written to the MtlQueue table and then SelectForPicking is reset to NO.  */  
   SelectForPicking:boolean,
      /**  The job pick "Staging" warehouse for the job material.  Defaults from the system default warehouse (PlantConfCtrl.DefJobPickWhse).  */  
   StagingWarehouseCode:string,
      /**  The job pick "Staging" bin for the job material.  Defaults from the system default bin (PlantConfCtrl.DefJobPickBin).  */  
   StagingBinNum:string,
      /**  A non blank character indicates that the release could not be picked by the Auto Pick process. The possible values are: "L" - Order Line can't be shipped complete. "O" - Order can't be shipped complete. "I" - Insufficient quantity reserved"Z" - Zero quantity reserved.  */  
   PickError:string,
      /**  Estimated Material Unit Cost component of the EstUnitCost.  Defaults from the Part table if valid PartNum.  This field will only have value if the part is a manufactured stock part. This is a subcomponent of the EstUnitCost where: EstUnitCost = EstMtlUnitCost + EstLbrUnitCost + EstBurUnitCost + EstSubUnitCost.  */  
   EstMtlUnitCost:number,
      /**  Estimated Labor Unit Cost component of the EstUnitCost.  Defaults from the Part table if valid PartNum.  This field will only have value if the part is a manufactured stock part. This is a subcomponent of the EstUnitCost where: EstUnitCost = EstMtlUnitCost + EstLbrUnitCost + EstBurUnitCost + EstSubUnitCost.  */  
   EstLbrUnitCost:number,
      /**  Estimated Burden Unit Cost component of the EstUnitCost.  Defaults from the Part table if valid PartNum.  This field will only have value if the part is a manufactured stock part. This is a subcomponent of the EstUnitCost where: EstUnitCost = EstMtlUnitCost + EstLbrUnitCost + EstBurUnitCost + EstSubUnitCost.  */  
   EstBurUnitCost:number,
      /**  Estimated Subcontract Unit Cost component of the EstUnitCost.  Defaults from the Part table if valid PartNum.  This field will only have value if the part is a manufactured stock part. This is a subcomponent of the EstUnitCost where: EstUnitCost = EstMtlUnitCost + EstLbrUnitCost + EstBurUnitCost + EstSubUnitCost.  */  
   EstSubUnitCost:number,
      /**  Estimated Salvage Material Unit Credit.  Use the appropriate cost from the Part master as a default.  This is a subcomponent of the field SalvageUnitCredit where: SalvageUnitCredit = SalvageEstMtlUnitCredit + SalvageEstLbrUnitCredit + SalvageEstBurUnitCredit + SalvageEstSubUnitCredit.  */  
   SalvageEstMtlUnitCredit:number,
      /**  Estimated Salvage Labor Unit Credit.  Use the appropriate cost from the Part master as a default.  This is a subcomponent of the field SalvageUnitCredit where: SalvageUnitCredit = SalvageEstMtlUnitCredit + SalvageEstLbrUnitCredit + SalvageEstBurUnitCredit + SalvageEstSubUnitCredit.  */  
   SalvageEstLbrUnitCredit:number,
      /**  Estimated Salvage Burden Unit Credit.  Use the appropriate cost from the Part master as a default.  This is a subcomponent of the field SalvageUnitCredit where: SalvageUnitCredit = SalvageEstMtlUnitCredit + SalvageEstLbrUnitCredit + SalvageEstBurUnitCredit + SalvageEstSubUnitCredit.  */  
   SalvageEstBurUnitCredit:number,
      /**  Estimated Salvage Subcontract Unit Credit.  Use the appropriate cost from the Part master as a default.  This is a subcomponent of the field SalvageUnitCredit where: SalvageUnitCredit = SalvageEstMtlUnitCredit + SalvageEstLbrUnitCredit + SalvageEstBurUnitCredit + SalvageEstSubUnitCredit.  */  
   SalvageEstSubUnitCredit:number,
      /**  The material quantity that has been loaned out to another job.  */  
   LoanedQty:number,
      /**  The material quantity that has been borrowed from another job.  */  
   BorrowedQty:number,
      /**  flag used to designate if the serial numbers from the job material/subassembly can be reassigned as the serial number of the parent assembly (top assembly or n deep subassembly) being reworked using a job.  */  
   ReassignSNAsm:boolean,
      /**  GeneralPlanInfo  */  
   GeneralPlanInfo:string,
      /**  EstStdDescription  */  
   EstStdDescription:string,
      /**  PricingUOM  */  
   PricingUOM:string,
      /**  RemovedFromPlan  */  
   RemovedFromPlan:boolean,
      /**  IsPOCostingMaintained  */  
   IsPOCostingMaintained:boolean,
      /**  EstStdType  */  
   EstStdType:number,
      /**  POCostingFactor  */  
   POCostingFactor:number,
      /**  PlannedQtyPerUnit  */  
   PlannedQtyPerUnit:number,
      /**  POCostingDirection  */  
   POCostingDirection:number,
      /**  POCostingUnitVal  */  
   POCostingUnitVal:number,
      /**  GroupSeq  */  
   GroupSeq:number,
      /**  When getting details on a multi-level configuration, the StructTag is used to load the configuration at each level so that method rules can be applied at that level.  By storing the original StructTag of the configuration as it was defined under its parent, it speeds up the process of determining where the lower level configured was originally configured.  If this field is populated, the lower level was originally configured as a child of another configured part.  */  
   OrigStructTag:string,
      /**  By storing the original Group Sequence of the configuration as it was defined under its parent, it speeds up the process of determining where the lower level configured was originally configured.  If this field is populated, the lower level was originally configured as a child of another configured part.  */  
   OrigGroupSeq:number,
      /**  ShowStatusIcon  */  
   ShowStatusIcon:string,
      /**  Contract ID  */  
   ContractID:string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the Planning Contract.  */  
   LinkToContract:boolean,
      /**  Stores the lot number of the material in the Staging Warehouse/Bin.  */  
   StagingLotNum:string,
      /**  PCLinkRemoved  */  
   PCLinkRemoved:boolean,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   ExternalMESSyncRequired:boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   ExternalMESLastSync:string,
      /**  Controls if this material record is viewable in Location Management or the web.  */  
   LocationView:boolean,
      /**  LotNum  */  
   LotNum:string,
      /**  SerialNum  */  
   SerialNum:string,
      /**  WarrantyCode  */  
   WarrantyCode:string,
      /**  WarrantyComment  */  
   WarrantyComment:string,
      /**  WarrantyStartDate  */  
   WarrantyStartDate:string,
      /**  WarrantyExpirationDate  */  
   WarrantyExpirationDate:string,
      /**  LocationNum  */  
   LocationNum:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  Planning number of pieces for this attribute set.  */  
   PlanningNumberOfPieces:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   SalvageAttributeSetID:number,
      /**  Salvage planning number of pieces for this attribute set.  */  
   SalvagePlanningNumberOfPieces:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   SalvagePlanningAttributeSetID:number,
      /**  Dealer specific warranty code.  This is a non ERP warranty code.  */  
   DealerWarranty:string,
      /**  Dealer specific warranty description  */  
   DealerWarrantyDesc:string,
      /**  Dealer specifc warranty expiration date.  */  
   DealerWarrantyExpiration:string,
      /**  Dealer specific warranty start date.  */  
   DealerWarrantyStart:string,
      /**  Original Serial Number  */  
   OriginalSerialNum:string,
   OriginalPartNum:string,
   BitFlag:number,
   FSWarrCdWarrDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_LocationWarrantyTranRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  LocationNum  */  
   LocationNum:number,
      /**  Sequence number.  This is system generated and is not maintainable.  */  
   WarrantySeqNum:number,
      /**  Finished good Identificaton Number  */  
   IDNum:string,
      /**  SerialNum  */  
   SerialNum:string,
      /**  Comment about the warranty transfer transaction.  */  
   Comment:string,
      /**  Effective Date  */  
   EffectiveDate:string,
      /**  HDCaseNum  */  
   HDCaseNum:number,
      /**  ParentPartNum  */  
   ParentPartNum:string,
      /**  OriginalPartNum  */  
   OriginalPartNum:string,
      /**  OriginalPartSerialNum  */  
   OriginalPartSerialNum:string,
      /**  NewPartNum  */  
   NewPartNum:string,
      /**  NewPartSerialNum  */  
   NewPartSerialNum:string,
      /**  PartDescription  */  
   PartDescription:string,
      /**  WarrantyCode  */  
   WarrantyCode:string,
      /**  WarrantyComment  */  
   WarrantyComment:string,
      /**  Date when warranty started.  */  
   WarrantyStartDate:string,
      /**  Date when warranty expires  */  
   WarrantyExpirationDate:string,
      /**  Dealer Warranty, this is for a non Erp warranty.  */  
   DealerWarranty:string,
      /**  Dealer warranty description, this is for a non Erp warranty  */  
   DealerWarrantyDesc:string,
      /**  Date dealer warranty started, this is for a non Erp warranty  */  
   DealerWarrantyStart:string,
      /**  Date dealer warranty expires, this is for a non Erp warranty.  */  
   DealerWarrantyExpiration:string,
      /**  WarrantyUsage  */  
   WarrantyUsage:string,
      /**  LotNum  */  
   LotNum:string,
      /**  SystemCreated  */  
   SystemCreated:boolean,
      /**  Created On  */  
   CreatedOn:string,
      /**  Created By  */  
   CreatedBy:string,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
   BitFlag:number,
   FSWarrCdWarrDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderDtlRow{
      /**   Indicates that the line item was closed before any shipments were made against it. Normally line items are closed as part of the Shipping process. By using the "Close Line" menu option the user can close the line manually, to provide the function to close the line when the customer cancels there request.  If the line item had no shipments made it is then marked as "voided". Regardless of shipment activity the line is also marked as closed (OpenLine = No).
When an OrderDtl record is 'voided/closed' all of it's related OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   VoidLine:boolean,
      /**  Indicates if the OrderDtl record is in a "open or closed" status.  This field is not directly maintainable. It can be set to "closed" via the "Close-Line" menu option,  the "Close-Order" menu option, or when all the related OrderRel records are closed, OrderRel records are closed via shipping or by the "Close Release" button within Order Entry. (See VoidLine also).  */  
   OpenLine:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  Contains the Order Number that ties this detail record back to an OrderHed record.  */  
   OrderNum:number,
      /**  This field along with Company and OrderNum make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the OrderDtl record for the Order and the adding 1 to it.  The user can override this number if they wish.  */  
   OrderLine:number,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT".  */  
   LineType:string,
      /**   The user's Internal Part number used to identify line item part. It cannot  be blank. It does not have to exist in the Part table.

A default should be made when the OrderDtl.XPartNum is changed.  The PartNum and XPartNum fields work together in providing defaults for each other. Default when a valid record is found in the PartXRef table. NOTE THE PART CROSS REFERENCE LOGIC IS NOT INCLUDED IN RELEASE 1.0 ... PLAN FOR FUTURE  */  
   PartNum:string,
      /**  Line Item description. The Part.Description can be used as a default.  */  
   LineDesc:string,
      /**  EDI Reference  */  
   Reference:string,
      /**  Unit Of Measure (how it is sold/issued). Use the default Part.IUM if it's a valid Part.  */  
   IUM:string,
      /**  Optional field that contains the customers revision. Default from the PartRev.RevisionNum field.  */  
   RevisionNum:string,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   POLine:string,
      /**  Controls if line is commissionable. Note if all the OrderHed.SalesRep are blank then this should be "No", also the user should not even see this field when there are no sales reps for the order.  */  
   Commissionable:boolean,
      /**  The line item discount percent. It has nothing to do with price break discounts. It is a flat discount percent that defaults from the OrderHed.DiscountPercent, which was originally defaulted from the Customer.DiscountPercent.  */  
   DiscountPercent:number,
      /**   If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in
the customer currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   DocUnitPrice:number,
      /**  Total Order Quantity for the line item. This quantity must always be kept in sync with the scheduled ship quantities stored in the OrderRel table. Normally this field is directly maintainable. However when multiple shipping releases have been established for this line ( more than one OrderRel record) the OrderQty is not maintainable. As the user modifies the quantities in the individual release lines the OrderQty field will get adjusted. This ensures that Order quantity and scheduled ship quantity are always in sync.  */  
   OrderQty:number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Discount:number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   DocDiscount:number,
      /**   Date that the first release needs be shipped by in order to meet the customers due date for the first delivery. Defaulted as OrderHed.RequestDate.
Not directly maintainable when more than one delivery record exists, in which case it gets refreshed as the earliest ReqDate of the related OrderRel records.  */  
   RequestDate:string,
      /**  Product Group Code. Use the Part.ProdCode as a default.  This can be blank or must be valid in the ProdGrup table.  */  
   ProdCode:string,
      /**  An optional field that is used if the customer has a different  Part number  than the users internal part number.  The XPartNum and PartNum can provide defaults for each other via the PartXref table.. The XPartNum can be blank, does not have to exist in the PartXref table.  */  
   XPartNum:string,
      /**  Optional field that contains the customers revision. Default from the CustXPrt.RevisionNum field.  */  
   XRevisionNum:string,
      /**  Indicates the pricing per quantity. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Used to calculate the extended unit price for the line item. The logic is to divide the OrderDtl.OrderQty by the appropriate "per" value and then multiply by unit price.  Use the  Part.PricePerCode as a default. If Part record does not exist then default as "E".  */  
   PricePerCode:string,
      /**  Contains comments about the detail order line item. These will be printed on the Sales Acknowledgements.  */  
   OrderComment:string,
      /**  Used to establish shipping comments about the order line item. These will copied into the packing slip detail  file as defaults.  */  
   ShipComment:string,
      /**  Used to establish invoice comments about the order line item. These will copied into the Invoice detail  file as defaults.  */  
   InvoiceComment:string,
      /**  Contains comments for pick list or job about the order line item. These will be printed on the picking lists or copied to the job during the link process.  */  
   PickListComment:string,
      /**  Indicates the Tax Category for this record. Defaults from the the or from the Part Master.  */  
   TaxCatID:string,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs. This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering amount in the InvcDetl.  */  
   AdvanceBillBal:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   DocAdvanceBillBal:number,
      /**  Quote number to which this line item detail record is associated with. This is part of the foreign key to QuoteHed file. This field is updated via the "get quote" function within Order Entry.  */  
   QuoteNum:number,
      /**  Quote Line number from which this order line was created. Updated via the Get Quote function within Order Entry. This field along with Company and QuoteNum make up the link to the QuoteDtl file.  */  
   QuoteLine:number,
      /**  Indicates if the Order line item is billed based on Time & Material. This flag is copied into the ShipDtl record during the Shipping Entry process. See ShipDtl.TMBilling description for further details.  */  
   TMBilling:boolean,
      /**  This field is no longer active. It has been replaced by OrderRel.Exempt. The contents were copied into OrderRel.Exempt during the release conversion process. This will be removed in the next release.  */  
   OrigWhyNoTax:string,
      /**   Date the customer needs the first release to be delivered.
Defaulted as OrderHed.NeedByDate. Not directly maintainable when more than one delivery record exists. In which case it is kept in sync with the OrderRel record which has the earliest ReqDate which are maintained in the shipping release dialog boxes.  */  
   NeedByDate:string,
      /**  Customer number that the sales order is for. Duplicated from OrderHed.CustNum.  Used to allow efficient browsing of the OrderDtl records for a specific customer.  */  
   CustNum:number,
      /**   Used to indicate that line item is to be "Reworked" instead of manufactured.  It is shown in the Job Entry Order Activity screens.
When Yes then all related OrderRel records are Make=Yes.  */  
   Rework:boolean,
      /**   Return Authorization Number that OrderDtl is fulfilling.
If entered, must be valid in RMAHead.  */  
   RMANum:number,
      /**  The line item of the RMA detail that this order line item is fulfilling.  */  
   RMALine:number,
      /**  Project ID of the Project table record that this OrderDtl record. Can be blank.  */  
   ProjectID:string,
      /**  Contract Number of the related Service Contract when the LineType field is "CONTRACT"  */  
   ContractNum:number,
      /**  A unique code that identifies the Service Contract when the Line Type is "CONTRACT"  */  
   ContractCode:string,
      /**  The part number used to identify the configured part number initially entered on the line.  */  
   BasePartNum:string,
      /**  Indicate that the item or the product group has a warranty.  */  
   Warranty:boolean,
      /**  Unique code for the Warranty that ties this record to a type of warranty.  Found on either the Part or ProdGrup table.  */  
   WarrantyCode:string,
      /**  The # of days, months, years the material is covered by warranty  */  
   MaterialDuration:number,
      /**  The # of days, months, years the Labor is covered by warranty  */  
   LaborDuration:number,
      /**  The # of days, months, years the Misc. Charges are covered by warranty  */  
   MiscDuration:number,
      /**  Whether the duration of warranty  is for "Days"," Months", "Years".  */  
   MaterialMod:string,
      /**  Whether the duration of warranty  is "Days"," Months"," years".  */  
   LaborMod:string,
      /**  Editor widget for Warranty comments.  */  
   WarrantyComment:string,
      /**  This warranty covers On site visits  */  
   Onsite:boolean,
      /**  Are Material cost covered  */  
   MatCovered:boolean,
      /**  Is Labor Cost Covered  */  
   LabCovered:boolean,
      /**  Are misc. Costs Covered  */  
   MiscCovered:boolean,
      /**  Unit of measure (how it is sold/issued).  Use the default Part.SUM if its a valid Part else use the global variable Def-UM which is established from XaSyst.DefaultUM.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  Represents one of the requested Order Quantities for the line item using OrderDtl.SUM.  */  
   SellingQuantity:number,
      /**  A Cod which uniquely identfies SalesCat record. Can't be blank.  */  
   SalesCatID:string,
      /**  Indicates if the order line must be shipped complete.  That is, as an orders release are selected for picking during the Auto Pick process of the Order Allocation program, the all releases of the line with a ship date <= the given cutoff date also have to be picked complete otherwise they will not be selected. This is defaulted to Yes when Customer.ShippingQualifier = "L" (Ship Order line 100% complete) and OrderHed.ShipOrderComplete = No. This field is disabled and set to No if the OrderHed.ShipOrderComplete = Yes.  */  
   ShipLineComplete:boolean,
      /**  Quantity from last EDI update.  */  
   CumeQty:number,
      /**  Date of last update  */  
   CumeDate:string,
      /**  The related Marketing Campaign ID. Mirror image of the QuoteHed.MkthCampaignID. Maintainable via order entry if not related to a quote and the CRM module is installed.  */  
   MktgCampaignID:string,
      /**   Link to the marketing event associated with this record.
The related Marketing Event Sequence. Mirror image of the QuoteHed.MktgEventSeq. Maintainable via order entry if not related to a quote and the CRM module is installed.  */  
   MktgEvntSeq:number,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the order quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   LockQty:boolean,
      /**  Indicates if this order line is linked to an inter-company PO line.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   ICPONum:number,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   ICPOLine:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  The date when the configuration was completed for the assembly.  */  
   LastConfigDate:string,
      /**  The system time when the configuration was completed for the assembly.  */  
   LastConfigTime:number,
      /**  The User ID of the last user to complete the configuration of the assembly.  */  
   LastConfigUserID:string,
      /**   Same as Unit price except that this field contains the unit price computed from the input based pricing in a configuration.
If price breaks exist this price should be used as the base price instead of the one found in the part table.  */  
   ConfigUnitPrice:number,
      /**  This is the base price for inputs based pricing of a configuration.  The price of inputs are added to this price to get the ConfigUnitPrice.  */  
   ConfigBaseUnitPrice:number,
      /**  This is the Price List used to determine the starting base price.  */  
   PriceListCode:string,
      /**  This is the Price List used to determine the break % or amount.  */  
   BreakListCode:string,
      /**  The Order Quantity (total qty of related order lines) used to find price when quantity based discounting is applied.  */  
   PricingQty:number,
      /**  Indicates if the price of the order line can be changed.  */  
   LockPrice:boolean,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied.  */  
   ListPrice:number,
      /**   Same as List price except that this field contains the list price in
the customer currency (converted using the exchange rate on OrderHed).  */  
   DocListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied.  */  
   OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency (converted using the exchange rate on OrderHed).  */  
   DocOrdBasedPrice:number,
      /**  This is the Price Group ID used to price the order line with.  */  
   PriceGroupCode:string,
      /**  Indicates if the user selected a price list different from the default.  */  
   OverridePriceList:boolean,
      /**  The revision number used to identify the configured part/revision number initially entered on the line.  */  
   BaseRevisionNum:string,
      /**  The Order Value (total extended price of related order lines) used to find order value break when value based discounting is applied.  */  
   PricingValue:number,
      /**  This field controls the order in which Sales Order lines are displayed.  Display Seq is a decimal number where the whole number portion is used to sequence normal sales order lines and the decimal portion is used to sequence kit components under their associated kit parent.  */  
   DisplaySeq:number,
      /**  The sales order line number of the parent kit item.  This is only relevent for sales order lines which are kit parent or component lines.  If the KitParentLine equals the OrderLine then this is a kit parent line.  */  
   KitParentLine:number,
      /**  Indicates if component lines can be added, deleted and modified during Sales Order entry.  This field is only relevant for sales order lines which are kit parents.  */  
   KitAllowUpdate:boolean,
      /**  Indicates if the parent kit part must be shipped complete of if kit components can be shippped in varying degrees of completeness.  This field is only relevant for sales order lines which are kit parents. If this field is set to "No" then KitPricing must be set to "P".  */  
   KitShipComplete:boolean,
      /**  Indicates if all components are to be backflushed when a kit parent part is shipped.  This field is only relevant for sales order lines which are kit parents.  */  
   KitBackFlush:boolean,
      /**  Indicates if kit components are to be printed on packing slips.  If KitShipComplete is "Yes", then this field must be set to "YES" as well.  This field is only relevant for sales order lines which are kit parents.  */  
   KitPrintCompsPS:boolean,
      /**  Indicates if kit components are to be printed on invoices.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  This field is only relevant for sales order lines which are kit parents.  */  
   KitPrintCompsInv:boolean,
      /**  Indicates how kits will be priced.  Values are P = Parent Pricing (The price is obtained from the sales price for the kit parent item), C = Component Pricing (The price is obtained from a rollup of kit component items).  This field is only relevant for sales order lines which are kit parents.  */  
   KitPricing:string,
      /**  Component quantity required to fulfill one kit parent.  This field is only relevant on a sales order line which is a kit component.  */  
   KitQtyPer:number,
      /**  Indicates how Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate1:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate2:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate3:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate4:number,
      /**  Commission Pay rates for the line item associated to the possible 5 sales reps for the order. Use the OrderHed.RepRate as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y".  */  
   RepRate5:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit1:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit2:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit3:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit4:number,
      /**  Use the OrderHed.RepSplit as the default. These fields are not accessible if the OrderDtl.Commissionable is not "Y"  */  
   RepSplit5:number,
      /**  The Demand Contract Detail record this OrderDtl is related to.  */  
   DemandContractLine:number,
      /**  Create New Job flag  */  
   CreateNewJob:boolean,
      /**  The date before which the order cannot be shipped.  */  
   DoNotShipBeforeDate:string,
      /**  Get Details flag  */  
   GetDtls:boolean,
      /**  The date after which the order cannot be shipped.  */  
   DoNotShipAfterDate:string,
      /**  Schedule Job flag  */  
   SchedJob:boolean,
      /**  Release Job flag  */  
   RelJob:boolean,
      /**  Enable New Job flag  */  
   EnableCreateNewJob:boolean,
      /**  Enable Get Details flag  */  
   EnableGetDtls:boolean,
      /**  Enable Schedule Job flag  */  
   EnableSchedJob:boolean,
      /**  Enable Release Job flag  */  
   EnableRelJob:boolean,
      /**  Indicates the warehouse selected for a counter sale order line.  */  
   CounterSaleWarehouse:string,
      /**  Identifies the Bin selected for a counter sale order line.  */  
   CounterSaleBinNum:string,
      /**  Indicates the lot number selected for a counter sale order line.  */  
   CounterSaleLotNum:string,
      /**  Indicates the dimension code selected for a counter sales order line.  */  
   CounterSaleDimCode:string,
      /**  Indicates if the demand detail that created/updated this order line has been rejected.  */  
   DemandDtlRejected:boolean,
      /**   A character flag field used to differentiate between regular sales order line, Sales Kit parent order line and Sales Kit component order line.
P = Sales Kit Parent line
C = Sales Kit Component Line
Null = regular line  */  
   KitFlag:string,
      /**  Indicates if the kit components have been automatically loaded.  If set to false the user interface will attempt to load the kit components after the user saves a new order line.  */  
   KitsLoaded:boolean,
      /**  The demand contract this demand is for.  */  
   DemandContractNum:number,
      /**  This field along with Company and DemandContractNum make up the unique key to the table. The system should generate this number during entry of new header records. The system determines next available number by finding the last DemandHead for the DemandContractNum and adding 1.  */  
   DemandHeadSeq:number,
      /**  This field along with Company, DemandContractNum and DemandHeadSeq make up the unique key to the table. The system should generate this number during entry of new detail records. The system determines next available number by finding the last DemandDetail record for the DemandHead and the adding 1 to it.  */  
   DemandDtlSeq:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Reverse Charge.  */  
   ReverseCharge:boolean,
      /**  Total Number of releases for the line  */  
   TotalReleases:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt1UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt2UnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt3UnitPrice:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt1Discount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt2Discount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt3Discount:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   Rpt1AdvanceBillBal:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   Rpt2AdvanceBillBal:number,
      /**  Tracks the "Balance" of Advance billings which are to be used to reduce the invoice when actual shipment occurs( in the customer's currency). This value is increased via the "Advance Bill" invoice type. It is reduced when the shipment invoice is created by entering the amount in the InvcDetl.  */  
   Rpt3AdvanceBillBal:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1ListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2ListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3ListPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3OrdBasedPrice:number,
      /**  Extended Price for the order line item, rounded according to the Base currency Round rule  */  
   ExtPriceDtl:number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule  */  
   DocExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt1ExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt2ExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt3ExtPriceDtl:number,
      /**  Status of Order Line  */  
   LineStatus:string,
      /**   If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table. Assumed to include taxes  */  
   InUnitPrice:number,
      /**  Same as DocUnit price except that this field contains the unit price including taxes  */  
   DocInUnitPrice:number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * InUnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, InUnitPrice or OrderQty fields are changed.  - includes taxes  */  
   InDiscount:number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * InUnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, InUnitPrice or OrderQty fields are changed. - includes taxes  */  
   DocInDiscount:number,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied. including taxes  */  
   InListPrice:number,
      /**   Same as List price except that this field contains the list price in
the customer currency -including taxes.  */  
   DocInListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied. including taxes  */  
   InOrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency - including taxes.  */  
   DocInOrdBasedPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt1InUnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt2InUnitPrice:number,
      /**   Same as Unit price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed.
If it's a valid item in the Part table the unit price is defaulted using the following logic:
- Determine if a price break is effective. The basic idea is to see if you can find a record in the OPrice table and then adjust the unit price retrieved from the Part table. 
Price breaks can exist with the following configurations:

 1. Part/Customer
 2. Part/Price level
 3. Part 
 4. Product group/Customer
 5. Product group/level
 6. Product Group 
The search logic is done in the above order. If a OPrice is found and it has an EndDate of zeros or the EndDate is >= OrderDate then consider that a price break has been found and the search quits. Use the Order quantity to determine which element of the QtyBreak array should be used. Then either a fixed unit price is selected (unitprices) or a discount percent is selected (discountPercents) and applied to the Unit Price retrieved from the Part table.  */  
   Rpt3InUnitPrice:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt1InDiscount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt2InDiscount:number,
      /**  A flat discount amount for the line item Converted to a report currency. It can be left zero. This is calculated using the OrderDtl.DiscountPercent * (OrderQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt3InDiscount:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1InListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2InListPrice:number,
      /**   Same as List price except that this field contains the list price in
a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3InListPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt1InOrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt2InOrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in a report currency (converted using the exchange rate on OrderHed).  */  
   Rpt3InOrdBasedPrice:number,
      /**  Extended Price for the order line item, rounded according to the Base currency Round rule - Taxes are Included  */  
   InExtPriceDtl:number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule - Taxes Included  */  
   DocInExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt1InExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt2InExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt3InExtPriceDtl:number,
      /**  Used to store selling open quantity value setting assigned in product configuration programs  */  
   OldOurOpenQty:number,
      /**  Used to store selling open quantity value setting assigned in product configuration programs  */  
   OldSellingOpenQty:number,
      /**  Used to store open value setting assigned in product configuration programs  */  
   OldOpenValue:number,
      /**  Used to store prod code value assigned in product configuration programs  */  
   OldProdCode:string,
      /**  Previous Selling Quantity  */  
   PrevSellQty:number,
      /**  Previous Part Number  */  
   PrevPartNum:string,
      /**  Previous Customer Part Number  */  
   PrevXPartNum:string,
      /**  The original material sequence of this kit component under the kit parent part.  */  
   KitCompOrigSeq:number,
      /**  The original kit component part number prior to processing any configurator rule programs  */  
   KitCompOrigPart:string,
      /**  If TRUE then this field will mean that the smart string has already been processed  */  
   SmartStringProcessed:boolean,
      /**  Original smart string passed in for configuration  */  
   SmartString:string,
      /**  Contract renewal number. If the value is zero then the contract is not for a renewal.  */  
   RenewalNbr:number,
   DiscBreakListCode:string,
   DiscListPrice:number,
   LockDisc:boolean,
   OverrideDiscPriceList:boolean,
      /**  GroupSeq  */  
   GroupSeq:number,
      /**  ECCOrderNum  */  
   ECCOrderNum:string,
      /**  ECCOrderLine  */  
   ECCOrderLine:number,
      /**  DupOnJobCrt  */  
   DupOnJobCrt:boolean,
      /**  UndersPct  */  
   UndersPct:number,
      /**  Overs  */  
   Overs:number,
      /**  Unders  */  
   Unders:number,
      /**  OversUnitPrice  */  
   OversUnitPrice:number,
      /**  PlanUserID  */  
   PlanUserID:string,
      /**  PlanGUID  */  
   PlanGUID:string,
      /**  MOMsourceType  */  
   MOMsourceType:string,
      /**  MOMsourceEst  */  
   MOMsourceEst:string,
      /**  DefaultOversPricing  */  
   DefaultOversPricing:string,
      /**  ECCPlant  */  
   ECCPlant:string,
      /**  ECCQuoteNum  */  
   ECCQuoteNum:string,
      /**  ECCQuoteLine  */  
   ECCQuoteLine:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  MfgJobType  */  
   MfgJobType:string,
      /**  ProFormaInvComment  */  
   ProFormaInvComment:string,
      /**  CreateJob  */  
   CreateJob:boolean,
      /**  The identifier of the planning contract.  */  
   ContractID:string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the planning of the Contract.  */  
   LinkToContract:boolean,
      /**  DocInAdvanceBillBal  */  
   DocInAdvanceBillBal:number,
      /**  InAdvanceBillBal  */  
   InAdvanceBillBal:number,
      /**  Rpt1InAdvanceBillBal  */  
   Rpt1InAdvanceBillBal:number,
      /**  Rpt2InAdvanceBillBal  */  
   Rpt2InAdvanceBillBal:number,
      /**  Rpt3InAdvanceBillBal  */  
   Rpt3InAdvanceBillBal:number,
      /**  PCLinkRemoved  */  
   PCLinkRemoved:boolean,
      /**  CommodityCode  */  
   CommodityCode:string,
      /**  Base price before any price breaks and discounts  */  
   MSRP:number,
      /**  Same as MSRP except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   DocMSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   Rpt1MSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   Rpt2MSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency.  */  
   Rpt3MSRP:number,
      /**  Distributor end customer price.  */  
   EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   DocEndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   Rpt1EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   Rpt2EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency.  */  
   Rpt3EndCustomerPrice:number,
      /**  Promotional Price offered to Dealer and Distributors.  */  
   PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in the customer currency converted using the exchange rate on OrderHed.  */  
   DocPromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   Rpt1PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   Rpt2PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on OrderHed.  */  
   Rpt3PromotionalPrice:number,
      /**  Current status of line.  This is a maintainable status through Order Line Status maintenance.  Depending on the setting can control is line is updatable from the web.  */  
   OrderLineStatusCode:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  Used specifically for Deal Portal and Location Inventory, not for Inventory Tracked Attributes.  */  
   AttributeSetID:number,
      /**  The unique identifier of the related CPQ Configured Quote Product.  */  
   KBConfigProdID:number,
      /**  The unique identifier of the related original CPQ Configured Quote Product.  */  
   KBOriginalConfigProdID:number,
      /**  TotalCovenantDiscount  */  
   TotalCovenantDiscount:number,
      /**  DocCovenantDiscount  */  
   DocCovenantDiscount:number,
      /**  Rpt1CovenantDiscount  */  
   Rpt1CovenantDiscount:number,
      /**  Rpt2CovenantDiscount  */  
   Rpt2CovenantDiscount:number,
      /**  Rpt3CovenantDiscount  */  
   Rpt3CovenantDiscount:number,
      /**  TotalInCovenantDiscount  */  
   TotalInCovenantDiscount:number,
      /**  DocInCovenantDiscount  */  
   DocInCovenantDiscount:number,
      /**  Rpt1InCovenantDiscount  */  
   Rpt1InCovenantDiscount:number,
      /**  Rpt2InCovenantDiscount  */  
   Rpt2InCovenantDiscount:number,
      /**  Rpt3InCovenantDiscount  */  
   Rpt3InCovenantDiscount:number,
   AvailableQuantity:number,
      /**  Available Price Lists  */  
   AvailPriceLists:string,
   AvailUMFromQuote:string,
   BaseCurrencyID:string,
   BaseCurrSymbol:string,
      /**  Default calculated unit price for a particular part/customer.  Used with integrations for pre-order price validations.  */  
   CalcUnitPrice:number,
   ConfigType:string,
   Configured:string,
   CounterSale:boolean,
      /**  The message text returned by the credit check process.  */  
   CreditLimitMessage:string,
      /**  The source that put the customer on credit hold.  */  
   CreditLimitSource:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencyID:string,
   CurrencySwitch:boolean,
   CurrSymbol:string,
   DemandQuantity:number,
   DimCode:string,
   DimConvFactor:number,
      /**  Document currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DocDspDiscount:number,
      /**  Document currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DocDspUnitPrice:number,
      /**  Extended Price for the order line item in Customer currency, rounded according to the Doc currency Round rule  */  
   DocExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in document currency  */  
   DocInMiscCharges:number,
      /**  The amount of discount for display in document currency which does not include taxes  */  
   DocLessDiscount:number,
   DocMiscCharges:number,
      /**  Total tax in Doc currency. The sum of all the tax details for the line (OrderRelTax).  */  
   DocTaxAmt:number,
   DocTotalPrice:number,
      /**  Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DspDiscount:number,
      /**  To display the type of job this is: MFG = Manufacturing, PRJ = Project  */  
   DspJobType:string,
      /**  Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   DspUnitPrice:number,
   DUM:string,
      /**  Web basket configuration related SysRowID  */  
   ECCConfigSysRowId:string,
      /**  Additional discount calculated by ECC  */  
   ECCDiscount:number,
      /**  Prevents Epicor repricing the unit price coming from ECC.  This usually would be a result of Epicor going off-line and order pricing was performed by ECC.  */  
   ECCPreventRepricing:boolean,
      /**  Allow enable/disable for the button Attibutes in Order Line  */  
   EnableDynAttrButton:boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   EnableKitUnitPrice:boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   EnableRenewalNbr:boolean,
      /**  This field is used for a row rule on the UIApp, it is set on the AfterGetRows for this table  */  
   EnableSellingQty:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
   ExtPrice:number,
   FromQuoteLineFlag:boolean,
      /**  Installation price of an equipment that requires installation in Epicor FSA. This value by default is inherited from the part but it could be overridden for another value if it's necessary.  */  
   FSAInstallationCost:number,
   FSAInstallationOrderLine:number,
   FSAInstallationOrderNum:number,
      /**  Indicates if the equipment requires an installation prior being marked as Installed on a Location in Epicor FSA. If true, at shipment it will create a service order for the installation service in FSA.  */  
   FSAInstallationRequired:boolean,
      /**  Indicates the service order template ID that Epicor FSA will use to create the installation service order.  */  
   FSAInstallationType:string,
   FSAInstallationTypeDescription:string,
      /**  Indicates whether the part has at least one Complement  */  
   HasComplement:boolean,
      /**  Indicates whether the part has at least one Downgrade  */  
   HasDowngrade:boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   HasSubstitute:boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   HasUpgrade:boolean,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line  */  
   InMiscCharges:number,
      /**  The flag to indicate if the Order Header Tax Liability is Tax Inclusive Pricing.  */  
   InPrice:boolean,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
      /**  Inventory UOM that the Order Detail is allocated against.  */  
   InvtyUOM:string,
   JobTypeDesc:string,
      /**  If the Job has been already created against this line.  */  
   JobWasCreated:boolean,
      /**  If Kit Flag = P then sets this field to the value of the related PartPlant.KitAllowChangeParms. If KitFlag <> P then this will be FALSE.  */  
   KitChangeParms:boolean,
      /**  Will be set to true if the current OrderDtl record is KitFlag = 'C' and the KitParent of this record is KitAllowUpdate = NO  */  
   KitDisable:boolean,
      /**  Kit Flag Description. "P" = Parent, "C" = Component.  */  
   KitFlagDescription:string,
   KitOrderQtyUOM:string,
      /**  If KitFlag = "C" and the parent kit line is configured OR if KitFlag = "P" and Configured = "On" then this field will be TRUE, otherwise it will be false.  */  
   KitStandard:boolean,
      /**  The amount of discount for display which does not include taxes  */  
   LessDiscount:number,
   LotNum:string,
   MiscCharges:number,
   MultipleReleases:boolean,
   OnHandQuantity:number,
   PartExists:boolean,
   PartTrackDimension:boolean,
   PartTrackLots:boolean,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   POLineRef:string,
   PriceListCodeDesc:string,
   ProcessCounterSale:boolean,
   ProcessQuickEntry:boolean,
   QuoteQtyNum:number,
      /**  For this Detail line there is Release line that has Project and Phase and these Project or Phase was invoiced or used in revenue recognition.  */  
   RelWasRecInvoiced:boolean,
      /**  Pass Credit Limit check message to the UI  */  
   RespMessage:string,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt1DspDiscount:number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt1DspUnitPrice:number,
      /**  Extended Price for the Order Line in Rpt1 currency  */  
   Rpt1ExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   Rpt1InMiscCharges:number,
      /**  The amount of discount for display which does not include taxes (report currency)  */  
   Rpt1LessDiscount:number,
      /**  Report currency misc charges  */  
   Rpt1MiscCharges:number,
      /**  Report currency line tax amount  */  
   Rpt1TaxAmt:number,
      /**  Report currency line total price  */  
   Rpt1TotalPrice:number,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt2DspDiscount:number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt2DspUnitPrice:number,
      /**  Extended Price for the orderLine in Rpt2 currency.  */  
   Rpt2ExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   Rpt2InMiscCharges:number,
      /**  The amount of discount for display in report currency which does not include taxes (report currency)  */  
   Rpt2LessDiscount:number,
      /**  Report currency misc charges  */  
   Rpt2MiscCharges:number,
      /**  Report currency line tax amount  */  
   Rpt2TaxAmt:number,
      /**  Report currency line total price  */  
   Rpt2TotalPrice:number,
      /**  Report Currency Discount amount being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt3DspDiscount:number,
      /**  Report Currency Unit Price being displayed (if the tax option is Tax Inclusive Pricing this amount includes taxes)  */  
   Rpt3DspUnitPrice:number,
      /**  Extended price for the order line in Rpt3 currency  */  
   Rpt3ExtPrice:number,
      /**  Tax Inclusive Pricing - Total Misc Charges for the Order Line in report currency  */  
   Rpt3InMiscCharges:number,
      /**  The amount of discount for display in report currency which does not include taxes (report currency)  */  
   Rpt3LessDiscount:number,
      /**  Report Currency misc charges  */  
   Rpt3MiscCharges:number,
      /**  Report currency line tax amount  */  
   Rpt3TaxAmt:number,
      /**  Report currency line total price  */  
   Rpt3TotalPrice:number,
   SalesRepName1:string,
   SalesRepName2:string,
   SalesRepName3:string,
   SalesRepName4:string,
   SalesRepName5:string,
      /**  Total tax in base currency. The sum of all the tax details for the line.  */  
   TaxAmt:number,
      /**  The Sales Order Quantity expressed in the Inventory Unit of Measure  */  
   ThisOrderInvtyQty:number,
   TotalPrice:number,
   TotalShipped:number,
   WarehouseCode:string,
   WarehouseDesc:string,
   BinNum:string,
      /**  Attribute class is MRP Planned but AttributeSetID has not been set on releases.  */  
   AttributeMismatch:boolean,
      /**  A string containing the parameters needed to run Job Manager  */  
   JobManagerString:string,
      /**  Default calculated order value based discounts unit price for a particular part/customer.  Used with integrations for pre-order price validations.  */  
   CalcOrdBasedPrice:number,
      /**  At least 1 OrderRel for OrderDtl has a PONum assigned.  */  
   SalesOrderLinked:boolean,
      /**  This external column is to be used for the purpose of adding an OrderDtl for a part that has Track Inventory Attributes, allowing the AttributeSetID to be passed in with the line to be included on the OrderRel within the same update method call.  */  
   InventoryAttributeSetID:number,
   BitFlag:number,
   CommodityCodeDescription:string,
   ContractCodeContractDescription:string,
   CustNumSendToFSA:boolean,
   CustNumBTName:string,
   CustNumCustID:string,
   CustNumName:string,
   DiscBreakListCodeListDescription:string,
   DiscBreakListCodeEndDate:string,
   DiscBreakListCodeStartDate:string,
   MktgCampaignIDCampDescription:string,
   MktgEvntEvntDescription:string,
   OrderNumBTCustNum:number,
   OrderNumCurrencyCode:string,
   OrderNumCardMemberName:string,
   PartNumSendToFSA:boolean,
   PartNumTrackInventoryByRevision:boolean,
   PartNumAttrClassID:string,
   PartNumSalesUM:string,
   PartNumPricePerCode:string,
   PartNumTrackSerialNum:boolean,
   PartNumPartDescription:string,
   PartNumIUM:string,
   PartNumTrackLots:boolean,
   PartNumSellingFactor:number,
   PartNumTrackDimension:boolean,
   PartNumDefaultAttributeSetID:number,
   PartNumFSAEquipment:boolean,
   PartNumTrackInventoryAttributes:boolean,
   PriceBreakListDescription:string,
   PriceBreakStartDate:string,
   PriceBreakEndDate:string,
   ProdCodeDescription:string,
   ProjectIDDescription:string,
   QuoteNumCurrencyCode:string,
   SalesCatIDDescription:string,
   TaxCatIDDescription:string,
   WarrantyCodeWarrDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_OrderHedRow{
      /**  Indicates if this order is in an "open" status. Open orders appear in the browses, open order reports. This field is not directly maintainable. Instead it is set to "no" if order is cancelled or if there are no open line details. If the order has no OrderDtl records, then it is still considered as "open". An order that is not open, is not accessible by order entry.  */  
   OpenOrder:boolean,
      /**   Indicates that the Order item was closed before any shipments were made against it. Normally the Orders are closed as part of the Shipping process when all the releases have been closed.  By using the "Close Order" menu option the user can close the Order manually, to provide the function to "Cancel"  the order when the customer cancels there request.  If the Order item had no shipments made it is then marked as "voided". Regardless of shipment activity the Order is always marked as closed (OpenOrder = No).
When an OrderHed record is 'voided/closed' all of it's related OrderDtl and OrderRel records are also Closed/Voided thereby removing  any outstanding inventory allocations, if the OrderRel records were related to Jobs then they are flagged (OrderRel.OpenChg = Yes) to show up in the Job "Change Order List".  */  
   VoidOrder:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  When creating a new order the user is prompted for an order number. If the field is left blank, the next available # is assigned by the system. The system generates a number by finding the order # of the last record on file and then adding 1 to it.  */  
   OrderNum:number,
      /**  Contains the Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   CustNum:number,
      /**  This is an optional field used to enter the customers Purchase Order Number.  This will be used as an alternate index for searching Orders by PO number.  */  
   PONum:string,
      /**  Indicates if an order is flagged as being "HELD" , this  is primarily used as a visual indicator in shipping entry. It does not prevent shipments from being entered for this order.  */  
   OrderHeld:boolean,
      /**   This is used as one of the selection parameters on the Order entry edit reports. The intent is for users to be able to select orders that they have entered for hard copy edit.

On new orders use the users login ID as the default. They can override this if they wish to enter something more meaningful.  */  
   EntryPerson:string,
      /**  Indicates which customer ship to is to be used as the default for the Order release records for this order. It  can be blank or it must be valid in the SHIPTO table. Use the CUSTOMER.SHIPTONUM as the default on new orders or when the ORDERHED.CUSTNUM is changed.  */  
   ShipToNum:string,
      /**  Date that the items need to be shipped by to meet the customers NeedByDate.  This can be left blank, it is only used to supply a default for OrderDtl.RequestDate.  */  
   RequestDate:string,
      /**  Mandatory entry and must be valid. Default as the system date.  */  
   OrderDate:string,
      /**  An optional field that describes the FOB policy.  */  
   FOB:string,
      /**  Contains the key value of the record in the "SHIPVIA" table. It can be left blank or must be valid in the 'SHIPTO"  table.
Use the CUSTOMER.SHIPVIA as the default when the ORDER.CUSTNUM field is changed and the ORDERHED.SHIPTO is blank. Use SHIPTO.SHIPVIA when ORDER.CUSTNUM or ORDERHED.SHIPTO fields are changed and the ORDERHED.SHIPTO is not blank.  */  
   ShipViaCode:string,
      /**   Contains the key value of the record in the TERMS table which indicates the sales terms established for this order. On change of ORDERHED.CUSTNUM use the CUSTOMER.TERMS

field as the default.  */  
   TermsCode:string,
      /**  Used to establish a discount percent value which will be used as a default during order detail line entry. It can be left as zero.  Use the CUSTOMER.DISCOUNTPERCENT field as a default. Refreshed whenever ORDERHED.CUSTOMER field changes.  */  
   DiscountPercent:number,
      /**  Contains the key  value for the Purchasing Contact. This can be blank or it must be valid in the CUSTCNT  table. Use the CUSTOMER.PRIMPCON as the default.  */  
   PrcConNum:number,
      /**  Establishes the Shipping Contact to be used as default on the Order release records. Contains the key value for the shipping contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table. Use the Customer.PrimScon as a default.  */  
   ShpConNum:number,
      /**  Stores the Sales Rep Codes for the order. Up to five codes can be  established. This field is not directly maintainable. Instead temp widgets are used for entry of each individual code and then put together as one comma delimited string field and assigned to this field.  This field will have a Word index, it then will make reporting and data base integrity checking much easier through the use of the "contains phrase" when retrieving records. These codes can be left blank or must be valid in the SalesRep master. The first one is defaulted from the Customer master if ship to is blank; otherwise, from the Ship To.  */  
   SalesRepList:string,
      /**  Contains comments about the overall order. These will be printed on the Sales Acknowledgements.  */  
   OrderComment:string,
      /**  Used to establish shipping comments about the overall order. These will copied into the packing slip header file as defaults.  */  
   ShipComment:string,
      /**  Used to establish invoice comments about the overall order. These will copied into the Invoice detail file as defaults.  */  
   InvoiceComment:string,
      /**  Contains picking  comments about the overall order. These will be printed on the picking lists.  */  
   PickListComment:string,
      /**  Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   DepositBal:number,
      /**  Display value contains the deposit balance in the customer's currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   DocDepositBal:number,
      /**  Date customer needs the items on this order to arrive.  This is used only as the default value for the NeedByDate when creating order detail line items.  This can be left blank.  */  
   NeedByDate:string,
      /**  Indicates that the credit hold was overridden for this order.  */  
   CreditOverride:boolean,
      /**  The USERID of the user that overrode an order credit hold (system set).  */  
   CreditOverrideUserID:string,
      /**  The date that the user last overrode the customer credit hold (system set).  */  
   CreditOverrideDate:string,
      /**  The time that the user last overrode the customer credit hold in HH:MM:SS format (system set).  */  
   CreditOverrideTime:string,
      /**  The authorized maximum dollar limit that an order for a credit held customer is approved for.  Initially defaulted to the current order amount when the order is credit hold overridden.  The order amount is calculated by using line information only (i.e. extended amount and discounts) - deposits, advance billings, shipments and miscellaneous charges are NOT considered.  */  
   CreditOverrideLimit:number,
      /**  Controls if an alert is to be sent when shipments are made for this order.  */  
   SndAlrtShp:boolean,
      /**   Exchange rate that will be used for this order.  Defaults from
CurrRate.CurrentRate. Conversion rates will be calculated as System Base = Foreign value * rate, Foreign value = system base * (1/rate). This is the dollar in foreign currency from the exchange rate tables in the newspapers.  */  
   ExchangeRate:number,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**  Used with the currency module.  When TRUE the currency rate can be changed by the user and cannot be changed by the system.  This will also be the default for the invoice.  */  
   LockRate:boolean,
      /**  The member's name on the credit card.  */  
   CardMemberName:string,
      /**  The credit card account identifier.  */  
   CardNumber:string,
      /**  A code assigned by the user to uniquely identify a Credit Card Type master. This can't be blank.  */  
   CardType:string,
      /**  The expiration month of the credit card.  */  
   ExpirationMonth:number,
      /**  The expiration year of the credit card.  */  
   ExpirationYear:number,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention.  */  
   CardID:string,
      /**  Up to 17 alphnumeric characters provided by customer. This is used to track information on customer spending (e.g., cost center, project code). This field is especially critical, since inaccurate information will affect the general ledger. If no reference number is provided, leave this field blank.  */  
   CardmemberReference:string,
      /**  Code used to relate a AllocPri record to the order.  Defaulted from Customer.AllocPriorityCode.  */  
   AllocPriorityCode:string,
      /**  Code used to relate a ReservePri record to the order.  Defaulted from Customer.ReservePriorityCode.  */  
   ReservePriorityCode:string,
      /**  Indicates if the order must be shipped complete.  That is, as an orders release are selected for picking during the Auto Pick process of the Order Allocation program, the all releases with a ship date <= the given cutoff date alos have to be picked complete otherwise they will not be selected. This is defaulted to Yes when Customer.ShippingQualifier = "O" (Ship Order 100% complete)  */  
   ShipOrderComplete:boolean,
      /**  Not editable, When SF Synch creates orders, this flag is set to YES.  */  
   WebOrder:boolean,
      /**  Updated Via SF Synch.  This is the authorization number from a third party credit card validation service.  */  
   CCApprovalNum:string,
      /**  Order created from EDI interfaced module.  */  
   EDIOrder:boolean,
      /**  Updated from EDI module if 855 or 865 created.  */  
   EDIAck:boolean,
      /**  Indicates if this order header is linked to an inter-company PO header.  */  
   Linked:boolean,
      /**  Inter-Company Purchase order number that uniquely identifies the purchase order.  */  
   ICPONum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  This is the web-login-id (email address) of the person that placed the order.  */  
   WebEntryPerson:string,
      /**  Indicates whether the email acknowledgement of the order has been sent.  (For web orders)  */  
   AckEmailSent:boolean,
      /**  Indicates if order based discounting needs to be applied to the order.  */  
   ApplyOrderBasedDisc:boolean,
      /**  Indicates if order based discounting should be applied automatically or manually triggered by user as menu option.  */  
   AutoOrderBasedDisc:boolean,
      /**   Indicates Entry method program that used to create the order.
S = Standard, Q = Quick Entry,  C = Counter Sales, D = Demand/EDI  */  
   EntryMethod:string,
      /**  The help desk case that created this order.  */  
   HDCaseNum:number,
      /**  Flag used in sales order entry for counter sales orders.  */  
   CounterSale:boolean,
      /**  Create AR Invoice for counter sales order.  */  
   CreateInvoice:boolean,
      /**  Create Packing Slip for counter sale.  */  
   CreatePackingSlip:boolean,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the order quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   LockQty:boolean,
      /**  Stores the encrypted credit card number  */  
   ProcessCard:string,
      /**  Credit Transaction Amount, makes up part of CCTotal  */  
   CCAmount:number,
      /**  Credit Card transaction freight amount, part of CCTotal  */  
   CCFreight:number,
      /**  Credit Card Transaction Tax amount, part of CCTotal  */  
   CCTax:number,
      /**  Total amount being sent to the credit card processor  */  
   CCTotal:number,
      /**  See CCAmount  */  
   CCDocAmount:number,
      /**  See CCFreight  */  
   CCDocFreight:number,
      /**  See CCTax  */  
   CCDocTax:number,
      /**  See CCTotal  */  
   CCDocTotal:number,
      /**  Address used during AVS validation for credit transactions  */  
   CCStreetAddr:string,
      /**  Zip used during AVS validation in credit transactions  */  
   CCZip:string,
      /**  Bill To Customer Number  */  
   BTCustNum:number,
      /**  New database field as it can be changed by user.  Default is set to BTCustNum?s primary billing contact.  If a primary billing contact is not set, default is ?None Selected?.  Keep in mind the BTCustNum field may be the same as CustNum (SoldTo) but the default would still be this customer?s primary billing contact where the ConNum field (Contact for sold to) is defaulting the primary purchasing contact.  */  
   BTConNum:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate4:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate5:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit1:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit2:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit3:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit4:number,
      /**  Split percent is used to calculate the "commissionable"  dollar amount. This field is used to establish the default split percent used in detail line entry. Should be zero if the corresponding SalesRep code is blank. Default as 100 percent  */  
   RepSplit5:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate1:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate2:number,
      /**  Establishes the defaults sales rep commission rates to be used during entry of order detail lines. Must be zero if the ORDERHED.SALEREPCODE is blank. Default is the SALESREP.COMMISSIONPERCENT.  */  
   RepRate3:number,
      /**  Incremented whenever an outbound sales document is generated from the order, i.e. Sales Order Acknowledgement, Response to Change, etc.  */  
   OutboundSalesDocCtr:number,
      /**  Incremented whenever an outbound shipping document is generated from the order, i.e. ASN.  */  
   OutboundShipDocsCtr:number,
      /**  The demand contract this OrderHed is related to.  */  
   DemandContractNum:number,
      /**  The date before which the order cannot be shipped.  */  
   DoNotShipBeforeDate:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  The date after which the order cannot be shipped.  */  
   DoNotShipAfterDate:string,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  The date after which the sales order should be canceled.  */  
   CancelAfterDate:string,
      /**  Indicates if the demand that created/updated this order has been rejected.  */  
   DemandRejected:boolean,
      /**  Override Carrier Defaults.  If not checked then the Site values will be used  */  
   OverrideCarrier:boolean,
      /**  Override Service Options.  If not checked then the Site values will be used  */  
   OverrideService:boolean,
      /**  Indicates if the Order is a credit card order  */  
   CreditCardOrder:boolean,
      /**  This field along with Company and DemandContractNum make up the unique key to the table. The system should generate this number during entry of new header records. The system determines next available number by finding the last DemandHead for the DemandContractNum and adding 1.  */  
   DemandHeadSeq:number,
      /**  For Shipping; Bill Shipper, Bill Recipient, Bill Third Party, Bill Consignee  */  
   PayFlag:string,
      /**  Shipping Pay Flag Account Number. Required when Pag Flag is collect or Third party  */  
   PayAccount:string,
      /**  Shipping Bill To. The first line of the Payers main address. Required when Pay Flag is Third party.  */  
   PayBTAddress1:string,
      /**  Shipping Bill To.  The second line of the Payers main address. An address is required when Pay Flag is Third party  */  
   PayBTAddress2:string,
      /**  Shipping, The city portion of the Payer main address.  */  
   PayBTCity:string,
      /**  The state or province portion of the shipment payer main address.  */  
   PayBTState:string,
      /**  The zip or postal code portion of the shipping payers main address.  */  
   PayBTZip:string,
      /**  The country of the main shipping payers address.  */  
   PayBTCountry:string,
      /**  Freight charges will not be returned if 'yes'  */  
   DropShip:boolean,
      /**  Added for international shipping  */  
   CommercialInvoice:boolean,
      /**  Added for international shipping. Shipper's Export Declaration  */  
   ShipExprtDeclartn:boolean,
      /**  For International shipping.  Certificate of Orgin.  */  
   CertOfOrigin:boolean,
      /**  For International shipping.  Shipper's Letter of Instruction.  */  
   LetterOfInstr:boolean,
      /**  International Shipping. Frieght Forwarder ID  */  
   FFID:string,
      /**  International Shipping. The first line of the Frieght Forwarder main address.  */  
   FFAddress1:string,
      /**  International Shipping. The second line of the Frieght Forwarder main address.  */  
   FFAddress2:string,
      /**  Shipping, The city portion of the Frieght Forwarder main address.  */  
   FFCity:string,
      /**  International Shipping. The state or province portion of the shipment Frieght Forwarder main address.  */  
   FFState:string,
      /**  International Shipping. The zip or postal code portion of the shipping Frieght Forwarder main address.  */  
   FFZip:string,
      /**  International shipping. The country of the Frieght Forwarder .  */  
   FFCountry:string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   FFContact:string,
      /**  International Shipping. Frieght Forwarder company name  */  
   FFCompName:string,
      /**  International Shipping. Frieght Forwarder Phone number  */  
   FFPhoneNum:string,
      /**  Is this an International shipment  */  
   IntrntlShip:boolean,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**  Defines if this document is marked as EDI Ready  */  
   EDIReady:boolean,
      /**  Indicates whether or not all freight charges sent or received are for individual pack DIs or the master pack.  */  
   IndividualPackIDs:boolean,
      /**  Freight Forwarder third address line.  */  
   FFAddress3:string,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Additional Handling Required flag  */  
   AddlHdlgFlag:boolean,
      /**  Non Standard Package flag.  */  
   NonStdPkg:boolean,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Freight Forwarder country portion of the address  */  
   FFCountryNum:number,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Payer Bill To  third address line  */  
   PayBTAddress3:string,
      /**  Payer Bill To country portion of the address  */  
   PayBTCountryNum:number,
      /**  Payer Bill To phone number  */  
   PayBTPhone:string,
      /**  UPS Quantity View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View Ship from Nam  */  
   UPSQVShipFromName:string,
      /**  UPS Quantity View Memo  */  
   UPSQVMemo:string,
      /**  This flag will be used to indicate if the order is ready for calculations. When set to true, tax calculations will take place whenever a save takes place for any tables tied to the order which could affect taxes (OrderDtl, OrderHed, OrderMisc, etc). It defaults from XASyst.SOReadyToCalcDflt field when an order is created.  */  
   ReadyToCalc:boolean,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalCharges:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalMisc:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalDiscount:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   TotalComm:number,
      /**  Total Advance Billable Balance  */  
   TotalAdvBill:number,
      /**  Total number of lines on the order  */  
   TotalLines:number,
      /**  Total Number of releases on order  */  
   TotalReleases:number,
      /**  Total number of distinct release dates on order  */  
   TotalRelDates:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalCharges:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalMisc:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalDiscount:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   DocTotalComm:number,
      /**   Order Total Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   TotalTax:number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   DocTotalTax:number,
      /**  Total Advance Billable Balance  */  
   DocTotalAdvBill:number,
      /**  Total Shipped amount  */  
   TotalShipped:number,
      /**  Total amount of order that has been invoiced  */  
   TotalInvoiced:number,
      /**  Total number of lines that were commissionable  */  
   TotalCommLines:number,
      /**  Commission earned for first sales rep  */  
   SRCommAmt1:number,
      /**  Commission earned for second sales rep  */  
   SRCommAmt2:number,
      /**  Commission earned for third sales rep  */  
   SRCommAmt3:number,
      /**  Commission earned for fourth sales rep  */  
   SRCommAmt4:number,
      /**  Commission earned for fifth sales rep  */  
   SRCommAmt5:number,
      /**  Total Commissionable Amount for first salesrep  */  
   SRCommableAmt1:number,
      /**  Total Commissionable Amount for second salesrep  */  
   SRCommableAmt2:number,
      /**  Total Commissionable Amount for third salesrep  */  
   SRCommableAmt3:number,
      /**  Total Commissionable Amount for fourth salesrep  */  
   SRCommableAmt4:number,
      /**  Total Commissionable Amount for fifth salesrep  */  
   SRCommableAmt5:number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   Rounding:number,
      /**  Display value contains the deposit balance in a reporting currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   Rpt1DepositBal:number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   DocRounding:number,
      /**  Display value contains the deposit balance in a report currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   Rpt2DepositBal:number,
      /**  Display value contains the deposit balance in a report currency when the currency module is used; otherwise it is equal to the DepositBal. customer. Contains the current outstanding (liability) deposits that have been made for the sales order. This value is increased via cash receipts or "deposit" type invoices. It is supplied as a default to invoice entry (InvcHead.DepositCredit) at which time it is decreased.  */  
   Rpt3DepositBal:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalCharges:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalCharges:number,
      /**   Total Line Amount
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalCharges:number,
      /**  Total Advance Billable Balance  */  
   Rpt1TotalAdvBill:number,
      /**  Total Advance Billable Balance  */  
   Rpt2TotalAdvBill:number,
      /**  Total Advance Billable Balance  */  
   Rpt3TotalAdvBill:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalMisc:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalMisc:number,
      /**   Total Miscellaneous charges
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalMisc:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalDiscount:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalDiscount:number,
      /**   Total Line Discounts
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalDiscount:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt1TotalComm:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt2TotalComm:number,
      /**   Total Commissions for Order
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes
Net Total = Order Total - TotalComm  */  
   Rpt3TotalComm:number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax +TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt1TotalTax:number,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt2TotalTax:number,
      /**  Reporting currency value of this field  */  
   Rpt1Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt2Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt3Rounding:number,
      /**  Unique identifier  */  
   RateGrpCode:string,
      /**   Total Order Invoice Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt3TotalTax:number,
      /**  See CCAmount  */  
   Rpt1CCAmount:number,
      /**  See CCAmount  */  
   Rpt2CCAmount:number,
      /**  See CCAmount  */  
   Rpt3CCAmount:number,
      /**  See CCFreight  */  
   Rpt1CCFreight:number,
      /**  See CCFreight  */  
   Rpt2CCFreight:number,
      /**  See CCFreight  */  
   Rpt3CCFreight:number,
      /**  See CCTax  */  
   Rpt1CCTax:number,
      /**  See CCTax  */  
   Rpt2CCTax:number,
      /**  See CCTax  */  
   Rpt3CCTax:number,
      /**  See CCTotal  */  
   Rpt1CCTotal:number,
      /**  See CCTotal  */  
   Rpt2CCTotal:number,
      /**  See CCTotal  */  
   Rpt3CCTotal:number,
      /**  Total order Amount. This field is an accumulation of the extended net amounts of the detail line items  */  
   OrderAmt:number,
      /**  Total order Amount in customer currency. This field is an accumulation of the extended net amounts of the detail line items and rounded according to the Doc currency Round rule  */  
   DocOrderAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1OrderAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2OrderAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3OrderAmt:number,
      /**  Tax Point  */  
   TaxPoint:string,
      /**  Date Used to calculate Tax Rates  */  
   TaxRateDate:string,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**   Indicates if the One Time Shipto information is to be used.
Note: This can only be true when if the OTSName is not blank. 
UI disables this when Customer.AllowQTS = False,  */  
   UseOTS:boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   OTSName:string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   OTSAddress1:string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   OTSAddress2:string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   OTSAddress3:string,
      /**  City portion of the One Time Shipto  address.  */  
   OTSCity:string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   OTSState:string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   OTSZIP:string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   OTSResaleID:string,
      /**  One Time Ship To Contact Name  */  
   OTSContact:string,
      /**  Fax number for the One Time ShipTo.  */  
   OTSFaxNum:string,
      /**  Phone number for the One Time ShipTo  */  
   OTSPhoneNum:string,
      /**  One Time Shipment country  */  
   OTSCountryNum:number,
      /**   Order Total Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   TotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   DocTotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt1TotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt2TotalWHTax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt3TotalWHTax:number,
      /**   Order Total Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   TotalSATax:number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   DocTotalSATax:number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt1TotalSATax:number,
      /**   Total Order Self Assessed Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt2TotalSATax:number,
      /**   Total Order Withholding Taxes
Order Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Order Total - TotalComm  */  
   Rpt3TotalSATax:number,
      /**  Indicates if/how the OTS is saved. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   OTSSaveAs:string,
      /**  CustID to be used if the OTS is used to create a customer record.  */  
   OTSSaveCustID:string,
      /**  True if Customer or ShipTo record was created using the  OTS info.  */  
   OTSCustSaved:boolean,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  Status of Order  */  
   OrderStatus:string,
      /**  Hold Set by Demand  */  
   HoldSetByDemand:boolean,
      /**  Indicates that the tax is included in the unit price  */  
   InPrice:boolean,
      /**  Reserved for future use  */  
   InTotalCharges:number,
      /**  Reserved for future use  */  
   InTotalMisc:number,
      /**  Reserved for future use  */  
   InTotalDiscount:number,
      /**  Reserved for future use  */  
   DocInTotalCharges:number,
      /**  Reserved for future use  */  
   DocInTotalMisc:number,
      /**  Reserved for future use  */  
   DocInTotalDiscount:number,
      /**  Reserved for future use  */  
   Rpt1InTotalCharges:number,
      /**  Reserved for future use  */  
   Rpt2InTotalCharges:number,
      /**  Reserved for future use  */  
   Rpt3InTotalCharges:number,
      /**  Reserved for future use  */  
   Rpt1InTotalMisc:number,
      /**  Reserved for future use  */  
   Rpt2InTotalMisc:number,
      /**  Reserved for future use  */  
   Rpt3InTotalMisc:number,
      /**  Reserved for future use  */  
   Rpt1InTotalDiscount:number,
      /**  Reserved for future use  */  
   Rpt2InTotalDiscount:number,
      /**  Reserved for future use  */  
   Rpt3InTotalDiscount:number,
      /**  Letter of Credit ID.  */  
   ARLOCID:string,
      /**  Bank for Cash Receipts. Default is from Customer(Bill To).  */  
   OurBank:string,
      /**  It will be used to identify SO that will generate an invoice at the shipment.  If the order is created manually the default for this order will be taken from the customer master file. If the order is created via DM, the default will be taken from the value in the DM records.  */  
   ERSOrder:boolean,
      /**  Indicates that order is on hold due to amount exceeding value on Letter of Credit.  */  
   LOCHold:boolean,
      /**  Currency code used in further packing slips.  */  
   PSCurrCode:string,
      /**  Currency code used in further AR invoices.  */  
   InvCurrCode:string,
      /**  Legal Number for the record.  */  
   LegalNumber:string,
      /**  Transaction Document for the record.  */  
   TranDocTypeID:string,
      /**  Cross Reference Contract Number.  */  
   XRefContractNum:string,
      /**  Cross Reference Contract Date.  */  
   XRefContractDate:string,
      /**  Date in which the related demand was last processed.  */  
   DemandProcessDate:string,
      /**  System Time when demand was last processed.  */  
   DemandProcessTime:number,
      /**  Last Schedule Number in which the demand was processed.  */  
   LastScheduleNumber:string,
      /**  EDI Transaction Control Number  */  
   LastTCtrlNum:string,
      /**  EDI Batch Control Number  */  
   LastBatchNum:string,
      /**  ECCOrderNum  */  
   ECCOrderNum:string,
      /**  ECCPONum  */  
   ECCPONum:string,
      /**  WIOrder  */  
   WIOrder:string,
      /**  WIApplication  */  
   WIApplication:string,
      /**  WIUsername  */  
   WIUsername:string,
      /**  WIUserID  */  
   WIUserID:string,
      /**  WICreditCardorder  */  
   WICreditCardorder:boolean,
      /**  OrderCSR  */  
   OrderCSR:string,
      /**  UserChar1  */  
   UserChar1:string,
      /**  UserChar2  */  
   UserChar2:string,
      /**  UserChar3  */  
   UserChar3:string,
      /**  UserChar4  */  
   UserChar4:string,
      /**  UserDate1  */  
   UserDate1:string,
      /**  UserDate2  */  
   UserDate2:string,
      /**  UserDate3  */  
   UserDate3:string,
      /**  UserDate4  */  
   UserDate4:string,
      /**  UserDecimal1  */  
   UserDecimal1:number,
      /**  UserDecimal2  */  
   UserDecimal2:number,
      /**  UserInteger1  */  
   UserInteger1:number,
      /**  UserInteger2  */  
   UserInteger2:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  IsCSRSet  */  
   IsCSRSet:boolean,
      /**  ECCPaymentMethod  */  
   ECCPaymentMethod:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  OTSShipToNum  */  
   OTSShipToNum:string,
      /**  ProFormaInvComment  */  
   ProFormaInvComment:string,
      /**  ccToken  */  
   ccToken:string,
      /**  InvcOrderCmp  */  
   InvcOrderCmp:boolean,
      /**  ReprintSOAck  */  
   ReprintSOAck:boolean,
      /**  CounterSOAck  */  
   CounterSOAck:number,
      /**  DispatchReason  */  
   DispatchReason:string,
      /**  Plant  */  
   Plant:string,
      /**  This flag will be used to indicate if the sales order is ready to be fulfilled.  */  
   ReadyToFulfill:boolean,
      /**  Ship the good by this time  */  
   ShipByTime:number,
      /**  Taiwan GUI Calendar Fiscal Year  */  
   TWFiscalYear:number,
      /**  Taiwan GUI Calendar Fiscal Year Suffix  */  
   TWFiscalYearSuffix:string,
      /**  Taiwan GUI Calendar Fiscal Period  */  
   TWFiscalPeriod:number,
      /**  GUI Group of Legal Numbers  */  
   TWGUIGroup:string,
      /**  Seller GUI Code  */  
   TWGUIRegNumSeller:string,
      /**  Buyer GUI Code  */  
   TWGUIRegNumBuyer:string,
      /**  OrderOpenCredit  */  
   OrderOpenCredit:number,
      /**  ClosedNotShipped  */  
   ClosedNotShipped:number,
      /**  InvCurrDepositBal  */  
   InvCurrDepositBal:number,
      /**  Article. 106c  */  
   PLArticle106c:boolean,
      /**  Invoices are issued by a taxpayer's representative  */  
   PLInvIssuedByTaxpayer:boolean,
      /**  Invoices issued by the second taxpayer  */  
   PLInvIssuedBySecondTaxpayer:boolean,
      /**  Tourist Services  */  
   PLTouristService:boolean,
      /**  Second hand goods, works of art, collectibles or antiques  */  
   PLSecondHandOrArts:boolean,
      /**  Appropriate Legal Article of the Act  */  
   PLLegalArticleAct:string,
      /**  Appropriate Legal Article of 2006/112/WE Directive  */  
   PLLegalArticleWEDirective:string,
      /**  Other Legal Article  */  
   PLLegalArticleOther:string,
      /**  Name of the Enforcement Authority or the Name of the Judicial Officer  */  
   PLEnforcementAuthName:string,
      /**  Address of the Enforcement Authority or Judicial Officer  */  
   PLEnforcementAuthAddr:string,
      /**  Tax Representative Name  */  
   PLTaxRepresentativeName:string,
      /**  Tax Representative Address  */  
   PLTaxRepresentativeAddr:string,
      /**  Tax ID of the Tax Representative  */  
   PLTaxRepresentativeTaxID:string,
      /**  Margin Scheme  */  
   PLMarginScheme:number,
      /**  Goods or Service VAT exempt  */  
   PLGoodsOrServiceVATExempt:boolean,
      /**  Credit Card Holder City  */  
   CCCity:string,
      /**  Credit Card Holder State  */  
   CCState:string,
      /**  ExtAOEUserID  */  
   ExtAOEUserID:string,
      /**  ExtAOE  */  
   ExtAOE:string,
      /**  OTSTaxValidationStatus  */  
   OTSTaxValidationStatus:number,
      /**  OTSTaxValidationDate  */  
   OTSTaxValidationDate:string,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  Incoterm Code  */  
   IncotermCode:string,
      /**  Incoterm Location  */  
   IncotermLocation:string,
      /**  CovenantDiscPercent  */  
   CovenantDiscPercent:number,
      /**  TotalCovenantDiscount  */  
   TotalCovenantDiscount:number,
      /**  DocCovenantDiscount  */  
   DocCovenantDiscount:number,
      /**  Rpt1CovenantDiscount  */  
   Rpt1CovenantDiscount:number,
      /**  Rpt2CovenantDiscount  */  
   Rpt2CovenantDiscount:number,
      /**  Rpt3CovenantDiscount  */  
   Rpt3CovenantDiscount:number,
      /**  TotalInCovenantDiscount  */  
   TotalInCovenantDiscount:number,
      /**  DocInCovenantDiscount  */  
   DocInCovenantDiscount:number,
      /**  Rpt1InCovenantDiscount  */  
   Rpt1InCovenantDiscount:number,
      /**  Rpt2InCovenantDiscount  */  
   Rpt2InCovenantDiscount:number,
      /**  Delimited list of available bill to customers (CustID`CustomerName~CustID`CustomerName)  */  
   AvailBTCustList:string,
      /**  AVSADDR returned by a 3rd party credit card processing company  for a credit card transaction. This value represents the results of the Address Verification System (AVS) address test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   AVSAddr:string,
      /**  Rpt3InCovenantDiscount  */  
   Rpt3InCovenantDiscount:number,
      /**  AVSZIP returned by a 3rd party credit card processing company  for a credit card transaction. This value represents the results of the Address Verification System (AVS) zip code test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   AVSZip:string,
   BaseCurrencyID:string,
   BaseCurrSymbol:string,
      /**  Bill to customer name.  */  
   BillToCustomerName:string,
      /**  Bill To Address List.  */  
   BTAddressList:string,
   BTContactEMailAddress:string,
      /**  Bill to contact fax number.  */  
   BTContactFaxNum:string,
      /**  Bill to contact name.  */  
   BTContactName:string,
      /**  Bill to contact phone number.  */  
   BTContactPhoneNum:string,
      /**  Bill To Customer ID  */  
   BTCustID:string,
      /**  The flag to indicate if the user can change Tax Liability on the header level after adding a detail line.  */  
   CanChangeTaxLiab:boolean,
      /**  Stored Credit Card Number  */  
   CardStore:string,
      /**  Optional field, a 4-digit, non-embossed code on face of American Express Card assigned for fraud prevention  */  
   CCCSCID:string,
      /**  Tokenized value of CSCID  */  
   CCCSCIDToken:string,
      /**   Indicates if the credit card setup will be using a testing Paygate instance for transactions.
Force requests to use Paygate test url: paygate-test1.eaglesoa.com  */  
   CCIsTraining:boolean,
      /**  RESPMSG returned by  a 3rd party credit card processing company for a credit card transaction. This is a brief description of the status of the credit card transaction.  */  
   CCResponse:string,
   CCRounding:number,
      /**  PNREF returned by a 3rd party credit card processing company for a credit card transaction. This is a unique number that identifies the transaction and is often referenced we performing related transactions.  */  
   CCTranID:string,
      /**  Credit Card Transaction Type  */  
   CCTranType:string,
      /**  CVV2MATCH returned by a 3rd party credit card processing company for a credit card transaction. This value represents the results of the Card Security Code test. The result in this field does not affect the outcome of the transaction and is supplied for advisory purposes only.  */  
   CSCResult:string,
   CurrencySwitch:boolean,
   CustAllowOTS:boolean,
   CustomerPrintAck:boolean,
      /**  If true the customer requires a unique PO on Sales Orders  */  
   CustomerRequiresPO:boolean,
      /**  When set to true, indicates that this customer does not have credit available from your company.  */  
   CustOnCreditHold:boolean,
   CustTradePartnerName:string,
      /**  DemandContract  */  
   DemandContract:string,
   DocCCRounding:number,
   DocTotalNet:number,
   DocTotalOrder:number,
      /**  If SoldTo and Alt-Bill to are the same, this displays as null.  */  
   dspBTCustID:string,
      /**  ECC Contact Email - Contains the email address of the ECC login that placed the sales order. This only applies for B2C Orders.  */  
   ECCEmail:string,
      /**  ECC Payment Description  */  
   ECCPaymentDesc:string,
      /**  True when Credit Card Procesing module is enabled  */  
   EnableCreditCard:boolean,
      /**  True when Job Wizard must be enabled  */  
   EnableJobWizard:boolean,
      /**  True when SoldTo ID must be enabled  */  
   EnableSoldToID:boolean,
      /**  this is used in order entry to ignore afterGetRows logic (logic that just refreshes external fields).  */  
   EntryProcess:string,
      /**  It will be displayed when the value of the ERS flag at the sales order is different from the value in the customer master file.  */  
   ERSOverride:boolean,
      /**  Used by UI to disable CurrencyCode  */  
   HasMiscCharges:boolean,
   HasOrderLines:boolean,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
   LinkMsg:string,
      /**  Internal field which indicates if Order Tax Liability is not going to be changed even though Ship To is changed.  Related to Tax inclusive pricing. Depends on user response.  */  
   NoTaxRgnChange:boolean,
   OTSSaved:boolean,
      /**  OTS Tax Liability Code (Header)  */  
   OTSTaxRegionCode:string,
      /**  Contains the Parent Customer number that the sales order is for.  This must be valid in the Customer table.  */  
   ParentCustNum:number,
   ProposedTaxRgn:string,
      /**  PNRef number referred to in the transaction.  If Deposit transaction must referenece prior Authorization using the PNRef  */  
   ReferencePNRef:string,
      /**  Internal field toindicate if the system should reset Bill to Customer address.  Based on the  user reply for LOC.  */  
   ResetBTCustAddr:boolean,
      /**  Internal field which indicates if existing Release Tax Region should be se-set to the new Order Header Tax Liability.  Depends on the user reply.  */  
   ResetRelTaxRgn:boolean,
   Rpt1CCRounding:number,
   Rpt1TotalNet:number,
   Rpt2CCRounding:number,
   Rpt2TotalNet:number,
   Rpt3CCRounding:number,
   Rpt3TotalNet:number,
      /**  Element 1 of SalesRepList  */  
   SalesRepCode1:string,
      /**  Element 2 of SalesRepList  */  
   SalesRepCode2:string,
      /**  Element 3 of SalesRepList  */  
   SalesRepCode3:string,
      /**  Element 4 of SalesRepList  */  
   SalesRepCode4:string,
      /**  Element 5 of SalesRepList  */  
   SalesRepCode5:string,
   SalesRepName1:string,
   SalesRepName2:string,
   SalesRepName3:string,
   SalesRepName4:string,
   SalesRepName5:string,
   ShipToAddressList:string,
   ShipToContactEMailAddress:string,
   ShipToContactFaxNum:string,
   ShipToContactName:string,
   ShipToContactPhoneNum:string,
      /**  Customer Id of the third-party Ship To  */  
   ShipToCustId:string,
   ShowApplyOrderDiscountsControl:boolean,
   SoldToAddressList:string,
   SoldToContactEMailAddress:string,
   SoldToContactFaxNum:string,
   SoldToContactName:string,
   SoldToContactPhoneNum:string,
      /**  This field defines the type of the term  */  
   TermsType:string,
   TotalNet:number,
   TotalOrder:number,
   TranDocTypeDescr:string,
      /**  the true discount percent from the order total  */  
   TrueDiscountPercent:number,
      /**  Taiwan GUI Legal Number Generation Type  */  
   TWGenerationType:string,
   UpdateDtlAndRelRecords:boolean,
      /**  Indicates if one or more invoices exist for this order  */  
   InvoicesExist:boolean,
   BTAddressFormatted:string,
      /**  The formatted ship to address  */  
   ShipToAddressFormatted:string,
      /**  The formatted Sold To Address  */  
   SoldToAddressFormatted:string,
   TranDate:string,
   TranNum:number,
   TranTime:number,
      /**  Indicates there is an OrderRel record that has a non-null NeedByDate  */  
   OrderRelNeedByDateNotNull:boolean,
      /**  Indicates a customer referenced on the order is inactive.  */  
   InactiveCustomer:boolean,
      /**  Enable Fulfillment Queue Actions  */  
   EnableAllocationQueueActions:boolean,
      /**  CREProcessor is true when Credit Card Configuration is CRE Server.  */  
   CREProcessor:boolean,
      /**  Flag indicating whether to enable Incoterm Location  */  
   EnableIncotermLocation:boolean,
   BitFlag:number,
   BTCustNumCustID:string,
   BTCustNumName:string,
   BTCustNumBTName:string,
   CardTypeDescription:string,
   CurrencyCodeCurrName:string,
   CurrencyCodeCurrSymbol:string,
   CurrencyCodeDocumentDesc:string,
   CurrencyCodeCurrencyID:string,
   CurrencyCodeCurrDesc:string,
   CustomerBTName:string,
   CustomerCustID:string,
   CustomerName:string,
   CustomerAllowShipTo3:boolean,
   FOBDescription:string,
   HDCaseDescription:string,
   IncotermsDescription:string,
   InvCurrCurrDesc:string,
   OTSCntryISOCode:string,
   OTSCntryDescription:string,
   OTSCntryEUMember:boolean,
   OurBankDescription:string,
   OurBankBankName:string,
   PlantName:string,
   PSCurrCurrDesc:string,
   RateGrpDescription:string,
   ReservePriDescription:string,
   ShipToNumInactive:boolean,
   ShipViaCodeInactive:boolean,
   ShipViaCodeDescription:string,
   ShipViaCodeWebDesc:string,
   TaxRegionCodeDescription:string,
   TermsCodeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PODetailRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates if this line item is Open/Closed. This is not directly maintainable by the user. Normally it gets set to "Closed" as a result of the receiving process. When there are no longer any open PORel records then the PODetail record is closed. This can also be closed when the user Voids the Order or PODetail record.  */  
   OpenLine:boolean,
      /**   Indicates if the Line was voided. Voided line items are not maintainable, can't "unvoid".  This field is not directly maintainable.  Instead the void function will be performed via a "Void Line" button.  Which then presents a verification dialog box.
When an PODetail record is 'voided',  all current open  PORel records are also closed and voided.  If no other open PoDetail records exist then set the PoHeader.OperOrder = No.
This can also be set when the related PoHeader is voided.  */  
   VoidLine:boolean,
      /**  Purchase order number that the detail line item is linked to.  */  
   PONUM:number,
      /**  The line number of the detail record on the purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   POLine:number,
      /**  Defaults from JobOper, JobMtl or Part depending on the reference to the job records.  If no job reference then uses the Part.PartDescription if it is a valid PartNum.  */  
   LineDesc:string,
      /**  (Our) Unit Of Measure.  */  
   IUM:string,
      /**   The unit price in the vendors unit of measure.  Unfortunately the Field Name is UnitCost instead of UnitPrice which is a little
misleading  */  
   UnitCost:number,
      /**  The unit price in the vendors unit of measure and currency.  Unfortunately the Field Name is UnitCost instead of UnitPrice which is a little misleading.  */  
   DocUnitCost:number,
      /**  Total Order Quantity for the line item.  This is stored in the Vendors Unit of Measure. This quantity must always be kept in sync with the scheduled release quantities stored in the PORel table. Normally this field is directly maintainable. However when multiple shipping releases have been established for this line (more than one PORel record) the OrderQty is not maintainable.  As the user modifies the quantities in the individual release lines the OrderQty field will get adjusted. This insures that Order quantity and scheduled  quantities are always in sync.  */  
   OrderQty:number,
      /**  Total Order Quantity for the line item.  This is stored in Our Unit of Measure. This quantity must always be kept in sync with the scheduled release quantities stored in the PORel table.  Normally this field is directly maintainable. However when multiple shipping releases have been established for this line (more than one PORel record) the XOrderQty is not maintainable.  As the user modifies the quantities in the individual release lines the XOrderQty field will get adjusted.  This ensures that Order quantity and scheduled quantities are always in sync.  */  
   XOrderQty:number,
      /**  Taxable  */  
   Taxable:boolean,
      /**  Purchasing UOM  */  
   PUM:string,
      /**   Indicates the costing per quantity. It can be "E" = per each,
"C" = per hundred,  "M" = per thousand.  Used to calculate the extended unit cost for the line item.  The logic is to divide the PODetail.OrderQty by the appropriate "per" value and then multiply by unit cost.  Use the  Part.PricePerCode as a default.  If Part record does not exist then default as "E".  */  
   CostPerCode:string,
      /**  OUR internal Part number for this item.  */  
   PartNum:string,
      /**  Supplier Part Number  */  
   VenPartNum:string,
      /**  Contains comments about the detail order line item. These will be printed on the purchase order.  Defaults from the related JobOper, JobMtl or Part file.  */  
   CommentText:string,
      /**  The foreign key to the PartClass Master. May be blank, if entered must be valid in PartClass file.  Defaulted from Part.ClassID. The PartClass is used in determining a default G/L expense account.  */  
   ClassID:string,
      /**  OUR revision number of the OUR part.  An optional field. Defaults from the most current  PartRev.RevisionNum.  */  
   RevisionNum:string,
      /**  Indicates if  Inspection is required when this PO line item is received. Inspection may also be enforced if the related PartClass, Vendor, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   RcvInspectionReq:boolean,
      /**  The VendorNum that ties back to the Vendor master file.  This field is a duplicate of the field in POHeader and is maintained  in the write triggers of POHeader and PODetail.  */  
   VendorNum:number,
      /**  Tracks the "Balance" of Advance Payments which are to be used to reduce the invoice when actual order is received. This value is increased via the "Advance Pay" invoice type. It is reduced when the receipt invoice is created by entering amount in the APInvDtl.  */  
   AdvancePayBal:number,
      /**  Tracks the "Balance" of Advance Payments which are to be used to reduce the invoice when actual order is received. This value is increased via the "Advance Pay" invoice type. It is reduced when the receipt invoice is created by entering amount in the APInvDtl.  */  
   DocAdvancePayBal:number,
      /**  Indicated Supplier Confirmed the PO.  Will default from the PO header.  Also used when the supplier or  */  
   Confirmed:boolean,
      /**  Indicates this line has a pending date change  */  
   DateChgReq:boolean,
      /**  Indicates this line has a pending qty change  */  
   QtyChgReq:boolean,
      /**  Requested pending partnumber change  */  
   PartNumChgReq:string,
      /**  Requested pending revision change  */  
   RevisionNumChgReq:string,
      /**  Date Supplier Confirmed the PO  */  
   ConfirmDate:string,
      /**  Can be "web" or "client"  */  
   ConfirmVia:string,
      /**  Requested Price change.  SRM  */  
   PrcChgReq:number,
      /**  If the ExtCompany.APPurchType field is yes, then this field cannot be blank (EuroFin)  */  
   PurchCode:string,
      /**  Order number created for this PO for the Inter-Company Trading.  */  
   OrderNum:number,
      /**  Order Line created for this PO Line for the Inter-Company Trading.  */  
   OrderLine:number,
      /**  Linked to sales order line.  */  
   Linked:boolean,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  Global Company identifier.  Used in Consolidated Purchasing.  */  
   GlbCompany:string,
      /**  Is this line active on the Contract Purchase Order?  */  
   ContractActive:boolean,
      /**  Quantity for this Contract Purchase Order Line.  */  
   ContractQty:number,
      /**  Unit Price for this Contract Purchase Order Line.  */  
   ContractUnitCost:number,
      /**  Document Unit Price for this Contract Purchase Order Line.  */  
   ContractDocUnitCost:number,
      /**  Advanced Payments Balance in Rpt1 currency.  */  
   Rpt1AdvancePayBal:number,
      /**  Advanced Payments Balance in Rpt2 currency.  */  
   Rpt2AdvancePayBal:number,
      /**  Advanced Payments Balance in Rpt3 currency.  */  
   Rpt3AdvancePayBal:number,
      /**  Unit price in the vendors unit of measure and Rpt1 currency.  */  
   Rpt1UnitCost:number,
      /**  Unit price in the vendors unit of measure and Rpt2 currency.  */  
   Rpt2UnitCost:number,
      /**  Unit price in the vendors unit of measure and Rpt3 currency.  */  
   Rpt3UnitCost:number,
      /**  Unit Of Measure of the ContractQty.  */  
   ContractQtyUOM:string,
      /**  Unit Price for this Contract Purchase Order Line in Rpt1 currency.  */  
   Rpt1ContractUnitCost:number,
      /**  Unit Price for this Contract Purchase Order Line in Rpt2 currency.  */  
   Rpt2ContractUnitCost:number,
      /**  Unit Price for this Contract Purchase Order Line in Rpt3 currency.  */  
   Rpt3ContractUnitCost:number,
      /**  Quantity in the Parts Base UOM.  Set by the system by doing a UOM conversion of the PODeltail.XOrderQty to the PODetail.BaseUOM .  */  
   BaseQty:number,
      /**   Unit of Measure of the PODetail.BaseXOrderQty.
If valid part, then it is the Parts Primary Inventory UOM otherwise it is the same as PODetail.IUM  */  
   BaseUOM:string,
      /**  Order Num related to this purchase order. Used only for Buy To Order POs.  */  
   BTOOrderNum:number,
      /**  The line number of the sales order related to this purchase order. Used only for Buy To Order POs.  */  
   BTOOrderLine:number,
      /**   Vendor Part Print Options. Determines what is printed.
M = Main Part Reference (Default)
S = Secondary Part Reference
O = Only Part Reference
A = All Supplier Parts Referenced
N = No Supplier Parts Referenced  */  
   VendorPartOpts:string,
      /**   Mfg Part Print Options. Determines what is printed.
O = Only Part Reference (Default)
A = All Supplier Parts Referenced
N = No Supplier Parts Referenced  */  
   MfgPartOpts:string,
      /**   Substitute Part Print Options. Determines what is printed.
O = Only Part Reference (Default)
M = Main Part Reference
S = Secondary Part Reference  */  
   SubPartOpts:string,
      /**  Manufacturer Unique ID  */  
   MfgNum:number,
      /**  Manufacturer's Part Number.  */  
   MfgPartNum:string,
      /**  Substitute Part Number  */  
   SubPartNum:string,
      /**   Substitute Part Type
O = Original
S = Substitute  */  
   SubPartType:string,
      /**   Same as Unit cost except that this field contains the unit price computed from the input based pricing in a configuration.
If price breaks exist this price should be used as the base price instead of the one found in the part table.  */  
   ConfigUnitCost:number,
      /**  This is the base cost for inputs based pricing of a configuration.  The price of inputs are added to this price to get the ConfigUnitPrice.  */  
   ConfigBaseUnitCost:number,
      /**  When True, the Supplier Quantity field is entered directly instead of being calculated from Our Quantity with a UOM conversion  */  
   ConvOverRide:boolean,
      /**  The part number used to identify the configured part number initially entered on the line.  */  
   BasePartNum:string,
      /**  The revision number used to identify the configured part/revision number initially entered on the line.  */  
   BaseRevisionNum:string,
      /**  Direction  */  
   Direction:string,
      /**  Per  */  
   Per:string,
      /**  MaintainPricingUnits  */  
   MaintainPricingUnits:boolean,
      /**  OverrideConversion  */  
   OverrideConversion:boolean,
      /**  RowsManualFactor  */  
   RowsManualFactor:boolean,
      /**  KeepRowsManualFactorTmp  */  
   KeepRowsManualFactorTmp:boolean,
      /**  ShipToSupplierDate  */  
   ShipToSupplierDate:string,
      /**  Factor  */  
   Factor:number,
      /**  PricingQty  */  
   PricingQty:number,
      /**  PricingUnitPrice  */  
   PricingUnitPrice:number,
      /**  UOM  */  
   UOM:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  GroupSeq  */  
   GroupSeq:number,
      /**  DocPricingUnitPrice  */  
   DocPricingUnitPrice:number,
      /**  Indicates if the supplier price list has been overriden which will in turn prevent the unit price from being updated when taking into account quantity / price breaks.  */  
   OverridePriceList:boolean,
      /**  It indicates the option of what type of quantity will be able to be changed in the POLine. The actual options are "Our" and "Supplier"  */  
   QtyOption:string,
      /**  Contains old comments about the detail order line item. This field saves old comments about the detail line that are going to be replaced by new comments.  */  
   OrigComment:string,
      /**  SmartString  */  
   SmartString:string,
      /**  SmartStringProcessed  */  
   SmartStringProcessed:boolean,
      /**  Specifies the date by which you need to receive the part. If you set the Due Date before create releases, it will act as default value when adding new releases. If you're adding lines from:  - BTO or Drop Shipments, PODetail.DueDate will take the value from OrderRel.NeedByDate. - Job Material , PODetail.DueDate  will take the value from JobMtl.ReqDate. - Subcontract Operations, PODetail.DueDate  wil take the value from JobOper.DueDate  */  
   DueDate:string,
      /**  The identifier of the planning contract.  */  
   ContractID:string,
      /**  When a demand is flagged as Link to Contract, MRP will take the demand as part of the planning of the Contract.  */  
   LinkToContract:boolean,
      /**  SelCurrPricingUnitPrice  */  
   SelCurrPricingUnitPrice:number,
      /**  Userid of the user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date and time that the record was last changed  */  
   ChangeDate:string,
      /**  PCLinkRemoved  */  
   PCLinkRemoved:boolean,
      /**  Indicates the Tax Category for this PO line. Used as a default to Order line items or Invoice line items. Can be left blank which indicates item is taxable. If entered must be valid in the TaxCat master file.  */  
   TaxCatID:string,
      /**  This flag determines whether any manual taxes were created for a line miscellaneous charge, if this is set to True the tax engine will not calculate any miscellaneous charge tax information  */  
   NoTaxRecalc:boolean,
      /**  Unit price in the vendors unit of measure inclusive of tax in base currency.  */  
   InUnitCost:number,
      /**  Unit price in the vendors unit of measure inclusive of tax in document currency.  */  
   DocInUnitCost:number,
      /**  Unit price in the vendors unit of measure inclusive of tax in Rpt1 currency.  */  
   Rpt1InUnitCost:number,
      /**  Unit price in the vendors unit of measure inclusive of tax in Rpt1 currency.  */  
   Rpt2InUnitCost:number,
      /**  Unit price in the vendors unit of measure inclusive of tax in Rpt1 currency.  */  
   Rpt3InUnitCost:number,
      /**  Advanced Payments Balance inclusive of tax in base currency.  */  
   InAdvancePayBal:number,
      /**  Advanced Payments Balance inclusive of tax in document currency.  */  
   DocInAdvancePayBal:number,
      /**  Advanced Payments Balance inclusive of tax in Rpt1 currency.  */  
   Rpt1InAdvancePayBal:number,
      /**  Advanced Payments Balance inclusive of tax in Rpt2 currency.  */  
   Rpt2InAdvancePayBal:number,
      /**  Advanced Payments Balance inclusive of tax in Rpt3 currency.  */  
   Rpt3InAdvancePayBal:number,
      /**  Contract unit cost inclusive of tax in base currency.  */  
   InContractUnitCost:number,
      /**  Contract unit cost inclusive of tax in document currency.  */  
   DocInContractUnitCost:number,
      /**  Contract unit cost inclusive of tax in Rpt1 currency.  */  
   Rpt1InContractUnitCost:number,
      /**  Contract unit cost inclusive of tax in Rpt2 currency.  */  
   Rpt2InContractUnitCost:number,
      /**  Contract unit cost inclusive of tax in Rpt3 currency.  */  
   Rpt3InContractUnitCost:number,
      /**  Extended cost of the PO Line in document currency. This is PODetail.OrderQty / PODetail.CostPerCode * PODetail.DocUnitCost.  */  
   DocExtCost:number,
      /**  Extended cost of the PO Line in base currency. This is PODetail.OrderQty / PODetail.CostPerCode * PODetail.UnitCost.  */  
   ExtCost:number,
      /**  Extended cost of the PO Line in Rpt1 currency. This is PODetail.OrderQty / PODetail.CostPerCode * PODetail.Rpt1UnitCost.  */  
   Rpt1ExtCost:number,
      /**  Extended cost of the PO Line in Rpt2 currency. This is PODetail.OrderQty / PODetail.CostPerCode * PODetail.Rpt2UnitCost.  */  
   Rpt2ExtCost:number,
      /**  Extended cost of the PO Line in Rpt3 currency. This is PODetail.OrderQty / PODetail.CostPerCode * PODetail.Rpt3UnitCost.  */  
   Rpt3ExtCost:number,
      /**  Total amount for all miscellaneous charges associated to this PO Line in document currency.  This is the sum of POMisc.DocMiscAmt for all line charges.  */  
   DocMiscCost:number,
      /**  Total amount for all miscellaneous charges associated to this PO Line in base currency.  This is the sum of POMisc.MiscAmt for all line charges.  */  
   MiscCost:number,
      /**  Total amount for all miscellaneous charges associated to this PO Line in Rpt1 currency.  This is the sum of POMisc.Rpt1MiscAmt for all line charges.  */  
   Rpt1MiscCost:number,
      /**  Total amount for all miscellaneous charges associated to this PO Line in Rpt2 currency.  This is the sum of POMisc.Rpt2MiscAmt for all line charges.  */  
   Rpt2MiscCost:number,
      /**  Total amount for all miscellaneous charges associated to this PO Line in Rpt3 currency.  This is the sum of POMisc.Rpt3MiscAmt for all line charges.  */  
   Rpt3MiscCost:number,
      /**  Total Tax amount for this PO Line in base currency,  */  
   TotalTax:number,
      /**  Total Tax amount for this PO Line in document currency.  */  
   DocTotalTax:number,
      /**  Total Tax amount for this PO Line in Rpt1 currency,  */  
   Rpt1TotalTax:number,
      /**  Total Tax amount for this PO Line in Rpt2 currency,  */  
   Rpt2TotalTax:number,
      /**  Total Tax amount for this PO Line in Rpt3 currency,  */  
   Rpt3TotalTax:number,
      /**  Total Order Self Assessed Taxes for this PO Line in base currency.  */  
   TotalSATax:number,
      /**  Total Order Self Assessed Taxes for this PO Line in document currency.  */  
   DocTotalSATax:number,
      /**  Total Self AssessedTax amount for this PO Line in Rpt1 currency.  */  
   Rpt1TotalSATax:number,
      /**  Total Self AssessedTax amount for this PO Line in Rpt2 currency.  */  
   Rpt2TotalSATax:number,
      /**  Total Self AssessedTax amount for this PO Line in Rpt3 currency.  */  
   Rpt3TotalSATax:number,
      /**  Total deductable tax amount for this PO Line in base currency.  */  
   TotalDedTax:number,
      /**  Total deductable tax amount for this PO Line in document currency.  */  
   DocTotalDedTax:number,
      /**  Total deductable tax amount for this PO Line in Rpt1 currency.  */  
   Rpt1TotalDedTax:number,
      /**  Total Deductable tax amount for this PO Line in Rpt2 currency.  */  
   Rpt2TotalDedTax:number,
      /**  Total Deductable tax amount for this PO Line in Rpt3 currency.  */  
   Rpt3TotalDedTax:number,
      /**  CommodityCode  */  
   CommodityCode:string,
      /**  CNBonded  */  
   CNBonded:boolean,
      /**  Acknowledge code received from EDI  */  
   EDIAckCode:string,
      /**  Additional comments to send with Acknowledge  */  
   EDIAckComment:string,
      /**  The flag to indicate if the user is supposed to be asked to enter a Reference code before saving a new PoDetail record .  */  
   AskRefCode:boolean,
   CalcAssemblySeq:number,
   CalcDocTotalCost:number,
   CalcDueDate:string,
   CalcJobNum:string,
   CalcJobSeq:number,
   CalcJobSeqType:string,
   calcLeadTime:number,
   CalcMangCustID:string,
   CalcMangCustName:string,
   CalcMangCustNum:number,
   CalcMfg:string,
   CalcMfgPart:string,
   calcMinOrderQty:number,
   CalcOurQty:number,
   calcPartPUM:string,
      /**  purchasing factor  */  
   CalcPurchasingFactor:number,
   CalcPurchasingFactorDirection:string,
   CalcTotalCost:number,
   CalcTranType:string,
   CalcVendQty:number,
   Configured:string,
   ConsolidatedPO:boolean,
   ContractOrder:boolean,
      /**  Indicates the costing per quantity (When Contract PO). It can be "E" = per each, "C" = per hundred,  "M" = per thousand.  Used to calculate the extended unit cost for the line item.  The logic is to divide the PODetail.OrderQty by the appropriate "per" value and then multiply by unit cost.  Use the  Part.PricePerCode as a default.  If Part record does not exist then default as "E".  */  
   CostPerCodeContract:string,
   CPFactor:number,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencySwitch:boolean,
   DelPoSug:boolean,
   DisablePartRevBtn:boolean,
      /**  Display Account Description.  */  
   DispAcctDescription:string,
      /**  A character string made up of Div, Dept, Chart and Segment values and their related separators concatenated into the full GL account number.  */  
   DispExpAccount:string,
   DisplaySymbol:string,
   DocDisplaySymbol:string,
   DocScrUnitCost:number,
      /**  False if vendor or class requires inspection, otherwise true.  */  
   EnableRcvInspectionReq:boolean,
      /**  The Chart ID component of the default G/L account.  */  
   ExpChart:string,
      /**  The Division Component of the default expence G/L account.  */  
   ExpDivision:string,
      /**  The Department component of the default G/L account.  */  
   ExpGLDept:string,
   FromPOSugChg:boolean,
   LinkedSOConfig:boolean,
   MultiRel:boolean,
   NonMasterPart:boolean,
   OpCode:string,
   PartQtyBearing:boolean,
   POHeaderApprove:boolean,
      /**  True if there is only one release and it's open.  */  
   PORelOneOpenRelease:boolean,
   PriceBrkBTNSensitive:boolean,
      /**  Reference Code Description  */  
   RefCodeDesc:string,
      /**  Reference Code Status  */  
   RefCodeStatus:string,
      /**  Link to the related code in GlRefCod.RefCode  */  
   ReferenceCode:string,
   Rpt1CalcTotalCost:number,
   Rpt1ScrUnitCost:number,
   Rpt2CalcTotalCost:number,
   Rpt2ScrUnitCost:number,
   Rpt3CalcTotalCost:number,
   Rpt3ScrUnitCost:number,
      /**   The unit price in the vendors unit of measure.  Unfortunately the Field Name is UnitCost instead of UnitPrice which is a little
misleading  */  
   ScrUnitCost:number,
   SetCheveron:boolean,
   SubAvail:boolean,
   UpdateRelRecords:boolean,
      /**  Update PO Release Taxable Flag on Change of PO Detail Taxable Flag  */  
   UpdateRelTaxable:boolean,
      /**  Purchase Point used in the Supplier Tracker.  */  
   VendPurPoint:string,
   AllowPORecon:boolean,
      /**  Internal flag used for the row rules to control whether the inventory attributes should be enabled or not.  */  
   EnableDynAttrButton:boolean,
      /**  True if there is a remaining qty difference between the attribute quantity and the receipt line quantity.  */  
   AttributeQtyMismatch:boolean,
   CalcJobMtlSeq:number,
   CalcJobOprSeq:number,
      /**  Flag to indicate the current PO Line has at least one Buy To Order Release  */  
   HasBuyToOrderRelease:boolean,
      /**  The flag to indicate if PO  doc/base/rpt line amounts are recalculated  whne entered and no need to recalculate on save.  */  
   LineAmtCalcd:boolean,
   BitFlag:number,
   ClassInactive:boolean,
   ClassDescription:string,
   CommodityCodeDescription:string,
   GlPurchPurchDesc:string,
   MfgNumMfgID:string,
   MfgNumName:string,
   PartNumTrackInventoryByRevision:boolean,
   PartNumPricePerCode:string,
   PartNumSalesUM:string,
   PartNumSellingFactor:number,
   PartNumTrackSerialNum:boolean,
   PartNumTrackInventoryAttributes:boolean,
   PartNumPartDescription:string,
   PartNumIUM:string,
   PartNumTrackDimension:boolean,
   PartNumTrackLots:boolean,
   PartNumAttrClassID:string,
   PONUMCurrencyCode:string,
   PONUMOrderDate:string,
   PONUMInPrice:boolean,
   PONUMShipName:string,
   PONUMShipToConName:string,
   TaxCatIDDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_POHeaderRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates if the order is open or closed. This is set automatically when all the PODetail records have been closed or can be set if the user Voids the Order. This field is not directly maintainable.  */  
   OpenOrder:boolean,
      /**  Indicates if the entire remaining Purchase Order is Voided. When an order is voided the POHeader.OpenOrder is set to No and all remaining PODetail and PORel records for the related order are closed and voided.  */  
   VoidOrder:boolean,
      /**  Purchase order number that uniquely identifies the purchase order.  */  
   PONum:number,
      /**  Entry Person  */  
   EntryPerson:string,
      /**  Order Date for this purchase order. Initially defaults as "today", then defaults as last date entered in this session.  */  
   OrderDate:string,
      /**  Incoterms  */  
   FOB:string,
      /**  Ship Via Code  */  
   ShipViaCode:string,
      /**  Terms  */  
   TermsCode:string,
      /**  defaults from the company file.  */  
   ShipName:string,
      /**  First adress line  */  
   ShipAddress1:string,
      /**  Second address line  */  
   ShipAddress2:string,
      /**  Third address line  */  
   ShipAddress3:string,
      /**  City portion of the address  */  
   ShipCity:string,
      /**  Statee portion of the address  */  
   ShipState:string,
      /**  Postal code or Zip code portion of the address  */  
   ShipZIP:string,
      /**  Country is used as part of the Ship to  address. It can be left blank.  */  
   ShipCountry:string,
      /**  The ID that links to the Purchasing Agent master file.  */  
   BuyerID:string,
      /**  The freight charge is to be paid by the vendor.  */  
   FreightPP:boolean,
      /**  Contains the key  value for the Purchasing Contact. This can be blank or it must be valid in the VendCnt  table. Use the Vendor.PRIMPCON as the default. or the VendorPP.PrimPCon if a vendor purchase point is referenced.  */  
   PrcConNum:number,
      /**  The VendorNum that ties back to the Vendor master file.  This field is not directly maintainable, instead its assigned via selection list processing.  */  
   VendorNum:number,
      /**  Ties the PO header back to the VendPP master file. This can be blank indicating No purchase point.  */  
   PurPoint:string,
      /**  Contains comments about over all  purchase order. These will be printed on the purchase order.  */  
   CommentText:string,
      /**  Indicates if an order is flagged as being "HELD" , this  is primarily used as a visual indicator in receipt entry. It does not prevent receipts from being entered for this order.  */  
   OrderHeld:boolean,
      /**  Ship to contact name. Prints on Purchase order form. Defaults from the CustCnt or VendCnt.  */  
   ShipToConName:string,
      /**  Indicates if the PO can be printed. Print functions are not available if this is = No.  */  
   ReadyToPrint:boolean,
      /**  N = New, C = Change Order  */  
   PrintAs:string,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**   Exchange rate that will be used for this order.  Defaults from
CurrRate.CurrentRate. Conversion rates will be calculated as System Base = Foreign value * rate, Foreign value = system base * (1/rate). This is the dollar in foreign currency from the exchange rate tables in the newspapers.  */  
   ExchangeRate:number,
      /**  Used with the currency module.  When TRUE the currency rate can be changed by the user and cannot be changed by the system.  This will also be the default for the invoice.  */  
   LockRate:boolean,
      /**  Country part of address. This field is in sync with the Country field. Must be a valid entry in the Country table.  */  
   ShipCountryNum:number,
      /**  This field indicates if the system should generate purchase order booking records. Booking tables are used to track changes to POheader.  */  
   LogChanges:boolean,
      /**  System date that the PO was approved.  This only pertains to PO which exceeded the buyers limit and have been approved.  */  
   ApprovedDate:string,
      /**  The BuyerID  that approved the PO. (See ApprovedDate for related info)  */  
   ApprovedBy:string,
      /**   Inidicates if the PO is "ready" to be approved.  This is checked  when all the information is complete and is ready to be processed. When checked the system will test if PO has exceeded the buyers or system purchasing limit.  (See ApprovalStatus for related info)
When Approve = yes the PO cannot be maintained.  */  
   Approve:boolean,
      /**   Indicates the approval status of the PO.
Valid values are; U - Unsubmitted for Approval,  P - Pending Approval, A - Approved, R - Rejected.  Before a PO can be printed it must be approved.  A PO is consider  approved if it doesn't exceed the buyers limit or it has been approved by the approver.  */  
   ApprovalStatus:string,
      /**   An internally used field that represents the total amount of the PO (in base currency) captured the last time the po was approved/rejected.  Note: this only pertains to PO that required approval in the first place otherwise it's zero.  The limit checking process will compare PO amounts to the greater of the buyers limit or this amount. Basically, if the PO was already approved once for a specific amount then it should not require subsequent approval until that amount is exceeded.
Note: This also contains the PO amount if it was rejected. In this case, the PO remains as rejected until they reduce the PO amount.  */  
   ApprovedAmount:number,
      /**  Indicates the Supplier will respond via Suppliers workbench  */  
   PostToWeb:boolean,
      /**  Date Buyer posted the PO  */  
   PostDate:string,
      /**  Vendor reference number.  */  
   VendorRefNum:string,
      /**  Indicated this PO requires a confirmation.  This would default yes for any Web Vendor  */  
   ConfirmReq:boolean,
      /**  Indicated Supplier Confirmed the PO  */  
   Confirmed:boolean,
      /**   Indicates if the Supplier has confirmed that they intend to fill the Order, and that it will be done through Supplier Connect("web"), 
phoned in a confirmation and clicked on the Confirmed checkbox in Epicor ("client"), or they clicked on the "Reject" checkbox in Supplier Connect("rejected").  */  
   ConfirmVia:string,
      /**  Order number created for this PO for the Inter-Company Trading.  */  
   OrderNum:number,
      /**  The Legal Number for the record.  This number is created based on setup parameters in table LegalNumber.  */  
   LegalNumber:string,
      /**  Linked to sales order.  */  
   Linked:boolean,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  Cross reference PO number used when converting data from another ERP system when the previous system data has alphanumeric content.  This field is not used by MfgSys.  This field can be used in searches and can be added to screens through customization.  */  
   XRefPONum:string,
      /**  Consolidated PO flag.  Used in Consolidated Purchasing.  */  
   ConsolidatedPO:boolean,
      /**  Global Company identifier.  Used in Consolidated Purchasing.  */  
   GlbCompany:string,
      /**  Is this Purchase Order a Contract Purchase Order?  */  
   ContractOrder:boolean,
      /**  The date the Contract Purchase Order is active.  */  
   ContractStartDate:string,
      /**  The date the Contract Purchase Order expires.  */  
   ContractEndDate:string,
      /**  Print Header Address flag  */  
   PrintHeaderAddress:boolean,
      /**  Unique identifier  */  
   RateGrpCode:string,
      /**  PO Type Identifier ('STD' - standard PO, 'CMI' - Customer managed inventory PO, or 'SMI' - Supplier managed inventory PO)  */  
   POType:string,
      /**  Letter of Credit ID.  */  
   APLOCID:string,
      /**  Transaction Document for the record.  */  
   TranDocTypeID:string,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**  ICPOLocked  */  
   ICPOLocked:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Specifies the date by which you need to receive the whole Purchase Order. If you set the Due Date before create lines and releases, it will act as a default value when adding new lines/releases.  */  
   DueDate:string,
      /**  Specifies the date on which the supplier has promised to ship the whole Purchase Order. If you set the Promise Date before create lines and releases, it will act as a default value when adding releases.  */  
   PromiseDate:string,
      /**  Userid of the user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date and time that the record was last changed.  */  
   ChangeDate:string,
      /**  Flag to determine whether PO taxes will be automatically calculated each time a PO line is updated.  */  
   POTaxReadyToProcess:boolean,
      /**  The Tax Liability for this Purchase Order  */  
   TaxRegionCode:string,
      /**  Tax Point  */  
   TaxPoint:string,
      /**  Date Used to calculate Tax Rates  */  
   TaxRateDate:string,
      /**  Total Tax amount for this PO in base currency, Totals the TaxAmt from the POTax records of this purchase order  */  
   TotalTax:number,
      /**  Total Tax amount for this PO in document currency, Totals the DocTaxAmt from the POTax records of this purchase order  */  
   DocTotalTax:number,
      /**  Total Tax amount for this PO in Rpt1 currency, Totals the Rpt1TaxAmt from the POTax records of this purchase order  */  
   Rpt1TotalTax:number,
      /**  Total Tax amount for this PO in Rpt2 currency, Totals the Rpt2TaxAmt from the POTax records of this purchase order  */  
   Rpt2TotalTax:number,
      /**  Total Tax amount for this PO in Rpt3 currency, Totals the Rpt3TaxAmt from the POTax records of this purchase order  */  
   Rpt3TotalTax:number,
      /**  Total Order Withholding Taxes in base currency  */  
   TotalWhTax:number,
      /**  Total Order Withholding Taxes in document currency  */  
   DocTotalWhTax:number,
      /**  Total Order Withholding Taxes in Rpt1 currency  */  
   Rpt1TotalWhTax:number,
      /**  Total Order Withholding Taxes in Rpt2 currency  */  
   Rpt2TotalWhTax:number,
      /**  Total Order Withholding Taxes in Rpt3 currency  */  
   Rpt3TotalWhTax:number,
      /**  Total Order Self Assessed Taxes in base currency.  */  
   TotalSATax:number,
      /**  Total Order Self Assessed Taxes in document currency.  */  
   DocTotalSATax:number,
      /**  Total Order Self Assessed Taxes in Rpt1 currency.  */  
   Rpt1TotalSATax:number,
      /**  Total Order Self Assessed Taxes in Rpt2 currency.  */  
   Rpt2TotalSATax:number,
      /**  Total Order Self Assessed Taxes in Rpt3 currency.  */  
   Rpt3TotalSATax:number,
      /**  Indicates that the tax is included in the unit price  */  
   InPrice:boolean,
      /**  This flag determines whether any manual taxes were created for a header miscellaneous charge, if this is set to True then the tax engine will not calculate any miscellaneous charge tax information.  */  
   HdrTaxNoUpdt:boolean,
      /**  Tax Rate Group Code - FUTUREUSE  */  
   TaxRateGrpCode:string,
      /**  Total deductable tax amount in base currency.  */  
   TotalDedTax:number,
      /**  Total deductable tax amount in document currency.  */  
   DocTotalDedTax:number,
      /**  Total deductable tax amount in Rpt1 currency.  */  
   Rpt1TotalDedTax:number,
      /**  Total deductable tax amount in Rpt2 currency.  */  
   Rpt2TotalDedTax:number,
      /**  Total deductable tax amount in Rpt3 currency.  */  
   Rpt3TotalDedTax:number,
      /**  Total charge amount for the PO in base currency,  This is the sum of PODetail.ExtCost for non voided lines.  */  
   TotalCharges:number,
      /**  Total amount for all miscellaneous charges associated to this PO in base currency.  This is the sum of POMisc.MiscAmt.  */  
   TotalMiscCharges:number,
      /**  Total amount for the PO in base currency.  This is the sum of POMisc.MiscAmt + PODetail.ExtCost + POHeader.TotalTax.  */  
   TotalOrder:number,
      /**  Total charge amount for the PO in document currency,  This is the sum of PODetail.DocExtCost for non voided lines.  */  
   DocTotalCharges:number,
      /**  Total amount for all miscellaneous charges associated to this PO in document currency.  This is the sum of POMisc.DocMiscAmt.  */  
   DocTotalMisc:number,
      /**  Total amount for the PO in document currency.  This is the sum of POMisc.DocMiscAmt + PODetail.DocExtCost + POHeader.DocTotalTax.  */  
   DocTotalOrder:number,
      /**  Total charge amount for the PO in Rpt1 currency,  This is the sum of PODetail.Rpt1ExtCost for non voided lines.  */  
   Rpt1TotalCharges:number,
      /**  Total charge amount for the PO in Rpt2 currency,  This is the sum of PODetail.Rpt2ExtCost for non voided lines.  */  
   Rpt2TotalCharges:number,
      /**  Total charge amount for the PO in Rpt3 currency,  This is the sum of PODetail.Rpt3ExtCost for non voided lines.  */  
   Rpt3TotalCharges:number,
      /**  Total amount for all miscellaneous charges associated to this PO in Rpt1 currency.  This is the sum of POMisc.Rpt1MiscAmt.  */  
   Rpt1TotalMiscCharges:number,
      /**  Total amount for all miscellaneous charges associated to this PO in Rpt2 currency.  This is the sum of POMisc.Rpt2MiscAmt.  */  
   Rpt2TotalMiscCharges:number,
      /**  Total amount for all miscellaneous charges associated to this PO in Rpt3 currency.  This is the sum of POMisc.Rpt3MiscAmt.  */  
   Rpt3TotalMiscCharges:number,
      /**  Total amount for the PO in Rpt1 currency.  This is the sum of POMisc.Rpt1MiscAmt + PODetail.Rpt1ExtCost + POHeader.Rpt1TotalTax.  */  
   Rpt1TotalOrder:number,
      /**  Total amount for the PO in Rpt2 currency.  This is the sum of POMisc.Rpt2MiscAmt + PODetail.Rpt2ExtCost + POHeader.Rpt2TotalTax.  */  
   Rpt2TotalOrder:number,
      /**  Total amount for the PO in Rpt3 currency.  This is the sum of POMisc.Rpt3MiscAmt + PODetail.Rpt3ExtCost + POHeader.Rpt3TotalTax.  */  
   Rpt3TotalOrder:number,
      /**  APTaxRoundOption  */  
   APTaxRoundOption:number,
      /**  CNBonded  */  
   CNBonded:boolean,
      /**  EDI Revision number that marks changes in the purchase order since the last time the purchase order was sent.  */  
   EDIRevNum:number,
      /**  Flag used to mark the Purchase Order as posted to EDI  */  
   EDIPosted:boolean,
      /**  Date when the PO was last acknowledge from EDI Portal  */  
   EDIPostedDate:string,
      /**  Date when the PO was last acknowledge from EDI Portal  */  
   EDIAckDate:string,
      /**  Temporarily stores the return message from the PO approval process  */  
   ApproveMessage:string,
      /**  Used when switching the Vendor and need to prompt if the user wants to recalculate unit costs.  */  
   RecalcUnitCosts:boolean,
   RuleCode:number,
   UpdateDtlAndRelRecords:boolean,
   VendCntFaxNum:string,
   VendCntPhoneNumber:string,
   ApproveChkBxSensitive:boolean,
   BaseCurrencyID:string,
   ConfirmChkBxSensitive:boolean,
      /**  Flag for UI to know when to Enable/Disable the SupplierID field in POEntry  */  
   EnableSupplierID:boolean,
      /**  True is there are lines for this PO  */  
   HasLines:boolean,
   HoldChkBxSensitive:boolean,
   MassPrntChkBxSensitive:boolean,
   RefCodeCurrSymbol:string,
      /**  The formatted vendor address  */  
   VendAddrFormat:string,
   EDIEnable:boolean,
   BitFlag:number,
   APLOCDescription:string,
   BuyerIDName:string,
   CurrencyCodeCurrName:string,
   CurrencyCodeCurrSymbol:string,
   CurrencyCodeDocumentDesc:string,
   CurrencyCodeCurrDesc:string,
   CurrencyCodeCurrencyID:string,
   FOBDescription:string,
   RateGrpDescription:string,
   ShipCountryNumDescription:string,
   ShipViaCodeInactive:boolean,
   ShipViaCodeDescription:string,
   ShipViaCodeWebDesc:string,
   TaxRegionCodeDescription:string,
   TermsCodeDescription:string,
   VendorVendorID:string,
   VendorZIP:string,
   VendorDefaultFOB:string,
   VendorCity:string,
   VendorName:string,
   VendorCountry:string,
   VendorAddress3:string,
   VendorTermsCode:string,
   VendorAddress1:string,
   VendorAddress2:string,
   VendorCurrencyCode:string,
   VendorState:string,
   VendorEDISupplier:boolean,
   VendorCntName:string,
   VendorCntEmailAddress:string,
   VendorCntPhoneNum:string,
   VendorCntFaxNum:string,
   VendorPPAddress3:string,
   VendorPPCountry:string,
   VendorPPZip:string,
   VendorPPState:string,
   VendorPPAddress1:string,
   VendorPPName:string,
   VendorPPPrimPCon:number,
   VendorPPAddress2:string,
   VendorPPCity:string,
   XbSystAllowLinkedPOChg:boolean,
   XbSystPOUserInt2Label:string,
   XbSystPOUserDate3Label:string,
   XbSystPOUserChar3Label:string,
   XbSystPOUserChar4Label:string,
   XbSystPOUserChar2Label:string,
   XbSystPOUserDate2Label:string,
   XbSystPOUserInt1Label:string,
   XbSystPOUserDec1Label:string,
   XbSystPOUserDec2Label:string,
   XbSystPOUserDate4Label:string,
   XbSystPOUserDate1Label:string,
   XbSystPOUserChar1Label:string,
   XbSystDisableOverridePriceListOption:boolean,
   XbSystPOTaxCalculate:boolean,
   XbSystAPTaxLnLevel:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  An abbreviated part description field by which the user can search the Part file. In Part maintenance the Search Word is to only be updated upon initial creation of the Part with the first 8 bytes of the Part.Description.  */  
   SearchWord:string,
      /**  Describes the Part.  */  
   PartDescription:string,
      /**   The Inventory class that this Part belongs to. The Class field can be blank or must be valid in the PartClass master file.
Classes could be set up for different type of raw materials. It will primarily be used as a report selection parameter.  */  
   ClassID:string,
      /**  Primary Inventory Unit of Measure. The unit costs, are based on this uom. Used as a default for issue transactions for the part.  Part onhand and allocation quantities are tracked by this uom.  The quantities can also be tracked by other uoms (see PartUOM table) but tracking at this uom is mandatory.   Use UOMClass.DefUOMCode of the system default UOMClass  when creating new part records (see XASyst.DefUOMClassID).  */  
   IUM:string,
      /**  The Purchasing Unit of measure for the Part.  During Part Maintenance the XaSyst.UM is used as a default for this field. This is used in Purchase Order entry as the default on line item details.  */  
   PUM:string,
      /**   Classifies Parts into the following...
M = Manufactured Part.
P = Purchased Part.
K = Sales Kit Part.B = Planning BOM.
This type code does limit referencing any part in any way. For example a type "P" can be entered on a sales order, or a type "M" can be referenced in a Purchase Order.
This field will also be used as a selection parameter in certain reports, such as Time Phase Requirements.  */  
   TypeCode:string,
      /**  A flag which indicates if this Part is not a stocked inventory item. This can be used so that "custom" built items which only exist per the customers order can be established as a valid part in order to provide default descriptions etc.... This can also be used for parts that are only purchased for direct use on jobs, but would normally never exist in inventory. This value will be used in report selection criteria.  It also controls the default setting of the "Make" flag in order entry line items  and the "Purchase" flag in Job material records. If a NoStock part is referenced in order entry then it defaults as "Make".  If it is referenced on a job material requirement it will default as "Purchase"  */  
   NonStock:boolean,
      /**   This value is used to convert quantity when there is a difference in the vendors unit of measure and how it is stocked in inventory. Example is purchased in pounds, stocked in sheets.


Formula: Issue Qty * Conversion Factor = Purchased Qty.  */  
   PurchasingFactor:number,
      /**  Base Unit Selling Price for the Item. Maintainable only via Part Master Maintenance program. It is used as a default unit price on Sales Order line detail and on Invoice line details that are not referencing a sales order line.  */  
   UnitPrice:number,
      /**  Indicates the pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. Maintainable only via Part Maintenance. The initial default is "E". Used as default PricePerCode in order entry and invoice entry.  */  
   PricePerCode:string,
      /**  Base Internal Unit Selling Price for the Item.  Maintainable only via Part Master Maintenance program.  If zero, then the external unit price (Part.UnitPrice) is used.  */  
   InternalUnitPrice:number,
      /**  Indicates the internal pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand.  Maintainable only via Part Maintenance.  The initial default is "E".  */  
   InternalPricePerCode:string,
      /**  Product Group ID for the Part. This can be blank or must be valid in the ProdGrup file.  This will be used for report sorting and selection. Also as a default in order entry, invoice entry and job entry.  */  
   ProdCode:string,
      /**  Used to enter comments for manufacturing when this part is referenced on a job. These are copied to JobHead.Comment, JobAsmbl.Comment,JobMtl.MfgComment depending on the point of reference. Commens are printed on the routing report.  */  
   MfgComment:string,
      /**   Part Comments that will be used as a default for purchasing. These will be copied into the JobMtl.PurComment which then will be used to pass along to the PO when that JobMtl is referenced. It will also be copied into the PODetail.Comment field when the PO is buying the part for stock and not referencing a Job. View as an EDITOR widget.
To be view-as EDITOR widget.  */  
   PurComment:string,
      /**  Defines the Costing method to be associated with this Part. Use the XaSyst.CostMethod as a default.  When a unit cost is retrieved from the Part file the programs will use this field to determine which one of the Four sets of cost fields should be used.  A = Use Average L= Use Last S = Use Standard T = Use Avg by lot(not found in XaSyst).  */  
   CostMethod:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar1Label
is non blank.  */  
   UserChar1:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar2Label
is non blank.  */  
   UserChar2:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar3Label
is non blank.  */  
   UserChar3:string,
      /**   User Defined character field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserChar4Label
is non blank.  */  
   UserChar4:string,
      /**   User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate1Label
is non blank.  */  
   UserDate1:string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate2Label is non blank.  */  
   UserDate2:string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate3 Label is non blank.  */  
   UserDate3:string,
      /**  User Defined Date field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDate4 Label is non blank.  */  
   UserDate4:string,
      /**   User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec1Label
is non blank.  */  
   UserDecimal1:number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec2Label is non blank.  */  
   UserDecimal2:number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec3Label is non blank.  */  
   UserDecimal3:number,
      /**  User Defined Decimal field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserDec4Label is non blank.  */  
   UserDecimal4:number,
      /**  User Defined Integer field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserInt1Label is non blank.  */  
   UserInteger1:number,
      /**  User Defined Integer field. Actual label used is defined in the XaSyst record. This Field is only accessible if XaSyst.PartUserInt2Label is non blank.  */  
   UserInteger2:number,
      /**  Indicates the Tax Category for this Part. Used as a default to Order line items or Invoice line items. Can be left blank which indicates item is taxable. If entered must be valid in the TaxCat master file.  */  
   TaxCatID:string,
      /**   Flag which indicates if the Part Master is considered as "Inactive".
This flag will be used to exclude parts from certain searches and reports.  */  
   InActive:boolean,
      /**  Internally assigned integer which indicates the deepest level of assembly indention that this part is used at.  This is used by the Cost Rollup routines to control the order in which parts get costed. Part at the bottom (highest levelcode) Product structure are calculated first and continues up the chain, with the final assembly parts being processed last.  This insures that when retrieving the cost of an assemblies components the components will already have had their cost rolled up.  */  
   LowLevelCode:number,
      /**  An internal flag which indicates that this part contains Method of Manufacture details (PartMtl/PartOpr records).  We use this to avoid processing raw material part records during processes such as BOM Cost roll up, Indented BOM lists, etc...  */  
   Method:boolean,
      /**  Indicates if Lot numbers are prompted for in transactions for this part.  Backflushing and AutoReceiving functions are ignored when TrackLots = Yes.  */  
   TrackLots:boolean,
      /**   Onhand quantity is always tracked in the Parts primary inventory uom (Part.IUM). Checking this box indicates that you want to allow tracking of onhand quantity by additional uoms.
The actual UOMs to be tracked for the part are indicated by PartUOM.TrackOnHand. In order to set the PartUOM.TrackOhHand = True the Part.TrackDimension must = true.
This replaces the old 8.3 Track Dimension feature  */  
   TrackDimension:boolean,
      /**  Default dimension code for the part.  Set by selecting a PartDim record as default.  */  
   DefaultDim:string,
      /**  Indicates if this part is serial number tracked  */  
   TrackSerialNum:boolean,
      /**  Intrastat goods classification code following the Intrastat Classification Nomenclature (ICN). The Commodity Code field can be blank to indicate the value from the part class or must be valid in the ICommCode (formerly called IStatGrp) master file.  */  
   CommodityCode:string,
      /**  Unique code for the Warranty for this part  */  
   WarrantyCode:string,
      /**  A flag which indicates if this Part is a "Phantom BOM".  */  
   PhantomBOM:boolean,
      /**  The Selling Unit of measure for the Part. The UOM which the unit prices are based on. Defaults as the Part.IUM.  */  
   SalesUM:string,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingFactor:number,
      /**  The material burden rate for this part.  */  
   MtlBurRate:number,
      /**  The Part's Unit Net Weight.  */  
   NetWeight:number,
      /**  if Yes then the part effective revision is used. If No then the revision of the demand source is used (OrderDtl, JobMtl...)  */  
   UsePartRev:boolean,
      /**  Default for label printing.  Zero indicates that only one label should be produced for the entire quantity.  */  
   PartsPerContainer:number,
      /**  Part's length.  */  
   PartLength:number,
      /**  Part's width.  */  
   PartWidth:number,
      /**  Part's Height.  */  
   PartHeight:number,
      /**  Shelf life of a lot in days.  Zero indicates unlimited shelf life.  */  
   LotShelfLife:number,
      /**  This is a Web saleable part  */  
   WebPart:boolean,
      /**  Indicates that the onhand quantity is to be consumed and no further replenishments should be made.  Similar to Obsolete, however only warning messages will be issued to the user if they attempt new references.  */  
   RunOut:boolean,
      /**  Indicates the default Substitute part number.  This is optional. Must be one of the related PartSub records.  This field is set indirectly when the user checks the default toggle box in Part Substitution dialog.  */  
   SubPart:string,
      /**  Part's diameter.  */  
   Diameter:number,
      /**  Part's gravity.  */  
   Gravity:number,
      /**  Indicates that the part is on hold.  This feature can be used to indicate that a new part is not yet approved, that it is being phased out, has a quality issue, etc.  Further demands/supplies of this part should not be made. Similar to an "Inactive" part. However at the moment it still may have an onhand balance, supply and demands and will be reflected in stock status reporting.  */  
   OnHold:boolean,
      /**  Date that part becomes obsolete.  This can be set to a future date when the part should become obsolete.  */  
   OnHoldDate:string,
      /**  The Reason.Code associate with the reason why the part has been placed on hold. Valid only when Part.OnHold = Yes.  */  
   OnHoldReasonCode:string,
      /**  Default analysis code to be used when this part appears as an assembly  on a quote or a job.  */  
   AnalysisCode:string,
      /**  Marks the Part as a global Part, available to be sent out to other companies  */  
   GlobalPart:boolean,
      /**  MtlAnalysisCode  */  
   MtlAnalysisCode:string,
      /**  Disables this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  This value is used to calculate the Supplementary Units for the Intrastat.  */  
   ISSuppUnitsFactor:number,
      /**  Holds the internal object id of pdm parts.  */  
   PDMObjID:string,
      /**  Path & filename (relative to images/prod_img directory on Web Server) of .jpg product image file.  */  
   ImageFileName:string,
      /**  This field contains the Intrastat Country of Origin Code from the Country table.  */  
   ISOrigCountry:string,
      /**  Current setting for the prefix that will be attached to all new Serial Numbers as they are generated.  */  
   SNPrefix:string,
      /**  Current setting for Format of the Base serial number that will be used as new serial numbers are generated. Expressed in progress syntax. Ex: X(30), 99999999  */  
   SNFormat:string,
      /**  Current setting for Data type of the Base Serial Number field to be used as new serial numbers are generated. Valid values; Character, Integer  */  
   SNBaseDataType:string,
      /**  Used by the scheduling process when a part is stocked.  When TRUE,  the availability of this Part must be calculated via the TimePhase process prior to scheduling a Job.  */  
   Constrained:boolean,
      /**  UPS / UCC Code required by some industries.  */  
   UPCCode1:string,
      /**  UPS / UCC Code required by some industries.  */  
   UPCCode2:string,
      /**  UPS / UCC Code required by some industries.  */  
   UPCCode3:string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  For Customer Connect Only.  This field is used in Store Front to indicate if the part is available in stock.  */  
   WebInStock:boolean,
      /**  Should this Part be included in Consolidated Purchasing?  */  
   ConsolidatedPurchasing:boolean,
      /**  Indicates how Purchasing Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   PurchasingFactorDirection:string,
      /**  Indicates how Selling Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**   Receiving Documents Required.
Indicates receiving documents are required when receiving this part.  This pertains only to lot tracked parts that are received to inventory. If checked, then at the time of receiving the system will require that one or more attachments with a reference to a DocType having Receipt = yes be entered.Requires DocManagement license.  */  
   RecDocReq:boolean,
      /**  Maximum daily production value.  Used in demand shipping schedule.  */  
   MDPV:number,
      /**   Shipping Documents Required.
Indicates if shipping documents are required when shipping this part. Pertains to Inventory shipments of lot tracked parts or shipments directly from the job only. If checked, then at the time of shipping the system will require that the PartLot.Ship DocsAvail, or JobPart.ShipDocsAvail flag is true before allowing the shipment.Requires DocManagement license.  */  
   ShipDocReq:boolean,
      /**  The returnable container for this part when the part needs to be returned.  The value is provided by the trading partner.  */  
   ReturnableContainer:string,
      /**  The Part's Net Volume.  */  
   NetVolume:number,
      /**  Indicates a Quantity Bearing part. Works in conjunction with the Non-Stock field to enable the part master parts to be setup for expense items.  Quantity Bearing will be set to Yes by default and only enable to be set to No if the Non-Stock flag is Yes.  */  
   QtyBearing:boolean,
      /**  This field contains the Country of Origin Code from the Country table.  For International shipping.  */  
   NAFTAOrigCountry:string,
      /**  NAFTA Producer Code - For international shipping  */  
   NAFTAProd:string,
      /**  NAFTA Preference Code  */  
   NAFTAPref:string,
      /**  Export License Type  */  
   ExpLicType:string,
      /**  Export License Number  */  
   ExpLicNumber:string,
      /**  ECCN Number  */  
   ECCNNumber:string,
      /**  AES Export code  */  
   AESExp:string,
      /**  Harmonized Tariff Schedule Code  */  
   HTS:string,
      /**  Use HTS description flag - for shippers shippers export declaration  */  
   UseHTSDesc:boolean,
      /**  Schedule B Code  */  
   SchedBcode:string,
      /**  Hazardous Item  */  
   HazItem:boolean,
      /**  Hazardous Technical Name  */  
   HazTechName:string,
      /**  Hazardous Class Number  */  
   HazClass:string,
      /**  Hazardous Subrisk Class  */  
   HazSub:string,
      /**  Hazardous Government Assigned ID  */  
   HazGvrnmtID:string,
      /**  Hazardous Packing instructions  */  
   HazPackInstr:string,
      /**   Indicates what VAT Reverse Charge method needs to be applied for this Part.  The possible values are:
   "RCT"  -  "Reverse Charge with Threshold";
   "RCN"  -  "Reverse Charge with No Threshold"
Leave this field blank if no Reverse Charge should be applied in the invoice line for this Part.  */  
   RevChargeMethod:string,
      /**  Reverse Charge Under Threshold value. If the absolute value of an invoice line is less than the under threshold then the reverse charge tax code will be applied.  */  
   RCUnderThreshold:number,
      /**  Reverse Charge Over Threshold value. If the absolute value of an invoice line is more than the over threshold then the reverse charge tax code will be applied.  */  
   RCOverThreshold:number,
      /**  This field can be used with external system integrations to identify which system currently has ownership of the record.  This field can hold either the name of the external system (example: PDM), ERP (Epicor) or null.  */  
   OwnershipStatus:string,
      /**   The UOM Class that will be used for the Part. The UOM Class establishes the list of unit of measures that can be used in reference to this part.
Must be valid in the UOMClass table.  */  
   UOMClassID:string,
      /**  This is the ID by which the user will reference a particular serial number format mask.  */  
   SNMask:string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   SNMaskExample:string,
      /**  A standard suffix that will be attached to all serial numbers currently used only by SNBaseStructure Mask types.  */  
   SNMaskSuffix:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types.  */  
   SNMaskPrefix:string,
      /**  This is the last used serial sequence default. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It will be used when defaulting the SNLastUsedSeq field for new PartSite records.  */  
   SNLastUsedSeq:string,
      /**  Indicates to use the value in SerialMask.SNLastUsedSeq when generating the next serial number for a Generate Mask type.  */  
   UseMaskSeq:boolean,
      /**   Qualifies the unit of measure of the NetWeight field.
Must be a UOMConv of the UOMClass with ClassType of "weight".   Use UOMClass.DefUOMCode of the "weight" UOMClass as a default  when creating new part records.
Having a NetWeightUOM will provides the ability to calculate total  weight.  */  
   NetWeightUOM:string,
      /**   Qualifies the unit of measure of the NewVolume field.
Must be a UOMConv of the UOMClass with ClassType of "volume".   Use UOMClass.DefUOMCode of the "volume" UOMClass as a default  when creating new part records.
Having a Net Volume UOM will provides the ability to calculate total volume  */  
   NetVolumeUOM:string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotBatch:boolean,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgBatch:boolean,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgLot:boolean,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotHeat:boolean,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotFirmware:boolean,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotBeforeDt:boolean,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotMfgDt:boolean,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotCureDt:boolean,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts.  */  
   LotExpDt:boolean,
      /**  Defines a prefix to be used when a lot number is generated for the specific part.  */  
   LotPrefix:string,
      /**  When generating the numeric portion of a lot number it can be either based on a next available number for the part (see Part.LotNextNum) or next available number from a Global Sequence (see LotSeq table and Part.LotSeqID)  */  
   LotUseGlobalSeq:boolean,
      /**  The LotSeqID of the LotSeq record to use to retreive next available number when the part is using a Global Sequence  (Part.LotUseGlobalSeq = True). Must be valid in the LotSeq table if Part.LotUseGlobalSeq = True)  */  
   LotSeqID:string,
      /**  The next available number to use to generate new lot numbers a part when the  is configured to use "Part Specific" number sequence. (Part.LotUseGlobalSeq = false).  */  
   LotNxtNum:number,
      /**  Number of digits of the Next Avail Lot Number controls that will be used by system Generate lot number logic.  */  
   LotDigits:number,
      /**  If leading zeros should be included in the numeric portion of the system generated lot number.  */  
   LotLeadingZeros:boolean,
      /**   Option to append a trailing date string to the system generated lot number. The Date is the current system date.
Valid options are: None (Default), DD, MM, YYYY, MMYYYY, MM_YYYY, DDMMYYY, DD-MM-YYY, MMDDYYYY, MM-DD-YYYY,  YYYYMMDD, YYYY-MM-DD  */  
   LotAppendDate:string,
      /**  This flag identifies those parts that will suggest a PO each time than a sales order is created. This flag will be used as a default in the sales order.  */  
   BuyToOrder:boolean,
      /**  This flag identifies those parts that are commonly drop shipped. This flag will be used as a default in the sales order.  */  
   DropShip:boolean,
      /**  Configured Part  */  
   IsConfigured:boolean,
      /**  External Configurator  */  
   ExtConfig:boolean,
      /**  The reference category that this Part belongs to.  */  
   RefCategory:string,
      /**   Malaysia Localization
The flag to indicate that the part is under CJ5 jurisdiction  */  
   CSFCJ5:boolean,
      /**   Malaysa Localization
The flag to indicate that the part is under LMW jurisdiction  */  
   CSFLMW:boolean,
      /**  The Part's Unit Gross Weight.  */  
   GrossWeight:number,
      /**   Qualifies the unit of measure of the GrossWeight field.
Must be a UOMConv of the UOMClass with ClassType of "weight".   Use UOMClass.DefUOMCode of the "weight" UOMClass as a defaul
t  when creating new part records.  */  
   GrossWeightUOM:string,
      /**  The part number used to identify the configured part number this part number was generated from.  */  
   BasePartNum:string,
      /**  Class Code Entry Field  */  
   FSAssetClassCode:string,
      /**  Field Service Sales Unit Price  */  
   FSSalesUnitPrice:number,
      /**  Indicates the field service sales pricing per quantity for this part. It can be "E" = per each, "C" = per hundred,  "M" = per thousand. The initial default is "E".  */  
   FSPricePerCode:string,
      /**  Indicates if  Inspection is required upon receipt.  Inspection will also be enforced if the related Part Class, Vendor, PO Detail, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   RcvInspectionReq:boolean,
      /**  EstimateID  */  
   EstimateID:string,
      /**  EstimateOrPlan  */  
   EstimateOrPlan:string,
      /**  DiffPrc2PrchUOM  */  
   DiffPrc2PrchUOM:boolean,
      /**  DupOnJobCrt  */  
   DupOnJobCrt:boolean,
      /**  PricingFactor  */  
   PricingFactor:number,
      /**  PricingUOM  */  
   PricingUOM:string,
      /**  MobilePart  */  
   MobilePart:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  AGUseGoodMark  */  
   AGUseGoodMark:boolean,
      /**  AGProductMark  */  
   AGProductMark:boolean,
      /**  ISRegion  */  
   ISRegion:string,
      /**  INChapterID  */  
   INChapterID:string,
      /**  CSF Peru -  SUNAT Type  */  
   PESUNATType:string,
      /**  PESUNATUOM  */  
   PESUNATUOM:string,
      /**  DEIsServices  */  
   DEIsServices:boolean,
      /**  DEIsSecurityFinancialDerivative  */  
   DEIsSecurityFinancialDerivative:boolean,
      /**  DEInternationalSecuritiesID  */  
   DEInternationalSecuritiesID:string,
      /**  LinkToContract  */  
   LinkToContract:boolean,
      /**  DEIsInvestment  */  
   DEIsInvestment:boolean,
      /**  DEPayStatCode  */  
   DEPayStatCode:string,
      /**  DEDenomination  */  
   DEDenomination:string,
      /**  PartLengthWidthHeightUM  */  
   PartLengthWidthHeightUM:string,
      /**  DiameterUM  */  
   DiameterUM:string,
      /**  DiameterInside  */  
   DiameterInside:number,
      /**  DiameterOutside  */  
   DiameterOutside:number,
      /**  ThicknessUM  */  
   ThicknessUM:string,
      /**  Thickness  */  
   Thickness:number,
      /**  ThicknessMax  */  
   ThicknessMax:number,
      /**  Durometer  */  
   Durometer:string,
      /**  Specification  */  
   Specification:string,
      /**  EngineeringAlert  */  
   EngineeringAlert:string,
      /**  Condition  */  
   Condition:string,
      /**  IsCompliant  */  
   IsCompliant:boolean,
      /**  IsRestricted  */  
   IsRestricted:boolean,
      /**  IsSafetyItem  */  
   IsSafetyItem:boolean,
      /**  CommercialBrand  */  
   CommercialBrand:string,
      /**  CommercialSubBrand  */  
   CommercialSubBrand:string,
      /**  CommercialCategory  */  
   CommercialCategory:string,
      /**  CommercialSubCategory  */  
   CommercialSubCategory:string,
      /**  CommercialStyle  */  
   CommercialStyle:string,
      /**  CommercialSize1  */  
   CommercialSize1:string,
      /**  CommercialSize2  */  
   CommercialSize2:string,
      /**  CommercialColor  */  
   CommercialColor:string,
      /**  IsGiftCard  */  
   IsGiftCard:boolean,
      /**  PhotoFile  */  
   PhotoFile:string,
      /**  PartPhotoExists  */  
   PartPhotoExists:boolean,
      /**  CommentText  */  
   CommentText:string,
      /**  Indicates if the packaging information is part specific or specified at the UOM class level.  */  
   PartSpecificPackingUOM:boolean,
      /**  ImageID  */  
   ImageID:string,
      /**  Specification Code for China GTI purposes  */  
   CNSpecification:string,
      /**  This field defines if the part  is synchronized to an External CRM.  */  
   SyncToExternalCRM:boolean,
      /**  This field holds the id of this part in the External CRM  */  
   ExternalCRMPartID:string,
      /**  This field defines the last time that the  part  has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   ExternalCRMLastSync:string,
      /**  This fields determines if the part needs to be synchronized to the External CRM. If there are changes in the part master file , Epicor ERP automatically turns on this field.  */  
   ExternalCRMSyncRequired:boolean,
      /**  PESUNATTypeCode  */  
   PESUNATTypeCode:string,
      /**  PESUNATUOMCode  */  
   PESUNATUOMCode:string,
      /**  Code Version for China GTI purposes  */  
   CNCodeVersion:string,
      /**  Tax Category Code for China GTI purposes  */  
   CNTaxCategoryCode:string,
      /**  Has Preferential Treatment value for China GTI purposes  */  
   CNHasPreferentialTreatment:boolean,
      /**  Preferential Treatment Content for China GTI purposes  */  
   CNPreferentialTreatmentContent:string,
      /**  Zero Tax Rate Mark for China GTI purposes  */  
   CNZeroTaxRateMark:string,
      /**  SubLevelCode  */  
   SubLevelCode:number,
      /**  Date the Part was created  */  
   CreatedBy:string,
      /**  User the Part was created by  */  
   CreatedOn:string,
      /**  Indicates if entry of a BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttBatch:string,
      /**  Indicates if entry of a MFG BATCH is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgBatch:string,
      /**  Indicates if entry of a MFG Lot is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgLot:string,
      /**  Indicates if entry of a Heat Number  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttHeat:string,
      /**  Indicates if entry of FIRMWARE is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttFirmware:string,
      /**  Indicates if entry of a Best Before Date is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttBeforeDt:string,
      /**  Indicates if entry of a Original Manufacture Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttMfgDt:string,
      /**  Indicates if entry of a CURE DATE  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttCureDt:string,
      /**  Indicates if entry of an Expiration Date  is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttExpDt:string,
      /**  DeferManualEntry  */  
   DeferManualEntry:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Container Receipt, Receipt Entry.  */  
   DeferPurchaseReceipt:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Job Receipt to Job, Job Receipt to Salvage, Job Receipt to Inventory, Kanban Receipts.  */  
   DeferJobReceipt:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Inspection Processing.  */  
   DeferInspection:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: Quantity Adjustment.  */  
   DeferQtyAdjustment:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Inventory Transfer.  */  
   DeferInventoryMove:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Customer Shipment Entry, Subcontractor Shipment Entry, Drop Shipment Entry, Order Entry.  */  
   DeferShipments:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later. This flag is used for following screens: Count Tag Entry.  */  
   DeferInventoryCounts:boolean,
      /**  DeferAssetDisposal  */  
   DeferAssetDisposal:boolean,
      /**  This flag indicates if the Lots attributes are necessary to be entered in the creation of the lot or could be entered later.  This flag is used for following screens: RMA Processing.  */  
   DeferReturnMaterials:boolean,
      /**  MXProdServCode  */  
   MXProdServCode:string,
      /**  Date/Time when the Part record was updated  */  
   ChangedOn:string,
      /**  MXCustomsDuty  */  
   MXCustomsDuty:string,
      /**  Determines if the Part has to be synchronized with Epicor FSA application.  */  
   SendToFSA:boolean,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   ExternalMESSyncRequired:boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   ExternalMESLastSync:string,
      /**  When the part is marked as Item, it will create an Item Resource in Epicor FSA.  */  
   FSAItem:boolean,
      /**  When the part is marked as Equipment, it will create an Equipment Resource Template in Epicor FSA.  */  
   FSAEquipment:boolean,
      /**  Bill of Lading Class. Additional data for the part required for LTL and International shipments.  */  
   BOLClass:string,
      /**  Fair Market Value. Additional data for the part required for LTL and International shipments.  */  
   FairMarketValue:number,
      /**  SAFTProdCategory  */  
   SAFTProdCategory:string,
      /**  ID of related Attribute Class.  */  
   AttrClassID:string,
      /**  Indicates if this part requires Identification Numbers shipment time.  This is disable if Track Location inventory is false.  */  
   LocationIDNumReq:boolean,
      /**  Indicates if this part tracks Location Inventory.  */  
   LocationTrackInv:boolean,
      /**  Set the default value of Location View for materials added in Engineering Workbench.  */  
   LocationMtlView:boolean,
      /**  LCNRVReporting  */  
   LCNRVReporting:boolean,
      /**  LCNRVEstimatedUnitPrice  */  
   LCNRVEstimatedUnitPrice:number,
      /**  MXCustomsUMFrom  */  
   MXCustomsUMFrom:string,
      /**  Default format ID used when assigning ID Numbers.  */  
   LocationFormatID:string,
      /**  IsServices  */  
   IsServices:boolean,
      /**  PEDetrGoodServiceCode  */  
   PEDetrGoodServiceCode:string,
      /**  PEProductServiceCode  */  
   PEProductServiceCode:string,
      /**  Dual UOM Class ID  */  
   DualUOMClassID:string,
      /**  Product Name  */  
   CNProductName:string,
      /**  Weight  */  
   CNWeight:number,
      /**  Unit of Weight  */  
   CNWeightUOM:string,
      /**  Bonded  */  
   CNBonded:boolean,
      /**  Indicates if inventory for this part is tracked at the attribute level. This feature requires the Advanced Unit of Measure license.  */  
   TrackInventoryAttributes:boolean,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   DefaultAttributeSetID:number,
      /**  Indicates if entry of a County of Origin is required for Lots of this Part. Pertinent only for lot tracked parts. Accepted values are N="Not Tracked", T = "Tracked" and M = "Mandatory".  */  
   AttISOrigCountry:string,
      /**  ISO / IEC 6523  */  
   ExternalSchemeID:string,
      /**  Part ID  */  
   ExternalID:string,
      /**  UNTDID 7143  */  
   CommoditySchemeID:string,
      /**  Part Commodity Scheme Version  */  
   CommoditySchemeVersion:string,
      /**  Indicates if inventory for this part is tracked by revision number.  */  
   TrackInventoryByRevision:boolean,
      /**  Indicates if this part performs MRP by Revision.  Requires Planning by Revision license.  */  
   PlanningByRevision:boolean,
      /**  RcvInspectionReqPart  */  
   RcvInspectionReqPart:string,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  FSMPartType  */  
   FSMPartType:number,
   CountryNumDescription:string,
      /**  Should the Express Part Check Out option be enabled?  */  
   EnableExpressCheckOut:boolean,
   EnableGlobalLock:boolean,
   EnableGlobalPart:boolean,
      /**  Indicates if the InActive flag should be available for input,  */  
   EnableInActive:boolean,
      /**  Flag to tell UI whether the Part.IUM field should be enabled or not.  */  
   EnableIUM:boolean,
      /**  Indicates if Override Reverse Charge check box should be enabled.  */  
   EnableRevCharge:boolean,
      /**  Indicates if the Serial Number button should be enabled.  */  
   EnableSerialNum:boolean,
      /**  This field is used only as a flag to determine in UI, if the Part.TrackSerialNum can be change.  */  
   EnableTrackSerialNum:boolean,
      /**  Flag to tell UI whether the UOMClassID field should be enabled or not.  */  
   EnableUOMClass:boolean,
   ExtCoExist:boolean,
      /**  Default installation price of an equipment that requires installation in Epicor FSA.  */  
   FSAInstallationCost:number,
      /**  Indicates if the equipment requires an installation prior being marked as Installed on a Location in Epicor FSA. If true, at shipment it will create a service order for the installation service in FSA.  */  
   FSAInstallationRequired:boolean,
      /**  Indicates the service order template ID that Epicor FSA will use to create the installation service order.  */  
   FSAInstallationType:string,
   FSAInstTypeDesc:string,
      /**  Indicates if the Part is Global (master or linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany and GlbPartNum that is linking to this part  */  
   GlbLink:string,
      /**  check if TrackDimension is in GlbTable and should be disabled in Part Entry  */  
   GlbTableAllowUpdTrackDim:boolean,
      /**  check if TrackLots is in GlbTable and should be disabled in Part Entry  */  
   GlbTableAllowUpdTrackLots:boolean,
      /**  check if TrackSerialNum is in GlbTable and should be disabled in Part Entry  */  
   GlbTableAllowUpdTrackSerial:boolean,
      /**  Indicates if there is any quantity on hand for this part  */  
   HasOnHandQty:boolean,
      /**  Indicates if part is a component (has a where used list available)  */  
   IsComponent:boolean,
      /**   This field indicates if the part is being used as a co-part anywhere.  This field will be used to prevent a Part from being marked as serial tracked or configured after being added as a co-part.

CoParts Project.  */  
   IsCoPart:boolean,
      /**  This is the numeric value of ISOrigCountry.  */  
   ISOrigCountryNum:number,
      /**  Shows what the next generated lot number for this part would look like  */  
   NextGeneratedLotNum:string,
   PEDetrGoodServiceCodeDesc:string,
   PEProductServiceCodeDesc:string,
   PLM:boolean,
      /**  Indicates if the PLM toggle box is enabled.  */  
   PLMEnabled:boolean,
      /**  Revision  */  
   Revision:boolean,
   SalesUMDisp:string,
   SNLeadingZeros:boolean,
   SNMaskPrefixLength:number,
   SNMaskSuffixLength:number,
   SNNumODigits:number,
      /**  Yes means to copy the NonStock and CostMethod from Part to all the PartPlant records.  */  
   UpdatePartPlant:boolean,
      /**  Indicates whether to update the Part serial number format changes to part plant  */  
   UpdateSNPartPlant:boolean,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
      /**  If this Part is TrackInventoryAttributes = true, and the AttrClassID it is associated to has one or more attributes whose DynAttrClassDtl.UsedInPlanning= true.  */  
   HasMRPPlanningAttribute:boolean,
   UpdatePartPlantOverride:boolean,
      /**  DEPayStatCode Description  */  
   DEPayStatCodeDescr:string,
      /**  DEDenomination Description  */  
   DEDenominationDescr:string,
   DefaultBuyerName:string,
   DefaultPlannerName:string,
      /**  This field is used only as a flag to determine in UI, if the Part.TrackInventoryByRevision can be changed.  */  
   EnableTrackByRevision:boolean,
      /**  indicated if this part has been linked to a global part  */  
   LinkedToGlbPart:boolean,
   BitFlag:number,
   AnalysisCdDescription:string,
   ClassDescription:string,
   CommodityCodeSuppUnitsUOM:string,
   CommodityCodeDescription:string,
   CompanySendToFSA:boolean,
   DualUOMClassIDDescription:string,
   DynAttrValueSetShortDescription:string,
   DynAttrValueSetDescription:string,
   FSAssetClassCodeFSAssetClassDesc:string,
   Mtl_AnalysisCdDescription:string,
   MXProdServCodeDesc:string,
   OnHoldReasonCodeDescription:string,
   ProdCodeDescription:string,
   RefCategoryDescription:string,
   SerialMaskMaskType:number,
   SerialMaskDescription:string,
   TaxCatIDDescription:string,
   UOMClassIDDescription:string,
   WarrantyCodeWarrDescription:string,
   XbSystELIEinvoice:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartSubsRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Part number that this substitute Part is for.  */  
   PartNum:string,
      /**  Substitute Part  */  
   SubPart:string,
      /**  Indicates the record type. "S" = Substitute, "C" = Compliment  */  
   RecType:string,
      /**  Pertains only to Substitute Parts (RecType = "S"). Values are "C" - Comparable, "D" - Downgrade, "U" - Upgrade  */  
   SubType:string,
      /**   The quantity of the alternate part per 1 of the parent part in the parents base inventory uom. Cannot be zero.
To convert an existing OrderDtl.SellingQty to a PartSubs. It is converted to the Parents Part Base Inventory UOM  then multiply PartSubs.QtyPer, then converted to  PartSub.SalesUM.  */  
   QtyPer:number,
      /**  Selling Unit of measure used when this part is used as a substitute/compliment with the parent part (partsubs.partnum).  Defaults as Part.SUM of the PartSub.SubPart.  */  
   SalesUM:string,
      /**  Optional Comment  */  
   Comment:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   DefaultSub:boolean,
      /**  Price for the Suggested Quantity  */  
   Price:number,
      /**  Suggested Quantity  */  
   SuggestedQty:number,
      /**  Selected Row  */  
   Selected:boolean,
      /**  Suggested Quantity for Order Qty in Quote Detail  */  
   SugOrderQty:number,
   BitFlag:number,
   PartNumPricePerCode:string,
   PartNumTrackLots:boolean,
   PartNumPartDescription:string,
   PartNumSalesUM:string,
   PartNumIUM:string,
   PartNumSellingFactor:number,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   SubPartSellingFactor:number,
   SubPartTrackSerialNum:boolean,
   SubPartTrackDimension:boolean,
   SubPartPartDescription:string,
   SubPartIUM:string,
   SubPartSalesUM:string,
   SubPartTrackLots:boolean,
   SubPartPricePerCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartUOMRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  A unique part number that identifies this part.  */  
   PartNum:string,
      /**  User defined code which uniquely identifies the UOM within the UOMClass.  */  
   UOMCode:string,
      /**   Value used to convert to/from base uom for the specific part. Cannot change if it's base uom of UOMClass (always 1.0) Sometimes a unit of measure conversion is relative to a specific part. These are non-standard conversions.
For example; 1 box(bx) of  Part A is 12ea. 1(bx) of Part B is 24ea. Non-standard conversions are defined in the PartUOM table. When ConvOperator = * then ConvFactor is 1 UOM expressed in Base UOM else it is 1 Base UOM expressed in UOM  */  
   ConvFactor:number,
      /**  Indicates if the PartUOM is Active. This field is ready only and is used for internal logic purposes only.  */  
   Active:boolean,
      /**  If true then Onhand Quantity will be tracked per this UOM for this part.  */  
   TrackOnHand:boolean,
      /**  The Part's Net Volume.  */  
   NetVolume:number,
      /**   Qualifies the unit of measure of the NewVolume field.
Must be a UOMConv of the UOMClass with ClassType of "volume".   Use UOMClass.DefUOMCode of the "volume" UOMClass as a default  when creating new part records.
Having a Net Volume UOM will provides the ability to calculate total volume  */  
   NetVolumeUOM:string,
      /**  This indicates that this Part UOM has been used somewhere.  Therefore we do not want to allow the associated part specific conversion to change.  */  
   HasBeenUsed:boolean,
      /**   Indicates the mathmatical operator that is used for performing the UOM Conversion. Options are "*" (Multiply) or "\" (Divide).
For example for Feet to Inch where Inch is the base uom. 
You could have 1ft / 12 = 1In  */  
   ConvOperator:string,
      /**  WebUOM  */  
   WebUOM:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Qualifies that 1 of this uom = ConvFactor in ConvToUOM. Example: 12in = 1ft or 1ft = 12in  */  
   ConvFromUOM:string,
      /**  External field used to enable/disable the conversion factor to able to change it.  */  
   ConvOverrride:boolean,
      /**  Qualifies UOM of the ConvFactor. This either the UOMClass.BaseUOM or the UOMConv.UOMCode depending on the value of ConvOperator.  */  
   ConvToUOM:string,
      /**  EAN13 product code from PartPC  */  
   EAN13:string,
      /**  EAN14 product code from PartPC  */  
   EAN14:string,
      /**  EAN8 product code from PartPC  */  
   EAN8:string,
      /**  Internal use. To indicate if the ConvFactor should be enabled. This field is set to true if the related UOMClass is non-standard and the UOMCode is not the BaseUOM  */  
   EnableConvFactor:boolean,
      /**  Indicates if the TrackOnHand is enabled. True when Part.TrackMultiUOM = true and UOMCode <> Part.IUM  */  
   EnableTrackOnHand:boolean,
      /**  GTIN14 product code from PartPC  */  
   GTIN14:string,
      /**  HIBC UPN product code from PartPC  */  
   HIBC:string,
      /**  Value of UOMConv.PartSpecific for informational purposes  */  
   PartSpecific:boolean,
   UOMDesc:string,
      /**  UPC12 product code from PartPC  */  
   UPC12:string,
      /**  BaseUOMCode from UOMClass file  */  
   BaseUOMCode:string,
      /**  Used to input/display the package code related to the part/UOM. The user will only be able to update this data if Part.UsePartSpecificPckCode = true  */  
   DispPkgCode:string,
      /**  Description of the PkgCode  */  
   DispPkgCodeDesc:string,
      /**  Indicates the display sequence of the packaging in relation to the other packaging for the part.  */  
   DispPkgDisplaySeq:number,
      /**  Indicates if the PkgCode is the default.  */  
   DispPkgIsDefault:boolean,
      /**  Indicates if the pkg code information seen in PartUOM is part specific (the data came from PackingUOM where PartNum is not blank.) If true the package code data can be updated in Part Maint, if false the PartUOM pkgcode columns will be disabled.  */  
   PartSpecificPkgCode:boolean,
      /**  Indicates if the package code will be displayed in the application. If false, the package codes that are not valid for the MGF process on the shop floor are hidden.  */  
   DispPkgDisplayHidden:boolean,
   StandardUpdate:boolean,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PartXRefIntRow{
      /**  Company Code  */  
   Company:string,
      /**  PartNum  */  
   PartNum:string,
      /**  Cross Reference PartNum  */  
   XRefPartNum:string,
      /**  XRefPartDesc  */  
   XRefPartDesc:string,
      /**  If the SNBaseDataType is Mask this is the Serial Mask ID assigned for format validation/generation.  */  
   SNMask:string,
      /**  BL-generated example of the serial number mask if SNBaseDataType = Mask.  */  
   SNMaskExample:string,
      /**  A standard suffix that will be attached to all serial numbers generated for the PartSite currently used only by SNBaseStructure Mask types  */  
   SNMaskSuffix:string,
      /**  The prefix that was used to construct the serial number currently used only by SNBaseStructure Mask types  */  
   SNMaskPrefix:string,
      /**  This is the last used serial sequence. It is used only for the Mask Generate type to determine the next logical serial number to generate for this part/Site. It can be altered by the user and several PartSites can have the same counter values defined, but  */  
   SNLastUsedSeq:string,
      /**  SNOverride - Determines whether SN field values on PartXRefInt are used instead of the Part values. If this is true, they are used. If this is false, those values are ignored.  */  
   SNOverride:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_PcECCOrderDtlRow{
      /**  Company  */  
   Company:string,
      /**  ECCBSVID  */  
   ECCBSVID:string,
      /**  CustNum  */  
   CustNum:number,
      /**  PartNum  */  
   PartNum:string,
      /**  BasePartNum  */  
   BasePartNum:string,
      /**  BaseRevisionNum  */  
   BaseRevisionNum:string,
      /**  Plant  */  
   Plant:string,
      /**  LineDesc  */  
   LineDesc:string,
      /**  CurrencyCode  */  
   CurrencyCode:string,
      /**  BreakListCode  */  
   BreakListCode:string,
      /**  Commissionable  */  
   Commissionable:boolean,
      /**  DiscBreakListCode  */  
   DiscBreakListCode:string,
      /**  UnitPrice  */  
   UnitPrice:number,
      /**  LockPrice  */  
   LockPrice:boolean,
      /**  LockQty  */  
   LockQty:boolean,
      /**  NeedByDate  */  
   NeedByDate:string,
      /**  OrderComment  */  
   OrderComment:string,
      /**  OverrideDiscPriceList  */  
   OverrideDiscPriceList:boolean,
      /**  OverridePriceList  */  
   OverridePriceList:boolean,
      /**  PickListComment  */  
   PickListComment:string,
      /**  POLine  */  
   POLine:string,
      /**  PricePerCode  */  
   PricePerCode:string,
      /**  ProdCode  */  
   ProdCode:string,
      /**  ProjectID  */  
   ProjectID:string,
      /**  Reference  */  
   Reference:string,
      /**  RequestDate  */  
   RequestDate:string,
      /**  Rework  */  
   Rework:boolean,
      /**  RMALine  */  
   RMALine:number,
      /**  RMANum  */  
   RMANum:number,
      /**  SalesCatID  */  
   SalesCatID:string,
      /**  SalesUM  */  
   SalesUM:string,
      /**  SellingQuantity  */  
   SellingQuantity:number,
      /**  ShipComment  */  
   ShipComment:string,
      /**  ShipLineComplete  */  
   ShipLineComplete:boolean,
      /**  TaxCatID  */  
   TaxCatID:string,
      /**  TMBilling  */  
   TMBilling:boolean,
      /**  XPartNum  */  
   XPartNum:string,
      /**  XRevisionNum  */  
   XRevisionNum:string,
      /**  DocUnitPrice  */  
   DocUnitPrice:number,
      /**  ConfigBaseUnitPrice  */  
   ConfigBaseUnitPrice:number,
      /**  ConfigUnitPrice  */  
   ConfigUnitPrice:number,
      /**  SysRevID  */  
   SysRevID:number,
      /**  SysRowID  */  
   SysRowID:string,
      /**  ECCQuoteNum  */  
   ECCQuoteNum:string,
      /**  RevisionNum  */  
   RevisionNum:string,
      /**  ShipToNum  */  
   ShipToNum:string,
      /**  GroupSeq  */  
   GroupSeq:number,
      /**  CreateDate  */  
   CreateDate:string,
      /**  AnalysisCode  */  
   AnalysisCode:string,
      /**  BestCsPct  */  
   BestCsPct:number,
      /**  Discount  */  
   Discount:number,
      /**  DiscountPercent  */  
   DiscountPercent:number,
      /**  DocDiscount  */  
   DocDiscount:number,
      /**  Engineer  */  
   Engineer:boolean,
      /**  JobComment  */  
   JobComment:string,
      /**  KitQtyPer  */  
   KitQtyPer:number,
      /**  LeadTime  */  
   LeadTime:string,
      /**  MultiRel  */  
   MultiRel:boolean,
      /**  PhaseID  */  
   PhaseID:string,
      /**  QuoteComment  */  
   QuoteComment:string,
      /**  ReqShipDate  */  
   ReqShipDate:string,
      /**  SellingExpectedQty  */  
   SellingExpectedQty:number,
      /**  SellingExpectedUM  */  
   SellingExpectedUM:string,
      /**  Template  */  
   Template:boolean,
      /**  WorstCsPct  */  
   WorstCsPct:number,
      /**  PCLinkRemoved  */  
   PCLinkRemoved:boolean,
      /**  MSRP  */  
   MSRP:number,
      /**  EndCustomerPrice  */  
   EndCustomerPrice:number,
      /**  Promotional Price offered to Dealer and Distributors  */  
   PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in the customer currency converted using the exchange rate.  */  
   DocPromotionalPrice:number,
      /**  Same as end customer price except that this field contains the price in the customer currency converted using the exchange rate.  */  
   DocEndCustomerPrice:number,
      /**  Same as MSRP except that this field contains the price in the customer currency converted using the exchange rate.  */  
   DocMSRP:number,
      /**  The unique identifier of the related CPQ Configured Quote Product.  */  
   KBConfigProdID:number,
   ConfigID:string,
   ConfigVersion:number,
   BitFlag:number,
   CustNumBTName:string,
   CustNumCustID:string,
   CustNumName:string,
   PartNumTrackLots:boolean,
   PartNumSalesUM:string,
   PartNumPartDescription:string,
   PartNumTrackDimension:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumPricePerCode:string,
   PartNumIUM:string,
   PartNumSellingFactor:number,
   ProdCodeDescription:string,
   ProjectIDDescription:string,
   SalesCatIDDescription:string,
   TaxCatIDDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ProdGrupRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Descriptive code assigned by the user to uniquely identify a Product Group master. Can't be blank. Used as a foreign key in other files and may be used in displays/reports where space for the full description is not available.  */  
   ProdCode:string,
      /**  Full description of Product Group.  */  
   Description:string,
      /**   Identifies the Person to be used as the default Production Planner. This person is responsible for handling  the manufacturing suggestions of parts in this Product Group.
Used as the default for "new" manufacturing suggestions and on Job Header. Manufacturing suggestions can be filtered by Planner.
Relates to the Person table.  */  
   PersonID:string,
      /**  Unique code for the Warranty for this Product group  */  
   WarrantyCode:string,
      /**  Site Identifier.  */  
   Plant:string,
      /**  Descriptive code assigned by user which uniquely identifies a Sales Tax category master record.  Cannot be blank.  This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  Examples: SERV = Service, FRT = Freight, etc.  */  
   TaxCatID:string,
      /**  The default job completion code for this product group. This code is used in the auto-job completion process.  */  
   JobCompletionCode:string,
      /**  The default job closing code for this product group. This code is used in the auto-job closing process.  */  
   JobClosingCode:string,
      /**  Rough Cut Code.  Rough cut parameters to use when rough cut scheduling for a part using this product code.  */  
   RoughCutCode:string,
      /**  Specifies the Price Group Code where the current Product Group belongs  */  
   PriceGroupCode:string,
      /**  Indicates if revenue is deferred for contracts assigned to this group.  */  
   DeferredRev:boolean,
      /**  Revenue Amortization Code.  */  
   RACode:string,
      /**  Marks this ProdGrup as global, available to be sent out to other companies.  */  
   GlobalProdGrup:boolean,
      /**  Disables this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  Descriptive code assigned by the user to uniquely identify a Product Family master.  */  
   ProdFamilyID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Territory ID selected for the Product Group.  */  
   TerritoryID:string,
   TerritoryDesc:string,
   BitFlag:number,
   JobClosingCodeDescription:string,
   JobCompletionCodeDescription:string,
   PersonIDName:string,
   PlantName:string,
   RASchedCdRADesc:string,
   RoughCutParamDescription:string,
   TaxCatIDDescription:string,
   WarrantyCodeWarrDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_QuoteDtlRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Quote number to which this line item detail record is associated with. This is part of the foreign key to OrderHed file.  */  
   QuoteNum:number,
      /**  This field along with Company and QuoteNum make up the unique key to the table. The system generates this number during entry of new detail records. The system determines next available number by finding the QuoteDtl record for the Quote and the adding 1 to it.  */  
   QuoteLine:number,
      /**  Indicates if this Quote item has been ordered. This is not directly set by the user. It is updated via Order Entry when the QuoteDtl is referenced.  */  
   Ordered:boolean,
      /**   The user's Internal Part number used to identify line item part. It cannot  be blank. It does not have to exist in the Part table.

A default should be made when the QuoteDtl.XPartNum is changed.  The PartNum and XPartNum fields work together in providing defaults for each other. Default when a valid record is found in the PartXRef table. NOTE THE PART CROSS REFERENCE LOGIC IS NOT INCLUDED IN RELEASE 1.0 ... PLAN FOR FUTURE  */  
   PartNum:string,
      /**  Line Item description. The Part.Description can be used as a default.  */  
   LineDesc:string,
      /**  Optional field that contains the customers revision. Default from the Part.RevisionNum field.  */  
   RevisionNum:string,
      /**  Product Group Code. Use the Part.ProdCode as a default.  This can be blank or must be valid in the ProdGrup table.  */  
   ProdCode:string,
      /**  An optional field that is used if the customer has a different  Part number  than the users internal part number.  The XPartNum and PartNum can provide defaults for each other via the CustXPrt table.. The XPartNum can be blank, does not have to exist in the CustXPrt table.  THIS FIELD WILL BE USED TO PASS THE VALUE ALONG TO ORDER ENTRY.  */  
   XPartNum:string,
      /**  Contains comments about the detail line item. These will be printed on the Quote form.  */  
   QuoteComment:string,
      /**  A field to describe lead time. For example "Allow 4-5 weeks". This is printed on the Quote form.  */  
   LeadTime:string,
      /**  Indicates if this quote detail is considered a "Template".  Template lines appear in the browse of quotes that can be copied.  */  
   Template:boolean,
      /**  Engineering Drawing Number. An optional field.  */  
   DrawNum:string,
      /**  Production Job comments. These will be copied to the JobHead.CommentText when the quote is pulled into a job during a get detail function.  It is also copied to the OrderDtl.PickListComment which may then be copied to JobHead.CommentText when linked.  */  
   JobComment:string,
      /**  An internally used flag field which indicates if Manufacturing Details exist for this quote line item. It is set to "Yes" if any QuoteOpr or QuoteMtl records exist for the quote line. This is controlled via write/delete triggers on the QuoteOpr and QuoteMtl files. Used by the "Get Detail" function in job entry so that only QuoteDtl record that MfgDetail = Yes are shown in the browser.  */  
   MfgDetail:boolean,
      /**  Indicates the Tax Category for this record. Defaults from the Part Master.  */  
   TaxCatID:string,
      /**  Optional field that contains the customers revision. Default from the CustXPrt.RevisionNum field.  */  
   XRevisionNum:string,
      /**  Number that relates to the Customer master. Duplicated from QuoteHed.CustNum.  Used to allow efficient browsing of the QuoteDtl records for a specific customer.  */  
   CustNum:number,
      /**  Mirror image of QuoteHed.Quoted.  Duplicated to provide efficient browsing of QuoteDtl records.  */  
   Quoted:boolean,
      /**  Mirror image of QuoteHed.Expired.  Duplicated to provide efficient browsing of QuoteDtl records.  */  
   Expired:boolean,
      /**  Used for scheduling a quote.  This date is only valid for the quantity and date the user entered for Quote Scheduling.  */  
   WIStartDate:string,
      /**  This field is established by scheduling, and it only valid for the Date/Quantity the user entered in quote scheduling.  */  
   WIStartHour:number,
      /**  Used for scheduling.  Only valid for the Date and Quantity the user entered in quote scheduling.  */  
   WIDueDate:string,
      /**  Used for scheduling.  Only valid for the Date and Quantity the user entered in quote scheduling.  */  
   WIDueHour:number,
      /**  The part number used to identify the configured part number initially entered on the line.  */  
   BasePartNum:string,
      /**  The quantity expected to be ordered. (In selling unit of measure)  */  
   SellingExpectedQty:number,
      /**  Unit of measure (how it is sold/issued) for the SellingExpectedQty.  Use the default Part.SUM if its a valid Part else use the global variable Def-UM which is established from XaSyst.DefaultUM.  */  
   SellingExpectedUM:string,
      /**  Allows Sales Rep to enter a percentage to factor the calculated revenue potential for the quote line  */  
   ConfidencePct:number,
      /**  The date this line was last updated  */  
   LastUpdate:string,
      /**  The last User Is that updated this Quote  */  
   LastDcdUserID:string,
      /**  The line item discount percent. It has nothing to do with price break discounts. It is a flat discount percent that defaults from the QuoteHed.DiscountPercent, which was originally defaulted from the Customer.DiscountPercent.  */  
   DiscountPercent:number,
      /**  A flat discount amount for the line item. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Discount:number,
      /**  A flat discount amount for the line item Converted to the customers currency. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or QuoteQty fields are changed.  */  
   DocDiscount:number,
      /**  Expected revenue for this line.  Calculated from SellingExpectedQty and Unit Price, discount and SalesRepFactor  */  
   ExpectedRevenue:number,
      /**  Expected revenue for this line  in customer currency.  Calculated from SellingExpectedQty and Unit Price, discount and SalesRepFactor  */  
   DocExpectedRevenue:number,
      /**  The requested ship date for the sales order  */  
   ReqShipDate:string,
      /**  The quantity to be used when a Sales order is created. (In selling unit of measure)  */  
   OrderQty:number,
      /**   This value is used to convert quantity when there is a difference in the customers unit of measure and how it is stocked in inventory. Example is sold in pounds, stocked in sheets.

Formula: Inventory Qty * Conversion Factor = Selling Qty.  */  
   SellingExpFactor:number,
      /**  Indicates that the order line made from this quote line should have multiple releases.  Informational only.  */  
   MultiRel:boolean,
      /**  Optional field used to enter the customers Purchase Order line item reference number.  */  
   POLine:string,
      /**  A Code which uniquely identifies a SalesCat record.  */  
   SalesCatID:string,
      /**  Replicated from QuoteHed to easier sorting  */  
   TerritoryID:string,
      /**   Duplicated from QuoteHed for Query's.  Describe the type of Quote this is.
LEAD = Lead
OPPO = Opportunity
QUOT = Quote  */  
   CurrentStage:string,
      /**  Indicates if the Quote line was created from opportunity entry "QUOTE" or from Order Entry "ORDER".  Used to determine if the Quote can be deleted when the Order gets deleted.  */  
   CreatedFrom:string,
      /**  Analysis Code  */  
   AnalysisCode:string,
      /**  Holds the internal object id of pdm parts.  */  
   PDMObjID:string,
      /**  The date when the configuration was completed for the assembly.  */  
   LastConfigDate:string,
      /**  The system time when the configuration was completed for the assembly.  */  
   LastConfigTime:number,
      /**  The User ID of the last user to complete the configuration of the assembly.  */  
   LastConfigUserID:string,
      /**   Same as Unit price except that this field contains the unit price computed from the input based pricing in a configuration.
If price breaks exist this price should be used as the base price instead of the one found in the part table.  */  
   ConfigUnitPrice:number,
      /**  This is the base price for inputs based pricing of a configuration.  The price of inputs are added to this price to get the ConfigUnitPrice.  */  
   ConfigBaseUnitPrice:number,
      /**  The revision number used to identify the configured part/revision number initially entered on the line.  */  
   BaseRevisionNum:string,
      /**  This is the Price List used to determine the starting base price.  */  
   PriceListCode:string,
      /**  This is the Price List used to determine the break % or amount.  */  
   BreakListCode:string,
      /**  The Expected Quantity (total qty of related quote lines) used to find price when quantity based discounting is applied.  */  
   PricingQty:number,
      /**  This is the price returned by the price list before quantity based or order value based discounts are applied.  */  
   ListPrice:number,
      /**   Same as List price except that this field contains the list price in
QuoteHed).  */  
   DocListPrice:number,
      /**  This is the unit price after quantity based or order value based discounts are applied.  */  
   OrdBasedPrice:number,
      /**  Same as Order Based price except that this field contains the unit price in the customer currency (converted using the exchange rate on QuoteHed).  */  
   DocOrdBasedPrice:number,
      /**  This is the Price Group ID used to price the quote line with.  */  
   PriceGroupCode:string,
      /**  Indicates if the user selected a price list different from the default.  */  
   OverridePriceList:boolean,
      /**  The Expected Order Value (total extended price of related quote lines) used to find order value break when value based discounting is applied.  */  
   PricingValue:number,
      /**  This is the unit price based on the expected quantity.  */  
   ExpUnitPrice:number,
      /**  This is the unit price (in customer currency) based on the expected quantity.  */  
   DocExpUnitPrice:number,
      /**   Indicates the pricing per quantity. It can be "E" = per each,
"C" = per hundred,  "M" = per thousand. Used to calculate the extended unit price for the line item. The logic is to divide the QuoteDtl.SellingExpectedQty by the appropriate "per" value and then multiply by expected unit price.  Use the  Part.PricePerCode as a default. If Part record does not exist then default as "E"  */  
   ExpPricePerCode:string,
      /**  An internally used integer assigned by the system to provide a unique key to the QuoteQty file.  This indicate what QuoteQty break should be used to get the related miscellaneous charges.  */  
   MiscQtyNum:number,
      /**  The Quote Line has been Engineered.  */  
   Engineer:boolean,
      /**  Indicates if Engineering details are complete/valid if the EngineerReq field is marked as Yes.  */  
   ReadyToQuote:boolean,
      /**  Indicates if component lines can be added, deleted and modified during quote entry.  This field is only relevant for quote lines which are kit parents.  */  
   KitAllowUpdate:boolean,
      /**  Indicates if the parent kitted part must be shipped complete or if kit components can be shipped in varying degrees of completeness.  This field is only relevant for quote lines which are kit parents.  If this field is set to "No", then KitPricing must be set to "C".  */  
   KitShipComplete:boolean,
      /**  Indicates if all components are to be backflushd when a kit parent item is shipped.  This field is only relevant for quote lines which are kit parents.  */  
   KitBackFlush:boolean,
      /**  Indicates if kit components are to be printed on packing slips.  If KitShipComplete is "Yes",then this field must be set to "Yes" as well.  This field is only relevant for quote lines which are kit parents.  */  
   KitPrintCompsPS:boolean,
      /**  Indicates if kit components are to be printed on invoices.  If KitShipComplete is "Yes", then this field must be set to "Yes" as well.  This field is only relevant for quote lines which are kit parents.  */  
   KitPrintCompsInv:boolean,
      /**  Indicates how kits will be priced.  Values are: P = Parent Pricing (The price is otained from the sales price for the kit parent item), C = Component Pricing (The price is obtained from a rollup of kit component items).  This field is only relevant for quote lines which are kit parents.  */  
   KitPricing:string,
      /**  The quote line number of the parent kit item.  This is only relevent for quote lines which are kit parent or component lines.  If the KitParentLine equals the QuoteLine then this is a kit parent line.  */  
   KitParentLine:number,
      /**  Component quantity required to fulfill one kit parent.  This field is only relevant on a quote line which is a kit component.  */  
   KitQtyPer:number,
      /**  This field controls the order in which quote lines are displayed.  DisplaySeq is a decimal number where the whole number portion is used to sequence normal quote lines and the decimal portion is ued to sequence kit components under their associated kit parent.  */  
   DisplaySeq:number,
      /**  Project ID of linked project.  Must exist on the Project table. Can be blank.  */  
   ProjectID:string,
      /**  Indicates how Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   SellingFactorDirection:string,
      /**  To indicate whether or not the line is make direct  */  
   MakeDirect:boolean,
      /**  Must exist on ProjPhase table if entered  */  
   PhaseID:string,
      /**   A character flag field used to differentiate between regular quote line, Sales Kit parent quote line and Sales Kit component quote line.
P = Sales Kit Parent line
C = Sales Kit Component Line
Null = regular line  */  
   KitFlag:string,
      /**  Indicates if the kit components have been automatically loaded.  If set to false the user interface will attempt to load the kit components after the user saves a new quote line.  */  
   KitsLoaded:boolean,
      /**  Non-blank value prevents taxes from being calculated for this line item  */  
   TaxExempt:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  This field can be used with external system integrations to identify which system currently has ownership of the record.  This field can hold either the name of the external system (example: PDM), ERP (Epicor) or null.  */  
   OwnershipStatus:string,
      /**  Reporting currency value of this field  */  
   Rpt1Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt2Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt3Discount:number,
      /**  Reporting currency value of this field  */  
   Rpt1ExpectedRevenue:number,
      /**  Reporting currency value of this field  */  
   Rpt2ExpectedRevenue:number,
      /**  Reporting currency value of this field  */  
   Rpt3ExpectedRevenue:number,
      /**  Reporting currency value of this field  */  
   Rpt1ExpUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2ExpUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3ExpUnitPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1ListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2ListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3ListPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt1OrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt2OrdBasedPrice:number,
      /**  Reporting currency value of this field  */  
   Rpt3OrdBasedPrice:number,
      /**  Extended Price for the quote line, rounded according to the Base currency Round rule  */  
   ExtPriceDtl:number,
      /**  Extended Price for the quote line in Customer currency, rounded according to the Doc currency Round rule  */  
   DocExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt1ExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt2ExtPriceDtl:number,
      /**  Reporting currency value of this field  */  
   Rpt3ExtPriceDtl:number,
      /**  Reserved for future use  */  
   InDiscount:number,
      /**  Reserved for future use  */  
   DocInDiscount:number,
      /**  Reserved for future use  */  
   InExpectedRevenue:number,
      /**  Reserved for future use  */  
   DocInExpectedRevenue:number,
      /**  Reserved for future use  */  
   InListPrice:number,
      /**  Reserved for future use  */  
   DocInListPrice:number,
      /**  Reserved for future use  */  
   InOrdBasedPrice:number,
      /**  Reserved for future use  */  
   DocInOrdBasedPrice:number,
      /**  Reserved for future use  */  
   InExpUnitPrice:number,
      /**  Reserved for future use  */  
   DocInExpUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt1InDiscount:number,
      /**  Reserved for future use  */  
   Rpt2InDiscount:number,
      /**  Reserved for future use  */  
   Rpt3InDiscount:number,
      /**  Reserved for future use  */  
   Rpt1InExpectedRevenue:number,
      /**  Reserved for future use  */  
   Rpt2InExpectedRevenue:number,
      /**  Reserved for future use  */  
   Rpt3InExpectedRevenue:number,
      /**  Reserved for future use  */  
   Rpt1InExpUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt2InExpUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt3InExpUnitPrice:number,
      /**  Reserved for future use  */  
   Rpt1InListPrice:number,
      /**  Reserved for future use  */  
   Rpt2InListPrice:number,
      /**  Reserved for future use  */  
   Rpt3InListPrice:number,
      /**  Reserved for future use  */  
   Rpt1InOrdBasedPrice:number,
      /**  Reserved for future use  */  
   Rpt2InOrdBasedPrice:number,
      /**  Reserved for future use  */  
   Rpt3InOrdBasedPrice:number,
      /**  Reserved for future use  */  
   InExtPriceDtl:number,
      /**  Reserved for future use  */  
   DocInExtPriceDtl:number,
      /**  Reserved for future use  */  
   Rpt1InExtPriceDtl:number,
      /**  Reserved for future use  */  
   Rpt2InExtPriceDtl:number,
      /**  Reserved for future use  */  
   Rpt3InExtPriceDtl:number,
      /**  Allows Sales Rep to enter a percentage to factor the calculated revenue potential (worst case) for the quote line.  */  
   WorstCsPct:number,
      /**  Allows Sales Rep to enter a percentage to factor the calculated revenue potential (best case) for the quote line.  */  
   BestCsPct:number,
      /**  Worst case revenue for this line.  Calculated from SellingExpectedQty and Unit Price, discount and WorstCsPct.  */  
   WorstCsRevenue:number,
      /**  Worst case revenue for this line in customer currency.  Calculated from SellingExpectedQty and Unit Price, discount and WorstCsPct.  */  
   DocWorstCsRevenue:number,
   Rpt1WorstCsRevenue:number,
   Rpt2WorstCsRevenue:number,
   Rpt3WorstCsRevenue:number,
      /**  Best case revenue for this line.  Calculated from SellingExpectedQty and Unit Price, discount and BestCsPct.  */  
   BestCsRevenue:number,
      /**  Best case revenue for this line in customer currency.  Calculated from SellingExpectedQty and Unit Price, discount and BestCsPct.  */  
   DocBestCsRevenue:number,
   Rpt1BestCsRevenue:number,
   Rpt2BestCsRevenue:number,
   Rpt3BestCsRevenue:number,
      /**  The original material sequence of this kit component under the kit parent part.  */  
   KitCompOrigSeq:number,
      /**  The original kit component part number prior to processing any configurator rule programs  */  
   KitCompOrigPart:string,
      /**  If TRUE then this field will mean that the smart string has already been processed  */  
   SmartStringProcessed:boolean,
      /**  Original smart string passed in for configuration  */  
   SmartString:string,
      /**  Used to differentiate between standard lines which are for parts "PART"  and lines for service contracts "CONTRACT".  */  
   LineType:string,
      /**  Contract Number of the related Service Contract when the LineType field is "CONTRACT"  */  
   ContractNum:number,
      /**  A unique code that identifies the Service Contract when the Line Type is "CONTRACT"  */  
   ContractCode:string,
   DiscBreakListCode:string,
      /**  Contract renewal number. If the value is zero then the contract is not for a renewal.  */  
   RenewalNbr:number,
   DiscListPrice:number,
      /**  The demand contract this demand is for.  */  
   DemandContractNum:number,
   OverrideDiscPriceList:boolean,
      /**  Demand Contract Line  */  
   DemandContractLine:number,
      /**  Demand Header sequence number to which this record is related.  */  
   DemandHedSeq:number,
      /**  Demand Detail Sequence number to which this record is related.  */  
   DemandDtlSeq:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  The line number of the detail record on the inter-company purchase order.  This number uniquely identifies the record within the Purchase Order number.  The number not directly maintainable, it's assigned by the system when records are created. The user references this item during PO receipt process.  */  
   ICPOLine:number,
      /**  Inter-Company Purchase order number  that the detail line item is linked to.  */  
   ICPONum:number,
      /**  Indicates if this quote line is linked to an inter-company PO line.  */  
   Linked:boolean,
      /**  Indicates if the price of the quote line can be changed.  */  
   LockPrice:boolean,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the quote quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   LockQty:boolean,
      /**  Indicates that the line item was closed before any shipments were made against it.  */  
   VoidLine:boolean,
      /**  Indicate that the item or the product group has a warranty.  */  
   Warranty:boolean,
      /**  Unique code for the Warranty that ties this record to a type of warranty.  Found on either the Part or ProdGrup table.  */  
   WarrantyCode:string,
      /**  Editor widget for Warranty comments.  */  
   WarrantyComment:string,
      /**  GroupSeq  */  
   GroupSeq:number,
      /**  EstimateGUID  */  
   EstimateGUID:string,
      /**  RFQCurrBaseEst  */  
   RFQCurrBaseEst:string,
      /**  RFQTemplate  */  
   RFQTemplate:string,
      /**  CreateEstimate  */  
   CreateEstimate:boolean,
      /**  Rating  */  
   Rating:string,
      /**  EstimateUserID  */  
   EstimateUserID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Indicates the record is used with Machine MES  */  
   ExternalMES:boolean,
      /**  NeedByDate  */  
   NeedByDate:string,
      /**  Indicates the way in which parts are made for Co-Part jobs.  There are two value S  Sequential and C  Concurrent.  Sequential is the default. This field is similar to the JobHead.ProcessMode field.  */  
   ProcessMode:string,
      /**  ECC Quote Number  */  
   ECCQuoteNum:string,
      /**  ECC Quote Line  */  
   ECCQuoteLine:number,
      /**  ECC Comment Ref  */  
   ECCCmmtRef:string,
      /**  ECCComment  */  
   ECCComment:string,
      /**  ContractID  */  
   ContractID:string,
      /**  PCLinkRemoved  */  
   PCLinkRemoved:boolean,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**  Total tax in base currency. Tax detail for the line.  */  
   Tax:number,
      /**  Total tax in base currency. Tax detail for the line.  */  
   DocTax:number,
      /**  Total tax in base currency. Tax detail for the line.  */  
   Rpt1Tax:number,
      /**  Total tax in base currency. Tax detail for the line.  */  
   Rpt2Tax:number,
      /**  Total tax in base currency. Tax detail for the line.  */  
   Rpt3Tax:number,
      /**  If true, the QuoteDtlTax records tied to this release are calculated using Tax Connect logic. If  false, taxes are calculated using the standard calc methods.  */  
   TaxConnectCalc:boolean,
      /**  Indicates if no tax recalculation by the system is supposed to be done.  */  
   NoTaxRecalc:boolean,
      /**  Total Quote Self Assessed Taxes for the Quote Line  */  
   TotalSATax:number,
      /**  Total Quote Self Assessed Taxes for the Quote Line  */  
   DocTotalSATax:number,
      /**  Total Quote Self Assessed Taxes for the Quote Line  */  
   Rpt1TotalSATax:number,
      /**  Total Quote Self Assessed Taxes for the Quote Line  */  
   Rpt2TotalSATax:number,
      /**  Total Quote Self Assessed Taxes for the Quote Line  */  
   Rpt3TotalSATax:number,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  This field holds the id of this quote line in the External CRM  */  
   ExternalCRMQuoteLineID:string,
      /**  Type for returns: Blank, (C)redit or (S)tandard  */  
   ReturnLineType:string,
      /**  Base price before any price breaks and discounts  */  
   MSRP:number,
      /**  Same as MSRP except that this field contains the price in the customer currency converted using the exchange rate on QuoteHed.  */  
   DocMSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency converted..  */  
   Rpt1MSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency converted..  */  
   Rpt2MSRP:number,
      /**  Same as MSRP except that this field contains the price in a report currency converted..  */  
   Rpt3MSRP:number,
      /**  Distributor end customer price.  */  
   EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in the customer currency converted using the exchange rate on QuoteHed.  */  
   DocEndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency converted.  */  
   Rpt1EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency converted.  */  
   Rpt2EndCustomerPrice:number,
      /**  Same as end customer price except that this field contains the price in a report currency converted.  */  
   Rpt3EndCustomerPrice:number,
      /**  Mark For Customer Number. This along with Mark For ShipToNum provides the foreign key field to a given ShipTo.  */  
   MFCustNum:number,
      /**  Mark For ShipToNum  */  
   MFShipToNum:string,
      /**  Indicates that the One Time Mark For information defined for this record should be used.  */  
   UseOTMF:boolean,
      /**  One Time Mark For Contact Name  */  
   OTMFName:string,
      /**  One Time Mark For first line of the ShipTo address.  */  
   OTMFAddress1:string,
      /**  One Time Mark For second line of the ShipTo address.  */  
   OTMFAddress2:string,
      /**  One Time Mark For third line of the ShipTo address.  */  
   OTMFAddress3:string,
      /**  City portion of the One Time Mark For address.  */  
   OTMFCity:string,
      /**  The state or province portion of the One Time Mark For address.  */  
   OTMFState:string,
      /**  The zip or postal code portion of the One Time Mark For address.  */  
   OTMFZIP:string,
      /**  One Time Mark For Contact Name  */  
   OTMFContact:string,
      /**  Fax number for the One Time Mark For.  */  
   OTMFFaxNum:string,
      /**  Phone number for the One Time Mark For  */  
   OTMFPhoneNum:string,
      /**  Country number for the One Time Mark For  */  
   OTMFCountryNum:number,
      /**  Promotional Price offered to Dealer and Distributors  */  
   PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in the customer currency converted using the exchange rate on QuoteHed.  */  
   DocPromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on QuoteHed.  */  
   Rpt1PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on QuoteHed.  */  
   Rpt2PromotionalPrice:number,
      /**  Same as Promotional Price except that this field contains the price in a report currency converted using the exchange rate on QuoteHed.  */  
   Rpt3PromotionalPrice:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  Used specifically for Deal Portal and Location Inventory, not for Inventory Tracked Attributes.  */  
   AttributeSetID:number,
      /**  The unique identifier of the related CPQ Configured Quote Product.  */  
   KBConfigProdID:number,
      /**  The unique identifier of the related original CPQ Configured Quote Product.  */  
   KBOriginalConfigProdID:number,
      /**  Currency.CurrSymbol for BASE  */  
   BaseCurrSymbol:string,
   BaseExtPrice:number,
   BaseMiscAmt:number,
   BasePotential:number,
      /**  If yes, then a new non-standard part was added with no description and validation needs to be run again  */  
   CheckPartDescription:boolean,
      /**  PLM Flag  */  
   CodePLM:boolean,
      /**  Valid values are "win" "lose" "next" "next" is the default  */  
   Conclusion:string,
   ConfigType:string,
      /**  Indicates whether the part is/can be configured  */  
   Configured:string,
      /**  Currency Code of the related record  */  
   CurrencyCode:string,
   CurrencySwitch:boolean,
      /**  Currency.CurrSymbol from QuoteHed  */  
   CurrSymbol:string,
      /**  Date that the quoter considered the quoting process for this quote complete.  */  
   DateQuoted:string,
      /**  Indicates if the discount fields should be disabled for the current quote line detail.  */  
   DisableDiscounts:boolean,
      /**  Display a Document  flat discount amount for the line item. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   DocDspDiscount:number,
      /**  Display Document unit price based on the expected quantity.  */  
   DocDspExpUnitPrice:number,
   DocExtPrice:number,
   DocMiscAmt:number,
   DocOrderUnitPrice:number,
   DocPotential:number,
   DocTotalPrice:number,
      /**   Total Quote which includes the total sum of potential, misc charges and taxas.
TotalQuote = Potential + Misc Charges + Tax  */  
   DocTotalQuote:number,
      /**  Total Withholding Tax amount for the Quote Line  */  
   DocTotalWHTax:number,
      /**  Display a  flat discount amount for the line item. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   DspDiscount:number,
      /**  Used to displayed UOM for expected quantity for detail line  */  
   DspExpectedUM:string,
   EnableRenewalNbr:boolean,
      /**  The date when this quote expires.  */  
   ExpirationDate:string,
      /**  Indicates whether the part has at least one Complement  */  
   HasComplement:boolean,
   HasCoParts:boolean,
      /**  Indicates if this Quote line has an associated credit memo (only for dealer portal)  */  
   HasCreditMemo:boolean,
      /**  Indicates whether the part has at least one Downgrade  */  
   HasDowngrade:boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   HasSubstitute:boolean,
      /**  Indicates whether the part has at least one Upgrade  */  
   HasUpgrade:boolean,
      /**  If Kit Flag = P then sets this field to the value of the related PartPlant.KitAllowChangeParms. If KitFlag <> P then this will be FALSE.  */  
   KitChangeParms:boolean,
      /**  Will be set to true if the current OrderDtl record is KitFlag = 'C' and the KitParent of this record is KitAllowUpdate = NO  */  
   KitDisable:boolean,
      /**  The description for Kit Flag. "P" = Parent, "C" = Component.  */  
   KitFlagDescription:string,
   KitOrderQtyUOM:string,
   LineStatus:string,
      /**  Contains the Mark For Address  */  
   MarkForAddrList:string,
   MFCustID:string,
   OrderUM:string,
   OrderUnitPrice:number,
      /**  If yes, the line will be copied to the Order  */  
   OrderWorthy:boolean,
      /**  Internal flag to identify if the Part is an Inventory Part.  */  
   PartExists:boolean,
      /**  This is an optional field used to enter the customers Purchase Order Number.  */  
   PONum:string,
   QtyBearing:boolean,
   QuantityToOrder:number,
      /**  Indicates whether to Refresh the QuoteQty table  */  
   RefreshQty:boolean,
      /**  The flag to indicate if the logic should delete quote line related manually added and manual taxes if the user populates Tax Exempt field previously blank  */  
   RemoveManAdTax:boolean,
   Rpt1BaseExtPrice:number,
   Rpt1BaseMiscAmt:number,
   Rpt1BasePotential:number,
      /**  Display a  flat discount amount for the line item. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt1DspDiscount:number,
      /**  Display unit price based on the expected quantity.  */  
   Rpt1DspExpUnitPrice:number,
   Rpt1OrderUnitPrice:number,
   Rpt1TotalPrice:number,
      /**   Total Quote which includes the total sum of potential, misc charges and taxas.
TotalQuote = Potential + Misc Charges + Tax  */  
   Rpt1TotalQuote:number,
      /**  Total Withholding Tax Amount for the Quote Line  */  
   Rpt1TotalWHTax:number,
   Rpt2BaseExtPrice:number,
   Rpt2BaseMiscAmt:number,
   Rpt2BasePotential:number,
      /**  Display a  flat discount amount for the line item. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt2DspDiscount:number,
      /**  Display unit price based on the expected quantity.  */  
   Rpt2DspExpUnitPrice:number,
   Rpt2OrderUnitPrice:number,
   Rpt2TotalPrice:number,
      /**   Total Quote which includes the total sum of potential, misc charges and taxas.
TotalQuote = Potential + Misc Charges + Tax  */  
   Rpt2TotalQuote:number,
      /**  Total Withholding Tax Amount for the Quote Line  */  
   Rpt2TotalWHTax:number,
   Rpt3BaseExtPrice:number,
   Rpt3BaseMiscAmt:number,
   Rpt3BasePotential:number,
      /**  Display a  flat discount amount for the line item. It can be left zero. This is calculated using the QuoteDtl.DiscountPercent * (QuoteQty * UnitPrice). This field can also be directly updated by the user, However it is refreshed whenever the DiscountPercent, UnitPrice or OrderQty fields are changed.  */  
   Rpt3DspDiscount:number,
      /**  Display unit price based on the expected quantity.  */  
   Rpt3DspExpUnitPrice:number,
   Rpt3OrderUnitPrice:number,
   Rpt3TotalPrice:number,
      /**   Total Quote which includes the total sum of potential, misc charges and taxas.
TotalQuote = Potential + Misc Charges + Tax  */  
   Rpt3TotalQuote:number,
      /**  Total Withholding Tax Amount for the Quote Line  */  
   Rpt3TotalWHTax:number,
      /**  Selected row  */  
   Selected:boolean,
   ShipByDate:string,
   TotalPrice:number,
      /**   Total Quote which includes the total sum of potential, misc charges and taxas.
TotalQuote = Potential + Misc Charges + Tax  */  
   TotalQuote:number,
      /**  Total Withholding Tax amount for the Quote Line  */  
   TotalWHTax:number,
      /**   Indicates that a QuoteAsm.QtyPer field was updated with out updating the RequiredQty field on the sub tables.
*** FUTURE USE  */  
   UpdateReq:boolean,
      /**  Indicates that the Quote should be used as the BOM when creating a job for the linked order  */  
   UseQuoteBOM:boolean,
      /**  Delimited list of Available Price Lists  */  
   AvailPriceLists:string,
      /**  Display unit price based on the expected quantity.  */  
   DspExpUnitPrice:number,
   ECCLineCRQ:number,
      /**  Allow enable/disable for the Dynamic Attributes button on a Quote Line  */  
   EnableDynAttrButton:boolean,
      /**  Flag indicating whether to enable CodePLM or not  */  
   EnablePLM:boolean,
   MarkForAddressFormatted:string,
   InventoryAttributeSetID:number,
      /**  The amount of discount for display  */  
   LessDiscount:number,
      /**  The amount of discount for display in Doc currency  */  
   DocLessDiscount:number,
      /**  The amount of discount for display in reporting currency  */  
   Rpt1LessDiscount:number,
      /**  The amount of discount for display in reporting currency  */  
   Rpt2LessDiscount:number,
      /**  The amount of discount for display in reporting currency  */  
   Rpt3LessDiscount:number,
      /**   This flag indicates if taxes can be modified by user:
True: Taxes are from Tax Engine (Vantage). They can be adjusted/deleted.
False: Taxes are from TaxConnect. They cannot be adjusted/deleted.
AllowTaxCodeUpd depends on TaxConnectCalc value. If TaxConnectCalc is True, AllowTaxCodeUpd will be False. Otherwise, it will be True.  */  
   AllowTaxCodeUpd:boolean,
   BitFlag:number,
   AnalysisCdDescription:string,
   CustomerBTName:string,
   CustomerName:string,
   CustomerCustID:string,
   DiscBreakListCodeListDescription:string,
   DiscBreakListCodeEndDate:string,
   DiscBreakListCodeStartDate:string,
   MFShipToNumInactive:boolean,
   OTMFCountryDescription:string,
   PartNumDefaultAttributeSetID:number,
   PartNumAttrClassID:string,
   PartNumTrackInventoryAttributes:boolean,
   PartNumPricePerCode:string,
   PartNumSalesUM:string,
   PartNumTrackLots:boolean,
   PartNumSellingFactor:number,
   PartNumTrackSerialNum:boolean,
   PartNumTrackDimension:boolean,
   PartNumPartDescription:string,
   PartNumIUM:string,
   PriceBreakListDescription:string,
   PriceGroupDescription:string,
   ProdCodeDescription:string,
   QuoteNumInPrice:boolean,
   QuoteNumCurrencyCode:string,
   SalesCatIDDescription:string,
   TaxCatIDDescription:string,
   TaxRegionDescription:string,
   TaxRegionTaxConnectCalc:boolean,
   TerritoryIDTerritoryDesc:string,
   WarrantyCodeWarrDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_QuoteHedRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Quote number is an integer which is used to uniquely identify a quote within the system.  This is automatically assigned by the system when the user requests to create a new quote. To create a new quote the user either takes an "add" option or leaves the Quote Number fill-in zero. The system generates a number by finding the quote number of the last record on file and then a 1 to it. It then uses the greater of Last quote number + 1 or the EQSyst.StartQuoteNum.  */  
   QuoteNum:number,
      /**  Contains the internal Customer number that the links the quote to the customer master. This is not directly entered by the user. Instead the CustID is entered which provides the CustNum from the customer master. The quote must reference a valid Customer master.  */  
   CustNum:number,
      /**  Date that quote was created in the system. Not user maintainable. Set equal to the system date when record was created.  */  
   EntryDate:string,
      /**  Contains the key  value for the Purchasing Contact. This can be blank or it must be valid in the CUSTCNT  table. Use the CUSTOMER.PRIMPCON as the default.  */  
   PrcConNum:number,
      /**  Contains comments about the overall Quote. These will be printed on the Quote form.  */  
   QuoteComment:string,
      /**  Date that quoted needs to be quoted by.  Defaulted as Today + EQSyst.DueDays. This will be used to browse unquoted quotes in order by when they need to get quoted. Like a work queue for the quoters.  */  
   DueDate:string,
      /**  Indicates if the quote has been quoted.  That is, the details have been entered, prices have been determined and is ready to be sent to the customer.  The quoter considers this quote complete.  Toggling this field also sets the DateQuoted equal to the current system date.  */  
   Quoted:boolean,
      /**  Date that the quoter considered the quoting process for this quote complete. This field is not accessible until Quoted = Yes. At which time this gets defaulted to system date. It is overrideable. A change to this field triggers a refresh to ExpirationDate.  */  
   DateQuoted:string,
      /**   The date when this quote expires. This field is not maintainable until the quote is marked as Quoted = Yes. At which time the DateQuoted is generated and then the ExpirationDate is set to DateQuoted + EQSyst.ExpirationDays.

This date is also used as part of the quote purging criteria testing.  */  
   ExpirationDate:string,
      /**  Date that this quote should be followed up with the prospect by. This can be left blank.  When the quote is completed (i.e. Quoted = TRUE) this field is defaulted to DateQuoted + EQSyst.FollowUpDays and is user overrideable.  If EQSyst.FollowUpDays = Zero(0) then no default is generated.  */  
   FollowUpDate:string,
      /**  A reference field that could be used to enter the customer RFQ # or any other piece of useful information.  */  
   Reference:string,
      /**   Optional Quote check off # 1. The label for this field is found in EQSyst. If the label field is blank then field should be invisible.
These "check offs" could be used for selecting quotes. An example would be a "Engineering" or "Purchasing" check off.  */  
   CheckOff1:boolean,
      /**  Optional check off # 2.  */  
   CheckOff2:boolean,
      /**  Optional check off # 3.  */  
   CheckOff3:boolean,
      /**  Optional check off # 4.  */  
   CheckOff4:boolean,
      /**  Optional check off # 5.  */  
   CheckOff5:boolean,
      /**  Indicates if the Quote has expired.  A quote is expired when QuoteHed.ExpirationDate < Today.  Each time a user logs on the system does a quick check for any unexpired quotes that have an expiration date < Today and sets them as expired. This field is also set during the QuoteHed write trigger.  */  
   Expired:boolean,
      /**  System maintained flag - set to yes when the quote follow up alert has been sent.  */  
   FlwAlrtSnt:boolean,
      /**  System maintained flag - set to yes when the quote due date alert has been sent.  */  
   DueAlrtSnt:boolean,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**   Exchange rate that will be used for this order.  Defaults from
CurrRate.CurrentRate. Conversion rates will be calculated as System Base = Foreign value * rate, Foreign value = system base * (1/rate). This is the dollar in foreign currency from the exchange rate tables in the newspapers.  */  
   ExchangeRate:number,
      /**  A = High, Z = Low  */  
   LeadRating:string,
      /**  Link to the territory Id for this LOQ  */  
   TerritoryID:string,
      /**  Link to Task set  */  
   TaskSetID:string,
      /**   Describe the type of Quote this is.
LEAD = Lead
OPPO = Opportunity
QUOT = Quote  */  
   CurrentStage:string,
      /**  Link to the parent Quote.  This Quote is a for the same job as the parent but for a different customer.  This quotes revenues estimates won't be included in the sales managers figures.  */  
   ParentQuoteNum:number,
      /**  The Currently active Stage changing task  */  
   ActiveTaskID:string,
      /**  The Last Complete Milestone task  */  
   LastTaskID:string,
      /**  The date this quote is expected to close.  */  
   ExpectedClose:string,
      /**  Indicates the Type of reason for closing this quote.   "W" Win CRM "L" - Loss CRM, "T" Task CRM.  */  
   ReasonType:string,
      /**  Select from list of Win or loss reason codes depending on the setting if the conclusion field  */  
   ReasonCode:string,
      /**  Allows Sales Rep to enter a percentage to factor the calculated revenue potential  */  
   ConfidencePct:number,
      /**  Used to establish a discount percent value which will be used as a default during Quote line entry. It can be left as zero.  Use the CUSTOMER.DISCOUNTPERCENT field as a default. Refreshed whenever QUOTEHED.CUSTOMER field changes.  */  
   DiscountPercent:number,
      /**  Indicates which customer ship to is to be used as the default for the Order release record created from this Quote. It  can be blank or it must be valid in the SHIPTO table. Use the CUSTOMER.SHIPTONUM as the default on new Quotes or when the QuoteHED.CUSTNUM is changed.  */  
   ShipToNum:string,
      /**  Establishes the Shipping Contact to be used as default on the Order release record created from this Quote. Contains the key value for the shipping contact in the CUSTCNT table. Can be blank or must be valid in the CUSTCNT table. Use the Customer.PrimScon as a default.  */  
   ShpConNum:number,
      /**  This quote is no longer updatable.  */  
   QuoteClosed:boolean,
      /**  The date that the Quote was closed.  */  
   ClosedDate:string,
      /**  Contains the key value of the record in the "SHIPVIA" table. It can be left blank or must be valid in the 'SHIPTO"  table. Use the CUSTOMER.SHIPVIA as the default when the CUSTNUM field is changed and the SHIPTO is blank. Use SHIPTO.SHIPVIA when CUSTNUM or SHIPTO fields are changed and the SHIPTO is not blank.  */  
   ShipViaCode:string,
      /**  Link to the Marketing Campaign related to this Quote.  */  
   MktgCampaignID:string,
      /**  Link to the marketing event associated with this record.  */  
   MktgEvntSeq:number,
      /**  CallType code from the CallType table.  Identifies what type of communication this is. For example email, phone, visit, etc.  */  
   CallTypeCode:string,
      /**  This is an optional field used to enter the customers Purchase Order Number.  */  
   PONum:string,
      /**   Contains the key value of the record in the TERMS table which indicates the sales terms established for this Opportunity/Quote. On change of QutoeHED.CUSTNUM use the CUSTOMER.TERMS
field as the default.  */  
   TermsCode:string,
      /**  Indicates that the one or more detail line items have been ordered on this quote. Note: This can be set via 3 methods. 1 - When the task is marked as a win and order is created, 2 - Via the Order Entry Get function, 2 - Via the Order Entry Add from Quote Line function.  */  
   Ordered:boolean,
      /**  Indicates if order based discounting needs to be applied to the quote.  */  
   ApplyOrderBasedDisc:boolean,
      /**  Indicates if order based discounting should be applied automatically or manually triggered by user as menu option.  */  
   AutoOrderBasedDisc:boolean,
      /**  The help desk case that created this quote.  */  
   HDCaseNum:number,
      /**  Bill To Customer Number  */  
   BTCustNum:number,
      /**  When checked the exchange rate defaults the currency's exchanged reate, but the user can change it. When not checked the exchange rate defaults the currecy's exchange rate, and the field is disabled  */  
   LockRate:boolean,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  This flag will be used to indicate if the Quote is ready for calculations. When set to true, tax calculations will take place whenever a save takes place for any tables tied to the quote which could affect taxes (QuoteDtl, QuoteHed, QuoteMsc, etc). It defaults from EQSyst.QuoReadyToCalcDflt field when an order is created.  */  
   ReadyToCalc:boolean,
      /**  This field is used to store a code that represents the external system that the Quote is being exported to (ex. PDM).  This field is short lived, it is used to instruct the write trigger logic to create IM records for certain types of external systems.  After creating the IM records, the trigger logic should immediately clear the field.  */  
   ExportRequested:string,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   Rounding:number,
      /**  Rounding is occurred if multiplier or rule for Total amount is different with multiplier or rule for Total line amount, it is included in the 'Amount to Pay' and it is booked to the rounding account specified in the company setup when the invoice is posted  */  
   DocRounding:number,
      /**  Reporting currency value of this field  */  
   Rpt1Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt2Rounding:number,
      /**  Reporting currency value of this field  */  
   Rpt3Rounding:number,
      /**  Unique identifier  */  
   RateGrpCode:string,
      /**  Total quote Amount. This field is an accumulation of the extended net amounts of the detail line items.  */  
   QuoteAmt:number,
      /**  Total quote Amount in customer currency. This field is an accumulation of the extended net amounts of the detail line items and rounded according to the Doc currency Round rule  */  
   DocQuoteAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt1QuoteAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt2QuoteAmt:number,
      /**  Reporting currency value of this field  */  
   Rpt3QuoteAmt:number,
      /**   Indicates if the One Time Shipto information is to be used.
Note: This can only be true when if the OTSName is not blank. 
UI disables this when Customer.AllowQTS = False,  */  
   UseOTS:boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   OTSName:string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   OTSAddress1:string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   OTSAddress2:string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   OTSAddress3:string,
      /**  City portion of the One Time Shipto  address.  */  
   OTSCity:string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   OTSState:string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   OTSZIP:string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   OTSResaleID:string,
      /**  Contains the TaxRgn.TaxRegionCode value of the One Time ShipTo tax region for purposes of Sales Tax calculations.  */  
   OTSTaxRegionCode:string,
      /**  One Time Ship To Contact Name  */  
   OTSContact:string,
      /**  Fax number for the One Time ShipTo.  */  
   OTSFaxNum:string,
      /**  Phone number for the One Time ShipTo  */  
   OTSPhoneNum:string,
      /**  One Time Shipping Country Number  */  
   OTSCountryNum:number,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  Indicates that the tax is included in the unit price  */  
   InPrice:boolean,
      /**  Allows Sales Rep to enter a percentage to factor the calculated revenue potential (worst case) for the quote line.  */  
   WorstCsPct:number,
      /**  Allows Sales Rep to enter a percentage to factor the calculated revenue potential (best case) for the quote line.  */  
   BestCsPct:number,
      /**  The demand contract this demand is for.  */  
   DemandContractNum:number,
      /**  Demand Header sequence number to which this record is related.  */  
   DemandHeadSeq:number,
      /**  Defines if this document is marked as EDI Ready.  */  
   EDIReady:boolean,
      /**  Quote created from EDI interfaced module.  */  
   EDIQuote:boolean,
      /**  Updated from EDI module this type of document is created.  */  
   EDIAck:boolean,
      /**  Incremented whenever an outbound quote document is generated from the quote i.e. Response to Request For Quotes, etc.  */  
   OutboundQuoteDocCtr:number,
      /**  Date in which the related demand was last processed.  */  
   DemandProcessDate:string,
      /**  System Time when demand was last processed.  */  
   DemandProcessTime:number,
      /**  EDI Transaction Control Number  */  
   LastTCtrlNum:string,
      /**  EDI Batch Control Number  */  
   LastBatchNum:string,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**   Total Quote Self Assessed Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   DocTotalSATax:number,
      /**   Total Quote Invoice Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   DocTotalTax:number,
      /**   Total Quote Withholding Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   DocTotalWHTax:number,
      /**   Total Quote Self Assessed Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt1TotalSATax:number,
      /**   Total Quote Invoice Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax +TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt1TotalTax:number,
      /**   Total Quote Withholding Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt1TotalWHTax:number,
      /**   Total Quote Self Assessed Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt2TotalSATax:number,
      /**   Total Quote Invoice TaxesQuote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt2TotalTax:number,
      /**   Total Order Withholding Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt2TotalWHTax:number,
      /**   Total Quote Withholding Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt3TotalSATax:number,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**   Total Quote Invoice Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt3TotalTax:number,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**   Total Quote Withholding Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   Rpt3TotalWHTax:number,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Tax Point  */  
   TaxPoint:string,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Date Used to calculate Tax Rates  */  
   TaxRateDate:string,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Unique identifier of the Tax Region assigned by the user.  */  
   TaxRegionCode:string,
      /**  Freight charges will not be returned if 'yes'  */  
   DropShip:boolean,
      /**   Quote Total Self Assessed Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   TotalSATax:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**   Quote Total Invoice Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   TotalTax:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**   Quote Total Withholding Taxes
Quote Total = TotalCharges + TotalMisc - TotalDiscount + TotalTaxes + TotalWHTax + TotalSATax
Net Total = Quote Total - TotalComm  */  
   TotalWHTax:number,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Inter-Company Purchase order number that uniquely identifies the purchase order.  */  
   ICPONum:number,
      /**  Indicates if this quote header is linked to an inter-company PO header.  */  
   Linked:boolean,
      /**   increase/decrease when releases are changed.
When locked changes to releases does not change the quote quantity.
NOTE: This feature is not implemented with the initial 5.2 release. Intended to be available in a later patch.  */  
   LockQty:boolean,
      /**  Date customer needs the items on the order to arrive. This is used only as the default value for the NeedByDate when creating quote detail line items. This can be left blank.  */  
   NeedByDate:string,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  True if Customer or ShipTo record was created using the  OTS info.  */  
   OTSCustSaved:boolean,
      /**  Indicates if/how the OTS is saved. Valid values blank = None, C = Customer, P = Prospect, S = Suspect T = Ship To  */  
   OTSSaveAs:string,
      /**  CustID to be used if the OTS is used to create a customer record.  */  
   OTSSaveCustID:string,
      /**  Override Carrier Defaults.  If not checked then the Site values will be used  */  
   OverrideCarrier:boolean,
      /**  Override Service Options.  If not checked then the Site values will be used  */  
   OverrideService:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Date that the items need to be shipped by to meet the customers NeedByDate.  This can be left blank, it is only used to supply a default for QuoteDtl.RequestDate.  */  
   RequestDate:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Indicates that the Quote item was closed before any shipments were made against it.  */  
   VoidQuote:boolean,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Total discount percent.  */  
   TotalDiscPct:number,
      /**  The expected revenue, calculated with the confidence factor.  */  
   TotalExpected:number,
   TotalGrossValue:number,
   TotalMiscAmt:number,
   TotalPotential:number,
      /**  Worst case revenue, calculated with the worst case confidence factor.  */  
   TotalWorstCs:number,
      /**  Total best case revenue, calculated with the best case confidence factor.  */  
   DocTotalBestCs:number,
   DocTotalDiscount:number,
      /**  Total discount percent.  */  
   DocTotalDiscPct:number,
      /**  The expected revenue, calculated with the confidence factor.  */  
   DocTotalExpected:number,
   DocTotalGrossValue:number,
   DocTotalMiscAmt:number,
   DocTotalPotential:number,
      /**  Worst case revenue, calculated with the worst case confidence factor.  */  
   DocTotalWorstCs:number,
      /**  Total best case revenue, calculated with the best case confidence factor.  */  
   Rpt1TotalBestCs:number,
   Rpt1TotalDiscount:number,
      /**  Total discount percent.  */  
   Rpt1TotalDiscPct:number,
      /**  The expected revenue, calculated with the confidence factor.  */  
   Rpt1TotalExpected:number,
   Rpt1TotalGrossValue:number,
   Rpt1TotalMiscAmt:number,
   Rpt1TotalPotential:number,
      /**  Worst case revenue, calculated with the worst case confidence factor.  */  
   Rpt1TotalWorstCs:number,
      /**  Total best case revenue, calculated with the best case confidence factor.  */  
   Rpt2TotalBestCs:number,
   Rpt2TotalDiscount:number,
      /**  Total discount percent.  */  
   Rpt2TotalDiscPct:number,
      /**  The expected revenue, calculated with the confidence factor.  */  
   Rpt2TotalExpected:number,
   Rpt2TotalGrossValue:number,
   Rpt2TotalMiscAmt:number,
   Rpt2TotalPotential:number,
      /**  Worst case revenue, calculated with the worst case confidence factor.  */  
   Rpt2TotalWorstCs:number,
      /**  Total best case revenue, calculated with the best case confidence factor.  */  
   Rpt3TotalBestCs:number,
   Rpt3TotalDiscount:number,
      /**  Total discount percent.  */  
   Rpt3TotalDiscPct:number,
      /**  The expected revenue, calculated with the confidence factor.  */  
   Rpt3TotalExpected:number,
   Rpt3TotalGrossValue:number,
   Rpt3TotalMiscAmt:number,
   Rpt3TotalPotential:number,
      /**  Worst case revenue, calculated with the worst case confidence factor.  */  
   Rpt3TotalWorstCs:number,
      /**  Total best case revenue, calculated with the best case confidence factor.  */  
   TotalBestCs:number,
   TotalDiscount:number,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  LOQPrepressText  */  
   LOQPrepressText:string,
      /**  LOQNewPageOnQuoteLine  */  
   LOQNewPageOnQuoteLine:boolean,
      /**  LOQBookPCFinishing  */  
   LOQBookPCFinishing:boolean,
      /**  LOQBookPCPaper  */  
   LOQBookPCPaper:boolean,
      /**  LOQBookPCPress  */  
   LOQBookPCPress:boolean,
      /**  LOQBookPCPlates  */  
   LOQBookPCPlates:boolean,
      /**  LOQVariations  */  
   LOQVariations:boolean,
      /**  AEPLOQType  */  
   AEPLOQType:string,
      /**  LOQPrepressStyle  */  
   LOQPrepressStyle:string,
      /**  QuoteCSR  */  
   QuoteCSR:string,
      /**  DueHour  */  
   DueHour:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Quote was confirmed/rejected by ECC Web  */  
   ECCConfirmed:boolean,
      /**  Quote was confirmed/rejected by this ECC user  */  
   ECCConfirmedBy:string,
      /**  ECC quote message: RFQ or GQR  */  
   ECCMsgType:string,
      /**  Quote is ready to be approved by user via ECC web site.  */  
   ECCWebReady:boolean,
      /**  ECC Quote Number  */  
   ECCQuoteNum:string,
      /**  ECC Comment Reference Number  */  
   ECCCmmtRef:string,
      /**  ECCComment  */  
   ECCComment:string,
      /**  ECC Quote Status  */  
   ECCStatus:string,
      /**  ECC Expiration Date  */  
   ECCExpirationDate:string,
      /**  ECCCmmtRefSK  */  
   ECCCmmtRefSK:string,
      /**  This field defines if the Quote  is synchronized to an External CRM.  */  
   ExternalCRMQuote:boolean,
      /**  This field holds the  id of this quote in the External CRM  */  
   ExternalCRMQuoteID:string,
      /**  This field holds the sales order created in the External CRM. This id might not match an Epicor ERP Order id.  */  
   ExternalCRMOrderID:string,
      /**  Web Sales Rep ID  */  
   ECCSalesRepID:string,
      /**  Total tax in base currency. The sum of all the tax details for the quote.  */  
   Tax:number,
      /**  Total tax in base currency. The sum of all the tax details for the quote.  */  
   DocTax:number,
      /**  Total tax in base currency. The sum of all the tax details for the quote.  */  
   Rpt1Tax:number,
      /**  Total tax in base currency. The sum of all the tax details for the quote.  */  
   Rpt2Tax:number,
      /**  Total tax in base currency. The sum of all the tax details for the quote.  */  
   Rpt3Tax:number,
      /**  HdrTaxNoUpdt  */  
   HdrTaxNoUpdt:boolean,
      /**  This field defines the last time that the Quote has been Synchronized between Epicor ERP and the External CRM. This field is maintained by the External CRM Synchronization  process.  */  
   ExternalCRMLastSync:string,
      /**  This fields determines if the quotes needs to be synchronized to the External CRM. If there are changes in the quote or quote detail file, Epicor ERP automatically turns on this field.  */  
   ExternalCRMSyncRequired:boolean,
      /**  Total of claims credit lines  */  
   TotalClaimsCredit:number,
      /**  Total of claims credit lines in customer currency  */  
   DocTotalClaimsCredit:number,
      /**  Total of claims credit lines in report currency  */  
   Rpt1TotalClaimsCredit:number,
      /**  Total of claims credit lines in report currency  */  
   Rpt2TotalClaimsCredit:number,
      /**  Total of claims credit lines in report currency  */  
   Rpt3TotalClaimsCredit:number,
      /**  Total Quote claims credit Invoice Taxes.  */  
   TotalClaimsTax:number,
      /**  Total Quote claims credit Invoice Taxes in customer currency.  */  
   DocTotalClaimsTax:number,
      /**  Total Quote claims credit Invoice Taxes in report currency.  */  
   Rpt1TotalClaimsTax:number,
      /**  Total Quote claims credit Invoice Taxes in report currency.  */  
   Rpt2TotalClaimsTax:number,
      /**  Total Quote claims credit Invoice Taxes in report currency.  */  
   Rpt3TotalClaimsTax:number,
      /**  Total Quote claims credit Self Assessed Taxes.  */  
   TotalClaimsSATax:number,
      /**  Total Quote claims credit Self Assessed Taxes in customer currency.  */  
   DocTotalClaimsSATax:number,
      /**  Total Quote claims credit Self Assessed Taxes in customer currency.  */  
   Rpt1TotalClaimsSATax:number,
      /**  Total Quote claims credit Self Assessed Taxes in customer currency.  */  
   Rpt2TotalClaimsSATax:number,
      /**  Total Quote claims credit Self Assessed Taxes in customer currency.  */  
   Rpt3TotalClaimsSATax:number,
      /**  Total Quote claims credit Withholding Taxes.  */  
   TotalClaimsWHTax:number,
      /**  Total Quote claims credit Withholding Taxes in customer currency.  */  
   DocTotalClaimsWHTax:number,
      /**  Total Quote claims credit Withholding Taxes in report currency.  */  
   Rpt1TotalClaimsWHTax:number,
      /**  Total Quote claims credit Withholding Taxes in report currency.  */  
   Rpt2TotalClaimsWHTax:number,
      /**  Total Quote claims credit Withholding Taxes in report currency.  */  
   Rpt3TotalClaimsWHTax:number,
      /**  OTSTaxValidationStatus  */  
   OTSTaxValidationStatus:number,
      /**  OTSTaxValidationDate  */  
   OTSTaxValidationDate:string,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  Incoterm Code  */  
   IncotermCode:string,
      /**  Incoterm Location  */  
   IncotermLocation:string,
   AddrList:string,
   BaseCurrencyID:string,
      /**  Bill To Customer Name.  */  
   BTCustomerName:string,
      /**  Audit Log change description  */  
   ChangeDescription:string,
   CheckOffLabel1:string,
   CheckOffLabel2:string,
   CheckOffLabel3:string,
   CheckOffLabel4:string,
   CheckOffLabel5:string,
   Conclusion:string,
      /**  Primary Contact Name  */  
   ConName:string,
   CurrencySwitch:boolean,
      /**  Full Description of the CurrentStage field  */  
   CurrentStageDesc:string,
      /**  Value of the Customer.AllowOTS (customer allows one time shipment)  */  
   CustAllowOTS:boolean,
   CustOnCreditHold:boolean,
      /**  Number of days Quote has been open  */  
   DaysOpen:number,
      /**   Display the true discount percent of the quote. It's calculated by dividing the sum Discount Percent over Gross Value.
DiscountPercentCalc = (DocTotalDiscount / TotalGrossValue) *100  */  
   DiscountPercentCalc:number,
      /**  Total tax in Doc currency. The sum of all the tax details for the quote.  */  
   DocTaxAmt:number,
      /**   Quote total after including taxes.
TotalQuote = TotalPotential +  TotalMiscAmt + TaxAmt  */  
   DocTotalQuote:number,
      /**  Used for screen display. If SoldTo and Alt-Bill to are the same, this displays as null.  */  
   dspBTCustID:string,
   EmailAddress:string,
      /**  Indicates if it's okay to enable OrderBased Pricing  */  
   EnableOrderBasedDisc:boolean,
      /**   The expected revenue potential percentage of all lines.
ExpectedCsPct = (TotalExpected / TotalPotential) * 100  */  
   ExpectedCsPct:number,
   FaxNum:string,
   FOB:string,
   FOBDescription:string,
      /**  Used by IU to disabled Currency Code  */  
   HasQuoteLines:boolean,
      /**  EqSyst.LogChanges  */  
   LogChanges:boolean,
      /**  Order Date  */  
   OrderDate:string,
   OrderDiscount:number,
   OrderPONum:string,
   OrderShipVia:string,
   OrderTerms:string,
   OTSSaved:boolean,
   OTSShipToNum:string,
   PhoneNum:string,
   PreventQQChange:boolean,
      /**  Label for ExchangeRate  */  
   RateLabel:string,
   Rpt1TaxAmt:number,
      /**   Quote total after including taxes.
TotalQuote = TotalPotential +  TotalMiscAmt + TaxAmt  */  
   Rpt1TotalQuote:number,
   Rpt2TaxAmt:number,
      /**   Quote total after including taxes.
TotalQuote = TotalPotential +  TotalMiscAmt + TaxAmt  */  
   Rpt2TotalQuote:number,
   Rpt3TaxAmt:number,
      /**   Quote total after including taxes.
TotalQuote = TotalPotential +  TotalMiscAmt + TaxAmt  */  
   Rpt3TotalQuote:number,
   SalesRepCode:string,
   SalesRepName:string,
   ShipByDate:string,
   ShipToAddrList:string,
      /**  Total tax in base currency. The sum of all the tax details for the quote.  */  
   TaxAmt:number,
      /**   Quote total after including taxes.
TotalQuote = TotalPotential +  TotalMiscAmt + TaxAmt  */  
   TotalQuote:number,
      /**   Displays the calculated revenue potential percentage (worst case) for the quote line.
WorseCsPctCalc = (TotalWorstCs / TotalPotential) * 100  */  
   WorseCsPctCalc:number,
      /**  Delimited list of available bill to customers (CustID`CustomerName~CustID`CustomerName)  */  
   AvailBTCustList:string,
      /**  Currency.CurrSymbol for currency "BASE"  */  
   BaseCurrSymbol:string,
      /**   Displays the calculated revenue potential percentage (best case) for the quote line.
BestCsPctCalc = (TotalBestCs / TotalPotential) * 100  */  
   BestCsPctCalc:number,
      /**  Bill To Address List.  */  
   BTAddressList:string,
      /**  Customer ID of the bill to customer.  */  
   BTCustID:string,
      /**  Indicates if the order contains any credit type line  */  
   HasCreditLines:boolean,
      /**  Returns true if Customer.ECCType is B2C OR Dealer OR Distributor AND Customer.WebCustomer  */  
   IsValidECC:boolean,
      /**  Flag indicating whether to enable CaseNum or not  */  
   EnableHDCaseNum:boolean,
      /**  Indicates if the quote can be updated  */  
   UpdateAllowed:boolean,
      /**  Formatted address  */  
   AddressFormatted:string,
      /**  Ship To Address formatted  */  
   ShipToAddressFormatted:string,
      /**  Indicates if tax region is one of the field changes the user is asked about for propogating changes to lines  */  
   PromptTaxRegionCode:boolean,
      /**  Indicates a customer referenced on the quote is inactive.  */  
   InactiveCustomer:boolean,
      /**  Update primary contact on save of the quote header  */  
   UpdatePrimContact:boolean,
      /**  Flag indicating whether to enable Incoterm Location  */  
   EnableIncotermLocation:boolean,
   BitFlag:number,
   ActiveTaskTaskDescription:string,
   CurrencyDocumentDesc:string,
   CurrencyCurrencyID:string,
   CurrencyCurrName:string,
   CurrencyCurrDesc:string,
   CurrencyCurrSymbol:string,
   CurrencyBaseCurr:boolean,
   CustomerAllowShipTo3:boolean,
   CustomerBTName:string,
   CustomerCustID:string,
   CustomerName:string,
   CustomerCheckDuplicatePO:boolean,
   HDCaseDescription:string,
   IncotermsDescription:string,
   LastTaskTaskDescription:string,
   MktgCpgnCampDescription:string,
   MktgEventEvntDescription:string,
   OTSCountryNumISOCode:string,
   OTSCountryNumDescription:string,
   OTSCountryNumEUMember:boolean,
   OTSTaxRegionCodeDescription:string,
   RateGrpDescription:string,
   ReasonDescription:string,
   ResponseCallTypeDesc:string,
   ShipToBTName:string,
   ShipToCustID:string,
   ShipToName:string,
   ShipToNumName:string,
   ShipToNumInactive:boolean,
   ShipViaWebDesc:string,
   ShipViaDescription:string,
   ShipViaInactive:boolean,
   TaskSetTaskSetDescription:string,
   TaskSetWorkflowType:string,
   TaxRegionTaxConnectCalc:boolean,
   TaxRegionDescription:string,
   TermsDescription:string,
   TerritoryTerritoryDesc:string,
   XbSystCalcQuoteTax:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_RFQHeadRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates if the RFQ is open or closed. This is set automatically when all the RFQItem records have been closed or can be set if the user voids the RFQ.  This field is not directly maintainable.  */  
   OpenRFQ:boolean,
      /**  Number that uniquely identifies the RFQ document.  */  
   RFQNum:number,
      /**  Date that this RFQ was entered.  */  
   RFQDate:string,
      /**  The date the vendor responses are due.  */  
   RFQDueDate:string,
      /**  The ID that links to the Purchasing Agent master file.  */  
   BuyerID:string,
      /**  Contains comments about the RFQ. These will be printed on the RFQ document.  */  
   CommentText:string,
      /**  Indicates if the RFQ is to selected for printing during the Mass Print process.  */  
   ReadyToPrint:boolean,
      /**  Date the supplier is to respond by  */  
   RespondDate:string,
      /**  Date the PO is planned to be awarded  */  
   DecisionDate:string,
      /**  Indicates the Supplier will respond via Suppliers workbench  */  
   PostToWeb:boolean,
      /**  Date Buyer posted the RFQ  */  
   PostDate:string,
      /**  Global Company identifier.  Used in Consolidated Purchasing.  */  
   GlbCompany:string,
      /**  Global RFQ identifier.  Used in Consolidated Purchasing.  */  
   GlbRFQNum:number,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**  UOM Class ID  */  
   UOMClassID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   WebVendorExists:boolean,
   BitFlag:number,
   BuyerIDName:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_RFQItemRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates if this line item is Open/Closed.  Set to "Closed" as when there are no longer any open RFQDtl records. This can also be closed when the user voids the RFQItem.  */  
   OpenItem:boolean,
      /**  RFQ number  that the item is linked to.  */  
   RFQNum:number,
      /**  The line number of this detail record on the RFQ. This number uniquely identifies the record within the RFQ. The number is not directly maintainable, it's assigned by the system when records are created.  */  
   RFQLine:number,
      /**   Description of line item.
Defaults from JobOper, JobMtl or Part depending on the reference.  */  
   LineDesc:string,
      /**  Issue (our) unit of measure.  */  
   IUM:string,
      /**  OUR internal part number for this item.  */  
   PartNum:string,
      /**  OUR revision number of the OUR part.  An optional field. Defaults from the most current  PartRev.RevisionNum.  */  
   RevisionNum:string,
      /**  Contains comments about the item. These will be printed on the RFQ. Defaults from the Jobs Material Purchasing comments.  */  
   CommentText:string,
      /**  The foreign key to the PartClass file.  May be blank, if entered must be valid in PartClass file.  Defaulted from Part.ClassID. The PartClass is used in determining a default G/L expense account.  */  
   ClassID:string,
      /**  Related job number.  */  
   JobNum:string,
      /**  Related Customer QuoteNum.  */  
   QuoteNum:number,
      /**  The QuoteLine that record is related to.  */  
   QuoteLine:number,
      /**  Mtl = Material, Sub = Subcontract  */  
   ItemType:string,
      /**   Operation Code - used to identify specific subcontracting operation that is needs to be quoted.
This field can be blank (raw materials) or must be valid in the OpMaster (subcontracts service).  */  
   OpCode:string,
      /**  Assembly sequence number that this rfq is associated with.  */  
   AssemblySeq:number,
      /**  Job Seq of the requirement. Not maintainable.  */  
   JobSeq:number,
      /**  The number of vendor quotes that are required for this rfq line.  */  
   RFQVendQuotes:number,
      /**  Global Company identifier.  Used in Consolidated Purchasing.  */  
   GlbCompany:string,
      /**  Global RFQ identifier.  Used in Consolidated Purchasing.  */  
   GlbRFQNum:string,
      /**  Global RFQ Line identifier.  Used in Consolidated Purchasing.  */  
   GlbRFQLine:number,
      /**  Required Quantity from the source record (JobMtl/JobOper/QuoteMtl/QuoteOpr) used to create PORel.  Not user updatable.  */  
   RequiredQty:number,
      /**  Indicates if inspection is required when items are received.  Used when create PODetail records  */  
   RcvInspectionReq:boolean,
      /**  The warehouse that the material is allocated against.  */  
   WarehouseCode:string,
      /**  Number of quotes required as indicated by the source file  */  
   SrcVendQuotes:number,
      /**  Indicates if the Source file (JobMtl,QuoteMtl,...) is a valid source record  */  
   ValidSrc:boolean,
      /**  The Purchase Unit of Measure  */  
   PUM:string,
      /**  Used to capture the purchasing factor.  */  
   PurchasingFactor:number,
      /**  Indicates how Purchasing Factor is used in calculations.  If M (multiply), the Factor is multiplied, if  D (divide) the factor is divided.  */  
   PurchasingFactorDirection:string,
      /**  Displays the cause why the item is not compliant.  */  
   ComplianceMsg:string,
      /**  UOM Class ID  */  
   UOMClassID:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  Requisition number that the detail line is linked to.  */  
   ReqNum:number,
      /**  The line number of detail record on the requisition.  This number uniquely identifies the record within the Requisition number.  The number is not directly maintainable; it's assigned by the system when records are created.  */  
   ReqLine:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  Indicates if the item on the line is not compliant on its source.  */  
   NotCompliant:boolean,
   Source:string,
   BitFlag:number,
   AssemblySeqDescription:string,
   AttributeSetIDShortDescription:string,
   AttributeSetIDDescription:string,
   ClassDescription:string,
   JobNumPartDescription:string,
   OpCodeOpDesc:string,
   PartNumTrackInventoryAttributes:boolean,
   PartNumAttrClassID:string,
   PartNumTrackLots:boolean,
   PartNumPartDescription:string,
   PartNumSellingFactor:number,
   PartNumTrackDimension:boolean,
   PartNumIUM:string,
   PartNumPricePerCode:string,
   PartNumSalesUM:string,
   PartNumTrackSerialNum:boolean,
   PartNumTrackInventoryByRevision:boolean,
   QuoteLineLineDesc:string,
   QuoteNumCurrencyCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_RMADtlRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Mirror image of RMAHead.OpenRMA.  */  
   OpenRMA:boolean,
      /**  Indicates the Open/Closed status of the RMADtl.  This gets set to closed when there are no pending actions to be taken on related receipts.  */  
   OpenDtl:boolean,
      /**  Return Authorization Number. Used to relate RMADtl to RMAHead.  */  
   RMANum:number,
      /**  An integer that uniquely identifies a detail record within a Return Authorization document. Assigned by the system. Generated by reading last related RMADtl record and use its RALine 1.  */  
   RMALine:number,
      /**   The sales order number that the Return detail is related to.
Must be an order of the customer identified in the RMAHead.  When entered the OrderLine is then mandatory.  */  
   OrderNum:number,
      /**  Sales order line that the Return detail is related to.  If entered it must be valid in the OrderDtl file. If entered the OrderDtl supplies the Part Number, LineDesc, IUM . . .  */  
   OrderLine:number,
      /**  Reason code that links this return detail  to a Reason master record, which indicates why the item is being returned  and allows the system the ability to recap scrap by a code for analysis purposes. Uses Reason.ReasonType = "C" (customer returns) to find Reason master.  */  
   ReturnReasonCode:string,
      /**   Notes the about the RMA detail.
Used to key in customer comments, explanation of why item is returned, inspection results, Order/Mfg instructions, and perhaps information concerning Billing.  */  
   Note:string,
      /**  The user's Internal Part number used to identify line item part. It cannot  be blank. It does NOT have to valid in the Part master.  Defaulted from the OrderDtl if available.  */  
   PartNum:string,
      /**  Line Item description. Defaults for OrderDtl if available, else from  Part master if available.  */  
   LineDesc:string,
      /**  Optional field that contains the customers revision.  Default OrderDtl if available, else from finding the PartRev that is most current as of entry date.  */  
   RevisionNum:string,
      /**  Quantity that is to be returned  */  
   ReturnQty:number,
      /**  Unit Of Measure of the  ReturnQty.  */  
   ReturnQtyUOM:string,
      /**  Reference Invoice number used for finding Tax Category  */  
   RefInvoiceNum:number,
      /**  Reference invoice line - Used to obtain the correct tax category  */  
   RefInvoiceLine:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  The Ship to number of the related header contact.  */  
   ShipToNum:string,
      /**  The Contact Number of the related header contact  */  
   ConNum:number,
      /**  Contains the system internal customer number used to relate this record to the customer master.  */  
   CustNum:number,
      /**  The order release number that the RMA line was created from.  */  
   OrderRelNum:number,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  Reference AR Invoice Number  */  
   InvoiceNum:number,
      /**  Reference AR Invoice Line Number  */  
   InvoiceLine:number,
      /**  Job Number.  */  
   JobNum:string,
      /**  Assembly sequence number that this material is associated with.  */  
   AssemblySeq:number,
      /**  A sequence number that uniquely defines the Material (JobMtl) record within a specific Job/Assembly.  */  
   MtlSeq:number,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  ECC RMA Comment  */  
   ECCComment:string,
      /**  ECC RMA Num  */  
   ECCRMANum:string,
      /**  ECC RMA Line  */  
   ECCRMALine:number,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   AttributeSetID:number,
      /**  Number of pieces for this attribute set.  */  
   NumberOfPieces:number,
      /**  CNDeclarationBillLine  */  
   CNDeclarationBillLine:number,
      /**  Indicates that the line of the invoice has multiple packs consolidated. Details of the pack should be reviewied in InvcDtlPack table  */  
   ConsolidateLines:boolean,
      /**  Indicates that the invoice line has consolidated shipment lines that are related to the same release of the sales order  */  
   ConsolidateOneRelease:boolean,
   CustomerContactEMailAddress:string,
      /**  The full customer's name.  */  
   CustomerName:string,
      /**  The name for the ship to location.  */  
   CustomerShipToName:string,
      /**  From RMAHead.DebitMemoRef, used by Customer Tracker  */  
   DebitMemoRef:string,
      /**  If company parameter 'Allow Multiple Credit Invoices' is off and there is a least one credit memo then another credit memo adding is not allowed.  */  
   EnableAddCreditMemo:boolean,
   EnableDelete:boolean,
      /**  Flag to determine if Serial Numbers are required for this transaction.  */  
   EnableSN:boolean,
   EnableUpdate:boolean,
      /**  Determines if the RMA is synchronized with Epicor FSA application.  */  
   EpicorFSA:boolean,
      /**  Service Order number generated on FSA, stored on FSAExtData db table.  */  
   FSAServiceOrderNum:number,
      /**  Service Order Resource generated on FSA, stored on FSAExtData db table.  */  
   FSAServiceOrderResourceNum:number,
      /**  Serivce Type  */  
   FSAServiceType:string,
      /**  Technician  */  
   FSATechnician:string,
      /**  From RMAHead.HDCaseNum, used by Customer Tracker  */  
   HDCaseNum:number,
      /**  Unique identifier of related integration record.  */  
   IntExternalKey:string,
   LegalNumber:string,
   LocalizationFlag:string,
      /**  Set from RMAHead.RMADate, used by Customer Tracker  */  
   RMADate:string,
   RMARcptExists:boolean,
      /**  Customer Id of the third-party Ship To  */  
   ShipToCustID:string,
      /**  The name for the ship to location.  */  
   ShipToName:string,
   CustomerContactName:string,
      /**  The customer ID.  */  
   CustomerCustID:string,
   CNDeclarationBill:string,
   BitFlag:number,
   AttrValueSetDescription:string,
   AttrValueSetShortDescription:string,
   OrderNumCardMemberName:string,
   OrderNumCurrencyCode:string,
   PartNumAttrClassID:string,
   PartNumTrackInventoryByRevision:boolean,
   PartNumSellingFactor:number,
   PartNumPartDescription:string,
   PartNumIUM:string,
   PartNumPricePerCode:string,
   PartNumTrackDimension:boolean,
   PartNumTrackSerialNum:boolean,
   PartNumSalesUM:string,
   PartNumTrackLots:boolean,
   PartNumTrackInventoryAttributes:boolean,
   ReasonDescription:string,
   ReturnReasonCodeDescription:string,
   ShipToNumInactive:boolean,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_RMAHeadRow{
      /**  Indicates if this RA is in an "open" status.  The user can toggle the setting of this field in header maintenance. It is also set automatically as the details are "Closed/Opened".  If there are no RMADtl records, then it is still considered as "open".  */  
   OpenRMA:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  When creating a new Return Authorization the user is prompted for a Return number. If the field is zero , the next available # is assigned by the system. The system generates a number by finding the last CRAHead on file and uses its RANum + 1.  */  
   RMANum:number,
      /**  Date of the Return Material Authorization.  Default as System date.  */  
   RMADate:string,
      /**  Contains the system internal customer number used to relate this record to the customer master.  */  
   CustNum:number,
      /**  Reference to a customers accounts payable debit memo.  */  
   DebitMemoRef:string,
      /**  The Clientele call number that is related to this RMA.  */  
   CLCallNum:string,
      /**  Cross reference RMA number used when converting data from another ERP system when the previous system data has alphanumeric content.  This field is not used by MfgSys.  This field can be used in searches and can be added to screens through customization.  */  
   XRefRMANumber:string,
      /**  The help desk case that created this RMA.  */  
   HDCaseNum:number,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  The Ship to number of the related header contact.  */  
   ShipToNum:string,
      /**  The Contact Number of the related header contact  */  
   ConNum:number,
      /**  Field to use for the BAM to Auto-Print the Crystal Report or Bartender Labels associated to this table.  */  
   AutoPrintReady:boolean,
      /**  Bill To Customer Number  */  
   BTCustNum:number,
      /**   Indicates if the One Time Ship To info is to be used.
Note: This can only be true when if the OTSName is not blank. 
UI disables this when Customer.AllowQTS = False,  */  
   UseOTS:boolean,
      /**  One Time Shipto Name of the ShipTo.  */  
   OTSName:string,
      /**  One Time Shipto first line of the ShipTo address.  */  
   OTSAddress1:string,
      /**  One Time Shipto  second line of the ShipTo address.  */  
   OTSAddress2:string,
      /**  One Time Shipto  third line of the ShipTo address.  */  
   OTSAddress3:string,
      /**  City portion of the One Time Shipto  address.  */  
   OTSCity:string,
      /**  The state or province portion of the One Time Shipto  address.  */  
   OTSState:string,
      /**  The zip or postal code portion of the One Time ShipTo  address.  */  
   OTSZIP:string,
      /**  The State Tax Identification Number of the One Time Shipto.  */  
   OTSResaleID:string,
      /**  Contains the TaxRgn.TaxRegionCode value of the One Time ShipTo tax region for purposes of Sales Tax calculations.  */  
   OTSTaxRegionCode:string,
      /**  One Time Ship To Contact Name  */  
   OTSContact:string,
      /**  Fax number for the One Time ShipTo.  */  
   OTSFaxNum:string,
      /**  Phone number for the One Time ShipTo  */  
   OTSPhoneNum:string,
      /**  One Time Shipping Country Number  */  
   OTSCountryNum:number,
      /**  Ship To Customer Number. This along with ShipToNum provides the foreign key field to a given ShipTo. Normally this has the same value as the CustNum field. However, if the customer allows 3rd party shipto (Customer.AllowShipTo3) then this could be a different custnum.  */  
   ShipToCustNum:number,
      /**  Reference AR Invoice Number  */  
   InvoiceNum:number,
      /**  Transaction Document Type  */  
   TranDocTypeID:string,
      /**  The Legal Number of the record.  */  
   LegalNumber:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  The Return Invoice Number for the RMA (CSF - Turkey)  */  
   RetInvoiceNum:string,
      /**  ECC RMA Number  */  
   ECCRMANum:string,
      /**  Customer Web Reference to RMA.  */  
   ECCCustRef:string,
      /**  DocumentPrinted  */  
   DocumentPrinted:boolean,
      /**  Comments about the RMA overall  */  
   RMAComment:string,
      /**  Web Comments about the RMA overall  */  
   WebComment:string,
      /**  EpicorFSA  */  
   EpicorFSA:boolean,
      /**  Declaration Bill  */  
   CNDeclarationBill:string,
      /**  CNBonded  */  
   CNBonded:boolean,
      /**  Bil to customer name  */  
   BillToCustomerName:string,
      /**  Bill To Customer Name  */  
   BTCustName:string,
   CustomerContactEMailAddress:string,
   CustomerContactName:string,
      /**  Column to indicate if the customer set for the RMA is sync'd to FSA.  */  
   CustomerFSA:boolean,
   EnableDelete:boolean,
   EnableUpdate:boolean,
      /**  Column to indicate if the RMA was created on FSA.  */  
   FromFSA:boolean,
      /**  Web address list for the contact who initiated the RMA.  */  
   WebAddressList:string,
      /**  Delimited list of available bill to customers.  */  
   AvailBTCustList:string,
   BitFlag:number,
   BTCustNumInactive:boolean,
   CustomerName:string,
   CustomerCustID:string,
   CustomerBTName:string,
   CustomerInactive:boolean,
   HDCaseDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ReasonRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Indicates the Type of reason. Can be "S" - Scrap, "R" - Rework, "M" - Inventory Adjustments, "A" - RMA, "D" - DMR, "Q" - Quality Assurance "C" - Service Calls "W" Win CRM "L" - Loss CRM, "T" Task CRM, "H" - Part On Hold, "E" ECO Task, "H" HelpDesk, "C" Service Call, "U" Course Result, ""F" Field Service Contract.  */  
   ReasonType:string,
      /**  Descriptive code assigned by user which uniquely identifies a reason code master record.  Can't be blank. This is used as a foreign key in other files and may be used in displays/reports where space for the full description is limited.  */  
   ReasonCode:string,
      /**  Full description of Reason... used on displays/reports.  */  
   Description:string,
      /**  A flag which indicates if this is a valid reason to be used when rejecting an operaion when processing DMRs.  */  
   DMRRejOpr:boolean,
      /**  A flag which indicates if this is a valid reason to be used when rejecting material when processing DMRs.  */  
   DMRRejMtl:boolean,
      /**  A flag which indicates if this is a valid reason to be used when rejecting a subcontract operation when processing DMRs.  */  
   DMRRejSub:boolean,
      /**  A flag which indicates if this is a valid reason to be used when rejecting inventory when processing DMRs.  */  
   DMRRejInv:boolean,
      /**  A flag which indicates if this is a valid reason to be used when accepting an operaion when processing DMRs.  */  
   DMRAcceptOpr:boolean,
      /**  A flag which indicates if this is a valid reason to be used when accepting material when processing DMRs.  */  
   DMRAcceptMtl:boolean,
      /**  A flag which indicates if this is a valid reason to be used when accepting a subcontract operation when processing DMRs.  */  
   DMRAcceptSub:boolean,
      /**  A flag which indicates if this is a valid reason to be used when accepting inventory when processing DMRs.  */  
   DMRAcceptInv:boolean,
      /**  A flag which indicates if this is a valid reason to be used when failing an operaion during inspection processing.  */  
   InspFailOpr:boolean,
      /**  A flag which indicates if this is a valid reason to be used when failing a material during inspection processing.  */  
   InspFailMtl:boolean,
      /**  A flag which indicates if this is a valid reason to be used when failing a subcontract operation during inspection processing.  */  
   InspFailSub:boolean,
      /**  A flag which indicates if this is a valid reason to be used when failing an inventory item during inspection processing.  */  
   InspFailInv:boolean,
      /**  A flag which indicates if this is a valid reason to be used for scrap.  */  
   Scrap:boolean,
      /**  A flag which indicates if this is a valid reason to be used for Nonconformance processing of an operaion.  */  
   NonConfOpr:boolean,
      /**  A flag which indicates if this is a valid reason to be used for Nonconformance processing of a material.  */  
   NonConfMtl:boolean,
      /**  A flag which indicates if this is a valid reason to be used for Nonconformance processing of a subcontract operation.  */  
   NonConfSub:boolean,
      /**  A flag which indicates if this is a valid reason to be used for Nonconformance processing of something other than an Operation, Material or Subcontract Operation.  */  
   NonConfOther:boolean,
      /**  A flag which indicates if this is a valid reason for Quality Assurance cause.  */  
   QACause:boolean,
      /**  A flag which indicates if this is a valid reason for Quality Assurance corrective action.  */  
   QACorrectiveAct:boolean,
      /**  A flag which indicates if this is a valid reason for cycle counting and physical inventory count discrepancy reason. Only valid for Inventory Adjustment reason type.  */  
   InvAdjCountDiscrepancy:boolean,
      /**  Only valid for Course Result reason type.  */  
   Passed:boolean,
      /**  Marks this Reason as global, available to be sent out to other companies.  */  
   GlobalReason:boolean,
      /**  Disables this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  JDFWorkType  */  
   JDFWorkType:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  NonConfInv  */  
   NonConfInv:boolean,
      /**  This field determines if the record needs to be synchronized to the Machine MES. Changes to the record will automatically set the value to true.  */  
   ExternalMESSyncRequired:boolean,
      /**  The date and time the record was last synched to Machine MES.  The field is maintained by the Export Mattec process.  */  
   ExternalMESLastSync:string,
   BitFlag:number,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_ShipToRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  The Customer.CustNum value of the customer that the record is related to.  */  
   CustNum:number,
      /**  The ID assigned by the user which makes this record unique for the customer.  When a customer is created a ShipTo record is automatically created by the system for that customer with a ShipToNum equal to NULL.  */  
   ShipToNum:string,
      /**  Name of the ShipTo. When creating new records the Customer.Name is used as a default.  */  
   Name:string,
      /**  The first line of the ShipTo address.  */  
   Address1:string,
      /**  The second line of the ShipTo address.  */  
   Address2:string,
      /**  The third line of the ShipTo address.  */  
   Address3:string,
      /**  The city portion of the ShipTo address.  */  
   City:string,
      /**  The state or province portion of the ShipTo address.  */  
   State:string,
      /**  The zip or postal code portion of the ShipTo address.  */  
   ZIP:string,
      /**  The country portion of the ShipTo address.  */  
   Country:string,
      /**  The State Tax Identification Number. Used in Order Entry and prints on Sales Acknowledgements.  */  
   ResaleID:string,
      /**  The SalesRep.SalesRepCode value of the default salesperson for the customer. Used as a default in Order Entry and Invoice entry. The SalesRep from the customer master is used as an initial default when creating new ship to.  */  
   SalesRepCode:string,
      /**  The SalesTer.TerritoryID value of the territory the customer is assigned to.  */  
   TerritoryID:string,
      /**  The ShipVia.ShipViaCode value of the default ShipVia assigned to the customer. Used as a default in Order Entry, Shipping and Invoicing.  The shipvia from the customer record for this shipto is used as the initial default when creating new ShipTo records.  */  
   ShipViaCode:string,
      /**  The CustCnt.ConNum of the default shipping contact for the ShipTo location. The primary shipping contact is used as a default in the shipping process.  */  
   PrimSCon:number,
      /**  The fax number for the ShipTo location. isplayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   FaxNum:string,
      /**  The business phone number for the ShipTo location. Displayed in Order entry when no shipping contact is given for or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**  Determines whether or not the ShipTo location is normally exempt from sales tax. Used as a default in invoice entry.  If the field is non-blank it is considered exempt.   This code is totally user definable and no validation is required.  */  
   TaxExempt:string,
      /**  A mutually agreed upon value that links a customer's EDI shipto record (an N1 / ST) to the Manufacturing System DB ShipTo record.  */  
   EDIShipNum:string,
      /**  The Country.CountryNum value of the country selected in the ShipTo.Country field.  */  
   CountryNum:number,
      /**  The LangName.LangNameID value of the default Language assigned to the ShipTo location. This controls which language will be selected when extracting part descriptions from PartLangDesc table.  */  
   LangNameID:string,
      /**  Area/city code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Customer table. This field is only visible if ISSyst.EnableHarbour is set.  */  
   BorderCrossing:string,
      /**  Optional custom address format for the ShipTo location.  */  
   FormatStr:string,
      /**  Contains the TaxRgn.TaxRegionCode value of the customer's tax region for purposes of Sales Tax calculations.  */  
   TaxRegionCode:string,
      /**  The email address of the ShipTo location.  */  
   EMailAddress:string,
      /**   Determines how the ShipTo location should be assigned to a territory. There are 3 methods for Territory assignment in Ship-to:

Sync - Keep the ShipTo territory synchronized with the territory on the
       main customer record. (ShipTo.TerritoryID = Customer.TerritoryID)
Syst - Let the system (Get Territory) determine the territory to assign         to the ShipTo based on territory boundaries.
Lock - Check this method after assigning the territory manually to 
       prevent the system from attempting to reassign the territory.  */  
   TerritorySelect:string,
      /**  The pending sales territory that the customer will be assigned to based on changes to the territory boundaries.  This functionality is only available with the CRM module.  */  
   PendingTerritoryID:string,
      /**  Determines whether or not the ShipTo record was created by an EDI transaction.  */  
   CreatedByEDI:boolean,
      /**  Unique identifier of the ShipTo from an external General Ledger interface such as the EuroFinancial integration.  */  
   ExternalID:string,
      /**  The TaxAuthorityCd.TaxAuthorityCode value of the Tax Authority assigned to this ShipTo location.  */  
   TaxAuthorityCode:string,
      /**  Disable this record from receiving global updates.  */  
   GlobalLock:boolean,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  Days to use in calculating the Order Detail Ship By date from the incoming need by date.  */  
   DemandDeliveryDays:number,
      /**   Indicates incoming date type.  Values are:
S - Shipping Date
N - Need By Date  */  
   DemandDateType:string,
      /**  The number of days from today to give a warning when adding a new order release record from an incoming shipping schedule.  */  
   DemandAddLeadTime:number,
      /**  Indicates what type of action to take if the add lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandAddAction:string,
      /**  The number of days from today to give a warning when changing an order release record from an incoming shipping schedule.  This does not include changes to quantity or dates.  */  
   DemandChangeLeadTime:number,
      /**  Indicates what type of action to take if the change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeAction:string,
      /**  The number of days from today to give a warning when canceling an order release record from an incoming shipping schedule.  */  
   DemandCancelLeadTime:number,
      /**  Indicates what type of action to take if the cancel lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandCancelAction:string,
      /**  The number of days from today to give a warning when adding a new order line record from an incoming shipping schedule.  */  
   DemandNewLineLeadTime:number,
      /**  Indicates what type of action to take if the new line lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandNewLineAction:string,
      /**  The number of days from today to give a warning when changing the quantity on an order release record from an incoming shipping schedule.  */  
   DemandQtyChangeLeadTime:number,
      /**  Indicates what type of action to take if the quantity change lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandQtyChangeAction:string,
      /**  The number of days from today to give a warning when changing the date on an order release record from an incoming shipping schedule.  */  
   DemandChangeDateLeadTime:number,
      /**  Indicates what type of action to take if the change date lead time is breeched.  Options are B (reject the change) or W (warning - alert that the lead time has been breeched but allow the record to be accepted).  */  
   DemandChangeDateAction:string,
      /**  The trading partner name.  */  
   TradingPartnerName:string,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  Periodicity Code.  Must be a valid code in the Periodicity table.  */  
   PeriodicityCode:number,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Added for international shipping, Is a commercial invoice required  */  
   CommercialInvoice:boolean,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Added for international shipping. Shipper's Export Declaration required  */  
   ShipExprtDeclartn:boolean,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  For International shipping.  Certificate of Orgin required.  */  
   CertOfOrigin:boolean,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  For International shipping.  Shipper's Letter of Instruction.  */  
   LetterOfInstr:boolean,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  International Shipping - HazardousShipment  */  
   HazardousShipment:boolean,
      /**  Override Carrier Defaults.  If not checked then the customer values will be used if overriden else the Site values  */  
   OverrideCarrier:boolean,
      /**  Is this an International shipment  */  
   IntrntlShip:boolean,
      /**  Override Service Options.  If not checked then the customer values will be used if overriden else the Site values  */  
   OverrideService:boolean,
      /**  Indicates if the demand fields from the customer should be used.  */  
   DemandUseCustomerValues:boolean,
      /**  Tax Payer Registration Reason Code  */  
   TaxRegReason:string,
      /**  Used to calculate on-time delivery performance rating  */  
   EarlyBuffer:number,
      /**  Organization Registration Code  */  
   OrgRegCode:string,
      /**  Used to calculate on-time delivery performance rating  */  
   LateBuffer:number,
      /**  Indicates if the unit price between the demand and the contract should be validated.  If this flag is checked, and the prices are different, when the demand is accepted a record will be written to the DemandLog table.  */  
   DemandUnitPriceDiff:boolean,
      /**  Indicates what type of action to take if the unit price between the demand and the contract is different.  Options are B (reject the change) or W (warning - alert that the unit price is different but allow the record to be accepted).  */  
   DemandUnitPriceDiffAction:string,
      /**  A flag that indicates whether this address should be validated by the tax service.  */  
   ExcFromVal:boolean,
      /**  A flag indicating that an address has already been validated. This helps improve the performance of the bulk address validation process by allowing address that have already been validated to be skipped. This flag is set anytime a successful validation is performed, either by the bulk address validation or validation from the Customer form.  */  
   AddressVal:boolean,
      /**  Check for the part in the Part master.  */  
   DemandCheckForPart:boolean,
      /**  Indicates what type of action to take if the Check for Part options is selected and the part is not in the part master file.  Options are B (reject the change) or W (warning - alert that the part is not in the part master but allow the record to be accepted).  */  
   DemandCheckForPartAction:string,
      /**  International Shipping. Frieght Forwarder ID  */  
   FFID:string,
      /**  International Shipping. The first line of the Frieght Forwarder main address.  */  
   FFAddress1:string,
      /**  International Shipping. The second line of the Frieght Forwarder main address.  */  
   FFAddress2:string,
      /**  Shipping, The city portion of the Frieght Forwarder main address.  */  
   FFCity:string,
      /**  International Shipping. The state or province portion of the shipment Frieght Forwarder main address.  */  
   FFState:string,
      /**  International Shipping. The zip or postal code portion of the shipping Frieght Forwarder main address.  */  
   FFZip:string,
      /**  International shipping. The country of the Frieght Forwarder .  */  
   FFCountry:string,
      /**  International Shipping. Frieght Forwarder Contact  */  
   FFContact:string,
      /**  International Shipping. Frieght Forwarder company name  */  
   FFCompName:string,
      /**  International Shipping. Frieght Forwarder Phone number  */  
   FFPhoneNum:string,
      /**  Userid of user who made the last change to this record.  */  
   ChangedBy:string,
      /**  The date that the record was last changed  */  
   ChangeDate:string,
      /**  The time that the record was last change (seconds since midnight)  */  
   ChangeTime:number,
      /**  Individual Pack IDs  */  
   IndividualPackIDs:boolean,
      /**  Freight Forwarder Third address line  */  
   FFCountryNum:number,
      /**  Additional Handling flag  */  
   NonStdPkg:boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Non Standard Packaging  */  
   AddlHdlgFlag:boolean,
      /**  UPS Quantum View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View From Name  */  
   UPSQVShipFromName:string,
      /**  UPS Quantum View Memo  */  
   UPSQVMemo:string,
      /**  Freight Forwarder Country portion of the address  */  
   FFAddress3:string,
      /**  Used to determine if an address changed because of the tax integration.  If true, the tax integration changed the address.  */  
   ETCAddrChg:boolean,
      /**  Indicates if this is a alternate ShipTo. An alternate is a Shipto that is valid for this customer, but is defined/maintained by the "master" customer. See ShipTo.MasterCustNum/MasterShiptoNum.  */  
   IsAlternate:boolean,
      /**  Pertains to Alternate Shipto (IsAlternate). Contains the CustNum of the Shipto record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterCustNum:number,
      /**  Pertains to Alternate Shipto (IsAlternate). Contains the ShipToNum of the Shipto record that is the "Master". Changes made to the Master, are replicated to the alternates.  */  
   MasterShipToNum:string,
      /**  Check for Revision  */  
   DemandCheckForRev:boolean,
      /**  Check for Revision Action  */  
   DemandCheckForRevAction:string,
      /**  Flag for checking partial Shipment for Demand Entry.  */  
   DemandCheckPartialShip:boolean,
      /**  Check Partial Shipments Action: B =Stop  and W = Warning  */  
   DemandCheckShipAction:string,
      /**  Define if at the moment of processing a demand the process should also close those rejected schedules that remain at demand entry  */  
   DemandCloseRejSkd:boolean,
      /**  Defines if Internal Pricing or Customer Pricing will be used for checking price differences  */  
   DemandPricing:string,
      /**  Defines the tolerance for price difference validations  */  
   PriceTolerance:number,
      /**  If this flags is turned on then Demand CTP will automatically be executed as a part of the demand to order process.  */  
   CheckDateCapPromise:boolean,
      /**  Confirm or not the Capable to Promise jobs from Demand Entry  */  
   CheckConfirmCapPromise:boolean,
      /**  If checked, Updates the date in Demand Entry  */  
   CheckUpdateCapPromise:boolean,
      /**  This field will define the dates that will be validated as a part of the demand to order process. The valid values for this combo will be:  Need By (N), Ship By (S) and Both (B)  */  
   DemandCapPromiseDate:string,
      /**  The value on this field will define the action to be taken when validating CTP. The valid values for this combo box will be: Warning (W) and Stop (S)  */  
   DemandCapPromiseAction:string,
      /**   This field will define the dates that will be updated as a part of the demand to order process. The valid options will be:
Need By (N), Ship By (S) and Both  (B) NOTE .-In all the cases above the update of date will only be done if the CTP dates are beyond the dates on the file.  */  
   DemandCapPromiseUpdate:string,
      /**  When set to TRUE the smart string functionality will only be processed when the incoming demand is new. After it has been processed and saved, if a retransmission is sent the smart string values will be ignored.  */  
   OTSmartString:boolean,
      /**  Full Legal name  */  
   LegalName:string,
      /**  If true then demand will be rejected when one or more demand lines are not configured properly. Applies only to Configurable parts.  */  
   DemandCheckConfig:boolean,
      /**  Indicates the action to be taken if configuration values have not been entered for one or more demand lines.  */  
   DemandCheckCfgAction:string,
      /**  WIWebShipTo  */  
   WIWebShipTo:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  AGApartment  */  
   AGApartment:string,
      /**  AGExtraStreetNumber  */  
   AGExtraStreetNumber:string,
      /**  AGFloor  */  
   AGFloor:string,
      /**  AGGrossIncomeTaxID  */  
   AGGrossIncomeTaxID:string,
      /**  AGLocationCode  */  
   AGLocationCode:string,
      /**  AGNeighborhood  */  
   AGNeighborhood:string,
      /**  AGProvinceCode  */  
   AGProvinceCode:string,
      /**  AGStreet  */  
   AGStreet:string,
      /**  AGStreetNumber  */  
   AGStreetNumber:string,
      /**  EntityUseCode  */  
   EntityUseCode:string,
      /**  Check if the part is a run out part.  */  
   DemandCheckForRunOutPart:boolean,
      /**  Indicates what type of action to take if the Check for Run Out Part option is selected and the part is marked as a run out part.  Options are B (reject the change) or W (warning - alert that the part is marked as run out but allow the record to be accepted).  */  
   DemandCheckForRunOutPartAction:string,
      /**  INExciseRegNumber  */  
   INExciseRegNumber:string,
      /**  INVATNumber  */  
   INVATNumber:string,
      /**  INSTRegistration  */  
   INSTRegistration:string,
      /**  MXCURP  */  
   MXCURP:string,
      /**  MXMunicipio  */  
   MXMunicipio:string,
      /**  MXFederalID  */  
   MXFederalID:string,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  Geographical Location Code  */  
   PEUBIGEOCode:string,
      /**  EORI Number  */  
   EORINumber:string,
      /**  Tax ID Validation Status: Not Validated  0, Valid  1, Invalid  2.  */  
   TaxValidationStatus:number,
      /**  Tax Validation Date  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Indicates if the record is inactive.  */  
   Inactive:boolean,
      /**  FSMRegionCode  */  
   FSMRegionCode:string,
      /**  FSMArea  */  
   FSMArea:string,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
      /**  Used for ContactTracker.  This is needed so the UI can relate the Contact Tracker tables together.  */  
   ContactName:string,
      /**  Display Format String  */  
   DspFormatStr:string,
      /**  Indicates if ShipTo is Global (Master or Linked)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany, GlbCustNum and GlbShipto that is linking to this shipto  */  
   GlbLink:string,
      /**  Indicates Integration with financial package (like EuroFin)  */  
   IntegrationFlag:boolean,
      /**  Flag used for integrations whether to run the on change country logic.  */  
   IntRunChangeCountry:boolean,
   PeriodicityDesc:string,
      /**  List of available Periodicity values  */  
   PeriodicityList:string,
      /**  Used to indicate if primary shipto.  Updates Customer.ShipToNum field  */  
   PrimaryShipTo:boolean,
      /**  Sales Tax ID  */  
   SalesTaxID:string,
      /**  Service Tax ID  */  
   ServiceTaxID:string,
   TerritorySelectDescription:string,
      /**  Use this field to display/update; replaces TerritorySelect  */  
   TerrSelectFlag:string,
      /**  Address in formatted delimited list  */  
   AddrList:string,
   LanguageDescription:string,
   BitFlag:number,
   AGLocationDescription:string,
   AGProvinceDescription:string,
   CountryISOCode:string,
   CountryEUMember:boolean,
   CustNumName:string,
   CustNumCustID:string,
   CustNumBTName:string,
   DeliveryTypeDescription:string,
   MasterCustIDBTName:string,
   MasterCustIDCustID:string,
   MasterCustIDName:string,
   SalesRepName:string,
   ShipViaWebDesc:string,
   ShipViaDescription:string,
   TATaxAuthorityDescription:string,
   TaxRegionDescription:string,
   TerritoryTerritoryDesc:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_SugPOChgRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  Purchase order that this release record is related to.  */  
   PONum:number,
      /**  The line # of  PoDetail record that the PORel record is related to.  */  
   POLine:number,
      /**  Purchase order release number uniquely identifies a purchase release requirement record for a specific line item on an order. This is assigned by the system.  */  
   PORelNum:number,
      /**   Suggested action to be taken for this Purchase Order release.
"X" = Expedite, "P" = Postpone,  "C" = Cancel, "I"= increase qty, "R" = Reduce Qty, "S" for below safety and "Z" for below zero. This field is a 8 char. field it could contain "IP" increase and postpone.  */  
   SuggestionCode:string,
      /**   The Buyer Id that is on the related PO.
Duplicate of POHeader.BuyerID  */  
   BuyerID:string,
      /**  Requirement Due Date.  For suggested Cancels or Reduce Quantity this is set to Today.  */  
   RequireDate:string,
      /**  Human formatted string that contains the original source document of this entry.  */  
   SourceName:string,
      /**  New Suggested qty (in our UOM). This is the true amount suggested, not the difference between actual and suggested.  This only pertains to increase and reduce qty suggestions.  */  
   SurplusQty:number,
      /**   Reason for "Cancel" suggestion.  Purchase for stock which
1. OverMax - Stock purchase which surpasses the maximum.
2. No Requirement - Job purchase no open job record.  */  
   CancelReason:string,
      /**  Site Identifier. This field can not be blank.  */  
   Plant:string,
      /**  Supplier contact linked to this record.  */  
   ConNum:number,
      /**  Comment  */  
   Comment:string,
      /**  Indicates that this suggestion was initiated from the supplier Wb.  It is a reference field on time phase and does not add or subtract from the balance.  */  
   VendorChange:boolean,
      /**  Linked Inter-Company sales order.  */  
   OrderNum:number,
      /**  Linked Inter-Company Sales order Line number that this order release is linked to.  */  
   OrderLine:number,
      /**  The linked Inter-Company sale order release.  */  
   OrderRelNum:number,
      /**  External Trading Company Identifier.  */  
   ExtCompany:string,
      /**  Global Company identifier.  Used in Consolidated Purchasing.  */  
   GlbCompany:string,
      /**  ABC Code.  Valid values are "A" through "Z".  */  
   ABCCode:string,
      /**  SuggestionStatus  */  
   SuggestionStatus:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  A flag that is set by the user to indicate the suggestion has been reviewed.  This is only used to help filter suggestions.  */  
   Review:boolean,
      /**  For suggested changes to Promise Date.  */  
   ReqPromiseDate:string,
      /**  Date and time when this record was created.  */  
   CreatedOn:string,
      /**  LockDate  */  
   LockDate:boolean,
      /**  LockQty  */  
   LockQty:boolean,
      /**  PO Release Arrived Qty (note cannot be a linked field as need to set UOM Properties)  */  
   ArrivedQty:number,
   Brw_Exception:string,
   brwPartNum:string,
   brwPurPoint:string,
   brwVendorID:string,
   CancelToggle:boolean,
      /**  Logical indicating whether or not the suggested update is valid for PO releases tied to a Container.  */  
   ContainerAllowAccept:boolean,
   DueDate:string,
   ExpediteToggle:boolean,
   IncreaseToggle:boolean,
   IUM:string,
   JobSeqType:string,
   PostponeToggle:boolean,
   PUM:string,
   ReduceToggle:boolean,
   Rels_OnOrderQty:number,
   SupplierQty:number,
      /**  UOM for SurplusQty  */  
   SurplusQtyUOM:string,
   VendorName:string,
      /**  PO Release 'Our Quantity'  */  
   XRelQty:number,
   BrwPartDesc:string,
      /**  The Promise date set on the PO Release  */  
   PromiseDate:string,
      /**  The unique identifier of the related Dynamic Attribute Set.  */  
   brwAttributeSetID:number,
      /**  The Short Description of the Attribute Set.  */  
   brwAttributeSetShortDescription:string,
      /**  The Full Description of the Attribute Set.  */  
   brwAttributeSetDescription:string,
      /**  ID of parent Attribute Class  */  
   brwAttrClassID:string,
      /**  Number of pieces for inventory attribute tracked parts.  */  
   DispNumberOfPieces:number,
   brwPartTrackInventoryByRevision:boolean,
   brwRevisionNum:string,
   PartClassID:string,
   PartClassDescription:string,
   Selected:boolean,
   BitFlag:number,
   BuyerIDName:string,
   PlantName:string,
   POLineVenPartNum:string,
   POLineLineDesc:string,
   POLinePartNum:string,
   POLineRevisionNum:string,
   PORelContractID:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_VendCntRow{
      /**  Company Identifier.  */  
   Company:string,
      /**  This key links the record to the Vendor file.  */  
   VendorNum:number,
      /**  Purchase point from Vendor.  */  
   PurPoint:string,
      /**  Contact number.  Unique identifier for the contact record.  */  
   ConNum:number,
      /**  Contact name.  */  
   Name:string,
      /**  Used to enter a short description that should indicate what the contacts main function is. Ex: Shipping, Buyer, Engineer. This is an optional field.  */  
   Func:string,
      /**  Specific Fax telephone number for the contact. Optional field.  The user should only enter a Fax number for the contact if it is different than the fax number for the vendor. When displaying phone numbers of contacts the system will use the phone number found in the Vendor or Purchase Point file if the contacts number is blank.  */  
   FaxNum:string,
      /**  Specific Business telephone number for the contact. Optional field.  The user should only enter this when the contact has a phone number different than the Vendor.  When displaying phone numbers of contacts the system will use the phone number found in the Vendor or Purchase Point  file if the contacts number is blank.  */  
   PhoneNum:string,
      /**  Contact email address.  */  
   EmailAddress:string,
      /**  Password for SF/Portal, should not be easily editable from the Manufacturing System.  */  
   WebPassword:string,
      /**  Indicates if able to access the Supplier Workbench  */  
   WebUser:boolean,
      /**  Code that identifies the role of this person. Link to the RoleCD table.  */  
   RoleCode:string,
      /**  The contacts Cell phone number.  */  
   CellPhoneNum:string,
      /**  The contacts Pager number.  */  
   PagerNum:string,
      /**  The contacts Home number.  */  
   HomeNum:string,
      /**  The contacts Alternate number.  */  
   AltNum:string,
      /**  The Contacts Title  */  
   ContactTitle:string,
      /**  The name if the person this contact reports to.  */  
   ReportsTo:string,
      /**  Comments are intended to be internal comments about a specific contact.  */  
   Comment:string,
      /**  Indicates that this contact is no longer contacted.  */  
   NoContact:boolean,
      /**  The date the task was created.  */  
   CreateDate:string,
      /**  The UserID that created the task  */  
   CreateDcdUserID:string,
      /**  The date the task was last changed.  */  
   ChangeDate:string,
      /**  The UserID that last changed the task  */  
   ChangeDcdUserID:string,
      /**  This contact does not get used on new LOQs  */  
   Inactive:boolean,
      /**  First Name  */  
   FirstName:string,
      /**  Middle Name  */  
   MiddleName:string,
      /**  Last Name  */  
   LastName:string,
      /**  Prefix  */  
   Prefix:string,
      /**  Suffix  */  
   Suffix:string,
      /**  Initials  */  
   Initials:string,
      /**  Unique identifier from an external G/L interface  */  
   ExternalId:string,
      /**  Disable this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  Unique identifier for a PerCon record.  */  
   PerConID:number,
      /**  Default to True. If unchecked then changes to the email fields on PerCon won't affect this record and vice versa.  */  
   SyncEmailToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the Web link fields on PerCon won't affect this record and vice versa.  */  
   SyncLinksToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the Name fields on PerCon won't affect this record and vice versa.  */  
   SyncNameToPerCon:boolean,
      /**  Default to True. If unchecked then changes to the Phone fields on PerCon won't affect this record and vice versa.  */  
   SyncPhoneToPerCon:boolean,
      /**  Contact's website.  */  
   WebSite:string,
      /**  Contact's IM.  */  
   IM:string,
      /**  Contact's Twitter.  */  
   Twitter:string,
      /**  Contact's LinkedIn.  */  
   LinkedIn:string,
      /**  Contact's FaceBook.  */  
   FaceBook:string,
      /**  User defined Link 1.  */  
   WebLink1:string,
      /**  User defined Link 2.  */  
   WebLink2:string,
      /**  User defined Link 3.  */  
   WebLink3:string,
      /**  User defined Link 4.  */  
   WebLink4:string,
      /**  User defined Link 5.  */  
   WebLink5:string,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
   PrimaryContact:boolean,
   GlbFlag:boolean,
   VendCntAttrStrng:string,
      /**  GlbVendCnt fields in a linked list to find the linking record  */  
   GlbLink:string,
      /**  The name of the person contact.  */  
   PerConName:string,
   BitFlag:number,
   PurPointZip:string,
   PurPointAddress2:string,
   PurPointState:string,
   PurPointName:string,
   PurPointPrimPCon:number,
   PurPointCity:string,
   PurPointAddress1:string,
   PurPointCountry:string,
   PurPointAddress3:string,
   RoleCodeRoleDescription:string,
   VendorNumDefaultFOB:string,
   VendorNumState:string,
   VendorNumAddress2:string,
   VendorNumAddress1:string,
   VendorNumVendorID:string,
   VendorNumAddress3:string,
   VendorNumCurrencyCode:string,
   VendorNumCountry:string,
   VendorNumZIP:string,
   VendorNumName:string,
   VendorNumCity:string,
   VendorNumTermsCode:string,
      /**  RowMod  */  
   RowMod:string,
}

export interface Erp_Tablesets_VendorRow{
      /**  Indicates if vendor is inactive.  Inactive vendors are suppressed from data entry browses/selection lists and reports.  No new POs may be entered for the vendor, but the vendor may still be appear on existing POs.  */  
   Inactive:boolean,
      /**  Company Identifier.  */  
   Company:string,
      /**  A descriptive code assigned by the user to uniquely identify the vendor record.  This code must be unique within the file.  This ID may be used on displays/reports where space for full name is not available or may be inappropriate. This master key is a little different in that the user can change it.  This change is allowed because the system is not using the VendID as a foreign key in any other file. Instead it uses an internal value, VendNum, which cannot be changed, and is assigned by the system, for linking other records to the Vendor.  */  
   VendorID:string,
      /**  Vendor's name.  This field has a format length of 50. Normally the maintenance will be done in a left/right scrollable field of 30. Printing may not always print all 50. This also applies to the address lines.  */  
   Name:string,
      /**  A  unique integer assigned by the system to new vendors by the  maintenance program. This field is used as the foreign key to identify the vendor in other files such as CheckHed, or POHeader. The end user should never need to know about the value of this field.  */  
   VendorNum:number,
      /**  First address line of the Supplier  */  
   Address1:string,
      /**  Second address line of the Supplier  */  
   Address2:string,
      /**  Third address line of the Supplier  */  
   Address3:string,
      /**  City portion of the address of the Supplier  */  
   City:string,
      /**  Can be blank.  */  
   State:string,
      /**  Postal Code or Zip code portion of the address of the Supplier  */  
   ZIP:string,
      /**  Country Name. Printed as last line of mailing address. Can be blank.  */  
   Country:string,
      /**  The Tax Payer ID. Used in 1099 processing.  */  
   TaxPayerID:string,
      /**  Contains the key of the Purchase Point (VendorPP) record that should be used as a default for the vendor. Purchase points are used in Purchase Orders like Customer Shipto are used in Sales Orders. A blank value signifies that the default should be the vendor itself. This field is updated via a toggle box in purchase point maintenance. When the user checks this box the key of the Purchase Point record (PurPoint) is placed into this field. This method insures that only one Purchase point can exist as the default. Also if the toggle box is cleared then this field should be updated to blanks.  */  
   PurPoint:string,
      /**  Establishes the default Purchasing terms for this vendor. This can be blank or must be valid in the Terms file. It supplies Purchase Order and A/P Invoice entry with defaults.  */  
   TermsCode:string,
      /**  Vendors Group Code. Can be blank or must be valid in the VendGrup master file.  */  
   GroupCode:string,
      /**  Only vendors where Print 1099 = Yes will be selected in the 1099 processing.  */  
   Print1099:boolean,
      /**  Indicates that for this vendor all invoices must be paid on separate checks.  */  
   OneCheck:boolean,
      /**  Only vendors that are PrintLabel = Yes will be selected for printing of mailing labels.  */  
   PrintLabels:boolean,
      /**  Fax telephone number for the vendor. Optional field. This field is used as the general Fax # for the vendor.  It will be displayed as PO entry/Inquiry when no specific contact is given for the purchase order or the contact record has a blank Fax #.  */  
   FaxNum:string,
      /**  The general Business Phone Number for the vendor. Displayed in PO  entry and inquires when no contact is given or when contact has a blank phone number.  */  
   PhoneNum:string,
      /**   Comments are intended to be internal comments about a specific vendor. These do get pulled into other programs. They are mainly intended as an online storage facility.
To be view-as EDITOR widget.  */  
   Comment:string,
      /**  Indicates if payments to vendor should be held. If "yes" then vendor can't be selected in check processing. Also individual invoices can be put on hold.  */  
   PayHold:boolean,
      /**  Contains the key of the Primary Purchasing contact for the customer. This field is not directly maintainable. Instead it is set during contact maintenance by having the user mark a check box indicating primary Purchaser.  This is the contact that is used as a default in Purchase Order Entry when no purchase point is referenced  */  
   PrimPCon:number,
      /**  Identifies your account with the specific vendor. This is an optional field which is printed on any checks the system generates to this vendor.  */  
   AccountRef:string,
      /**  Default FOB policy for Purchase Orders to this vendor.  Used as a default to POHeader.FOB.  */  
   DefaultFOB:string,
      /**  Indicates if  Inspection is required for items received from this vendor.  Inspection will also be enforced if the related PartClass, Podetail, JobMtl or JobOper have their "RcvInspectionReq" fields set to Yes.  */  
   RcvInspectionReq:boolean,
      /**  A unique code that identifies the currency.  */  
   CurrencyCode:string,
      /**  Tax Liability of the Supplier  */  
   TaxRegionCode:string,
      /**  Country part of address. This field is in sync with the Country field. It must be a valid entry in the Country table.  */  
   CountryNum:number,
      /**  Indicates the language to be used.  This controls which language will be selected when extracting part descriptions from PartLangDesc table.  */  
   LangNameID:string,
      /**  Area/city code from where goods cross the border. This field is intended for Intrastat reporting. The field can be blank to indicate the value from the Country table.  This field is only visible if ISSyst.EnableHarbour is set.  */  
   BorderCrossing:string,
      /**  Optional Custom address format.  Controls the address format used on crystal forms.  */  
   FormatStr:string,
      /**  Payments to this vendors are made via electronic transfer.  */  
   ElecPayment:boolean,
      /**  ID of the vendor's primary bank.  Relates to the VendBank record, NOT the BankAcct record.  */  
   PrimaryBankID:string,
      /**   Indicates if the Vendor is approved for Purchasing.
Purchases can only be made from vendors that are approved.  */  
   Approved:boolean,
      /**  This is an inter-company vendor.  */  
   ICVend:boolean,
      /**  Email address of the vendor.  */  
   EMailAddress:string,
      /**  This vendor is web enabled  */  
   WebVendor:boolean,
      /**  Vendor URL.  */  
   VendURL:string,
      /**  Used to calculate on-time delivery performance rating  */  
   EarlyBuffer:number,
      /**  Used to calculate on-time delivery performance rating  */  
   LateBuffer:number,
      /**  Freeform field for rating On-time delivery performance.  This field is used as a criteria in selecting vendors in RFQ responses  */  
   OnTimeRating:string,
      /**  Freeform field for rating QA performance.  This field is used as a criteria in selecting vendors in RFQ responses.  */  
   QualityRating:string,
      /**  Freeform field for rating Price Accuracy.  This field is used as a criteria in selecting vendors in RFQ responses  */  
   PriceRating:string,
      /**  Freeform field for rating this vendors service.  This field is used as a criteria in selecting vendors in RFQ responses  */  
   ServiceRating:string,
      /**  Unique identifier from an external G/L interface  */  
   ExternalId:string,
      /**  An optional field that allows user to enter a monetary value to be used as a Credit limit for payment instruments such as post dated checks or bank drafts.  Credit limit of zero is considered as having unlimited credit.  */  
   VendPILimit:number,
      /**  Marks the vendor as a global vendor, available to be sent out to other companies  */  
   GlobalVendor:boolean,
      /**  Indicates if this vendor participates in the Inter-Company Trading.  */  
   ICTrader:boolean,
      /**  Establishes the tax authority for this vendor.  This field can be blank, but if entered, it must be valid in the TaxAuthorityCd file.  */  
   TaxAuthorityCode:string,
      /**  Disable this record from receiving global updates  */  
   GlobalLock:boolean,
      /**  MinOrderValue  */  
   MinOrderValue:number,
      /**  Identifies the production calendar for this Vendor.   If this equals "", then the ProdCal record is the Company Level production calendar.  */  
   CalendarID:string,
      /**  The Trading Partner ID that is used for incoming and outgoing EDI transactions.  */  
   EDICode:string,
      /**  Should this Supplier be included in Consolidated Purchasing?  */  
   ConsolidatedPurchasing:boolean,
      /**  If the Part Class being purchased is included in Consolidated Purchasing, should purchasing it from this Supplier override that so it will be purchased in this company?  */  
   LocalPurchasing:boolean,
      /**  Is this a residential delivery  */  
   ResDelivery:boolean,
      /**  Is a Saturday delivery acceptable  */  
   SatDelivery:boolean,
      /**  Is a Saturday pickup available  */  
   SatPickup:boolean,
      /**  Hazmat or Dangerous Goods delivery  */  
   Hazmat:boolean,
      /**  Documents Only delivery  */  
   DocOnly:boolean,
      /**  Reference Notes for the delivery  */  
   RefNotes:string,
      /**  Apply Handling Charge to shipment  */  
   ApplyChrg:boolean,
      /**  Handling Charge Amount  */  
   ChrgAmount:number,
      /**  Prefer COD delivery  */  
   COD:boolean,
      /**  Add Freight COD Amount owed  */  
   CODFreight:boolean,
      /**  Cashier's Check or Money order is required on COD Delivery  */  
   CODCheck:boolean,
      /**  Amount due on Cashier's check or money order  */  
   CODAmount:number,
      /**  Valid Values are blank, "Any" (Any Payment), "GF" (Guaranteed Funds), or "Cash" (Currency)  */  
   GroundType:string,
      /**  Indicates whether to send an email notification of delivery  */  
   NotifyFlag:boolean,
      /**  The list of email address to notify about a delivery  */  
   NotifyEMail:string,
      /**  Flag to indicate that an insurance value was declared on delivery  */  
   DeclaredIns:boolean,
      /**  Declared Insurance Amount  */  
   DeclaredAmt:number,
      /**  Service delivery requires signature  */  
   ServSignature:boolean,
      /**  Service Priority Alert flag  */  
   ServAlert:boolean,
      /**  Service Home Delivery allowed  */  
   ServHomeDel:boolean,
      /**  Service Home Delivery Type Code  */  
   DeliveryType:string,
      /**  Service Home Delivery date  */  
   ServDeliveryDate:string,
      /**  Home delivery phone number  */  
   ServPhone:string,
      /**  Service Delivery Instructions  */  
   ServInstruct:string,
      /**  Service Signature release is on file  */  
   ServRelease:boolean,
      /**  Service Signature Release authorization number  */  
   ServAuthNum:string,
      /**  Service Reference 1  */  
   ServRef1:string,
      /**  Service Reference 2  */  
   ServRef2:string,
      /**  Service Reference 3  */  
   ServRef3:string,
      /**  Service Reference 4  */  
   ServRef4:string,
      /**  Service Reference 5  */  
   ServRef5:string,
      /**  Flag to indicate if the Vendor participates in the Centralized Payment process.  */  
   CPay:boolean,
      /**  Indicates whether or not all freight charges sent or received are for individual pack DIs or the master pack.  */  
   IndividualPackIDs:boolean,
      /**  Indicates if the shipment is international.  */  
   IntrntlShip:boolean,
      /**  Certificate of Origin flag  */  
   CertOfOrigin:boolean,
      /**  Commercial Invoice flag.  */  
   CommercialInvoice:boolean,
      /**  Ship Export Declaration flag  */  
   ShipExprtDeclartn:boolean,
      /**  Letter of Instruction flag  */  
   LetterOfInstr:boolean,
      /**  Freight Forwarder ID  */  
   FFID:string,
      /**  Freight Forwarder Company Name  */  
   FFCompName:string,
      /**  Freight Forwarder contact person  */  
   FFContact:string,
      /**  First address line of the Freight Forwarder  */  
   FFAddress1:string,
      /**  Second address line of the Freight Forwarder  */  
   FFAddress2:string,
      /**  Third address line of the Freight Forwarder  */  
   FFAddress3:string,
      /**  Freight Forwarder city portion of address.  */  
   FFCity:string,
      /**  Freight Forwarder state portion of address.  */  
   FFState:string,
      /**  Freight Forwarder Zip code portion of the address  */  
   FFZip:string,
      /**  Freight Forwarder Country portion of the address  */  
   FFCountry:string,
      /**  Non Standard Packaging  */  
   NonStdPkg:boolean,
      /**   Determines the level of delivery confirmation.
1 - No Signature Required
2 - Adult Signature Required
3 - Confirmation Required
4 - Verbal Confirmation Required  */  
   DeliveryConf:number,
      /**  Additional Handling flag  */  
   AddlHdlgFlag:boolean,
      /**  UPS Quantum View  */  
   UPSQuantumView:boolean,
      /**  UPS Quantum View Ship from Name  */  
   UPSQVShipFromName:string,
      /**  UPS Quantum View Memo  */  
   UPSQVMemo:string,
      /**  Freight Forwarder Phone Number  */  
   FFPhoneNum:string,
      /**  Freight Forwarder Country Number  */  
   FFCountryNum:number,
      /**   Indicates what VAT Reverse Charge method needs to be applied for this Supplier.  The possible values are:
   "RCT"  -  "Reverse Charge with Threshold";
   "RCN"  -  "Reverse Charge with No Threshold"
Leave this field blank if no Reverse Charge should be applied in the AP invoice line for this Supplier.  */  
   RevChargeMethod:string,
      /**  Flag indicating whether this vendor is associated with a 3PL customer.  */  
   ManagedCust:boolean,
      /**  CustID of the associated managed customer.  Only populated if ManagedCust flag = true.  */  
   ManagedCustID:string,
      /**  CustNum associated with CustID of managed customer.  Only populated if ManagedCust flag = true.  */  
   ManagedCustNum:number,
      /**  Unique identifier of the payment method  */  
   PMUID:number,
      /**  If yes, indicates that Vendor has at least one assoicated VendBank record.  */  
   HasBank:boolean,
      /**  The Payment Banking Reference assigned by the supplier  */  
   PmtAcctRef:string,
      /**  Full Legal Name  */  
   LegalName:string,
      /**  Tax Payer Registration Reason Code  */  
   TaxRegReason:string,
      /**  Organization Registration Code  */  
   OrgRegCode:string,
      /**   Indicates Advanced Tax invoice is expected from supplier
after prepayment is done. If this field is set to yes, prepayment
invoice is not crated automatically.  */  
   AdvTaxInv:boolean,
      /**  AllowAsAltRemitTo  */  
   AllowAsAltRemitTo:boolean,
      /**  Revision identifier for this row. It is incremented upon each write.  */  
   SysRevID:number,
      /**  Unique identifier for this row. The value is a GUID.  */  
   SysRowID:string,
      /**  THBranchID  */  
   THBranchID:string,
      /**  ParamCode  */  
   ParamCode:string,
      /**  AGAFIPResponsibilityCode  */  
   AGAFIPResponsibilityCode:string,
      /**  AGGrossIncomeTaxID  */  
   AGGrossIncomeTaxID:string,
      /**  AGIDDocumentTypeCode  */  
   AGIDDocumentTypeCode:string,
      /**  AGProvinceCode  */  
   AGProvinceCode:string,
      /**  AGUseGoodDefaultMark  */  
   AGUseGoodDefaultMark:boolean,
      /**  AGApartment  */  
   AGApartment:string,
      /**  AGExtraStreetNumber  */  
   AGExtraStreetNumber:string,
      /**  AGFloor  */  
   AGFloor:string,
      /**  AGLocationCode  */  
   AGLocationCode:string,
      /**  AGNeighborhood  */  
   AGNeighborhood:string,
      /**  AGStreet  */  
   AGStreet:string,
      /**  AGStreetNumber  */  
   AGStreetNumber:string,
      /**  Colombia Loc Field. OneTimeCustVend new table ID  */  
   COOneTimeID:string,
      /**  No Banking Reference  */  
   NoBankingReference:boolean,
      /**  Peru Goods Contributor withholding status.  */  
   PEGoodsContributor:boolean,
      /**  Indicates the status of Peru Withholding Agent  */  
   PEWithholdAgent:boolean,
      /**  Indicates the status of Peru Collection Agent  */  
   PECollectionAgent:boolean,
      /**  Peru Not Found withholding status.  */  
   PENotFound:boolean,
      /**  Peru No Address Provided withholding status.  */  
   PENoAddress:boolean,
      /**  Displays the Peru Identity Document Type.  */  
   PEIdentityDocType:string,
      /**  Colombia Loc Field.  */  
   COIsOneTimeVend:boolean,
      /**  Peru Document ID.  */  
   PEDocumentID:string,
      /**  Defines the Number of Days from the PO release date the schedule engine considers a late PO Release or discard it. If the PO release date plus the supplier due date horizon is before today then the PO Release is discarded. If the PO release date plus the supplier due date horizon is today or later then the PO Release is considered late.  */  
   MaxLateDaysPORel:number,
      /**  1099 Code  */  
   Code1099ID:string,
      /**  Taxpayer Identification Number  */  
   TIN:string,
      /**  TIN Type. Values are 1 for EIN, 2 for SSNs, ITINs, and ATINs and 0 if type of TIN is not terminable.  */  
   TINType:string,
      /**  Second TIN Notice  */  
   SecondTINNotice:boolean,
      /**  Name Control. Optional and used for electronic export.  */  
   NameControl:string,
      /**  Specifies the method of shipment. The Ship Via associated with this supplier appears by default, but you can select a different option from the list.  */  
   ShipViaCode:string,
      /**  Non US Supplier  */  
   NonUS:boolean,
      /**  Form Type ID for the 1099 Code  */  
   FormTypeID:string,
      /**  INSupplierType  */  
   INSupplierType:string,
      /**  INCSTNumber  */  
   INCSTNumber:string,
      /**  INPANNumber  */  
   INPANNumber:string,
      /**  DEOrgType  */  
   DEOrgType:string,
      /**  PaymentReporting  */  
   PaymentReporting:boolean,
      /**  This field indicates that this record should be sent over to an external system whenever it is changed/created/deleted, etc.  */  
   ExternalPurchasing:boolean,
      /**  MXRetentionCode  */  
   MXRetentionCode:string,
      /**  Recipient's name for US 1099 reporting  */  
   Reporting1099Name:string,
      /**  Reporting1099Name2  */  
   Reporting1099Name2:string,
      /**  FATCA  */  
   FATCA:boolean,
      /**  AccountNum  */  
   AccountNum:string,
      /**  TW GUI Code  */  
   TWGUIRegNum:string,
      /**  MXTARCode  */  
   MXTARCode:string,
      /**  PEAddressID  */  
   PEAddressID:string,
      /**  PERetentionRegime  */  
   PERetentionRegime:string,
      /**  TaxEntityType  */  
   TaxEntityType:string,
      /**  GST Compliance Rate for India  */  
   INGSTComplianceRate:number,
      /**  INTaxRegistrationID  */  
   INTaxRegistrationID:string,
      /**  Validation Status of Taxpayer Identification Number  */  
   TINValidationStatus:number,
      /**  Indicates whether this supplier is importer of records or not. Used for Avalara Tax Connect calculation.  */  
   ImporterOfRecord:boolean,
      /**  PLAutomaticAPInvoiceNum  */  
   PLAutomaticAPInvoiceNum:boolean,
      /**  Standard Entry Class Code  */  
   SEC:string,
      /**  CSF Mexico DIOT Transaction Type  */  
   MXDIOTTranType:string,
      /**  Form 1099-K Merchant Category Code  */  
   US1099KMerchCatCode:string,
      /**  CSF Mexico Taxpayer Type  */  
   MXTaxpayerType:string,
      /**  CSF Mexico Legal Representative RFC  */  
   MXLegalRepRFC:string,
      /**  CSF Mexico Legal Representative CURP  */  
   MXLegalRepCURP:string,
      /**  CSF Mexico Legal Representative Name  */  
   MXLegalRepName:string,
      /**  CSF Mexico Legal Representative Taxpayer Type  */  
   MXLegalRepTaxpayerType:string,
      /**  US 1099 State  */  
   US1099State:string,
      /**  Tax ID Validation Status: Not Validated  0, Valid  1, Invalid  2.  */  
   TaxValidationStatus:number,
      /**  Tax Validation Date  */  
   TaxValidationDate:string,
      /**  HMRCTaxValidationLog  */  
   HMRCTaxValidationLog:string,
      /**  Supplier Scheme ID  */  
   ExternalSchemeID:string,
      /**  Municipio Code  */  
   MXMunicipio:string,
      /**  EInvoice  */  
   EInvoice:boolean,
      /**  Flag used to mark a Supplier as EDI.  */  
   EDISupplier:boolean,
      /**  FSMSendTo  */  
   FSMSendTo:boolean,
      /**  Delimited list of Business Categories  */  
   BusinessCatList:string,
      /**  List of fields which are referenced by COA segments.  */  
   COASegReferences:string,
   CountryDescription:string,
      /**  Currency Description.  */  
   CurrDesc:string,
   DocumentMaskID:string,
   EnableGlobalLock:boolean,
   EnableGlobalVendor:boolean,
   EnableMultiCompany:boolean,
      /**  Indicates if Reverse Charge Method should be enabled.  */  
   EnableRevCharge:boolean,
   FOBDescription:string,
      /**  Indicates if the Vendor is a global vendor (either master or child)  */  
   GlbFlag:boolean,
      /**  Delimited list of GlbCompany and GlbVendorNum that is linking to this vendor  */  
   GlbLink:string,
   Integrationflag:boolean,
      /**  A user defined external Netting Customer ID.  This must be existing Customer ID within the file  */  
   NettingCustID:string,
      /**  A user defined external Netting Customer Number.  This must be existing Customer Number within the file  */  
   NettingCustNum:number,
      /**  Reverse Charge Method description  */  
   RevChargeMethodDesc:string,
      /**  Sales Tax ID  */  
   SalesTaxID:string,
      /**  Automated Bank reconciliation.  */  
   SearchIDs:string,
      /**  Service Tax ID  */  
   ServiceTaxID:string,
   ShipViaDescription:string,
      /**  Delimited string of vendor attributes  */  
   VendAttrString:string,
   LangNameIDDescription:string,
   BitFlag:number,
   AGAFIPResponsibilityDescription:string,
   AGIDDocTypeDescription:string,
   AGLocationDescription:string,
   AGProvinceCodeDescription:string,
   CalendarIDDescription:string,
   Code1099Description:string,
   CountryNumEUMember:boolean,
   CountryNumISOCode:string,
   CountryNumDescription:string,
   CurrencyCodeCurrSymbol:string,
   CurrencyCodeDocumentDesc:string,
   CurrencyCodeCurrencyID:string,
   CurrencyCodeCurrName:string,
   CurrencyCodeCurrDesc:string,
   DeliveryTypeDescription:string,
   FormTypeDescription:string,
   GroupCodeGroupDesc:string,
   PayMethodType:number,
   PayMethodName:string,
   PayMethodSummarizePerCustomer:boolean,
   PurPointAddress3:string,
   PurPointAddress1:string,
   PurPointPrimPCon:number,
   PurPointName:string,
   PurPointZip:string,
   PurPointCountry:string,
   PurPointCity:string,
   PurPointState:string,
   PurPointAddress2:string,
   TaxAuthCdTaxAuthorityDescription:string,
   TaxRegionCodeDescription:string,
   TermsCodeDescription:string,
      /**  RowMod  */  
   RowMod:string,
}

   /** Required : 
      @param requestXmlDoc
      @param responseXmlDoc
   */  
export interface ExtendedInbound_input{
   requestXmlDoc:string,
   responseXmlDoc:string,
}

export interface ExtendedInbound_output{
parameters : {
      /**  output parameters  */  
   requestXmlDoc:string,
   responseXmlDoc:string,
}
}

   /** Required : 
      @param requestXmlDoc
   */  
export interface ExtendedOutbound_input{
   requestXmlDoc:string,
}

export interface ExtendedOutbound_output{
parameters : {
      /**  output parameters  */  
   requestXmlDoc:string,
}
}

   /** Required : 
      @param eccExtPartSubsRow
   */  
export interface GetAltPartSubsUD_input{
   eccExtPartSubsRow:Erp_Tablesets_PartSubsRow[],
}

export interface GetAltPartSubsUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPartRow
   */  
export interface GetAltPartUD_input{
   eccExtPartRow:Erp_Tablesets_PartRow[],
}

export interface GetAltPartUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtInvcHeadRow
   */  
export interface GetCUIDInvcHeadUD_input{
   eccExtInvcHeadRow:Erp_Tablesets_InvcHeadRow[],
}

export interface GetCUIDInvcHeadUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtShipToRow
   */  
export interface GetCadShipToUD_input{
   eccExtShipToRow:Erp_Tablesets_ShipToRow[],
}

export interface GetCadShipToUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPcECCOrderDtlRow
   */  
export interface GetCdmPcECCOrderDtlUD_input{
   eccExtPcECCOrderDtlRow:Erp_Tablesets_PcECCOrderDtlRow[],
}

export interface GetCdmPcECCOrderDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtQuoteDtlRow
   */  
export interface GetCdmQuoteDtlUD_input{
   eccExtQuoteDtlRow:Erp_Tablesets_QuoteDtlRow[],
}

export interface GetCdmQuoteDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtCustomerRow
   */  
export interface GetCncCustomerUD_input{
   eccExtCustomerRow:Erp_Tablesets_CustomerRow[],
}

export interface GetCncCustomerUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtShipToRow
   */  
export interface GetCncShipToUD_input{
   eccExtShipToRow:Erp_Tablesets_ShipToRow[],
}

export interface GetCncShipToUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtCustXPrtRow
   */  
export interface GetCpnCustXPrtUD_input{
   eccExtCustXPrtRow:Erp_Tablesets_CustXPrtRow[],
}

export interface GetCpnCustXPrtUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPartXRefIntRow
   */  
export interface GetCpnPartXRefIntUD_input{
   eccExtPartXRefIntRow:Erp_Tablesets_PartXRefIntRow[],
}

export interface GetCpnPartXRefIntUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtQuoteDtlRow
   */  
export interface GetCrqdQuoteDtlUD_input{
   eccExtQuoteDtlRow:Erp_Tablesets_QuoteDtlRow[],
}

export interface GetCrqdQuoteDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtQuoteHedRow
   */  
export interface GetCrqdQuoteHedUD_input{
   eccExtQuoteHedRow:Erp_Tablesets_QuoteHedRow[],
}

export interface GetCrqdQuoteHedUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtReasonRow
   */  
export interface GetCrrcReasonUD_input{
   eccExtReasonRow:Erp_Tablesets_ReasonRow[],
}

export interface GetCrrcReasonUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtRMADtlRow
   */  
export interface GetCrrdRMADtlUD_input{
   eccExtRMADtlRow:Erp_Tablesets_RMADtlRow[],
}

export interface GetCrrdRMADtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtRMAHeadRow
   */  
export interface GetCrrdRMAHeadUD_input{
   eccExtRMAHeadRow:Erp_Tablesets_RMAHeadRow[],
}

export interface GetCrrdRMAHeadUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtCustCntRow
   */  
export interface GetCucoCustCntUD_input{
   eccExtCustCntRow:Erp_Tablesets_CustCntRow[],
}

export interface GetCucoCustCntUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtInvcDtlRow
   */  
export interface GetCuidInvcDtlUD_input{
   eccExtInvcDtlRow:Erp_Tablesets_InvcDtlRow[],
}

export interface GetCuidInvcDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtOrderDtlRow
   */  
export interface GetCuodOrderDtlUD_input{
   eccExtOrderDtlRow:Erp_Tablesets_OrderDtlRow[],
}

export interface GetCuodOrderDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtOrderHedRow
   */  
export interface GetCuodOrderHedUD_input{
   eccExtOrderHedRow:Erp_Tablesets_OrderHedRow[],
}

export interface GetCuodOrderHedUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtOrderHedRow
   */  
export interface GetCuosOrderHedUD_input{
   eccExtOrderHedRow:Erp_Tablesets_OrderHedRow[],
}

export interface GetCuosOrderHedUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtCustomerRow
   */  
export interface GetCusCustomerUD_input{
   eccExtCustomerRow:Erp_Tablesets_CustomerRow[],
}

export interface GetCusCustomerUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtHDCaseRow
   */  
export interface GetDcldHDCaseUD_input{
   eccExtHDCaseRow:Erp_Tablesets_HDCaseRow[],
}

export interface GetDcldHDCaseUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtLocationMtlRow
   */  
export interface GetDebmLocationMtlUD_input{
   eccExtLocationMtlRow:Erp_Tablesets_LocationMtlRow[],
}

export interface GetDebmLocationMtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtLocationWarrantyTranRow
   */  
export interface GetDebmLocationWarrantyTranUD_input{
   eccExtLocationWarrantyTranRow:Erp_Tablesets_LocationWarrantyTranRow[],
}

export interface GetDebmLocationWarrantyTranUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtLocationInventoryRow
   */  
export interface GetDebmPayloadXml_input{
   eccExtLocationInventoryRow:Erp_Tablesets_LocationInventoryRow[],
}

export interface GetDebmPayloadXml_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtLocationInventoryRow
   */  
export interface GetDeidLocationInventoryUD_input{
   eccExtLocationInventoryRow:Erp_Tablesets_LocationInventoryRow[],
}

export interface GetDeidLocationInventoryUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtQuoteDtlRow
   */  
export interface GetGqrQuoteDtlUD_input{
   eccExtQuoteDtlRow:Erp_Tablesets_QuoteDtlRow[],
}

export interface GetGqrQuoteDtlUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtQuoteHedRow
   */  
export interface GetGqrQuoteHedUD_input{
   eccExtQuoteHedRow:Erp_Tablesets_QuoteHedRow[],
}

export interface GetGqrQuoteHedUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPODetailRow
   */  
export interface GetPODetailUD_input{
   eccExtPODetailRow:Erp_Tablesets_PODetailRow[],
}

export interface GetPODetailUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPOHeaderRow
   */  
export interface GetPOHeaderUD_input{
   eccExtPOHeaderRow:Erp_Tablesets_POHeaderRow[],
}

export interface GetPOHeaderUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtRFQHeadRow
   */  
export interface GetRFQHeadUD_input{
   eccExtRFQHeadRow:Erp_Tablesets_RFQHeadRow[],
}

export interface GetRFQHeadUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtRFQItemRow
   */  
export interface GetRFQItemUD_input{
   eccExtRFQItemRow:Erp_Tablesets_RFQItemRow[],
}

export interface GetRFQItemUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPartRow
   */  
export interface GetSgpPartUD_input{
   eccExtPartRow:Erp_Tablesets_PartRow[],
}

export interface GetSgpPartUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtProdGrupRow
   */  
export interface GetStgProdGrupUD_input{
   eccExtProdGrupRow:Erp_Tablesets_ProdGrupRow[],
}

export interface GetStgProdGrupUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPartRow
   */  
export interface GetStkPartUD_input{
   eccExtPartRow:Erp_Tablesets_PartRow[],
}

export interface GetStkPartUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   attributeSetTagValue:string,
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param partUOMRow
   */  
export interface GetStkPartUomUD_input{
   partUOMRow:Erp_Tablesets_PartUOMRow[],
}

export interface GetStkPartUomUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtPartRow
   */  
export interface GetSttPartUD_input{
   eccExtPartRow:Erp_Tablesets_PartRow[],
}

export interface GetSttPartUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtVendCntRow
   */  
export interface GetSucoVendCntUD_input{
   eccExtVendCntRow:Erp_Tablesets_VendCntRow[],
}

export interface GetSucoVendCntUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtVendorRow
   */  
export interface GetSuspVendorUD_input{
   eccExtVendorRow:Erp_Tablesets_VendorRow[],
}

export interface GetSuspVendorUD_output{
   returnObj:boolean,
parameters : {
      /**  output parameters  */  
   userDefinedSet:System_Xml_Linq_XElement,
   payload:System_Xml_Linq_XElement,
   xmlAnything:System_Xml_Linq_XElement,
   attributesSet:System_Xml_Linq_XElement,
}
}

   /** Required : 
      @param eccExtOrderDtl
      @param eccExtList
   */  
export interface GorCustomListOrderDtl_input{
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface GorCustomListOrderDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param eccExtList
   */  
export interface GorCustomListOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface GorCustomListOrderHed_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtOrderDtl
      @param columnName
      @param customValue
   */  
export interface GorCustomTagOrderDtl_input{
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface GorCustomTagOrderDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderDtl:Erp_Tablesets_ECCExtensionOrderDtlTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param columnName
      @param customValue
   */  
export interface GorCustomTagOrderHed_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   columnName:string,
   customValue:string,
}

export interface GorCustomTagOrderHed_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtOrderHed
      @param payload
   */  
export interface GorPayload_input{
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset[],
   payload:string,
}

export interface GorPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtOrderHed:Erp_Tablesets_ECCExtensionOrderHedTableset,
   payload:string,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param eccExtList
   */  
export interface GqrCustomListQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface GqrCustomListQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param eccExtList
   */  
export interface GqrCustomListQuoteHed_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface GqrCustomListQuoteHed_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtQuoteDtl
      @param columnName
      @param customValue
   */  
export interface GqrCustomTagQuoteDtl_input{
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset[],
   columnName:string,
   customValue:string,
}

export interface GqrCustomTagQuoteDtl_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteDtl:Erp_Tablesets_ECCExtensionQuoteDtlTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param columnName
      @param customValue
   */  
export interface GqrCustomTagQuoteHed_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   columnName:string,
   customValue:string,
}

export interface GqrCustomTagQuoteHed_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   customValue:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param xmlDoc
   */  
export interface GqrCustomXML_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   xmlDoc:string,
}

export interface GqrCustomXML_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtQuoteHed
      @param payload
   */  
export interface GqrPayload_input{
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset[],
   payload:string,
}

export interface GqrPayload_output{
parameters : {
      /**  output parameters  */  
   eccExtQuoteHed:Erp_Tablesets_ECCExtensionQuoteHedTableset,
   payload:string,
}
}

export interface Ice_Extensions_ExtensionRow{
   ColumnValues:object
   RowMod:string,
   SysRowID:string,
}

export interface Ice_Extensions_ExtensionTableColumn{
   ColumnName:string,
   ColumnType:string,
}

export interface Ice_Extensions_ExtensionTableData{
   Table:Ice_Extensions_ExtensionRow[],
   SystemCode:string,
   TableName:string,
   Columns:Ice_Extensions_ExtensionTableColumn[],
   PrimaryKeyColumns:string,
   PeerTableSystemCode:string,
   PeerTableName:string,
}

   /** Required : 
      @param custNum
      @param shipToID
      @param currencyCode
      @param partNum
      @param sellingUOM
      @param sellingQty
      @param custBasePrice
      @param custQtyPrice
   */  
export interface MsqOverride_input{
   custNum:number,
   shipToID:string,
   currencyCode:string,
   partNum:string,
   sellingUOM:string,
   sellingQty:number,
   custBasePrice:number,
   custQtyPrice:number,
}

export interface MsqOverride_output{
parameters : {
      /**  output parameters  */  
   custBasePrice:number,
   custQtyPrice:number,
}
}

   /** Required : 
      @param eccExtPart
      @param eccExtList
   */  
export interface SgpCustomListPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SgpCustomListPart_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPart
      @param columnName
      @param customValue
   */  
export interface SgpCustomTagPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   columnName:string,
   customValue:string,
}

export interface SgpCustomTagPart_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlDoc
   */  
export interface SgpCustomXML_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlDoc:string,
}

export interface SgpCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlOverride
      @param xmlDoc
   */  
export interface SgpFinalXml_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface SgpFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param payLoad
   */  
export interface SgpPayload_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   payLoad:string,
}

export interface SgpPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtPODetail
      @param eccExtList
   */  
export interface SpodCustomListPODetail_input{
   eccExtPODetail:Erp_Tablesets_ECCExtensionPODetailTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SpodCustomListPODetail_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPOHeader
      @param eccExtList
   */  
export interface SpodCustomListPOHeader_input{
   eccExtPOHeader:Erp_Tablesets_ECCExtensionPOHeaderTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SpodCustomListPOHeader_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPODetail
      @param columnName
      @param customValue
   */  
export interface SpodCustomTagPODetail_input{
   eccExtPODetail:Erp_Tablesets_ECCExtensionPODetailTableset[],
   columnName:string,
   customValue:string,
}

export interface SpodCustomTagPODetail_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPOHeader
      @param columnName
      @param customValue
   */  
export interface SpodCustomTagPOHeader_input{
   eccExtPOHeader:Erp_Tablesets_ECCExtensionPOHeaderTableset[],
   columnName:string,
   customValue:string,
}

export interface SpodCustomTagPOHeader_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPOHeader
      @param xmlDoc
   */  
export interface SpodCustomXML_input{
   eccExtPOHeader:Erp_Tablesets_ECCExtensionPOHeaderTableset[],
   xmlDoc:string,
}

export interface SpodCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPOHeader
      @param payLoad
   */  
export interface SpodPayload_input{
   eccExtPOHeader:Erp_Tablesets_ECCExtensionPOHeaderTableset[],
   payLoad:string,
}

export interface SpodPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtSugPOChg
      @param eccExtList
   */  
export interface SpouCustomListSugPOChg_input{
   eccExtSugPOChg:Erp_Tablesets_ECCExtensionSugPOChgTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SpouCustomListSugPOChg_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtSugPOChg
      @param columnName
      @param customValue
   */  
export interface SpouCustomTagSugPOChg_input{
   eccExtSugPOChg:Erp_Tablesets_ECCExtensionSugPOChgTableset[],
   columnName:string,
   customValue:string,
}

export interface SpouCustomTagSugPOChg_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtSugPOChg
      @param payLoad
   */  
export interface SpouPayload_input{
   eccExtSugPOChg:Erp_Tablesets_ECCExtensionSugPOChgTableset[],
   payLoad:string,
}

export interface SpouPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtProdGrup
      @param eccExtList
   */  
export interface StgCustomListProdGrup_input{
   eccExtProdGrup:Erp_Tablesets_ECCExtensionProdGrupTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface StgCustomListProdGrup_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtProdGrup
      @param columnName
      @param customValue
   */  
export interface StgCustomTagProdGrup_input{
   eccExtProdGrup:Erp_Tablesets_ECCExtensionProdGrupTableset[],
   columnName:string,
   customValue:string,
}

export interface StgCustomTagProdGrup_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtProdGrup
      @param xmlDoc
   */  
export interface StgCustomXML_input{
   eccExtProdGrup:Erp_Tablesets_ECCExtensionProdGrupTableset[],
   xmlDoc:string,
}

export interface StgCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtProdGrup
      @param xmlOverride
      @param xmlDoc
   */  
export interface StgFinalXml_input{
   eccExtProdGrup:Erp_Tablesets_ECCExtensionProdGrupTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface StgFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtProdGrup
      @param payLoad
   */  
export interface StgPayload_input{
   eccExtProdGrup:Erp_Tablesets_ECCExtensionProdGrupTableset[],
   payLoad:string,
}

export interface StgPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtPart
      @param attributeSet
   */  
export interface StkAttributeSet_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   attributeSet:string,
}

export interface StkAttributeSet_output{
parameters : {
      /**  output parameters  */  
   attributeSet:string,
}
}

   /** Required : 
      @param eccExtPartUOM
      @param eccExtList
   */  
export interface StkCustomListPartUOM_input{
   eccExtPartUOM:Erp_Tablesets_ECCExtensionPartUOMTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface StkCustomListPartUOM_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPart
      @param eccExtList
   */  
export interface StkCustomListPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface StkCustomListPart_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPartUOM
      @param columnName
      @param customValue
   */  
export interface StkCustomTagPartUOM_input{
   eccExtPartUOM:Erp_Tablesets_ECCExtensionPartUOMTableset[],
   columnName:string,
   customValue:string,
}

export interface StkCustomTagPartUOM_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPart
      @param columnName
      @param customValue
   */  
export interface StkCustomTagPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   columnName:string,
   customValue:string,
}

export interface StkCustomTagPart_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlDoc
   */  
export interface StkCustomXML_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlDoc:string,
}

export interface StkCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlOverride
      @param xmlDoc
   */  
export interface StkFinalXml_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface StkFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param payLoad
   */  
export interface StkPayload_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   payLoad:string,
}

export interface StkPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtPart
      @param eccExtList
   */  
export interface SttCustomListPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SttCustomListPart_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtPart
      @param columnName
      @param customValue
   */  
export interface SttCustomTagPart_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   columnName:string,
   customValue:string,
}

export interface SttCustomTagPart_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlDoc
   */  
export interface SttCustomXML_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlDoc:string,
}

export interface SttCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param xmlOverride
      @param xmlDoc
   */  
export interface SttFinalXml_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface SttFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtPart
      @param payLoad
   */  
export interface SttPayload_input{
   eccExtPart:Erp_Tablesets_ECCExtensionPartTableset[],
   payLoad:string,
}

export interface SttPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtVendCnt
      @param eccExtList
   */  
export interface SucoCustomListVendCnt_input{
   eccExtVendCnt:Erp_Tablesets_ECCExtensionVendCntTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SucoCustomListVendCnt_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtVendCnt
      @param columnName
      @param customValue
   */  
export interface SucoCustomTagVendCnt_input{
   eccExtVendCnt:Erp_Tablesets_ECCExtensionVendCntTableset[],
   columnName:string,
   customValue:string,
}

export interface SucoCustomTagVendCnt_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtVendCnt
      @param xmlDoc
   */  
export interface SucoCustomXML_input{
   eccExtVendCnt:Erp_Tablesets_ECCExtensionVendCntTableset[],
   xmlDoc:string,
}

export interface SucoCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtVendCnt
      @param xmlOverride
      @param xmlDoc
   */  
export interface SucoFinalXml_input{
   eccExtVendCnt:Erp_Tablesets_ECCExtensionVendCntTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface SucoFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtVendCnt
      @param payLoad
   */  
export interface SucoPayload_input{
   eccExtVendCnt:Erp_Tablesets_ECCExtensionVendCntTableset[],
   payLoad:string,
}

export interface SucoPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param eccExtList
   */  
export interface SurdCustomListRFQHead_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SurdCustomListRFQHead_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRFQItem
      @param eccExtList
   */  
export interface SurdCustomListRFQItem_input{
   eccExtRFQItem:Erp_Tablesets_ECCExtensionRFQItemTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SurdCustomListRFQItem_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param columnName
      @param customValue
   */  
export interface SurdCustomTagRFQHead_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   columnName:string,
   customValue:string,
}

export interface SurdCustomTagRFQHead_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtRFQItem
      @param columnName
      @param customValue
   */  
export interface SurdCustomTagRFQItem_input{
   eccExtRFQItem:Erp_Tablesets_ECCExtensionRFQItemTableset[],
   columnName:string,
   customValue:string,
}

export interface SurdCustomTagRFQItem_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param xmlDoc
   */  
export interface SurdCustomXML_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   xmlDoc:string,
}

export interface SurdCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param payLoad
   */  
export interface SurdPayload_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   payLoad:string,
}

export interface SurdPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param eccExtList
   */  
export interface SuruCustomListRFQHead_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SuruCustomListRFQHead_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRFQItem
      @param eccExtList
   */  
export interface SuruCustomListRFQItem_input{
   eccExtRFQItem:Erp_Tablesets_ECCExtensionRFQItemTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SuruCustomListRFQItem_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param columnName
      @param customValue
   */  
export interface SuruCustomTagRFQHead_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   columnName:string,
   customValue:string,
}

export interface SuruCustomTagRFQHead_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtRFQItem
      @param columnName
      @param customValue
   */  
export interface SuruCustomTagRFQItem_input{
   eccExtRFQItem:Erp_Tablesets_ECCExtensionRFQItemTableset[],
   columnName:string,
   customValue:string,
}

export interface SuruCustomTagRFQItem_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtRFQHead
      @param payLoad
   */  
export interface SuruPayload_input{
   eccExtRFQHead:Erp_Tablesets_ECCExtensionRFQHeadTableset[],
   payLoad:string,
}

export interface SuruPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

   /** Required : 
      @param eccExtVendor
      @param eccExtList
   */  
export interface SuspCustomListVendor_input{
   eccExtVendor:Erp_Tablesets_ECCExtensionVendorTableset[],
   eccExtList:Erp_Tablesets_ECCExtensionTableset[],
}

export interface SuspCustomListVendor_output{
parameters : {
      /**  output parameters  */  
   eccExtList:Erp_Tablesets_ECCExtensionTableset,
}
}

   /** Required : 
      @param eccExtVendor
      @param columnName
      @param customValue
   */  
export interface SuspCustomTagVendor_input{
   eccExtVendor:Erp_Tablesets_ECCExtensionVendorTableset[],
   columnName:string,
   customValue:string,
}

export interface SuspCustomTagVendor_output{
parameters : {
      /**  output parameters  */  
   customValue:string,
}
}

   /** Required : 
      @param eccExtVendor
      @param xmlDoc
   */  
export interface SuspCustomXML_input{
   eccExtVendor:Erp_Tablesets_ECCExtensionVendorTableset[],
   xmlDoc:string,
}

export interface SuspCustomXML_output{
parameters : {
      /**  output parameters  */  
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtVendor
      @param xmlOverride
      @param xmlDoc
   */  
export interface SuspFinalXml_input{
   eccExtVendor:Erp_Tablesets_ECCExtensionVendorTableset[],
   xmlOverride:boolean,
   xmlDoc:string,
}

export interface SuspFinalXml_output{
parameters : {
      /**  output parameters  */  
   xmlOverride:boolean,
   xmlDoc:string,
}
}

   /** Required : 
      @param eccExtVendor
      @param payLoad
   */  
export interface SuspPayload_input{
   eccExtVendor:Erp_Tablesets_ECCExtensionVendorTableset[],
   payLoad:string,
}

export interface SuspPayload_output{
parameters : {
      /**  output parameters  */  
   payLoad:string,
}
}

export interface System_Xml_Linq_XAttribute{
   IsNamespaceDeclaration:boolean,
   Name:System_Xml_Linq_XName[],
   NextAttribute:System_Xml_Linq_XAttribute[],
   NodeType:number,
   PreviousAttribute:System_Xml_Linq_XAttribute[],
   Value:string,
   BaseUri:string,
   Document:System_Xml_Linq_XDocument[],
   Parent:System_Xml_Linq_XElement[],
}

export interface System_Xml_Linq_XDeclaration{
   Encoding:string,
   Standalone:string,
   Version:string,
}

export interface System_Xml_Linq_XDocument{
   Declaration:System_Xml_Linq_XDeclaration[],
   DocumentType:System_Xml_Linq_XDocumentType[],
   NodeType:number,
   Root:System_Xml_Linq_XElement[],
   FirstNode:System_Xml_Linq_XNode[],
   LastNode:System_Xml_Linq_XNode[],
   NextNode:System_Xml_Linq_XNode[],
   PreviousNode:System_Xml_Linq_XNode[],
   BaseUri:string,
   Document:System_Xml_Linq_XDocument[],
   Parent:System_Xml_Linq_XElement[],
}

export interface System_Xml_Linq_XDocumentType{
   InternalSubset:string,
   Name:string,
   NodeType:number,
   PublicId:string,
   SystemId:string,
   NextNode:System_Xml_Linq_XNode[],
   PreviousNode:System_Xml_Linq_XNode[],
   BaseUri:string,
   Document:System_Xml_Linq_XDocument[],
   Parent:System_Xml_Linq_XElement[],
}

export interface System_Xml_Linq_XElement{
   FirstAttribute:System_Xml_Linq_XAttribute[],
   HasAttributes:boolean,
   HasElements:boolean,
   IsEmpty:boolean,
   LastAttribute:System_Xml_Linq_XAttribute[],
   Name:System_Xml_Linq_XName[],
   NodeType:number,
   Value:string,
   FirstNode:System_Xml_Linq_XNode[],
   LastNode:System_Xml_Linq_XNode[],
   NextNode:System_Xml_Linq_XNode[],
   PreviousNode:System_Xml_Linq_XNode[],
   BaseUri:string,
   Document:System_Xml_Linq_XDocument[],
   Parent:System_Xml_Linq_XElement[],
}

export interface System_Xml_Linq_XName{
   LocalName:string,
   Namespace:System_Xml_Linq_XNamespace[],
   NamespaceName:string,
}

export interface System_Xml_Linq_XNamespace{
   NamespaceName:string,
}

export interface System_Xml_Linq_XNode{
   NextNode:System_Xml_Linq_XNode[],
   PreviousNode:System_Xml_Linq_XNode[],
   BaseUri:string,
   Document:System_Xml_Linq_XDocument[],
   NodeType:number,
   Parent:System_Xml_Linq_XElement[],
}

   /** Required : 
      @param mapID
      @param msgType
      @param tableName
   */  
export interface UDMapIsEnabled_input{
   mapID:string,
   msgType:string,
   tableName:string,
}

export interface UDMapIsEnabled_output{
   returnObj:boolean,
}

